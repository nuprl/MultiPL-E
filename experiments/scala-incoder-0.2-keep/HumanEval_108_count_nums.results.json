{
  "language": "scala",
  "name": "HumanEval_108_count_nums",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for (i <- 0 until arr.length) {\n            val num = arr(i)\n            if (num < 0) num *= -1\n            val digits = num.toString.toInt\n            if (digits > 0) count += digits\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp55k5951f.scala:15:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (num < \u001b[31m0\u001b[0m) num *= -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value *= is not a member of Long - did you mean num.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val sums = mutable.ArrayBuffer.empty[Long]\n        for(i <- 0 until n) {\n            val digits = arr(i).abs\n            sums += digits\n        }\n        sums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps2ezlbk5.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798797
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val digits = arr.map(_.toString.toInt)\n        val digitSums = digits.map(_.sum)\n        val numsWithSum = nums.filter(x => digitSums.contains(x))\n        numsWithSum.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmplkc373c2.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdigitSums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   value sum is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val nums = arr.filter(x => math.abs(x) > 0).size\n        sums.filter(_ > 0).sum - nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3sanrw60.scala:18)\n\tat Problem.main(tmp3sanrw60.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmprpoi_b4s.scala:15:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.mapValues(_.size).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m            No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m            where:    B is a type variable with constraint >: (Int, Int)\n\u001b[31m   |\u001b[0m            .\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = nums.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpi631oq9i.scala:19)\n\tat Problem.main(tmpi631oq9i.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).length)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpcy0aj_g2.scala:19)\n\tat Problem.main(tmpcy0aj_g2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.filter(_ > 0).map(_ % 10).filter(x => sums.contains(x)).length\n        numsSums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo__v38m7.scala:14:84 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSums\u001b[0m = nums.filter(_ > \u001b[31m0\u001b[0m).map(_ % \u001b[31m10\u001b[0m).filter(\u001b[36mx\u001b[0m => sums.contains(x)).length\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value length is not a member of Set[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val positiveSums = sums.filter(x => x >= 0)\n        val negativeSums = sums.filter(x => x < 0)\n        val positiveSumsCount = positiveSums.count(x => x > 0)\n        val negativeSumsCount = negativeSums.count(x => x < 0)\n        val positiveSumsSum = positiveSums.sum\n        val negativeSumsSum = negativeSums.sum\n        val positiveSumsSumAbs = math.abs(positiveSumsSum)\n        val negativeSumsSumAbs = math.abs(negativeSumsSum)\n        val positiveSumsSumAbsCount = positiveSums.count(x => math.abs(x) > 0)\n        val negativeSumsSumAbsCount = negativeSums.count(x => math.abs(x) < 0)\n        val positiveSumsSumAbsSum = positiveSums.sum\n        val negativeSumsSumAbsSum = negativeSums.sum\n        val positiveSumsSumAbsSumAbs = math.abs(positiveSumsSumAbs)\n        val negativeSumsSumAbsSumAbs = math.abs(negativeSumsSumAbs)\n        val positiveSumsSumAbsSumAbsCount = positiveSums.count(x => math.abs(x) > 0)\n        val negativeSumsSumAbsSumAbsCount = negativeSums.count(x => math.abs(x) < 0)\n        val positiveSumsSumAbsSumAbsSum = positiveSums.sum\n        val negativeSumsSumAbsSumAbsSum = negativeSums.sum\n        val positiveSumsSumAbsSumAbsSumAbs = math.abs(positiveSumsSumAbsSumAbs)\n        val negativeSumsSumAbsSumAbsSumAbs = math.abs(negativeSumsSumAbsSumAbs)\n        val positiveSumsSumAbsSumAbsSumAbsCount = positiveSums.count(x => math.abs(x) > 0)\n        val negativeSumsSumAbsSumAbsSumAbsCount = negativeSums.count(x => math.abs(x) < 0)\n        val positiveSumsSumAbsSumAbsSumAbsSum = positiveSums.sum\n        val negativeSumsSumAbsSumAbsSumAbsSum = negativeSums.sum\n        val positiveSumsSumAbsSumAbsSumAbsSumAbs = math.abs(positiveSumsSumAbsSumAbsSumAbs)\n        val negativeSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpew6j31ms.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpew6j31ms.scala:40:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val positiveSums = sums.filter(x => x > 0)\n        val negativeSums = sums.filter(x => x < 0)\n        val positiveSumsCount = positiveSums.size\n        val negativeSumsCount = negativeSums.size\n        val numsCount = nums.size\n        val positiveSumsSum = positiveSums.sum\n        val negativeSumsSum = negativeSums.sum\n        val numsSum = nums.sum\n        val positiveSumsSumOfDigits = positiveSumsSum.toString.toInt\n        val negativeSumsSumOfDigits = negativeSumsSum.toString.toInt\n        val numsSumOfDigits = numsSum.toString.toInt\n        val positiveSumsSumOfDigitsCount = positiveSumsSumOfDigits.toInt\n        val negativeSumsSumOfDigitsCount = negativeSumsSumOfDigits.toInt\n        val numsSumOfDigitsCount = numsSumOfDigits.toInt\n        val positiveSumsSumOfDigitsSum = positiveSumsSumOfDigits / numsSumOfDigits\n        val negativeSumsSumOfDigitsSum = negativeSumsSumOfDigits / numsSumOfDigits\n        val numsSumOfDigitsSum = numsSum / numsSumOfDigits\n        val positiveSumsSumOfDigitsSumOfDigits = positiveSumsSumOfDigitsSum.toString.toInt\n        val negativeSumsSumOfDigitsSumOfDigits = negativeSumsSumOfDigitsSum.toString.toInt\n        val numsSumOfDigitsSumOfDigits = numsSumOfDigitsSum.toString.toInt\n        val positiveSumsSumOfDigitsSumOfDigitsCount = positiveSumsSumOfDigitsSumOfDigits.toInt\n        val negativeSumsSumOfDigitsSumOfDigitsCount = negativeSumsSumOfDigitsSumOfDigits.toInt\n        val numsSumOfDigitsSumOfDigitsCount = numsSumOfDigitsSumOfDigits.toInt\n        val positiveSumsSumOfDigitsSumOfDigitsSum = positiveSumsSumOfDigitsSumOfDigits / numsSumOfDigitsSumOfDigits\n        val negativeSumsSumOfDigitsSumOfDigitsSum = negativeSumsSumOfDigitsSumOfDig\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpcfog4zl2.scala:38:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumsSumOfDigitsSumOfDigitsSum\u001b[0m = negativeSumsSumOfDigitsSumOfDig\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: negativeSumsSumOfDigitsSumOfDig\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcfog4zl2.scala:39:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798799
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = nums.map(x => math.abs(x)).sum\n        nums.filter(x => math.abs(x) > 0).count(x => math.abs(x) == numsSum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc1uvpnf2.scala:19)\n\tat Problem.main(tmpc1uvpnf2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpi82fdzgl.scala:19)\n\tat Problem.main(tmpi82fdzgl.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = arr.count(x => nums.contains(x))\n        numsCount\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpffx8cr5x.scala:18)\n\tat Problem.main(tmpffx8cr5x.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.foldLeft(0)(_ + _._2)\n        nums.filter(x => math.abs(x) > 0).length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpfdn8jn1t.scala:15:41 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.foldLeft(\u001b[31m0\u001b[0m)(_ + _._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments ((_$2._2 : => List[Long]))\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfdn8jn1t.scala:16:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        nums.filter(\u001b[36mx\u001b[0m => math.abs(x) > \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value length is not a member of Set[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => math.abs(x))\n        val sums = nums.map(x => math.abs(x)).reduceLeft(_ + _)\n        sums.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat Problem$.countNums(tmpzldij73u.scala:13)\n\tat Problem$.main(tmpzldij73u.scala:17)\n\tat Problem.main(tmpzldij73u.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp3i_1mmyx.scala:14:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.mapValues(_.size).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798799
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(_._2)._2\n        val numsOverMaxCount = nums.filter(x => math.abs(x) > maxCount)\n        val numsOverMaxCountSum = numsOverMaxCount.map(x => math.abs(x)).reduce(_ + _)\n        numsOverMaxCountSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp7qfriacn.scala:15:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxCount\u001b[0m = counts.maxBy(_._2)._2\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for List[Long]..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.ordered[\u001b[35mList[Long]\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[List[Long]].\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.seqOrdering\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => if (x < 0) -x else x).distinct\n        val sums = nums.map(x => math.abs(x)).sum\n        nums.count(x => sums - math.abs(x) > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp65ek4242.scala:18)\n\tat Problem.main(tmp65ek4242.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for (i <- 0 until arr.length) {\n            sum += arr(i)\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppz_rdhhh.scala:25)\n\tat Problem.main(tmppz_rdhhh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sum = nums.sum\n        if (sum < 0) nums.map(_.toInt).sum\n        else nums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsoi83e_v.scala:19)\n\tat Problem.main(tmpsoi83e_v.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0)\n        val numsSum = nums.map(x => x.toString.toInt).sum\n        nums.filter(x => x < 0).map(x => x.toString.toInt).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5u1bz_1g.scala:19)\n\tat Problem.main(tmp5u1bz_1g.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var count = 0\n        for (i <- arr) {\n            sum += i\n            count += 1\n        }\n        if (sum > 0) {\n            count\n        } else {\n            count + 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpytn4g9pk.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798799
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val result = sums.count(x => x > 0)\n        nums.count(x => x < 0) == result * -1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpao4h2ri7.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        nums.count(\u001b[36mx\u001b[0m => x < \u001b[31m0\u001b[0m) == result * -\u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Boolean\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val nums = sums.filter(x => x > 0)\n        nums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12fi5_o9.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12fi5_o9.scala:14:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = sums.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp12fi5_o9.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        nums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798810
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => math.abs(x))\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x)).mapValues(_.size)\n        val result = counts.filter(_._2 > 0).map(_._2).sum\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6v52b0as.scala:20)\n\tat Problem.main(tmp6v52b0as.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.toList.foldLeft(0L) { (sum, num) =>\n            val digits = num.toString.reverse.grouped(2).map(_ + _)\n            sum + digits.sum\n        }\n        numsSum.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpeer5z7b0.scala:14:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigits\u001b[0m = num.toString.reverse.grouped(\u001b[31m2\u001b[0m).map(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmpeer5z7b0.scala:15:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            sum + digits.sum\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mBigDecimalIsFractional\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mBigIntIsIntegral\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mNumeric\u001b[0m match type Numeric[B] of parameter num of \u001b[33mmethod\u001b[0m \u001b[35msum\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mIterableOnceOps\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsLen = arr.length\n        val numsSum = arr.map(x => math.abs(x)).sum\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = math.abs(numsSum).floor.toInt\n        val numsSumDigits = numsSum.toString.length\n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeub087o0.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSum.toString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeub087o0.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = math.abs(numsSum).floor.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeub087o0.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSum.toString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeub087o0.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = math.abs(numsSum).floor.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpeub087o0.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSum.toString.length\n\u001b[31m\u001b",
      "stdout": "",
      "timestamp": 1659798810
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.map(x => math.abs(x)).toSet\n        val numsSumsSums = numsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSums = numsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSums = numsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSums = numsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x)).toSet\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpmjnx67yb.scala:26:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmjnx67yb.scala:20:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x)).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m             Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumsSumsSumsSumsSumsSums\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpmjnx67yb.scala:21:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x)).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m         Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmjnx67yb.scala:25:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x)).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     Not found: numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmjnx67yb.scala:27:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 ",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x > 0)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpsd0mvlkh.scala:15:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.mapValues(_.size).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798810
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSet\n        val numsSet2 = nums.toSet\n        val numsSet3 = nums.toSet\n        val numsSet4 = nums.toSet\n        val numsSet5 = nums.toSet\n        val numsSet6 = nums.toSet\n        val numsSet7 = nums.toSet\n        val numsSet8 = nums.toSet\n        val numsSet9 = nums.toSet\n        val numsSet10 = nums.toSet\n        val numsSet11 = nums.toSet\n        val numsSet12 = nums.toSet\n        val numsSet13 = nums.toSet\n        val numsSet14 = nums.toSet\n        val numsSet15 = nums.toSet\n        val numsSet16 = nums.toSet\n        val numsSet17 = nums.toSet\n        val numsSet18 = nums.toSet\n        val numsSet19 = nums.toSet\n        val numsSet20 = nums.toSet\n        val numsSet21 = nums.toSet\n        val numsSet22 = nums.toSet\n        val numsSet23 = nums.toSet\n        val numsSet24 = nums.toSet\n        val numsSet25 = nums.toSet\n        val numsSet26 = nums.toSet\n        val numsSet27 = nums.toSet\n        val numsSet28 = nums.toSet\n        val numsSet29 = nums.toSet\n        val numsSet30 = nums.toSet\n        val numsSet31 = nums.toSet\n        val numsSet32 = nums.toSet\n        val numsSet33 = nums.toSet\n        val numsSet34 = nums.toSet\n        val numsSet35 = nums.toSet\n        val numsSet36 = nums.toSet\n        val numsSet37 = nums.toSet\n        val numsSet38 = nums.toSet\n        val numsSet39 = nums.toSet\n        val numsSet40 = nums.toSet\n        val numsSet41 = nums.toSet\n        val numsSet42 = nums.toSet\n        val numsSet43 = nums.toSet\n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpueayferw.scala:57:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798809
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => if (x < 0) -x else x).distinct\n        val sums = nums.map(x => math.abs(x))\n        val sumsSum = sums.sum\n        nums.count(x => math.abs(x) > sumsSum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2jdxzo2j.scala:20)\n\tat Problem.main(tmp2jdxzo2j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for(i <- 0 until arr.length) {\n            sum += arr(i)\n            if(sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpih27g6zd.scala:25)\n\tat Problem.main(tmpih27g6zd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y == x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpil68igrt.scala:19)\n\tat Problem.main(tmpil68igrt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sum = digits.sum\n        if (sum < 0) sum * -1\n        else sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphhq6jtlj.scala:19)\n\tat Problem.main(tmphhq6jtlj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x > 0).map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, math.ceil(math.log10(x))))\n        val res = sums.foldLeft(0)((acc, x) => acc + x)\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkha2pg90.scala:14:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = sums.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc + x)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    Double\n\u001b[31m   |\u001b[0m                                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSet\n        val numsSum = nums.map(x => x.toString.toInt).sum\n        val numsSumSet = numsSum.toSet\n        val numsSumSet2 = numsSumSet.filter(_ > 0)\n        val numsSumSet3 = numsSumSet2.filter(_ > 0)\n        numsSumSet3.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf8p04djf.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet\u001b[0m = numsSum.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value toSet is not a member of Int - did you mean numsSum.toInt?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val result = counts.mapValues(x => x.size)\n        val sum = result.mapValues(x => x.sum)\n        val positiveSum = sum.filter(_ > 0)\n        val negativeSum = sum.filter(_ < 0)\n        val positiveCount = positiveSum.sum\n        val negativeCount = negativeSum.sum\n        val positiveSumCount = positiveSum.size\n        val negativeSumCount = negativeSum.size\n        val positiveCount = positiveCount.toLong\n        val negativeCount = negativeCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7csbvbdi.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveCount\u001b[0m = positiveCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7csbvbdi.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeCount\u001b[0m = negativeCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7csbvbdi.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumCount\u001b[0m = positiveSumCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveSumCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveSumCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7csbvbdi.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumCount\u001b[0m = negativeSumCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeSumCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeSumCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7csbvbdi.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumCount\u001b[0m = positiveSumCount.toLong\n\u001b[31m\u001b[",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for (i <- arr) {\n            sum += i\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp52gslib9.scala:25)\n\tat Problem.main(tmp52gslib9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var count = 0\n        for (i <- arr) {\n            sum += i\n            count += 1\n        }\n        if (sum > 0) {\n            count\n        } else {\n            count - 1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoolxojui.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfjuca_sd.scala:19)\n\tat Problem.main(tmpfjuca_sd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, x.length))\n        val count = sums.reduceLeft(_ + _)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpymgppxvw.scala:13:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = nums.map(\u001b[36mx\u001b[0m => math.pow(\u001b[31m10\u001b[0m, x.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpymgppxvw.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        count\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (count : Double)\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfjuca_sd.scala:19)\n\tat Problem.main(tmpfjuca_sd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(x => math.abs(x))\n        val sums = digits.map(x => math.pow(10, x))\n        val count = sums.filter(x => x > 0).size\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpp9os_s30.scala:19)\n\tat Problem.main(tmpp9os_s30.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        sumsSet.filter(x => numsSet.contains(x)).size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmqi8f_a0.scala:20)\n\tat Problem.main(tmpmqi8f_a0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSums = nums.map(x => math.abs(x)).filter(x => x > 0)\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSet = numsSums.toSet.toSet\n        val numsSumsSetSetSet = numsSums.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.to\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa3ymonru.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSet\u001b[0m = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpa3ymonru.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSums.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.toSet.to\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa3ymonru.scala:29:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = nums.size\n        val numsSum = nums.map(x => math.abs(x)).sum\n        numsCount - numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_5db1twt.scala:20)\n\tat Problem.main(tmp_5db1twt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798814
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        val negCount = sums.count(x => x < 0)\n        val negSums = sums.filter(x => x < 0)\n        val negSumsCount = negSums.count(x => x > 0)\n        val negSumsCount2 = negSums.count(x => x < 0)\n        val negSumsCount3 = negSums.count(x => x == 0)\n        val negSumsCount4 = negSums.count(x => x == -1)\n        val negSumsCount5 = negSums.count(x => x == -2)\n        val negSumsCount6 = negSums.count(x => x == -3)\n        val negSumsCount7 = negSums.count(x => x == -4)\n        val negSumsCount8 = negSums.count(x => x == -5)\n        val negSumsCount9 = negSums.count(x => x == -6)\n        val negSumsCount10 = negSums.count(x => x == -7)\n        val negSumsCount11 = negSums.count(x => x == -8)\n        val negSumsCount12 = negSums.count(x => x == -9)\n        val negSumsCount13 = negSums.count(x => x == -10)\n        val negSumsCount14 = negSums.count(x => x == -11)\n        val negSumsCount15 = negSums.count(x => x == -12)\n        val negSumsCount16 = negSums.count(x => x == -13)\n        val negSumsCount17 = negSums.count(x => x == -14)\n        val negSumsCount18 = negSums.count(x => x == -15)\n        val negSumsCount19 = negSums.count(x => x == -16)\n        val negSumsCount20 = negSums.count(x => x == -17)\n        val negSumsCount21 = negSums.count(x => x == -18)\n        val negSumsCount22 = negSums.count(x => x == -19)\n        val negSumsCount23 = negSums.count(x => x == -20)\n        val negSumsCount24 = negSums.count(x => x == -21)\n        val negSumsCount25 = negSums.count(x => x == -22)\n        val negSumsCount26 = negSums.count(x => x == -23)\n        val negSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpycbc5j9c.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpycbc5j9c.scala:44:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798817
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = nums.map(x => math.abs(x))\n        val numsSumSum = numsSum.sum\n        numsSumSum.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4y4lt0ft.scala:19)\n\tat Problem.main(tmp4y4lt0ft.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798822
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.filter(x => sums.contains(math.abs(x)))\n        numsSums.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb6cyg6wa.scala:19)\n\tat Problem.main(tmpb6cyg6wa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val digits = arr.filter(_ > 0).map(_.toString.toInt)\n        val sum = digits.sum\n        val numsSum = nums.filter(_ > 0).sum\n        val numsSumDigits = numsSum.toString.toInt\n        val numsSumDigit = numsSumDigits % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits / 10\n\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprss4uv0f.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprss4uv0f.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = numsSumDigit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprss4uv0f.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprss4uv0f.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = numsSumDigit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmprss4uv0f.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits / \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798821
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(x => x._2)._1\n        val nums = counts.filter(x => x._2 == maxCount).map(x => x._1)\n        val result = nums.filter(x => x > 0).length\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6163v2w_.scala:14:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxCount\u001b[0m = counts.maxBy(\u001b[36mx\u001b[0m => x._2)._1\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for List[Long]..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.comparatorToOrdering[\u001b[35mList[Long]\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type java.util.Comparator[List[Long]].\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.seqOrdering\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6163v2w_.scala:16:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = nums.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m).length\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue length is not a member of scala.collection.immutable.Iterable[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(x => math.abs(x))\n        val sum = digits.sum\n        val nums = arr.filter(x => math.abs(x) > 0).length\n        sum - nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp31vsq4gn.scala:19)\n\tat Problem.main(tmp31vsq4gn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for (i <- arr) {\n            sum += i\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp52gslib9.scala:25)\n\tat Problem.main(tmp52gslib9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSeq\n        val numsSetLen = numsSet.size\n        val numsSetSum = numsSet.sum\n        val numsSetSumLen = numsSetSum.length\n        val numsSetSumDigits = numsSetSum.digits\n        val numsSetSumDigitsLen = numsSetSumDigits.length\n        val numsSetSumDigitsSum = numsSetSumDigits.sum\n        val numsSetSumDigitsSumLen = numsSetSumDigitsSum.length\n        val numsSetSumDigitsSumDigits = numsSetSumDigitsSum.digits\n        val numsSetSumDigitsSumDigitsLen = numsSetSumDigitsSumDigits.length\n        val numsSetSumDigitsSumDigitsSum = numsSetSumDigitsSumDigits.sum\n        val numsSetSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSum.length\n        val numsSetSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigits.sum\n        val numsSetSumDigitsSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSumDigitsSum.length\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigitsSumDigits.sum\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSum.length\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum.digits\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum.len\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum.sum\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSumLen = nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc9i91vrn.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen\u001b[0m = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum.len\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpc9i91vrn.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum\u001b[0m = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsSum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc9i91vrn.scala:16:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumLen\u001b[0m = numsSetSum.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value length is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc9i91vrn.scala:17:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigits\u001b[0m = numsSetSum.digits\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value digits is not a member of Long\n\u001b[31m\u001b[31m-- [E00",
      "stdout": "",
      "timestamp": 1659798822
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        sumsSet.count(x => x > 0) + (numsSet.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x => x > 0) * (arr.count(x \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0gq8bpu6.scala:17:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0gq8bpu6.scala:16:1676 ----------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        sumsSet.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) + (numsSet.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m) * (arr.count",
      "stdout": "",
      "timestamp": 1659798820
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfjuca_sd.scala:19)\n\tat Problem.main(tmpfjuca_sd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        val negative = sums.count(x => x < 0)\n        if (negative > 0) count - negative else count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplnwirco0.scala:20)\n\tat Problem.main(tmplnwirco0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sum = digits.sum\n        val nums = arr.filter(x => x > 0).map(x => digits.count(_ > 0))\n        nums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp4oangx5e.scala:20)\n\tat Problem.main(tmp4oangx5e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(_._1)._1\n        val numsWithMaxCount = nums.filter(x => math.abs(x) == maxCount)\n        numsWithMaxCount.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.maxBy\n\tat scala.collection.IterableOnceOps.maxBy(IterableOnce.scala:978)\n\tat scala.collection.IterableOnceOps.maxBy$(IterableOnce.scala:976)\n\tat scala.collection.AbstractIterable.maxBy(Iterable.scala:926)\n\tat Problem$.countNums(tmpa0k8w4dy.scala:15)\n\tat Problem$.main(tmpa0k8w4dy.scala:20)\n\tat Problem.main(tmpa0k8w4dy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = nums.map(x => math.abs(x)).sum\n        numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpulnz27tv.scala:18)\n\tat Problem.main(tmpulnz27tv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSeq\n        val numsSetLen = numsSet.size\n        val numsSetSum = numsSet.sum\n        val numsSetSumLen = numsSetSum.length\n        val numsSetSumDigits = numsSetSum.map(_.toString.toInt)\n        val numsSetSumDigitsLen = numsSetSumDigits.length\n        val numsSetSumDigitsSum = numsSetSumDigits.sum\n        val numsSetSumDigitsSumLen = numsSetSumDigitsSum.length\n        val numsSetSumDigitsSumDigits = numsSetSumDigitsSum.map(_.toString.toInt)\n        val numsSetSumDigitsSumDigitsLen = numsSetSumDigitsSumDigits.length\n        val numsSetSumDigitsSumDigitsSum = numsSetSumDigitsSumDigits.sum\n        val numsSetSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSum.length\n        val numsSetSumDigitsSumDigitsSumDigits = numsSetSumDigitsSumDigitsSum.map(_.toString.toInt)\n        val numsSetSumDigitsSumDigitsSumDigitsLen = numsSetSumDigitsSumDigitsSumDigits.length\n        val numsSetSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigits.sum\n        val numsSetSumDigitsSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSumDigitsSum.length\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigits = numsSetSumDigitsSumDigitsSumDigitsSum.map(_.toString.toInt)\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsLen = numsSetSumDigitsSumDigitsSumDigitsSumDigits.length\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSum = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSum.sum\n        val numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsLen\n        numsSet\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz84kqp5d.scala:16:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumLen\u001b[0m = numsSetSum.length\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            value length is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz84kqp5d.scala:17:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigits\u001b[0m = numsSetSum.map(_.toString.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value map is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpz84kqp5d.scala:31:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSum\u001b[0m = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz84kqp5d.scala:32:64 ------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSumDigitsSumDigitsSumDigitsSumLen\u001b[0m = numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsLen\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Not found: numsSetSumDigitsSumDigitsSumDigitsSumDigitsSumDigitsLen\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz84kqp5d.scala:33:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        numsSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (numsSet : Seq[Long])\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanatio",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSum = nums.map(x => math.abs(x))\n        val numsSumSet = numsSum.toSet\n        val numsSumSet2 = numsSum.map(x => math.abs(x))\n        val numsSumSet3 = numsSum.map(x => math.abs(x))\n        val numsSumSet4 = numsSum.map(x => math.abs(x))\n        val numsSumSet5 = numsSum.map(x => math.abs(x))\n        val numsSumSet6 = numsSum.map(x => math.abs(x))\n        val numsSumSet7 = numsSum.map(x => math.abs(x))\n        val numsSumSet8 = numsSum.map(x => math.abs(x))\n        val numsSumSet9 = numsSum.map(x => math.abs(x))\n        val numsSumSet10 = numsSum.map(x => math.abs(x))\n        val numsSumSet11 = numsSum.map(x => math.abs(x))\n        val numsSumSet12 = numsSum.map(x => math.abs(x))\n        val numsSumSet13 = numsSum.map(x => math.abs(x))\n        val numsSumSet14 = numsSum.map(x => math.abs(x))\n        val numsSumSet15 = numsSum.map(x => math.abs(x))\n        val numsSumSet16 = numsSum.map(x => math.abs(x))\n        val numsSumSet17 = numsSum.map(x => math.abs(x))\n        val numsSumSet18 = numsSum.map(x => math.abs(x))\n        val numsSumSet19 = numsSum.map(x => math.abs(x))\n        val numsSumSet20 = numsSum.map(x => math.abs(x))\n        val numsSumSet21 = numsSum.map(x => math.abs(x))\n        val numsSumSet22 = numsSum.map(x => math.abs(x))\n        val numsSumSet23 = numsSum.map(x => math.abs(x))\n        val numsSumSet24 = numsSum.map(x => math.abs(x))\n        val numsSumSet25 = numsSum.map(x => math.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpw5qajplj.scala:42:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpw5qajplj.scala:42:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = sums.toSet\n        nums.filter(x => numsSums.contains(math.abs(x)))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv9hdayn8.scala:15:19 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        nums.filter(\u001b[36mx\u001b[0m => numsSums.contains(math.abs(x)))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31mSet\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSum = nums.map(x => math.abs(x)).reduceLeft(_ + _)\n        val numsSumSet = numsSum.toSet\n        val numsSumSetSet = numsSumSet.toSet\n        val numsSumSetSetSet = numsSumSetSet.toSet\n        val numsSumSetSetSetSet = numsSumSetSetSet.toSet\n        val numsSumSetSetSetSetSet = numsSumSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSet = numsSumSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSetSetSet = numsSumSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumSetSetSetSetSetSetSetSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpj_cc0cey.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj_cc0cey.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj_cc0cey.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumSetSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpj_cc0cey.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0)\n        val sums = nums.map(x => math.abs(x)).sum\n        nums.count(x => math.abs(x) > sums)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvw5ghu0p.scala:19)\n\tat Problem.main(tmpvw5ghu0p.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(x => x.toString.toInt).map(_.sum)\n        sums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmrm5mgs.scala:13:59 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(\u001b[36mx\u001b[0m => x.toString.toInt).map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpsmrm5mgs.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        sums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val sums = mutable.ArrayBuffer.empty[Long]\n        for(i <- 0 until n){\n            val sum = 0\n            for(j <- 0 until i){\n                sum += arr(j)\n            }\n            sums += sum\n        }\n        sums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgy2w6bhc.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgy2w6bhc.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                sum += arr(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean sum.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        arr.foreach(x => sum += x)\n        if (sum < 0) sum = -sum\n        arr.count(x => x > 0 && sum > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0xz3d6ez.scala:13:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        arr.foreach(\u001b[36mx\u001b[0m => sum += x)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798824
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.length)\n        count.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpruoenw16.scala:19)\n\tat Problem.main(tmpruoenw16.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798826
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, math.ceil(math.log10(x))))\n        val counts = sums.map(x => math.ceil(x / x))\n        val result = counts.foldLeft(0)((x, y) => x + y)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqmijpd1p.scala:15:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = counts.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x + y)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    Double\n\u001b[31m   |\u001b[0m                                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSet = numsSums.map(x => math.abs(x)).toSet\n        val numsSumsSetSetSet = numsSumsSet.toSet\n        val numsSumsSetSetSet = numsSumsSetSet.toSet\n        val numsSumsSetSetSetSet = numsSumsSetSetSet.toSet\n        val numsSumsSetSetSetSet = numsSumsSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSet = numsSumsSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSet = numsSumsSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSet = numsSumsSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvhda_moz.scala:35:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvhda_moz.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSet\u001b[0m = numsSumsSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvhda_moz.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSet\u001b[0m = numsSumsSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvhda_moz.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpvhda_moz.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSet",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val count = sums.count(x => x > 0)\n        nums.count(x => math.abs(x) > 0) - (count - nums.count(x => math.abs(x) > 0))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxeuc12k3.scala:19)\n\tat Problem.main(tmpxeuc12k3.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798829
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSum = sums.toSet\n        val numsSumCount = numsSum.count\n        nums.count(x => numsSum.contains(math.abs(x)))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwrdopn60.scala:20)\n\tat Problem.main(tmpwrdopn60.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798834
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sum = nums.sum\n        val digits = nums.map(_.toInt)\n        val negatives = nums.filter(x => x < 0).map(_.toInt)\n        val positives = nums.filter(x => x > 0).map(_.toInt)\n        val positiveSum = positives.sum\n        val negativeSum = negatives.sum\n        val positiveDigits = positives.map(_.toInt)\n        val negativeDigits = negatives.map(_.toInt)\n        val positiveDigitSum = positiveDigits.sum\n        val negativeDigitSum = negativeDigits.sum\n        val positiveDigitSumDigits = positiveDigits.map(_.toInt).sum\n        val negativeDigitSumDigits = negativeDigits.map(_.toInt).sum\n        val positiveDigitSumDigitsDigits = positiveDigits.map(_.toInt).map(_.toInt).sum\n        val negativeDigitSumDigitsDigits = negativeDigits.map(_.toInt).map(_.toInt).sum\n        val positiveDigitSumDigitsDigitsDigits = positiveDigits.map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val negativeDigitSumDigitsDigitsDigits = negativeDigits.map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val positiveDigitSumDigitsDigitsDigitsDigits = positiveDigits.map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val negativeDigitSumDigitsDigitsDigitsDigits = negativeDigits.map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val positiveDigitSumDigitsDigitsDigitsDigitsDigits = positiveDigits.map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val negativeDigitSumDigitsDigitsDigitsDigitsDigits = negativeDigits.map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).sum\n        val positiveDigitSumDigitsDigitsDigitsDigitsDigitsDigits = positiveDigits.map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.toInt).map(_.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp15tqoh4_.scala:34:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp15tqoh4_.scala:34:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798833
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val digits = arr.map(x => math.abs(x))\n        val sums = digits.map(x => math.pow(10, x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmptwuk5lbv.scala:20)\n\tat Problem.main(tmptwuk5lbv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798835
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSums = numsSums.map(x => math.abs(x))\n        val numsSumsSumsSums = numsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSums = numsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSums = numsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(x => math.abs(x))\n        val numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpsox6594i.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsox6594i.scala:20:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m             Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumsSumsSumsSumsSumsSums\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsox6594i.scala:21:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m         Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsox6594i.scala:25:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums\u001b[0m = numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums.map(\u001b[36mx\u001b[0m => math.abs(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     Not found: numsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSumsSums\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsox6594i.scala:27:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m",
      "stdout": "",
      "timestamp": 1659798833
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(_ > 0))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxp4lwir7.scala:19)\n\tat Problem.main(tmpxp4lwir7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798835
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val m = arr.map(_.toString.toInt).sum\n        val result = arr.filter(_ > 0).count(_ > 0)\n        if (result > 0) m / result else 0\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc3h8pp3d.scala:20)\n\tat Problem.main(tmpc3h8pp3d.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, math.ceil(math.log10(x))))\n        val counts = sums.map(x => nums.count(y => y % x == 0))\n        counts.reduce((x, y) => x + y)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat scala.collection.IterableOnceOps.reduce(IterableOnce.scala:698)\n\tat scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:698)\n\tat scala.collection.AbstractIterable.reduce(Iterable.scala:926)\n\tat Problem$.countNums(tmpug_y9t1m.scala:15)\n\tat Problem$.main(tmpug_y9t1m.scala:18)\n\tat Problem.main(tmpug_y9t1m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0)\n        val numsSum = nums.map(x => math.abs(x)).sum\n        nums.count(x => math.abs(x) > 0) + (numsSum - nums.sum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp606jdz87.scala:22)\n\tat Problem.main(tmp606jdz87.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x)).mapValues(_.size)\n        nums.foldLeft(0L){ (sum, num) =>\n            val count = counts(math.abs(num))\n            sum + math.pow(10, count) * count\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprk_lnard.scala:17:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            sum + math.pow(\u001b[31m10\u001b[0m, count) * count\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Double\n\u001b[31m   |\u001b[0m            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798834
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size)\n        val result = count.mapValues(x => math.abs(x))\n        val sum = result.mapValues(x => math.abs(x))\n        val positiveSum = sum.filter(_ > 0)\n        val negativeSum = sum.filter(_ < 0)\n        val positiveCount = positiveSum.sum\n        val negativeCount = negativeSum.sum\n        val positiveSumCount = positiveSum.sum\n        val negativeSumCount = negativeSum.sum\n        val positiveSumCount2 = positiveSum.sum\n        val negativeSumCount2 = negativeSum.sum\n        val positiveSumCount3 = positiveSum.sum\n        val negativeSumCount3 = negativeSum.sum\n        val positiveSumCount4 = positiveSum.sum\n        val negativeSumCount4 = negativeSum.sum\n        val positiveSumCount5 = positiveSum.sum\n        val negativeSumCount5 = negativeSum.sum\n        val positiveSumCount6 = positiveSum.sum\n        val negativeSumCount6 = negativeSum.sum\n        val positiveSumCount7 = positiveSum.sum\n        val negativeSumCount7 = negativeSum.sum\n        val positiveSumCount8 = positiveSum.sum\n        val negativeSumCount8 = negativeSum.sum\n        val positiveSumCount9 = positiveSum.sum\n        val negativeSumCount9 = negativeSum.sum\n        val positiveSumCount10 = positiveSum.sum\n        val negativeSumCount10 = negativeSum.sum\n        val positiveSumCount11 = positiveSum.sum\n        val negativeSumCount11 = negativeSum.sum\n        val positiveSumCount12 = positiveSum.sum\n        val negativeSumCount12 = negativeSum.sum\n        val positiveSumCount13 = positiveSum.sum\n        val negativeSumCount13 = negativeSum.sum\n        val positiveSumCount14 = positiveSum.sum\n        val negativeSumCount14 = negativeSum.sum\n        val positiveSumCount15 = positiveSum.sum\n        val negativeSumCount15 = negativeSum.sum\n        val positiveSumCount16 = positiveSum.sum\n        val negativeSumCount16 = negativeSum.sum\n        val positiveSumCount17 = positiveSum.sum\n        val negativeSumCount17 = negativeSum.sum\n        val positiveSumCount18 = positiveSum.sum\n        val negativeSumCount18 = negativeSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjohtldyv.scala:18:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSum\u001b[0m = sum.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of (Long, Int), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjohtldyv.scala:19:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSum\u001b[0m = sum.filter(_ < \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue < is not a member of (Long, Int), but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjohtldyv.scala:20:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveCount\u001b[0m = positiveSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjohtldyv.scala:21:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeCount\u001b[0m = negativeSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjohtldyv.scala:22:46",
      "stdout": "",
      "timestamp": 1659798840
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = arr.count(x => x > 0)\n        val numsSum = arr.count(x => x >= 0)\n        val numsSumDigit = arr.count(x => x >= 0 && x < 10)\n        val numsSumDigitNegative = arr.count(x => x >= 0 && x < 10 && x < 0)\n        val numsSumDigitNegativeFirst = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10)\n        val numsSumDigitNegativeSecond = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 0)\n        val numsSumDigitNegativeThird = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeFourth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeFifth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeSixth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeSeventh = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeEighth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeNinth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeTenth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeEleventh = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val numsSumDigitNegativeTwelth = arr.count(x => x >= 0 && x < 10 && x < 0 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 10 && x < 0)\n        val nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpvhn5ri93.scala:30:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvhn5ri93.scala:30:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798835
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sums = digits.map(x => math.abs(x))\n        val nums = sums.filter(x => x > 0)\n        nums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5ph5de__.scala:19)\n\tat Problem.main(tmp5ph5de__.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        nums.count(x => math.abs(x) == sums.max)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpoeh7oinq.scala:19)\n\tat Problem.main(tmpoeh7oinq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = arr.count(x => x > 0)\n        val numsSum = arr.count(x => x > 0 && x % 10 == 0)\n        numsCount - numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_vxxxa7y.scala:22)\n\tat Problem.main(tmp_vxxxa7y.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798837
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x))\n        val numsSumSet = numsSum.toSet\n        val numsSumSetSize = numsSumSet.size\n        val numsSumSetIterator = numsSumSet.iterator\n        val numsSumSetIteratorSize = numsSumSetIterator.size\n        val numsSumSetIteratorIterator = numsSumSetIterator.iterator\n        val numsSumSetIteratorIteratorSize = numsSumSetIteratorIterator.size\n        val numsSumSetIteratorIteratorIterator = numsSumSetIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIterator\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyrxysx5_.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyrxysx5_.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyrxysx5_.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyrxysx5_.scala:33:93 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIterat",
      "stdout": "",
      "timestamp": 1659798835
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        for(i <- arr) {\n            sum += i\n        }\n        sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgwhw_4rk.scala:14:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        sums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyj53wqlk.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyj53wqlk.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        sums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(_ % 10).mapValues(_.size)\n        val result = counts.filter(_._2 > 0).map(_._2).sum\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpe0pb1o_r.scala:24)\n\tat Problem.main(tmpe0pb1o_r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798839
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSet\n        val numsSetIterator = numsSet.iterator\n        var count = 0\n        while (numsSetIterator.hasNext) {\n            val num = numsSetIterator.next\n            if (num > 0) {\n                val digits = num.toString.toList.map(_.toInt)\n                val sum = digits.sum\n                if (sum > 0) {\n                    count = count + 1\n                }\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvq8f14ra.scala:31)\n\tat Problem.main(tmpvq8f14ra.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798838
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(_._1)._1\n        val numsWithMaxCount = nums.filter(x => math.abs(x) == maxCount)\n        numsWithMaxCount.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.maxBy\n\tat scala.collection.IterableOnceOps.maxBy(IterableOnce.scala:978)\n\tat scala.collection.IterableOnceOps.maxBy$(IterableOnce.scala:976)\n\tat scala.collection.AbstractIterable.maxBy(Iterable.scala:926)\n\tat Problem$.countNums(tmp5yrm8ur1.scala:15)\n\tat Problem$.main(tmp5yrm8ur1.scala:20)\n\tat Problem.main(tmp5yrm8ur1.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val positiveSums = sums.filter(sum => sum > 0)\n        val negativeSums = sums.filter(sum => sum < 0)\n        val positiveSumsCount = positiveSums.size\n        val negativeSumsCount = negativeSums.size\n        val positiveSumsSum = positiveSums.sum\n        val negativeSumsSum = negativeSums.sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positiveSums.map(_.toString.toInt).sum\n        val negativeSumsSumDigits = negativeSums.map(_.toString.toInt).sum\n        val positiveSumsSumDigits = positive\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpol_bhxxm.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumsSumDigits\u001b[0m = positiveSums.map(_.toString.toInt).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveSumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveSumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpol_bhxxm.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumsSumDigits\u001b[0m = negativeSums.map(_.toString.toInt).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeSumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeSumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpol_bhxxm.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumsSumDigits\u001b[0m = positiveSums.map(_.toString.toInt).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveSumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveSumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpol_bhxxm.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumsSumDigits\u001b[0m = negativeSums.map(_.toString.toInt).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeSumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeSumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be define",
      "stdout": "",
      "timestamp": 1659798839
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(_ > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphn82i_cm.scala:19)\n\tat Problem.main(tmphn82i_cm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798840
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsWithSum = sums.filter(x => x >= 0)\n        numsWithSum.count(x => x > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_xy1a31l.scala:19)\n\tat Problem.main(tmp_xy1a31l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798842
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val sumsSorted = sums.sortWith(_ < _)\n        val sumsSortedCount = sumsSorted.length\n        val nums = arr.filter(x => math.abs(x) > 0).length\n        val numsSorted = nums.sortWith(_ < _)\n        val numsSortedCount = numsSorted.length\n        val numsSum = sumsSorted.zip(numsSorted).filter(_._1 > 0).length\n        numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm6pm8c25.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSorted\u001b[0m = nums.sortWith(_ < _)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value sortWith is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798844
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = arr.toList.foldLeft(0)(_ + nums.count(_ > 0))\n        numsCount\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpazz4gx7p.scala:13:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsCount\u001b[0m = arr.toList.foldLeft(\u001b[31m0\u001b[0m)(_ + nums.count(_ > \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798840
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsWithSum = nums.filter(x => sums.contains(x))\n        numsWithSum.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpl1nn_zuq.scala:19)\n\tat Problem.main(tmpl1nn_zuq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798847
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y == x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpil68igrt.scala:19)\n\tat Problem.main(tmpil68igrt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sums = digits.map(_.toInt).map(_.toLong)\n        val positiveSums = sums.filter(_.isPositive)\n        val negativeSums = sums.filter(_.isNegative)\n        positiveSums.size + negativeSums.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxgi7iz_i.scala:14:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSums\u001b[0m = sums.filter(_.isPositive)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isPositive is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxgi7iz_i.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSums\u001b[0m = sums.filter(_.isNegative)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value isNegative is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798844
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x)).reduceLeft(_ + _)\n        nums.count(x => x > 0 && math.abs(x) == numsSum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat Problem$.countNums(tmpq3wbo6g2.scala:13)\n\tat Problem$.main(tmpq3wbo6g2.scala:17)\n\tat Problem.main(tmpq3wbo6g2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798847
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(y => y > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnbz1s2qb.scala:19)\n\tat Problem.main(tmpnbz1s2qb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = nums.map(x => math.abs(x))\n        val numsSum = sums.toSet\n        numsSum.size + (numsSum.size - sums.size)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpmxxu3ge0.scala:19)\n\tat Problem.main(tmpmxxu3ge0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.toList.map(x => math.abs(x)).sum\n        nums.count(x => x > 0 && numsSum - math.abs(x) > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2i2xd8rt.scala:19)\n\tat Problem.main(tmp2i2xd8rt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for(i <- 0 until arr.length) {\n            sum += arr(i)\n            if(sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpih27g6zd.scala:25)\n\tat Problem.main(tmpih27g6zd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.filter(_ > x).size)\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjhpj_b75.scala:19)\n\tat Problem.main(tmpjhpj_b75.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfjuca_sd.scala:19)\n\tat Problem.main(tmpfjuca_sd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val counts = sums.groupBy(_ > 0)\n        counts.map(_._2.length).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8msqlh21.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8msqlh21.scala:14:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcounts\u001b[0m = sums.groupBy(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798847
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(_ > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphn82i_cm.scala:19)\n\tat Problem.main(tmphn82i_cm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798840
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for (i <- arr) {\n            val digit = i % 10\n            if (digit > 0) count += digit\n            else count += -digit\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphncpu_7e.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (digit > \u001b[31m0\u001b[0m) count += digit\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphncpu_7e.scala:16:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33melse\u001b[0m count += -digit\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798847
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for(i <- arr) {\n            sum += i\n            if(sum > 0) {\n                count += 1L\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnzu_vgmj.scala:25)\n\tat Problem.main(tmpnzu_vgmj.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(_ > 0))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpxp4lwir7.scala:19)\n\tat Problem.main(tmpxp4lwir7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798835
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x > 0).map(x => math.abs(x))\n        val sum = nums.sum\n        val numsLessThanZero = nums.filter(x => x < 0)\n        val numsLessThanZeroSum = numsLessThanZero.sum\n        if (sum < 0 || numsLessThanZeroSum < 0) 0 else numsLessThanZeroSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpklb4svjs.scala:21)\n\tat Problem.main(tmpklb4svjs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => if (x < 0) -x else x)\n        val counts = sums.groupBy(x => x).mapValues(_.size)\n        counts.foldLeft(0)((acc, x) => acc + x)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpd_3glknl.scala:15:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        counts.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc + x)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments ((x : (Int, Int)))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798844
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val count = sums.count(x => x > 0)\n        nums.count(x => x > 0 && sums.contains(math.abs(x)))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpyqt72ig4.scala:20)\n\tat Problem.main(tmpyqt72ig4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798849
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val positiveSums = sums.filter(x => x > 0)\n        val negativeSums = sums.filter(x => x < 0)\n        val positiveSumsCount = positiveSums.length\n        val negativeSumsCount = negativeSums.length\n        val count = positiveSumsCount + negativeSumsCount\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2jcd6qn2.scala:22)\n\tat Problem.main(tmp2jcd6qn2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798849
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x)).mapValues(_.size)\n        val numsCount = nums.count(x => counts.getOrElse(math.abs(x), 0) > 0)\n        numsCount\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpn2si6ri_.scala:20)\n\tat Problem.main(tmpn2si6ri_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798850
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        var count = 0L\n        for (i <- 0 until arr.length) {\n            sum += arr(i)\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmppz_rdhhh.scala:25)\n\tat Problem.main(tmppz_rdhhh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpc1dfgco5.scala:19)\n\tat Problem.main(tmpc1dfgco5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798849
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => if (x < 0) -x else x)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpwhpmz552.scala:15:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.mapValues(_.size).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m           No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    B is a type variable with constraint >: (Long, Int)\n\u001b[31m   |\u001b[0m           .\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798848
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsWithSums = sums.filter(x => x > 0).map(x => nums.contains(x))\n        numsWithSums.count(_ == true)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_c8ro5l0.scala:20)\n\tat Problem.main(tmp_c8ro5l0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798850
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSums = nums.map(x => math.abs(x)).toSet\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSet = numsSumsSet.toSet\n        val numsSumsSetSetSet = numsSumsSetSet.toSet\n        val numsSumsSetSetSetSet = numsSumsSetSetSet.toSet\n        val numsSumsSetSetSetSetSet = numsSumsSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSet = numsSumsSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = num\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_pyrb69m.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_pyrb69m.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_pyrb69m.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_pyrb69m.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798850
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSet = numsSums.toSet\n        val numsSumsSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSums.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_cngauox.scala:39:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cngauox.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSet\u001b[0m = numsSums.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cngauox.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSet\u001b[0m = numsSums.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cngauox.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSet\u001b[0m = numsSums.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_cngauox.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSet\u001b[0m = numsSums.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m  ",
      "stdout": "",
      "timestamp": 1659798851
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val nums = mutable.HashMap[Long, Long]()\n        for (i <- 0 until n) {\n            val digit = arr(i).asDigit\n            if (digit < 0) {\n                nums(-digit) += 1\n            } else {\n                nums(digit) += 1\n            }\n        }\n        nums.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7f6y0yzi.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7f6y0yzi.scala:15:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdigit\u001b[0m = arr(i).asDigit\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value asDigit is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798851
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSet\n        val numsSortedSet = nums.toSortedSet\n        val numsSortedSetSet = nums.toSortedSetSet\n        val numsSortedSetSetSet = nums.toSortedSetSetSet\n        val numsSortedSetSetSetSet = nums.toSortedSetSetSetSet\n        val numsSortedSetSetSetSet = nums.toSortedSetSetSetSet\n        val numsSortedSetSetSetSetSet = nums.toSortedSetSetSetSetSet\n        val numsSortedSetSetSetSetSet = nums.toSortedSetSetSetSetSet\n        val numsSortedSetSetSetSetSet = nums.toSortedSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSetSetSetSetSetSetSet\n        val numsSortedSetSetSetSetSetSetSetSet = nums.toSortedSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt16koghz.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSortedSetSetSetSet\u001b[0m = nums.toSortedSetSetSetSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSortedSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSortedSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt16koghz.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSortedSetSetSetSetSet\u001b[0m = nums.toSortedSetSetSetSetSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSortedSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSortedSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt16koghz.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSortedSetSetSetSetSet\u001b[0m = nums.toSortedSetSetSetSetSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSortedSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSortedSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpt16koghz.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSortedSetSetSetSetSetSet\u001b[0m = nums.toSortedSetSetSetSetSetSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSortedSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSortedSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same gr",
      "stdout": "",
      "timestamp": 1659798854
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        val nums = mutable.ArrayBuffer.empty[Long]\n        for (i <- 0 until n) {\n            val digits = arr(i).abs\n            if (digits < 10) {\n                nums += digits\n            } else if (digits < 100) {\n                nums += digits % 10\n            } else if (digits < 1000) {\n                nums += digits % 100\n            } else if (digits < 10000) {\n                nums += digits % 1000\n            } else if (digits < 100000) {\n                nums += digits % 10000\n            } else if (digits < 1000000) {\n                nums += digits % 100000\n            } else if (digits < 10000000) {\n                nums += digits % 1000000\n            } else if (digits < 100000000) {\n                nums += digits % 10000000\n            } else if (digits < 1000000000) {\n                nums += digits % 100000000\n            } else if (digits < 10000000000) {\n                nums += digits % 1000000000\n            } else if (digits < 100000000000) {\n                nums += digits % 10000000000\n            } else if (digits < 1000000000000) {\n                nums += digits % 100000000000\n            } else if (digits < 10000000000000) {\n                nums += digits % 1000000000000\n            } else if (digits < 100000000000000) {\n                nums += digits % 10000000000000\n            } else if (digits < 1000000000000000) {\n                nums += digits % 100000000000000\n            } else if (digits < 10000000000000000) {\n                nums += digits % 1000000000000000\n            } else if (digits < 100000000000000000) {\n                nums += digits % 10000000000000000\n            } else if (digits < 100000000000000000) {\n                nums += digits % 100000000000000000\n            } else if (digits < 1000000000000000000) {\n                nums += digits % 1000000000000000000\n            } else {\n                nums += digits % 1000000000000000000\n            }\n        }\n        nums.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpka761jj2.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:34:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (digits < \u001b[31m10000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:36:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (digits < \u001b[31m100000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:38:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (digits < \u001b[31m1000000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:40:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (digits < \u001b[31m10000000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:42:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m            } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (digits < \u001b[31m100000000000000\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                number too large\n\u001b[31m\u001b[31m-- Error: /tmp/tmpka761jj2.scala:44:32 -------------------------------",
      "stdout": "",
      "timestamp": 1659798851
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.filter(x => sums.contains(math.abs(x)))\n        numsSums.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb6cyg6wa.scala:19)\n\tat Problem.main(tmpb6cyg6wa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = nums.count\n        val numsSum = nums.sum\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = numsSum.toString.charAt(0)\n        val numsSumDigits = numsSumDigit - numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val numsSumDigit = numsSumDigit % 10\n        val numsSumDigits = numsSumDigits + numsSumDigit\n        val numsSumDigit = numsSumDigit + numsSumDigit % 10\n        val num\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppdc3szam.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppdc3szam.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigit - numsSumDigit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppdc3szam.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = numsSumDigit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppdc3szam.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits + numsSumDigit\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppdc3szam.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigit\u001b[0m = numsSumDigit + numsSumDigit % \u001b[31m10\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigit is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigit\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in",
      "stdout": "",
      "timestamp": 1659798856
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val numsSum = nums.sum\n        val numsSumDigits = numsSum.toString.length\n        val numsSumDigit = numsSum.toString.charAt(0)\n        val numsSumDigits = numsSumDigit - numsSumDigits.toString.length\n        nums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuet535th.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigit - numsSumDigits.toString.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798852
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSet = numsSumsSet.toSet\n        val numsSumsSetSetSet = numsSumsSetSet.toSet\n        val numsSumsSetSetSetSet = numsSumsSetSetSet.toSet\n        val numsSumsSetSetSetSetSet = numsSumsSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSet = numsSumsSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSetSetSet = numsSumsSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val numsSumsSetSetSetSetSetSetSetSetSetSetSetSet = numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0y7ogib8.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0y7ogib8.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0y7ogib8.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSetSetSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0y7ogib8.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = numsSumsSetSetSetSetSetSetSetSetSetSet",
      "stdout": "",
      "timestamp": 1659798854
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => x.toString.toInt).sum\n        nums.filter(_ > 0).count(x => numsSum - x > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8uocx_2t.scala:19)\n\tat Problem.main(tmp8uocx_2t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798860
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSetSize = numsSumsSet.size\n        val numsSumsSetSum = numsSumsSet.sum\n        val numsSumsSetSumSize = numsSumsSetSum.size\n        val numsSumsSetSumSet = numsSumsSetSum.sum\n        val numsSumsSetSumSetSize = numsSumsSetSumSet.size\n        val numsSumsSetSumSetSum = numsSumsSetSumSet.sum\n        val numsSumsSetSumSetSumSize = numsSumsSetSumSetSum.size\n        val numsSumsSetSumSetSumSet = numsSumsSetSumSetSum.sum\n        val numsSumsSetSumSetSumSetSize = numsSumsSetSumSetSumSet.size\n        val numsSumsSetSumSetSumSetSum = numsSumsSetSumSetSumSet.sum\n        val numsSumsSetSumSetSumSetSumSize = numsSumsSetSumSetSumSetSum.size\n        val numsSumsSetSumSetSumSetSumSet = numsSumsSetSumSetSumSetSum.sum\n        val numsSumsSetSumSetSumSetSumSetSize = numsSumsSetSumSetSumSetSumSet.size\n        val numsSumsSetSumSetSumSetSumSetSum = numsSumsSetSumSetSumSetSumSetSum.sum\n        val numsSumsSetSumSetSumSetSumSetSumSize = numsSumsSetSumSetSumSetSumSetSumSet.size\n        val numsSumsSetSumSetSumSetSumSetSumSet = numsSumsSetSumSetSumSetSumSetSumSetSumSet.sum\n        val numsSumsSetSumSetSumSetSumSetSumSetSize = numsSumsSetSumSetSumSetSumSetSumSet.size\n        val numsSumsSetSumSetSumSetSumSetSumSetSum = numsSumsSetSumSetSumSetSumSetSumSetSumSet.sum\n        val numsSumsSetSumSetSumSetSumSetSumSetSumSize = numsSumsSetSumSetSumSetSumSet\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm5xjn9tx.scala:18:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSumSize\u001b[0m = numsSumsSetSum.size\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 value size is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm5xjn9tx.scala:19:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSumSet\u001b[0m = numsSumsSetSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value sum is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpm5xjn9tx.scala:29:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSumSetSumSetSumSetSum\u001b[0m = numsSumsSetSumSetSumSetSumSetSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m             Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSetSumSetSumSetSumSetSum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm5xjn9tx.scala:31:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSumSetSumSetSumSetSumSet\u001b[0m = numsSumsSetSumSetSumSetSumSetSumSetSumSet.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: numsSumsSetSumSetSumSetSumSetSumSetSumSet\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm5xjn9tx.scala:33:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSetSumSetSumSetSumSetSumSetSum\u001b[0m = numsSumsSetSumSetSumSetSumSetSumSetSumSet.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not fo",
      "stdout": "",
      "timestamp": 1659798860
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(x => math.abs(x))\n        val sumOfDigits = digits.sum\n        val nums = arr.filter(x => math.abs(x) > 0).map(x => math.abs(x))\n        val numsWithSumOfDigits = nums.filter(x => sumOfDigits - x > 0)\n        numsWithSumOfDigits.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpzyphn34n.scala:20)\n\tat Problem.main(tmpzyphn34n.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798860
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSum = numsSums.sum\n        val numsSumsSum2 = numsSumsSum * numsSumsSum\n        val numsSumsSum3 = numsSumsSum * numsSumsSum2\n        val numsSumsSum4 = numsSumsSum3 * numsSumsSum3\n        val numsSumsSum5 = numsSumsSum4 * numsSumsSum4\n        numsSumsSum5\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpco5l3u0f.scala:24)\n\tat Problem.main(tmpco5l3u0f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798861
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSum = nums.map(x => math.abs(x)).sum\n        val numsSumSet = numsSum.toSet\n        val numsSumSet2 = numsSum.filter(x => x > 0).toSet\n        val numsSumSet3 = numsSum.filter(x => x < 0).toSet\n        val numsSumSet4 = numsSum.filter(x => x == 0).toSet\n        val numsSumSet5 = numsSum.filter(x => x % 10 == 0).toSet\n        val numsSumSet6 = numsSum.filter(x => x % 10 != 0).toSet\n        val numsSumSet7 = numsSum.filter(x => x % 10 == 0).filter(x => x % 10 != 0).toSet\n        val numsSumSet8 = numsSum.filter(x => x % 10 != 0).filter(x => x % 10 == 0).toSet\n        val numsSumSet9 = numsSum.filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).toSet\n        val numsSumSet10 = numsSum.filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).toSet\n        val numsSumSet11 = numsSum.filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 != 0).filter(x => x % 10 == 0).\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpr3i04cxu.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:17:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet\u001b[0m = numsSum.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value toSet is not a member of Long - did you mean numsSum.toInt?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:18:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet2\u001b[0m = numsSum.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value filter is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:19:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet3\u001b[0m = numsSum.filter(\u001b[36mx\u001b[0m => x < \u001b[31m0\u001b[0m).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value filter is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:20:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet4\u001b[0m = numsSum.filter(\u001b[36mx\u001b[0m => x == \u001b[31m0\u001b[0m).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value filter is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:21:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet5\u001b[0m = numsSum.filter(\u001b[36mx\u001b[0m => x % \u001b[31m10\u001b[0m == \u001b[31m0\u001b[0m).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value filter is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr3i04cxu.scala:22:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0",
      "stdout": "",
      "timestamp": 1659798861
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val countsSorted = counts.toSeq.sortBy(_._1).reverse\n        val countsSortedSum = countsSorted.map(x => x._2).sum\n        countsSortedSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpwk4_srha.scala:16:61 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcountsSortedSum\u001b[0m = countsSorted.map(\u001b[36mx\u001b[0m => x._2).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m             No implicit Ordering defined for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m             where:    B is a type variable with constraint >: List[Int]\n\u001b[31m   |\u001b[0m             .\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798859
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sum = digits.sum\n        val nums = arr.filter(x => x > 0).map(x => digits(x) - digits(x - 1))\n        nums.count(x => x > 0).sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdcmb8u7j.scala:14:58 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m).map(\u001b[36mx\u001b[0m => digits(x) - digits(x - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdcmb8u7j.scala:14:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = arr.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m).map(\u001b[36mx\u001b[0m => digits(x) - digits(x - \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdcmb8u7j.scala:15:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        nums.count(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m).sum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value sum is not a member of Int\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798860
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.map(x => math.abs(x)).toSet\n        val numsSumsSum = numsSums.map(x => math.abs(x)).toSet\n        val numsSumsSumSum = numsSumsSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSum = numsSumsSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSum = numsSumsSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSum = numsSumsSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSum = numsSumsSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSumSumSumSumSum.map(x => math.abs(x)).toSet\n        val numsSumsSumSumSumSumSumSumSumSumSumSumSumSum = numsSumsSumSumSumSumSumSumSumSumSumSumSumSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplqnd0wyy.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumSumSumSumSumSumSumSumSumSum\u001b[0m = numsSumsSumSumSumSumSumSumSumSumSumSum.map(\u001b[36mx\u001b[0m => math.abs(x)).toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSumSumSumSumSumSumSumSumSumSum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumSumSumSumSumSumSumSumSumSum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplqnd0wyy.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumSumSumSumSumSumSumSumSumSumSumSum\u001b[0m = numsSumsSumSumSumSumSumSumSumSumSumSumSumSum\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumsSumSumSumSumSumSumSumSumSumSumSumSum is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumSumSumSumSumSumSumSumSumSumSumSum\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplqnd0wyy.scala:26:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumSumSumSumSumSumSumSumSumSumSum\u001b[0m = numsSumsSumSumSumSumSumSumSumSumSumSumSum.map(\u001b[36mx\u001b[0m => math.abs(x)).toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m    Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumsSumSumSumSumSumSumSumSumSumSumSum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmplqnd0wyy.scala:27:59 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSumSumSumSumSumSumSumSumSumSumSumSum\u001b[0m = numsSumsSumSumSumSumSumSumSumSumSumSumS",
      "stdout": "",
      "timestamp": 1659798860
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.length\n        var sum = 0L\n        var i = 0\n        while (i < n) {\n            val digit = arr(i).toInt\n            if (digit < 0) {\n                sum += digit\n            } else {\n                sum += digit % 10\n            }\n            i += 1\n        }\n        if (sum > 0) {\n            sum\n        } else {\n            arr.length\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpz3ejdgv0.scala:32)\n\tat Problem.main(tmpz3ejdgv0.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798861
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => x.toString.toInt).map(x => x * x)\n        val counts = sums.map(x => if (x > 0) x else -x)\n        val count = counts.sum\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplpghbsl7.scala:20)\n\tat Problem.main(tmplpghbsl7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798861
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        for (i <- arr) {\n            val digits = i.toString.toInt\n            if (digits > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp29b32olr.scala:27)\n\tat Problem.main(tmp29b32olr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798862
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => x.toString.toInt).map(_.sum)\n        sums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9fju5tn.scala:13:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = nums.map(\u001b[36mx\u001b[0m => x.toString.toInt).map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpe9fju5tn.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        sums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798861
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val positiveSums = sums.filter(sum => sum > 0)\n        val negativeSums = sums.filter(sum => sum < 0)\n        val positiveCount = positiveSums.size\n        val negativeCount = negativeSums.size\n        val totalCount = positiveCount + negativeCount\n        val positiveSum = positiveSums.sum\n        val negativeSum = negativeSums.sum\n        val positiveSumDigit = positiveSum.toString.toInt\n        val negativeSumDigit = negativeSum.toString.toInt\n        val totalSumDigit = totalCount.toString.toInt\n        val positiveSumDigitCount = positiveSumDigit.size\n        val negativeSumDigitCount = negativeSumDigit.size\n        val totalSumDigitCount = totalSumDigit.size\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positiveSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val negativeSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val totalSumDigitCount = positiveSumDigitCount + negativeSumDigitCount\n        val positive\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpmnqkiuaa.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmnqkiuaa.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumDigitCount\u001b[0m = positiveSumDigitCount + negativeSumDigitCount\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveSumDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveSumDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmnqkiuaa.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumDigitCount\u001b[0m = positiveSumDigitCount + negativeSumDigitCount\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeSumDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeSumDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmnqkiuaa.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtotalSumDigitCount\u001b[0m = positiveSumDigitCount + negativeSumDigitCount\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mtotalSumDigitCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mtotalSumDigitCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpmnqkiuaa.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumDigitCount\u001b[0m = positiveSumDigitCount + negativeSumDigitCount\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659798863
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        nums.count(x => x > 0 && sums.contains(math.abs(x)))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5ob_ybhs.scala:20)\n\tat Problem.main(tmp5ob_ybhs.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798863
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfjuca_sd.scala:19)\n\tat Problem.main(tmpfjuca_sd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = arr.filter(x => x >= 0).size\n        numsCount.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp97qybe4f.scala:18)\n\tat Problem.main(tmp97qybe4f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798862
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsWithSum = sums.filter(x => x > 0).size\n        numsWithSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnobv9tyg.scala:19)\n\tat Problem.main(tmpnobv9tyg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798864
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = nums.map(x => math.abs(x)).sum\n        numsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpulnz27tv.scala:18)\n\tat Problem.main(tmpulnz27tv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798825
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x))\n        val numsSumSet = numsSum.toSet\n        numsSumSet.count(x => x > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpyml8z_j7.scala:19)\n\tat Problem.main(tmpyml8z_j7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798864
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, math.ceil(math.log10(x))))\n        val count = sums.foldLeft(0)(_ + _)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpobu9ic_d.scala:14:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = sums.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Double\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798862
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsLen = arr.length\n        val numsSum = arr.map(x => x.toString.toInt).sum\n        val numsSumDigits = numsSum.toString.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.toInt\n        val numsSumDigits = numsSumDigits.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0oq4rfm8.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0oq4rfm8.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0oq4rfm8.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0oq4rfm8.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0oq4rfm8.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigits\u001b[0m = numsSumDigits.toInt\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumDigits is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigits\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /",
      "stdout": "",
      "timestamp": 1659798863
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(x => math.abs(x))\n        val sums = digits.map(x => math.abs(x)).reduce((x, y) => x + y)\n        sums.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat scala.collection.IterableOnceOps.reduce(IterableOnce.scala:698)\n\tat scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:698)\n\tat scala.collection.AbstractIterable.reduce(Iterable.scala:926)\n\tat Problem$.countNums(tmpcs6xd283.scala:13)\n\tat Problem$.main(tmpcs6xd283.scala:17)\n\tat Problem.main(tmpcs6xd283.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798865
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val nums = sums.filter(x => x > 0)\n        nums.size \n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4g6yrqp1.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4g6yrqp1.scala:14:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = sums.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798867
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => if (x < 0) -x else x).map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg1v32ugq.scala:18)\n\tat Problem.main(tmpg1v32ugq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798866
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y == x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpil68igrt.scala:19)\n\tat Problem.main(tmpil68igrt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.foldLeft(0)((acc, x) => acc + x._2)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpv9fhwmz3.scala:15:55 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcount\u001b[0m = counts.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc + x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments ((x._2 : => List[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798865
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = nums.map(x => math.abs(x))\n        val count = sums.count(_ > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfkxv_w6f.scala:19)\n\tat Problem.main(tmpfkxv_w6f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798872
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSum = nums.map(x => math.abs(x)).reduceLeft(_ + _)\n        val numsSums = nums.map(x => math.abs(x)).reduceLeft(_ + _)\n        val numsSumsSum = numsSums.reduceLeft(_ + _)\n        numsSum - numsSumsSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm4pxt82u.scala:16:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumsSum\u001b[0m = numsSums.reduceLeft(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value reduceLeft is not a member of Long\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798870
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(_._2)._2\n        val numsWithMaxCount = nums.filter(x => math.abs(x) == maxCount)\n        numsWithMaxCount.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpp2q4loyv.scala:15:41 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxCount\u001b[0m = counts.maxBy(_._2)._2\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0mNo implicit Ordering defined for List[Int]..\n\u001b[31m   |\u001b[0mI found:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m    scala.math.Ordering.comparatorToOrdering[\u001b[35mList[Int]\u001b[0m](\n\u001b[31m   |\u001b[0m      /* missing */summon[java.util.Comparator[List[Int]]]\n\u001b[31m   |\u001b[0m    )\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mBut no implicit values were found that match type java.util.Comparator[List[Int]].\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.seqOrdering\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798871
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0\n        var count = 0\n        for (i <- arr) {\n            sum += i\n            if (sum > 0) {\n                count += 1\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpik2lxqkg.scala:15:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            sum += i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798871
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var sum = 0L\n        for(i <- 0 until arr.length) {\n            sum += arr(i)\n        }\n        if(sum > 0) {\n            sum\n        } else {\n            arr.takeWhile(x => x < 0).sum\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp0fld57q4.scala:24)\n\tat Problem.main(tmp0fld57q4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sum = digits.sum\n        val positiveSum = sum.toLong\n        val negativeSum = sum.toLong * -1\n        val positiveDigits = digits.filter(_.toString.toInt > 0)\n        val negativeDigits = digits.filter(_.toString.toInt < 0)\n        val positiveCount = positiveDigits.count(_ > 0)\n        val negativeCount = negativeDigits.count(_ < 0)\n        val positiveSumCount = positiveDigits.count(_ > 0)\n        val negativeSumCount = negativeDigits.count(_ < 0)\n        val positiveSumCount2 = positiveDigits.count(_ > 0)\n        val negativeSumCount2 = negativeDigits.count(_ < 0)\n        val positiveSumCount3 = positiveDigits.count(_ > 0)\n        val negativeSumCount3 = negativeDigits.count(_ < 0)\n        val positiveSumCount4 = positiveDigits.count(_ > 0)\n        val negativeSumCount4 = negativeDigits.count(_ < 0)\n        val positiveSumCount5 = positiveDigits.count(_ > 0)\n        val negativeSumCount5 = negativeDigits.count(_ < 0)\n        val positiveSumCount6 = positiveDigits.count(_ > 0)\n        val negativeSumCount6 = negativeDigits.count(_ < 0)\n        val positiveSumCount7 = positiveDigits.count(_ > 0)\n        val negativeSumCount7 = negativeDigits.count(_ < 0)\n        val positiveSumCount8 = positiveDigits.count(_ > 0)\n        val negativeSumCount8 = negativeDigits.count(_ < 0)\n        val positiveSumCount9 = positiveDigits.count(_ > 0)\n        val negativeSumCount9 = negativeDigits.count(_ < 0)\n        val positiveSumCount10 = positiveDigits.count(_ > 0)\n        val negativeSumCount10 = negativeDigits.count(_ < 0)\n        val positiveSumCount11 = positiveDigits.count(_ > 0)\n        val negativeSumCount11 = negativeDigits.count(_ < 0)\n        val positiveSumCount12 = positiveDigits.count(_ > 0)\n        val negativeSumCount12 = negativeDigits.count(_ < 0)\n        val positiveSumCount13 = positiveDigits.count(_ > 0)\n        val negativeSumCount13 = negativeDigits.count(_ < 0)\n        val positiveSumCount14 = positiveDigits.count(_ > 0)\n        val negativeSumCount14 = negativeDigits.count(_ < 0)\n        val positiveSumCount15 = positiveDigits.count(_ > 0)\n        val negativeSumCount15 = negativeDigits.\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpchof8od9.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpchof8od9.scala:50:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798872
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x))\n        val numsSumSet = numsSum.toSet\n        val numsSumSetSize = numsSumSet.size\n        val numsSumSetSum = numsSumSet.foldLeft(0)(_ + _)\n        numsSumSetSize - numsSumSetSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprwff019j.scala:16:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetSum\u001b[0m = numsSumSet.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                   Found:    Long\n\u001b[31m   |\u001b[0m                                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798872
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val numsCount = nums.count(x => counts.getOrElse(x, 0) > 0)\n        numsCount\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc1t8muvn.scala:15:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsCount\u001b[0m = nums.count(\u001b[36mx\u001b[0m => counts.getOrElse(x, \u001b[31m0\u001b[0m) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Matchable, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798873
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toSet\n        val numsLen = nums.size\n        val numsSum = nums.map(x => x.toString.toInt).sum\n        val numsSumSet = numsSum.toSet\n        val numsSumLen = numsSum.size\n        val numsSumSetLen = numsSumSet.size\n        val numsSumSetDiff = numsSumSet.diff(nums)\n        val numsSumSetDiffLen = numsSumSetDiff.size\n        val numsSumSetDiffSet = numsSumSetDiff.toSet\n        val numsSumSetDiffSetLen = numsSumSetDiffSet.size\n        val numsSumSetDiffSetDiff = numsSumSetDiffSet.diff(numsSet)\n        val numsSumSetDiffSetDiffLen = numsSumSetDiffSetDiff.size\n        val numsSumSetDiffSetDiffSet = numsSumSetDiffSetDiff.toSet\n        val numsSumSetDiffSetDiffSetLen = numsSumSetDiffSetDiffSet.size\n        val numsSumSetDiffSetDiffSetDiff = numsSumSetDiffSetDiffSet.diff(numsLen)\n        val numsSumSetDiffSetDiffSetDiffLen = numsSumSetDiffSetDiffSetDiff.size\n        val numsSumSetDiffSetDiffSetDiffSet = numsSumSetDiffSetDiffSetDiff.toSet\n        val numsSumSetDiffSetDiffSetDiffSetLen = numsSumSetDiffSetDiffSetDiffSet.size\n        val numsSumSetDiffSetDiffSetDiffSetDiff = numsSumSetDiffSetDiffSetDiffSet.diff(numsSumLen)\n        val numsSumSetDiffSetDiffSetDiffSetDiffLen = numsSumSetDiffSetDiffSetDiffSetDiff.size\n        val numsSumSetDiffSetDiffSetDiffSetDiffSet = numsSumSetDiffSetDiffSetDiffSetDiff.toSet\n        val numsSumSetDiffSetDiffSetDiffSetDiffSetLen = numsSumSetDiffSetDiffSetDiffSetDiffSet.size\n        val numsSumSetDiffSetDiffSetDiffSetDiffSetDiff = numsSumSetDiffSetDiffSetDiffSetDiffSet.toSet\n        val numsSumSetDiffSetDiffSetDiffSetDiffSetDiffLen = numsSumSetDiffSetDiff\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2tzc62md.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSet\u001b[0m = numsSum.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value toSet is not a member of Int - did you mean numsSum.toInt?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2tzc62md.scala:17:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumLen\u001b[0m = numsSum.size\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value size is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp2tzc62md.scala:37:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798873
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val positiveSums = sums.filter(x => x > 0)\n        positiveSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2qo2_rs0.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2qo2_rs0.scala:14:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSums\u001b[0m = sums.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798873
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdw7lfxaw.scala:18)\n\tat Problem.main(tmpdw7lfxaw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(x => math.abs(x))\n        val numsWithSum = nums.filter(x => sums.contains(x))\n        numsWithSum.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_fi971iw.scala:20)\n\tat Problem.main(tmp_fi971iw.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sums = digits.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp58rf1ukb.scala:19)\n\tat Problem.main(tmp58rf1ukb.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        sumsSet.count(x => x > 0) + (nums.count(x => x < 0) * nums.count(x => x < 0) * nums.count(x => x < 0))\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp27jwepwi.scala:19)\n\tat Problem.main(tmp27jwepwi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798875
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x))\n        val numsSumSet = numsSum.toSet\n        val numsSumSetSize = numsSumSet.size\n        val numsSumSetIterator = numsSumSet.iterator\n        val numsSumSetIteratorSize = numsSumSetIterator.size\n        val numsSumSetIteratorIterator = numsSumSetIterator.iterator\n        val numsSumSetIteratorIteratorSize = numsSumSetIteratorIterator.size\n        val numsSumSetIteratorIteratorIterator = numsSumSetIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n        val numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize = numsSumSetIterator\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpih12q5p0.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIterator.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpih12q5p0.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator.iterator\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorIterator\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpih12q5p0.scala:33:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIteratorSize\u001b[0m = numsSumSetIteratorIteratorIteratorIteratorIteratorIteratorIterator.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnumsSum",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val sumsSet = sums.toSet\n        val numsSet = nums.toSet\n        val numsSums = nums.map(x => math.abs(x))\n        val numsSumsSet = numsSums.toSet\n        val numsSumsSet2 = numsSums.map(x => math.abs(x))\n        val numsSumsSet3 = numsSums.map(x => math.abs(x))\n        val numsSumsSet4 = numsSums.map(x => math.abs(x))\n        val numsSumsSet5 = numsSums.map(x => math.abs(x))\n        val numsSumsSet6 = numsSums.map(x => math.abs(x))\n        val numsSumsSet7 = numsSums.map(x => math.abs(x))\n        val numsSumsSet8 = numsSums.map(x => math.abs(x))\n        val numsSumsSet9 = numsSums.map(x => math.abs(x))\n        val numsSumsSet10 = numsSums.map(x => math.abs(x))\n        val numsSumsSet11 = numsSums.map(x => math.abs(x))\n        val numsSumsSet12 = numsSums.map(x => math.abs(x))\n        val numsSumsSet13 = numsSums.map(x => math.abs(x))\n        val numsSumsSet14 = numsSums.map(x => math.abs(x))\n        val numsSumsSet15 = numsSums.map(x => math.abs(x))\n        val numsSumsSet16 = numsSums.map(x => math.abs(x))\n        val numsSumsSet17 = numsSums.map(x => math.abs(x))\n        val numsSumsSet18 = numsSums.map(x => math.abs(x))\n        val numsSumsSet19 = numsSums.map(x => math.abs(x))\n        val numsSumsSet20 = numsSums.map(x => math.abs(x))\n        val numsSumsSet21 = numsSums.map(x => math.abs(x))\n        val numsSumsSet22 = numsSums.map(x => math.abs(x))\n        val numsSumsSet23 = numsSums.map(x => math.abs(x))\n        val numsSumsSet24 = nums\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxo15ijzk.scala:41:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m41 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798874
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(_ > 0)\n        val sums = nums.map(x => math.abs(x))\n        val count = sums.count(_ > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpll_m70ba.scala:23)\n\tat Problem.main(tmpll_m70ba.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798875
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val count = sums.count(x => x > 0)\n        nums.size - count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpbiyoz12f.scala:19)\n\tat Problem.main(tmpbiyoz12f.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798876
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n        val numsSums = nums.filter(x => sums.contains(math.abs(x)))\n        numsSums.size\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpb6cyg6wa.scala:19)\n\tat Problem.main(tmpb6cyg6wa.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798823
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val numsSums = nums.map(x => sums.count(y => y == x))\n        numsSums.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpil68igrt.scala:19)\n\tat Problem.main(tmpil68igrt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798811
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sum = nums.sum\n        val numsWithSum = nums.filter(x => x >= sum)\n        numsWithSum.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp3t9vhkuf.scala:19)\n\tat Problem.main(tmp3t9vhkuf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798876
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val positiveSums = sums.filter(x => x > 0)\n        val negativeSums = sums.filter(x => x < 0)\n        positiveSums.size + (negativeSums.size * negativeSums.sum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjjbtcwph.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjjbtcwph.scala:14:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSums\u001b[0m = sums.filter(\u001b[36mx\u001b[0m => x > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjjbtcwph.scala:15:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSums\u001b[0m = sums.filter(\u001b[36mx\u001b[0m => x < \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue < is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadli",
      "stdout": "",
      "timestamp": 1659798877
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        sums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyj53wqlk.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyj53wqlk.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        sums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798836
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.map(x => if (x < 0) -x else x)\n        val sums = nums.map(x => if (x < 0) x.toString.toLong else x)\n        val count = sums.count(x => x > 0)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpflysob1r.scala:19)\n\tat Problem.main(tmpflysob1r.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798877
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0L\n        for (i <- 0 until arr.length) {\n            val digits = arr(i).toString.toInt\n            if (digits > 0) {\n                count += digits\n            }\n        }\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsb_docid.scala:24)\n\tat Problem.main(tmpsb_docid.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798878
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = nums.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x)).mapValues(_.size)\n        val result = counts.maxBy(x => x._2)\n        result._1\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.maxBy\n\tat scala.collection.IterableOnceOps.maxBy(IterableOnce.scala:978)\n\tat scala.collection.IterableOnceOps.maxBy$(IterableOnce.scala:976)\n\tat scala.collection.AbstractIterable.maxBy(Iterable.scala:926)\n\tat Problem$.countNums(tmpr8qhv9x8.scala:15)\n\tat Problem$.main(tmpr8qhv9x8.scala:19)\n\tat Problem.main(tmpr8qhv9x8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798878
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toInt)\n        val sums = digits.map(x => math.abs(x))\n        val counts = sums.groupBy(_ > 0).mapValues(_.size)\n        counts.foldLeft(0)((acc, x) => acc + x)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmprzplzmbw.scala:15:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        counts.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc + x)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments ((x : (Boolean, Int)))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798878
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsCount = nums.count(_ > 0)\n        val numsSum = nums.sum\n        val numsSumDigits = numsSum.toString.reverse.map(_.toInt)\n        val numsSumDigitCount = numsSumDigits.count(_ > 0)\n        val numsSumDigitSum = numsSumDigits.sum\n        val numsSumDigitSumDigits = numsSumDigitSum.toString.reverse.map(_.toInt)\n        val numsSumDigitSumDigitCount = numsSumDigitSumDigits.count(_ > 0)\n        val numsSumDigitSumDigitSum = numsSumDigitSumDigits.sum\n        val numsSumDigitSumDigitSumDigits = numsSumDigitSumDigitSum.toString.reverse.map(_.toInt)\n        val numsSumDigitSumDigitSumDigitCount = numsSumDigitSumDigitSumDigits.count(_ > 0)\n        val numsSumDigitSumDigitSumDigitSum = numsSumDigitSumDigitSumDigits.sum\n        val numsSumDigitSumDigitSumDigitSumDigits = numsSumDigitSumDigitSumDigitSum.toString.reverse.map(_.toInt)\n        val numsSumDigitSumDigitSumDigitSumDigitCount = numsSumDigitSumDigitSumDigitSumDigits.count(_ > 0)\n        val numsSumDigitSumDigitSumDigitSumDigitSum = numsSumDigitSumDigitSumDigitSumDigits.sum\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigits = numsSumDigitSumDigitSumDigitSumDigitSum.toString.reverse.map(_.toInt)\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigitCount = numsSumDigitSumDigitSumDigitSumDigitSumDigits.count(_ > 0)\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigitSum = numsSumDigitSumDigitSumDigitSumDigitSumDigits.sum\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits = numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits.toString.reverse.map(_.toInt)\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigitCount = numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits.count(_ > 0)\n        val numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigitSum = numsSumDigitSum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp02q70lr0.scala:30:68 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits\u001b[0m = numsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits.toString.reverse.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSumDigitSumDigitSumDigitSumDigitSumDigitSumDigits\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp02q70lr0.scala:33:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798879
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        var count = 0\n        arr.foreach(x => if (x > 0) count = count + math.abs(x))\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprlr8t7za.scala:13:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        arr.foreach(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x > \u001b[31m0\u001b[0m) count = count + math.abs(x))\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    Long\n\u001b[31m   |\u001b[0m                                            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798879
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val sums = digits.map(_.sum)\n        val nums = sums.filter(_.isPositive)\n        nums.count(_ > 0)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp92xhuqa8.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = digits.map(_.sum)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value sum is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp92xhuqa8.scala:14:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnums\u001b[0m = sums.filter(_.isPositive)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value isPositive is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp92xhuqa8.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        nums.count(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\u001b[31m   |\u001b[0m\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sum = nums.sum\n        if (sum < 0) nums.head * -1\n        else sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpwms_xuhk.scala:20)\n\tat Problem.main(tmpwms_xuhk.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSum = arr.map(x => math.abs(x)).reduce(_ + _)\n        nums.count(x => x > 0 && math.abs(x) == numsSum)\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.reduceLeft\n\tat scala.collection.IterableOnceOps.reduceLeft(IterableOnce.scala:727)\n\tat scala.collection.IterableOnceOps.reduceLeft$(IterableOnce.scala:724)\n\tat scala.collection.AbstractIterable.reduceLeft(Iterable.scala:926)\n\tat scala.collection.IterableOnceOps.reduce(IterableOnce.scala:698)\n\tat scala.collection.IterableOnceOps.reduce$(IterableOnce.scala:698)\n\tat scala.collection.AbstractIterable.reduce(Iterable.scala:926)\n\tat Problem$.countNums(tmppltc067l.scala:13)\n\tat Problem$.main(tmppltc067l.scala:17)\n\tat Problem.main(tmppltc067l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val n = arr.size\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum += arr(i)\n        }\n        if (sum > 0) {\n            sum\n        } else {\n            arr.count(_ > 0)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt6qne3b6.scala:26)\n\tat Problem.main(tmpt6qne3b6.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798882
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sums = nums.map(x => math.pow(10, x.length))\n        val count = sums.reduceLeft(_ + _)\n        count\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpymgppxvw.scala:13:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = nums.map(\u001b[36mx\u001b[0m => math.pow(\u001b[31m10\u001b[0m, x.length))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value length is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpymgppxvw.scala:15:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        count\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (count : Double)\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659798812
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.filter(x => x >= 0).map(x => math.abs(x))\n        val sum = nums.sum\n        val numsWithSum = nums.filter(x => x == sum)\n        numsWithSum.length\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpjs5sydgc.scala:19)\n\tat Problem.main(tmpjs5sydgc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n        val result = counts.mapValues(x => x.size)\n        val sum = result.mapValues(x => x.sum)\n        val positiveSum = sum.filter(_ > 0)\n        val negativeSum = sum.filter(_ < 0)\n        val positiveCount = positiveSum.sum\n        val negativeCount = negativeSum.sum\n        val positiveSumCount = positiveSum.size\n        val negativeSumCount = negativeSum.size\n        val positiveCount = positiveCount.toLong\n        val negativeCount = negativeCount.toLong\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.toLong\n        val positiveSum = positiveSum.sum\n        val negativeSum = negativeSum.sum\n        val positiveSumCount = positiveSumCount.toLong\n        val negativeSumCount = negativeSumCount.to\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uwp5hor.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveCount\u001b[0m = positiveCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uwp5hor.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeCount\u001b[0m = negativeCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uwp5hor.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSumCount\u001b[0m = positiveSumCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mpositiveSumCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mpositiveSumCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uwp5hor.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnegativeSumCount\u001b[0m = negativeSumCount.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mnegativeSumCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mnegativeSumCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp4uwp5hor.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mpositiveSum\u001b[0m = positiveSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m  ",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val sums = mutable.HashMap[Long, Long]()\n        arr.foreach(x => sums += ((x % 10).abs -> 1))\n        sums.values.sum\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8lp9s7rw.scala:12:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msums\u001b[0m = mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659798879
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val digits = arr.map(_.toString.toInt)\n        val nums = arr.map(_.toString.toInt)\n        val sum = digits.foldLeft(0)((sum, digit) => sum + digit)\n        val numsSum = nums.foldLeft(0)((sum, num) => sum + num)\n        if (sum > 0) {\n            numsSum\n        } else {\n            -1\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp55i08t9o.scala:23)\n\tat Problem.main(tmp55i08t9o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659798881
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function count_nums which takes an array of integers and returns\n    // the number of elements which has a sum of digits > 0.\n    // If a number is negative, then its first signed digit will be negative:\n    // e.g. -123 has signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1, 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr : List[Long]) : Long = {\n        val nums = arr.toSet\n        val numsSet = nums.toList\n        val numsSetLen = numsSet.length\n        val numsSetSum = numsSet.sum\n        val numsSetSumDigits = numsSetSum.toString.length\n        val numsSetSumDigitsSet = numsSetSumDigits.toSet\n        val numsSetSumDigitsSetLen = numsSetSumDigitsSet.length\n        val numsSetSumDigitsSetSum = numsSetSumDigitsSet.sum\n        val numsSetSumDigitsSetSumDigits = numsSetSumDigitsSetSum.toString.length\n        val numsSetSumDigitsSetSumDigitsSet = numsSetSumDigitsSetSumDigits.toSet\n        val numsSetSumDigitsSetSumDigitsSetLen = numsSetSumDigitsSetSumDigitsSet.length\n        val numsSetSumDigitsSetSumDigitsSetSum = numsSetSumDigitsSetSumDigitsSet.sum\n        val numsSetSumDigitsSetSumDigitsSetSumDigits = numsSetSumDigitsSetSumDigitsSetSum.toString.length\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSet = numsSetSumDigitsSetSumDigitsSetSumDigitsSet.toSet\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSetLen = numsSetSumDigitsSetSumDigitsSetSumDigitsSetLen.toString.length\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSetSum = numsSetSumDigitsSetSumDigitsSetSumDigitsSetSum.toString.length\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigits = numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigits.toString.length\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigitsSet = numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigitsSet.toString.length\n        val numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigitsSetLen = numsSetSumDigitsSetSumDigitsSetSumDigitsSetSumDigitsSetLen.toString.length\n        val numsSetSumDig\n    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]())) == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong))) == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong, 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong, 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong, 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n    assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong))) == (1l));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpy_pgy3v0.scala:32:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpy_pgy3v0.scala:17:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSet\u001b[0m = numsSetSumDigits.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toSet is not a member of Int - did you mean numsSetSumDigits.toInt?\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpy_pgy3v0.scala:25:58 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSetSumDigitsSetSumDigitsSet\u001b[0m = numsSetSumDigitsSetSumDigitsSetSumDigitsSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0m  Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSetSumDigitsSetSumDigitsSet\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpy_pgy3v0.scala:26:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSetSumDigitsSetSumDigitsSetLen\u001b[0m = numsSetSumDigitsSetSumDigitsSetSumDigitsSetLen.toString.length\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSetSumDigitsSetSumDigitsSetLen\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpy_pgy3v0.scala:27:61 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnumsSetSumDigitsSetSumDigitsSetSumDigitsSetSum\u001b[0m = numsSetSumDigitsSetSumDigitsSetSumDigitsSetSum.toString.length\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mnumsSetSumDigitsSetSumDigitsSetSumDigitsSetSum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[",
      "stdout": "",
      "timestamp": 1659798881
    }
  ]
}