language: scala
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 0))\n\
    \        val newAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 0))\n\
    \        val newAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x) -\
    \ 2))\n        val newAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet21 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet22 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3vcwbwg7.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3vcwbwg7.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5xcj82uh.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5xcj82uh.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = new StringBuilder()\n        for(i <- 0 until s.length){\n\
    \            newString.append(newAlphabet(alphabet.indexOf(s.charAt(i)))) \n \
    \       }\n        newString.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpjuxiz1tk.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpjuxiz1tk.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpjuxiz1tk.scala:15)\n\
    \tat Problem$.main(tmpjuxiz1tk.scala:23)\n\tat Problem.main(tmpjuxiz1tk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 1))\n        val rotatedString = s.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpz6fiqjww.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpz6fiqjww.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpz6fiqjww.scala:15)\n\
    \tat Problem$.main(tmpz6fiqjww.scala:20)\n\tat Problem.main(tmpz6fiqjww.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp95mbpzyf.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp95mbpzyf.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp95mbpzyf.scala:15)\n\
    \tat Problem$.main(tmp95mbpzyf.scala:20)\n\tat Problem.main(tmp95mbpzyf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a' + 1)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a' + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a' + 3)\n        val newAlphabet4 = alphabet.map(x => x + 'z'\
    \ - 'a' + 4)\n        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a' + 5)\n\
    \        val newAlphabet6 = alphabet.map(x => x + 'z' - 'a' + 6)\n        val\
    \ newAlphabet7 = alphabet.map(x => x + 'z' - 'a' + 7)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 'z' - 'a' + 8)\n        val newAlphabet9 = alphabet.map(x\
    \ => x + 'z' - 'a' + 9)\n        val newAlphabet10 = alphabet.map(x => x + 'z'\
    \ - 'a' + 10)\n        val newAlphabet11 = alphabet.map(x => x + 'z' - 'a' + 11)\n\
    \        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a' + 12)\n        val\
    \ newAlphabet13 = alphabet.map(x => x + 'z' - 'a' + 13)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a' + 14)\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a' + 15)\n        val newAlphabet16 = alphabet.map(x => x + 'z'\
    \ - 'a' + 16)\n        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a' + 17)\n\
    \        val newAlphabet18 = alphabet.map(x => x + 'z' - 'a' + 18)\n        val\
    \ newAlphabet19 = alphabet.map(x => x + 'z' - 'a' + 19)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 'z' - 'a' + 20)\n        val newAlphabet21 = alphabet.map(x\
    \ => x + 'z' - 'a' + 21)\n        val newAlphabet22 = alphabet.map(x => x + 'z'\
    \ - 'a' + 22)\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbhaacg73.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhaacg73.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdbx8oap2.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet21 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo4ugcxzv.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        rotatedString.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp9995eej2.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp9995eej2.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp9995eej2.scala:15)\n\
    \tat Problem$.main(tmp9995eej2.scala:20)\n\tat Problem.main(tmp9995eej2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 11))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 13))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 15))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 17))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 18))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + \n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphhmc4l6o.scala:34:81 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet20\e[0m = alphabet.map(\e\
    [36mx\e[0m => x -> alphabet(alphabet.indexOf(x) + \n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphhmc4l6o.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0b228jat.scala:22:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnewAlphabet8\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,'\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0b228jat.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp95mbpzyf.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp95mbpzyf.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp95mbpzyf.scala:15)\n\
    \tat Problem$.main(tmp95mbpzyf.scala:20)\n\tat Problem.main(tmp95mbpzyf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet4 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet5 = alphabet.map(x => (x - 2) % 26 + 2)\n  \
    \      val newAlphabet6 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet7\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet8 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet9 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet10 = alphabet.map(x => (x - 2) % 26 + 2)\n \
    \       val newAlphabet11 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet12\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet13 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet14 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet15 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet16 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet17 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet18\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet20 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet21 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet22 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet23 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet24\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet25 = alphabet.map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj9yax8i4.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9yax8i4.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = new StringBuilder\n        for(i <- 0 until s.length)\n\
    \            newString.append(newAlphabet(alphabet.indexOf(s.charAt(i))))\n  \
    \      newString.toString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpw3ky64io.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpw3ky64io.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpw3ky64io.scala:15)\n\
    \tat Problem$.main(tmpw3ky64io.scala:22)\n\tat Problem.main(tmpw3ky64io.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet6\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet7 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet8 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet9 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet10\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet11 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet13 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet16 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet18\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet19 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet20 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet21 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet22\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet23 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet24 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet25 = alphabet.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6p43896n.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6p43896n.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet6\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet7 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet8 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet9 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet10\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet11 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet13 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet16 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet18\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet19 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet20 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet21 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet22\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet23 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet24 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet25 = alphabet.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6p43896n.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6p43896n.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x - 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_5m4swkc.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_5m4swkc.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = newAlphabet.map(x => (x - 2).toChar)\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = newAlphabet3.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = newAlphabet4.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet6 = newAlphabet5.map(x => (x - 2).toChar)\n        val newAlphabet7\
    \ = newAlphabet6.map(x => (x - 2).toChar)\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet9 = newAlphabet8.map(x => (x - 2).toChar)\n\
    \        val newAlphabet10 = newAlphabet9.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet11 = newAlphabet10.map(x => (x - 2).toChar)\n        val newAlphabet12\
    \ = newAlphabet11.map(x => (x - 2).toChar)\n        val newAlphabet13 = newAlphabet12.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet14 = newAlphabet13.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet15 = newAlphabet14.map(x => (x - 2).toChar)\n\
    \        val newAlphabet16 = newAlphabet15.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet17 = newAlphabet16.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = newAlphabet17.map(x => (x - 2).toChar)\n        val newAlphabet19 = newAlphabet18.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = newAlphabet19.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet21 = newAlphabet20.map(x => (x - 2).toChar)\n\
    \        val newAlphabet22 = newAlphabet21.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet23 = newAlphabet22.map(x => (x - 2).toChar)\n        val newAlphabet24\
    \ = newAlphabet23.map(x => (x - 2).toChar)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8iuxn9d.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwn907o5w.scala:22:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36malphabet9\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,\e[31m's'\e[0m,\e[31m't'\e[0m,\e[31m'u'\e[0m,\e[31m'v\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'v is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"v\" or an application Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{v} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn907o5w.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwn907o5w.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').toList\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'y').toList\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'x').toList\n        val newAlphabet4 = alphabet.map(x => x + 'w').toList\n\
    \        val newAlphabet5 = alphabet.map(x => x + 'v').toList\n        val newAlphabet6\
    \ = alphabet.map(x => x + 'u').toList\n        val newAlphabet7 = alphabet.map(x\
    \ => x + 't').toList\n        val newAlphabet8 = alphabet.map(x => x + 's').toList\n\
    \        val newAlphabet9 = alphabet.map(x => x + 'r').toList\n        val newAlphabet10\
    \ = alphabet.map(x => x + 'q').toList\n        val newAlphabet11 = alphabet.map(x\
    \ => x + 'p').toList\n        val newAlphabet12 = alphabet.map(x => x + 'o').toList\n\
    \        val newAlphabet13 = alphabet.map(x => x + 'n').toList\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'm').toList\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'l').toList\n        val newAlphabet16 = alphabet.map(x => x + 'k').toList\n\
    \        val newAlphabet17 = alphabet.map(x => x + 'j').toList\n        val newAlphabet18\
    \ = alphabet.map(x => x + 'i').toList\n        val newAlphabet19 = alphabet.map(x\
    \ => x + 'h').toList\n        val newAlphabet20 = alphabet.map(x => x + 'g').toList\n\
    \        val newAlphabet21 = alphabet.map(x => x + 'f').toList\n        val newAlphabet22\
    \ = alphabet.map(x => x + 'e').toList\n        val newAlphabet23 = alphabet.map(x\
    \ => x + 'd').toList\n        val newAlphabet24 = alphabet.map(x => x + 'c').toList\n\
    \        val newAlphabet25 = alphabet.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpze9vl7wa.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpze9vl7wa.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar).reverse\n       \
    \ val newString = s.map(x => newAlphabet(alphabet.indexOf(x) + 2))\n        newString.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppg9osxdj.scala:20)\n\tat Problem.main(tmppg9osxdj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4xn6qbhz.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4xn6qbhz.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(c => rotatedAlphabet(c))\n\
    \        val result = rotatedString.map(c => alphabet(alphabet.indexOf(c) - 2))\n\
    \        new String(result)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpwi1ytn90.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpwi1ytn90.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpwi1ytn90.scala:15)\n\
    \tat Problem$.main(tmpwi1ytn90.scala:21)\n\tat Problem.main(tmpwi1ytn90.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        rotatedString.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp9995eej2.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp9995eej2.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp9995eej2.scala:15)\n\
    \tat Problem$.main(tmp9995eej2.scala:20)\n\tat Problem.main(tmp9995eej2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetShift = alphabet.length/2\n\
    \        val alphabetShift2 = alphabet.length/3\n        val alphabetShift3 =\
    \ alphabet.length/4\n        val alphabetShift4 = alphabet.length/5\n        val\
    \ alphabetShift5 = alphabet.length/6\n        val alphabetShift6 = alphabet.length/7\n\
    \        val alphabetShift7 = alphabet.length/8\n        val alphabetShift8 =\
    \ alphabet.length/9\n        val alphabetShift9 = alphabet.length/10\n       \
    \ val alphabetShift10 = alphabet.length/11\n        val alphabetShift11 = alphabet.length/12\n\
    \        val alphabetShift12 = alphabet.length/13\n        val alphabetShift13\
    \ = alphabet.length/14\n        val alphabetShift14 = alphabet.length/15\n   \
    \     val alphabetShift15 = alphabet.length/16\n        val alphabetShift16 =\
    \ alphabet.length/17\n        val alphabetShift17 = alphabet.length/18\n     \
    \   val alphabetShift18 = alphabet.length/19\n        val alphabetShift19 = alphabet.length/20\n\
    \        val alphabetShift20 = alphabet.length/21\n        val alphabetShift21\
    \ = alphabet.length/22\n        val alphabetShift22 = alphabet.length/23\n   \
    \     val alphabetShift23 = alphabet.length/24\n        val alphabetShift24 =\
    \ alphabet.length/25\n        val alphabetShift25 = alphabet.length/26\n     \
    \   val alphabetShift26 = alphabet.length/27\n        val alphabetShift27 = alphabet.length/28\n\
    \        val alphabetShift28 = alphabet.length/29\n        val alphabetShift29\
    \ = alphabet.length/30\n        val alphabetShift30 = alphabet.length/31\n   \
    \     val alphabetShift31 = alphabet.length/32\n        val alphabetShift32 =\
    \ alphabet.length/33\n        val alphabetShift33 = alphabet.length/34\n     \
    \   val alphabetShift34 = alphabet.length/35\n        val alphabetShift35 = alphabet.length/36\n\
    \        val alphabetShift36 = alphabet.length/37\n        val alphabetShift37\
    \ = alphabet.length/38\n        val alphabetShift38 = alphabet.length/39\n   \
    \     val alphabetShift39 = alphabet.length/40\n        val alphabetShift40 =\
    \ alphabet.length/41\n        val alphabetShift41 = alphabet.length/42\n     \
    \   val alphabetShift42 = alphabet.length/43\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2_xw8q0m.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 11))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 13))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 15))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 17))\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jfepuiy.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpplis4x18.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpplis4x18.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n        val alphabetLength = alphabetLength\
    \ / 2\n        val alphabetLength = alphabetLength * 2\n        val alphabetLength\
    \ = alphabetLength + alphabetLength\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbfzkk0n2.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbfzkk0n2.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbfzkk0n2.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ + alphabetLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbfzkk0n2.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbfzkk0n2.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ *"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.map(c => rotatedAlphabet(c))\n        rotatedString.map(c\
    \ => c.mkString).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7nbrrthf.scala:17:33 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        rotatedString.map(\e[36mc\e[0m => c.mkString).mkString\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue mkString is not a member of (Char, Char) - did you mean c.toString?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpugs9147x.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659797858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.zip(newAlphabet).map(x => x._1 + x._2).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp30pctkjr.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp30pctkjr.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp30pctkjr.scala:15)\n\
    \tat Problem$.main(tmp30pctkjr.scala:20)\n\tat Problem.main(tmp30pctkjr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        val result = new String(rotatedString)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n\
    \    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpyr0icxvh.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpyr0icxvh.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpyr0icxvh.scala:15)\n\
    \tat Problem$.main(tmpyr0icxvh.scala:21)\n\tat Problem.main(tmpyr0icxvh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpzjep8c69.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpzjep8c69.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpzjep8c69.scala:15)\n\
    \tat Problem$.main(tmpzjep8c69.scala:20)\n\tat Problem.main(tmpzjep8c69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('z','y','x','w','v','u','t','s','r','q','p','o','n','m','l','k','j','i','h','g','f','e','d','c','b','a');\n\
    \        var newString = \"\"\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var\
    \ o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var\
    \ s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var\
    \ w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var\
    \ a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var\
    \ e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var\
    \ m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var\
    \ q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var\
    \ u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var\
    \ y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var\
    \ c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var\
    \ g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var\
    \ o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var\
    \ s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var\
    \ w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var\
    \ a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var\
    \ e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var\
    \ m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var\
    \ q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var\
    \ u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var\
    \ y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var\
    \ c = 0\n        var d\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq43a2j65.scala:117:4 ---------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq43a2j65.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpq43a2j65.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpq43a2j65.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq43a2j65.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m \e[36ml\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvariable\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq43a2j65.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvariable\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwn907o5w.scala:22:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36malphabet9\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,\e[31m's'\e[0m,\e[31m't'\e[0m,\e[31m'u'\e[0m,\e[31m'v\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'v is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"v\" or an application Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{v} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn907o5w.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwn907o5w.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => (c + 2).toChar)\n        val\
    \ rotatedAlphabet2 = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet3\
    \ = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet4 = alphabet.map(c\
    \ => (c + 2).toChar)\n        val rotatedAlphabet5 = alphabet.map(c => (c + 2).toChar)\n\
    \        val rotatedAlphabet6 = alphabet.map(c => (c + 2).toChar)\n        val\
    \ rotatedAlphabet7 = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet8\
    \ = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet9 = alphabet.map(c\
    \ => (c + 2).toChar)\n        val rotatedAlphabet10 = alphabet.map(c => (c + 2).toChar)\n\
    \        val rotatedAlphabet11 = alphabet.map(c => (c + 2).toChar)\n        val\
    \ rotatedAlphabet12 = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet13\
    \ = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet14 = alphabet.map(c\
    \ => (c + 2).toChar)\n        val rotatedAlphabet15 = alphabet.map(c => (c + 2).toChar)\n\
    \        val rotatedAlphabet16 = alphabet.map(c => (c + 2).toChar)\n        val\
    \ rotatedAlphabet17 = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet18\
    \ = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet19 = alphabet.map(c\
    \ => (c + 2).toChar)\n        val rotatedAlphabet20 = alphabet.map(c => (c + 2).toChar)\n\
    \        val rotatedAlphabet21 = alphabet.map(c => (c + 2).toChar)\n        val\
    \ rotatedAlphabet22 = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet23\
    \ = alphabet.map(c => (c + 2).toChar)\n        val rotatedAlphabet24 = alphabet.map(c\
    \ => (c + 2).toChar)\n        val rotatedAlphabet25 = alphabet.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n\
    \    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp63swm35l.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp63swm35l.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hlzymis.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3hlzymis.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n        val newAlphabet21 = alphabet.map(x => x -> alphabet(\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphjv0rkny.scala:35:60 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet21\e[0m = alphabet.map(\e\
    [36mx\e[0m => x -> alphabet(\n\e[31m\e[31m   |\e[0m                          \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphjv0rkny.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 4))\n\
    \        val newAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 6))\n\
    \        val newAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 8))\n\
    \        val newAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 10))\n\
    \        val newAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 12))\n\
    \        val newAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 14))\n\
    \        val newAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 16))\n\
    \        val newAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 18))\n\
    \        val newAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x) +\
    \ 20))\n        val newAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 22))\n        val newAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 24))\n        val newAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 26))\n        val newAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 28))\n        val newAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 30))\n        val newAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 32))\n        val newAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 34))\n        val newAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 36))\n        val newAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 38))\n        val newAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 40))\n        val newAlphabet21 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 42))\n        val newAlphabet22 = alphabet.map(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5r_kb1ul.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5r_kb1ul.scala:36:41\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mnewAlphabet22\e[0m = alphabet.map(x \n\e[31m\e[31m   |\e[0m              \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \               Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5r_kb1ul.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 11))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 13))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 15))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 17))\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jfepuiy.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => (x - 2).toChar).map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$2(tmpho4o0duk.scala:15)\n\tat Problem$.$anonfun$adapted$2(tmpho4o0duk.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:246)\n\tat Problem$.encrypt(tmpho4o0duk.scala:15)\n\
    \tat Problem$.main(tmpho4o0duk.scala:20)\n\tat Problem.main(tmpho4o0duk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.zip(newAlphabet).map(x => x._1 + x._2).mkString(\"\
    \")\n        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp2etpahih.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp2etpahih.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp2etpahih.scala:15)\n\
    \tat Problem$.main(tmp2etpahih.scala:20)\n\tat Problem.main(tmp2etpahih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.toCharArray.map(x => newAlphabet(alphabet.indexOf(x)\
    \ + 1))\n        new String(newString)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpeijdge9f.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpeijdge9f.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpeijdge9f.scala:15)\n\
    \tat Problem$.main(tmpeijdge9f.scala:20)\n\tat Problem.main(tmpeijdge9f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 20))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 22))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 24))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 26))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 28))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 30))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 32))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 34))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 36))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptnjv1j9m.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptnjv1j9m.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.map(x => newAlphabet(alphabet.indexOf(x)))\n\
    \        newString.mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpj26__z9l.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpj26__z9l.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpj26__z9l.scala:15)\n\
    \tat Problem$.main(tmpj26__z9l.scala:20)\n\tat Problem.main(tmpj26__z9l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpmgh3qnrn.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpmgh3qnrn.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpmgh3qnrn.scala:15)\n\
    \tat Problem$.main(tmpmgh3qnrn.scala:20)\n\tat Problem.main(tmpmgh3qnrn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18))\n        val newAlphabet21 = alphabet.map(x => x -> alphabet\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp791tpmhe.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp791tpmhe.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = newAlphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = newAlphabet3.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet5 = newAlphabet4.map(x => x + 'z' - 'a')\n  \
    \      val newAlphabet6 = newAlphabet5.map(x => x + 'z' - 'a')\n        val newAlphabet7\
    \ = newAlphabet6.map(x => x + 'z' - 'a')\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet9 = newAlphabet8.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet10 = newAlphabet9.map(x => x + 'z' - 'a')\n \
    \       val newAlphabet11 = newAlphabet10.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet12 = newAlphabet11.map(x => x + 'z' - 'a')\n        val newAlphabet13\
    \ = newAlphabet12.map(x => x + 'z' - 'a')\n        val newAlphabet14 = newAlphabet13.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet15 = newAlphabet14.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet16 = newAlphabet15.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = newAlphabet16.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet18 = newAlphabet17.map(x => x + 'z' - 'a')\n        val newAlphabet19\
    \ = newAlphabet18.map(x => x + 'z' - 'a')\n        val newAlphabet20 = newAlphabet19.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet21 = newAlphabet20.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet22 = newAlphabet21.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet23 = newAlphabet22.map(x => x + 'z\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphz7w0all.scala:37:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                                ^\e[0m\n\e[31m   |\e[0msymbol literal 'z is no\
    \ longer supported,\n\e[31m   |\e[0muse a string literal \"z\" or an application\
    \ Symbol(\"z\") instead,\n\e[31m   |\e[0mor enclose in braces '{z} if you want\
    \ a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphz7w0all.scala:38:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmphz7w0all.scala:37:53 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                            ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m  (x: String): String\n\e[31m   |\e[0m match\
    \ arguments (Symbol)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphz7w0all.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x) -\
    \ 1))\n        val newAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet21 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet22 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq3tutqjd.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpq3tutqjd.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797865
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hlzymis.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3hlzymis.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.map(x => alphabet(alphabet.indexOf(x) +\
    \ 2))\n        new String(newAlphabet ++ newString)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmfvtec5j.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(newAlphabet\
    \ ++ newString)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in\
    \ \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder):\
    \ String\n\e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments (List[Char])\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659797865
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        val result = new String(rotatedString)\n        return result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpvofbqj44.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpvofbqj44.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpvofbqj44.scala:15)\n\
    \tat Problem$.main(tmpvofbqj44.scala:21)\n\tat Problem.main(tmpvofbqj44.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => x + 'z' - 'a' + 1)\n        val\
    \ rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n        rotatedString.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsyhjj358.scala:20)\n\tat Problem.main(tmpsyhjj358.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var result = \"\"\n        var i = 0\n        var j = 0\n        while\
    \ (i < s.length){\n            result += alphabet(j) + alphabet(j+1)\n       \
    \     i += 1\n            j += 1\n            if (j == 26){\n                j\
    \ = 0\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp58ios1j8.scala:29)\n\tat Problem.main(tmp58ios1j8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9w31cbwl.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9w31cbwl.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c => c+c).map(c\
    \ => c\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1z1ef9uq.scala:16:4 ----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1z1ef9uq.scala:16:5 ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)).apply(x))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppihhpygk.scala:16:28\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mrotatedString\e\
    [0m = s.toCharArray.map(\e[36mx\e[0m => rotatedAlphabet(alphabet.indexOf(x)).apply(x))\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Array[\n\e[31m   |\e[0m   \
    \                    (?1 : Int)\e[33m match \e[0m{\n\e[31m   |\e[0m          \
    \               case (\e[31m0\e[0m : Int) => Char\n\e[31m   |\e[0m           \
    \              case scala.compiletime.ops.int.S[n1] => \n\e[31m   |\e[0m     \
    \                      scala.Tuple.Elem[Char *: EmptyTuple.type, n1]\n\e[31m \
    \  |\e[0m                       }\n\e[31m   |\e[0m                     ]\n\e[31m\
    \   |\e[0m                     Required: Array[Any]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                     where:    ?\e[31m1\e[0m is an unknown value of type\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n        val alphabetLength = alphabetLength - 1\n        val alphabetLength\
    \ = alphabetLength - 1\n        val alphabetLength = alphabetLength - 1\n    \
    \    val alphabetLength = alphabetLength - 1\n        val alphabetLength = alphabetLength\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpugs9147x.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0malphabetLength is already defined as \e[33mvalue\e[0m \e[35malphabetLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugs9147x.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36malphabetLength\e[0m = alphabetLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = newAlphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = newAlphabet3.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet5 = newAlphabet4.map(x => x + 'z' - 'a')\n  \
    \      val newAlphabet6 = newAlphabet5.map(x => x + 'z' - 'a')\n        val newAlphabet7\
    \ = newAlphabet6.map(x => x + 'z' - 'a')\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet9 = newAlphabet8.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet10 = newAlphabet9.map(x => x + 'z' - 'a')\n \
    \       val newAlphabet11 = newAlphabet10.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet12 = newAlphabet11.map(x => x + 'z' - 'a')\n        val newAlphabet13\
    \ = newAlphabet12.map(x => x + 'z' - 'a')\n        val newAlphabet14 = newAlphabet13.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet15 = newAlphabet14.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet16 = newAlphabet15.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = newAlphabet16.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet18 = newAlphabet17.map(x => x + 'z' - 'a')\n        val newAlphabet19\
    \ = newAlphabet18.map(x => x + 'z' - 'a')\n        val newAlphabet20 = newAlphabet19.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet21 = newAlphabet20.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet22 = newAlphabet21.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet23 = newAlphabet22.map(x => x + 'z\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphz7w0all.scala:37:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                                ^\e[0m\n\e[31m   |\e[0msymbol literal 'z is no\
    \ longer supported,\n\e[31m   |\e[0muse a string literal \"z\" or an application\
    \ Symbol(\"z\") instead,\n\e[31m   |\e[0mor enclose in braces '{z} if you want\
    \ a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphz7w0all.scala:38:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmphz7w0all.scala:37:53 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                            ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m  (x: String): String\n\e[31m   |\e[0m match\
    \ arguments (Symbol)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphz7w0all.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a' + 1).map(x => x + 'z'\
    \ - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x =>\
    \ x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x => x + 'z' - 'a' + 1).map(x\
    \ => x + 'z\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2g_iz9pf.scala:15:1168 ---------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e\
    [0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m =>\
    \ x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x +\
    \ \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e\
    [0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m -\
    \ \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e\
    [0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m +\
    \ \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e\
    [0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e\
    [0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m =>\
    \ x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x +\
    \ \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e\
    [0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m -\
    \ \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e\
    [0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m +\
    \ \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e\
    [0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e\
    [0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m =>\
    \ x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x +\
    \ \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e\
    [0m - \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m -\
    \ \e[31m'a'\e[0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e\
    [0m + \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m +\
    \ \e[31m1\e[0m).map(\e[36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \e[31m1\e\
    [0m).map(\e[36mx\e[0m => x + \e[31m"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a' + 1)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a' + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a' + 3)\n        val newAlphabet4 = alphabet.map(x => x + 'z'\
    \ - 'a' + 4)\n        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a' + 5)\n\
    \        val newAlphabet6 = alphabet.map(x => x + 'z' - 'a' + 6)\n        val\
    \ newAlphabet7 = alphabet.map(x => x + 'z' - 'a' + 7)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 'z' - 'a' + 8)\n        val newAlphabet9 = alphabet.map(x\
    \ => x + 'z' - 'a' + 9)\n        val newAlphabet10 = alphabet.map(x => x + 'z'\
    \ - 'a' + 10)\n        val newAlphabet11 = alphabet.map(x => x + 'z' - 'a' + 11)\n\
    \        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a' + 12)\n        val\
    \ newAlphabet13 = alphabet.map(x => x + 'z' - 'a' + 13)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a' + 14)\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a' + 15)\n        val newAlphabet16 = alphabet.map(x => x + 'z'\
    \ - 'a' + 16)\n        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a' + 17)\n\
    \        val newAlphabet18 = alphabet.map(x => x + 'z' - 'a' + 18)\n        val\
    \ newAlphabet19 = alphabet.map(x => x + 'z' - 'a' + 19)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 'z' - 'a' + 20)\n        val newAlphabet21 = alphabet.map(x\
    \ => x + 'z' - 'a' + 21)\n        val newAlphabet22 = alphabet.map(x => x + 'z'\
    \ - 'a' + 22)\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbhaacg73.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhaacg73.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val rotatedAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.map(x => x._1 + x._2).mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp7yehc0b3.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp7yehc0b3.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp7yehc0b3.scala:15)\n\
    \tat Problem$.main(tmp7yehc0b3.scala:20)\n\tat Problem.main(tmp7yehc0b3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x + 'z').map(x =>\
    \ x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x +\
    \ 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x\
    \ => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x\
    \ + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'i').map(x => x + 'h').map(x\
    \ => x + 'g').map(x => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x\
    \ + 'c').map(x => x + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newString\
    \ = s.toCharArray.map(x => newAlphabet(alphabet.indexOf(x) + 1)).map(x => x.toString).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdlbfdano.scala:20)\n\tat Problem.main(tmpdlbfdano.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.map(c => rotatedAlphabet(c))\n        rotatedString.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpl1py0jj3.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpl1py0jj3.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpl1py0jj3.scala:15)\n\
    \tat Problem$.main(tmpl1py0jj3.scala:20)\n\tat Problem.main(tmpl1py0jj3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2) % 26 + 2).toList\n      \
    \  val newAlphabet2 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet3 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet4\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet5 = alphabet.map(x\
    \ => (x - 2) % 26 + 2).toList\n        val newAlphabet6 = alphabet.map(x => (x\
    \ - 2) % 26 + 2).toList\n        val newAlphabet7 = alphabet.map(x => (x - 2)\
    \ % 26 + 2).toList\n        val newAlphabet8 = alphabet.map(x => (x - 2) % 26\
    \ + 2).toList\n        val newAlphabet9 = alphabet.map(x => (x - 2) % 26 + 2).toList\n\
    \        val newAlphabet10 = alphabet.map(x => (x - 2) % 26 + 2).toList\n    \
    \    val newAlphabet11 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet12 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet13\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet14 = alphabet.map(x\
    \ => (x - 2) % 26 + 2).toList\n        val newAlphabet15 = alphabet.map(x => (x\
    \ - 2) % 26 + 2).toList\n        val newAlphabet16 = alphabet.map(x => (x - 2)\
    \ % 26 + 2).toList\n        val newAlphabet17 = alphabet.map(x => (x - 2) % 26\
    \ + 2).toList\n        val newAlphabet18 = alphabet.map(x => (x - 2) % 26 + 2).toList\n\
    \        val newAlphabet19 = alphabet.map(x => (x - 2) % 26 + 2).toList\n    \
    \    val newAlphabet20 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet21 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet22\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphab\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyf242r2a.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyf242r2a.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.toCharArray.map(x => newAlphabet(alphabet.indexOf(x)).head).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp2ey__3v7.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp2ey__3v7.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp2ey__3v7.scala:15)\n\
    \tat Problem$.main(tmp2ey__3v7.scala:20)\n\tat Problem.main(tmp2ey__3v7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x => x + 'p').map(x\
    \ => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x + 'l').map(x => x\
    \ + 'k').map(x => x + 'j').map(x => x + 'i').map(x => x + 'h').map(x => x + 'g').map(x\
    \ => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x\
    \ + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newAlphabet2 = alphabet.map(x\
    \ => x + 'z').map(x => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x\
    \ + 'v').map(x => x + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x\
    \ => x + 'q').map(x => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x\
    \ + 'm').map(x => x + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'i').map(x\
    \ => x + 'h').map(x => x + 'g').map(x => x + 'f').map(x => x + 'e').map(x => x\
    \ + 'd').map(x => x + 'c').map(x => x + 'b').map(x => x + 'a').map(x => x + 'z')\n\
    \        val newAlphabet3 = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq4p5z7v0.scala:17:166 --------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m).map(\e[36mx\e[0m => x + \e[31m'y'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'x'\e[0m).map(\e[36mx\e[0m => x + \e[31m'w'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'v'\e[0m).map(\e[36mx\e[0m => x + \e[31m'u'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m't'\e[0m).map(\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpq4p5z7v0.scala:18:5 ---------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 11))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 13))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 15))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 17))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 18))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + \n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphhmc4l6o.scala:34:81 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet20\e[0m = alphabet.map(\e\
    [36mx\e[0m => x -> alphabet(alphabet.indexOf(x) + \n\e[31m\e[31m   |\e[0m    \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphhmc4l6o.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x + 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x - 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph2s7u11t.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmph2s7u11t.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 1))\n        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpa6v6260z.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpa6v6260z.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpa6v6260z.scala:15)\n\
    \tat Problem$.main(tmpa6v6260z.scala:20)\n\tat Problem.main(tmpa6v6260z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newString = s.map(x => newAlphabet(alphabet.indexOf(x)))\n\
    \        newString.mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpoq__fap5.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpoq__fap5.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpoq__fap5.scala:15)\n\
    \tat Problem$.main(tmpoq__fap5.scala:20)\n\tat Problem.main(tmpoq__fap5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val result = new StringBuilder\n        for(i <- 0 until\
    \ s.length){\n            val c = s.charAt(i)\n            val index = alphabet.indexOf(c)\n\
    \            val newIndex = index - 2\n            if(newIndex < 0){\n       \
    \         newIndex += alphabet.length\n            }\n            result.append(alphabet(newIndex))\n\
    \        }\n        return result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6acot8as.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                newIndex += alphabet.length\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean newIndex.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a' + 1)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a' + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a' + 3)\n        val newAlphabet4 = alphabet.map(x => x + 'z'\
    \ - 'a' + 4)\n        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a' + 5)\n\
    \        val newAlphabet6 = alphabet.map(x => x + 'z' - 'a' + 6)\n        val\
    \ newAlphabet7 = alphabet.map(x => x + 'z' - 'a' + 7)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 'z' - 'a' + 8)\n        val newAlphabet9 = alphabet.map(x\
    \ => x + 'z' - 'a' + 9)\n        val newAlphabet10 = alphabet.map(x => x + 'z'\
    \ - 'a' + 10)\n        val newAlphabet11 = alphabet.map(x => x + 'z' - 'a' + 11)\n\
    \        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a' + 12)\n        val\
    \ newAlphabet13 = alphabet.map(x => x + 'z' - 'a' + 13)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a' + 14)\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a' + 15)\n        val newAlphabet16 = alphabet.map(x => x + 'z'\
    \ - 'a' + 16)\n        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a' + 17)\n\
    \        val newAlphabet18 = alphabet.map(x => x + 'z' - 'a' + 18)\n        val\
    \ newAlphabet19 = alphabet.map(x => x + 'z' - 'a' + 19)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 'z' - 'a' + 20)\n        val newAlphabet21 = alphabet.map(x\
    \ => x + 'z' - 'a' + 21)\n        val newAlphabet22 = alphabet.map(x => x + 'z'\
    \ - 'a' + 22)\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbhaacg73.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhaacg73.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpbp782l9i.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpbp782l9i.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpbp782l9i.scala:15)\n\
    \tat Problem$.main(tmpbp782l9i.scala:20)\n\tat Problem.main(tmpbp782l9i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpzjep8c69.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpzjep8c69.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpzjep8c69.scala:15)\n\
    \tat Problem$.main(tmpzjep8c69.scala:20)\n\tat Problem.main(tmpzjep8c69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.map(x => newAlphabet(alphabet.indexOf(x)))\n\
    \        newString.mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmptx5z9vgo.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmptx5z9vgo.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmptx5z9vgo.scala:15)\n\
    \tat Problem$.main(tmptx5z9vgo.scala:20)\n\tat Problem.main(tmptx5z9vgo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797872
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => (c + c).toUpper)\n        val\
    \ rotatedAlphabet2 = rotatedAlphabet.map(c => (c + c).toUpper)\n        val rotatedAlphabet3\
    \ = rotatedAlphabet2.map(c => (c + c).toUpper)\n        val rotatedAlphabet4 =\
    \ rotatedAlphabet3.map(c => (c + c).toUpper)\n        val rotatedAlphabet5 = rotatedAlphabet4.map(c\
    \ => (c + c).toUpper)\n        val rotatedAlphabet6 = rotatedAlphabet5.map(c =>\
    \ (c + c).toUpper)\n        val rotatedAlphabet7 = rotatedAlphabet6.map(c => (c\
    \ + c).toUpper)\n        val rotatedAlphabet8 = rotatedAlphabet7.map(c => (c +\
    \ c).toUpper)\n        val rotatedAlphabet9 = rotatedAlphabet8.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet10 = rotatedAlphabet9.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet11 = rotatedAlphabet10.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet12 = rotatedAlphabet11.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet13 = rotatedAlphabet12.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet14 = rotatedAlphabet13.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet15 = rotatedAlphabet14.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet16 = rotatedAlphabet15.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet17 = rotatedAlphabet16.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet18 = rotatedAlphabet17.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet19 = rotatedAlphabet18.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet20 = rotatedAlphabet19.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet21 = rotatedAlphabet20.map(c => (c + c).toUpper)\n\
    \        val rotatedAlphabet22 = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwtsx8_8v.scala:36:31 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mrotatedAlphabet22\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtsx8_8v.scala:15:56\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mrotatedAlphabet\e[0m = alphabet.map(\e[36mc\e[0m => (c + c).toUpper)\n\e[31m\e\
    [31m   |\e[0m                                                ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value toUpper is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtsx8_8v.scala:16:59\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mrotatedAlphabet2\e[0m = rotatedAlphabet.map(\e[36mc\e[0m => (c + c).toUpper)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Nothing, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e\
    [0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e\
    [0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\e[31m\
    \   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\e\
    [31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwtsx8_8v.scala:17:60\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mrotatedAlphabet3\e[0m = rotatedAlphabet2.map(\e[36mc\e[0m => (c + c).toUpper)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Nothing, but could"
  stdout: ''
  timestamp: 1659797879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet4 = alphabet.map(x => x - 1)\n        val newAlphabet5\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet7 = alphabet.map(x => x - 1)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet9 = alphabet.map(x => x +\
    \ 1)\n        val newAlphabet10 = alphabet.map(x => x - 2)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet12 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet13 = alphabet.map(x => x + 1)\n        val newAlphabet14\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet16 = alphabet.map(x => x + 2)\n        val newAlphabet17\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet18 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet19 = alphabet.map(x => x - 1)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet21 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet22 = alphabet.map(x => x - 2)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet24 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet25 = alphabet.map(x => x + 1)\n        val newAlphabet26\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet28 = alphabet.map(x => x + 2)\n        val newAlphabet29\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet30 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet31 = alphabet.map(x => x - 1)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2iqyecry.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpoh_0i45w.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpoh_0i45w.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpoh_0i45w.scala:15)\n\
    \tat Problem$.main(tmpoh_0i45w.scala:20)\n\tat Problem.main(tmpoh_0i45w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.zip(newAlphabet).map(x => x._1 + x._2).mkString(\"\
    \")\n        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp2etpahih.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp2etpahih.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp2etpahih.scala:15)\n\
    \tat Problem$.main(tmp2etpahih.scala:20)\n\tat Problem.main(tmp2etpahih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmptxag1x45.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmptxag1x45.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmptxag1x45.scala:15)\n\
    \tat Problem$.main(tmptxag1x45.scala:20)\n\tat Problem.main(tmptxag1x45.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 1)\n        val newAlphabet4 = alphabet.map(x => x - 2)\n        val newAlphabet5\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 1)\n        val newAlphabet7 = alphabet.map(x => x - 2)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet9 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet10 = alphabet.map(x => x + 1)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet12 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet13 = alphabet.map(x => x - 2)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet16 = alphabet.map(x => x + 1)\n        val newAlphabet17\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet18 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet19 = alphabet.map(x => x - 2)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet21 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet22 = alphabet.map(x => x + 1)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet24 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet25 = alphabet.map(x => x - 2)\n        val newAlphabet26\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet28 = alphabet.map(x => x + 1)\n        val newAlphabet29\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet30 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet31 = alphabet.map(x => x - 2)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi_kqgqh7.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet4 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet5 = alphabet.map(x => (x - 2) % 26 + 2)\n  \
    \      val newAlphabet6 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet7\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet8 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet9 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet10 = alphabet.map(x => (x - 2) % 26 + 2)\n \
    \       val newAlphabet11 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet12\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet13 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet14 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet15 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet16 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet17 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet18\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet20 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet21 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet22 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet23 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet24\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet25 = alphabet.map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj9yax8i4.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9yax8i4.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val result = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n       \
    \ val result = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result\
    \ = result.map(x => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x\
    \ => alphabet(alphabet.indexOf(x)))\n        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n\
    \        val result = result.map(x => alphabet(alphabet.indexOf(x)))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3gyk3cqd.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.map(\e\
    [36mx\e[0m => alphabet(alphabet.indexOf(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3gyk3cqd.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.map(\e[36mx\e[0m\
    \ => alphabet(alphabet.indexOf(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3gyk3cqd.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.map(\e[36mx\e[0m\
    \ => alphabet(alphabet.indexOf(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3gyk3cqd.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.map(\e[36mx\e[0m\
    \ => alphabet(alphabet.indexOf(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3gyk3cqd.scala:21:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        new String(rotatedString)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpv76tarqu.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpv76tarqu.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpv76tarqu.scala:15)\n\
    \tat Problem$.main(tmpv76tarqu.scala:20)\n\tat Problem.main(tmpv76tarqu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a' + 1)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a' + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a' + 3)\n        val newAlphabet4 = alphabet.map(x => x + 'z'\
    \ - 'a' + 4)\n        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a' + 5)\n\
    \        val newAlphabet6 = alphabet.map(x => x + 'z' - 'a' + 6)\n        val\
    \ newAlphabet7 = alphabet.map(x => x + 'z' - 'a' + 7)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 'z' - 'a' + 8)\n        val newAlphabet9 = alphabet.map(x\
    \ => x + 'z' - 'a' + 9)\n        val newAlphabet10 = alphabet.map(x => x + 'z'\
    \ - 'a' + 10)\n        val newAlphabet11 = alphabet.map(x => x + 'z' - 'a' + 11)\n\
    \        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a' + 12)\n        val\
    \ newAlphabet13 = alphabet.map(x => x + 'z' - 'a' + 13)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a' + 14)\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a' + 15)\n        val newAlphabet16 = alphabet.map(x => x + 'z'\
    \ - 'a' + 16)\n        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a' + 17)\n\
    \        val newAlphabet18 = alphabet.map(x => x + 'z' - 'a' + 18)\n        val\
    \ newAlphabet19 = alphabet.map(x => x + 'z' - 'a' + 19)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 'z' - 'a' + 20)\n        val newAlphabet21 = alphabet.map(x\
    \ => x + 'z' - 'a' + 21)\n        val newAlphabet22 = alphabet.map(x => x + 'z'\
    \ - 'a' + 22)\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbhaacg73.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhaacg73.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => (c + c).rotate(2))\n        val\
    \ rotatedString = s.toCharArray.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvu6se1n8.scala:15:56 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mrotatedAlphabet\e[0m = alphabet.map(\e\
    [36mc\e[0m => (c + c).rotate(\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m           \
    \                                     ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \       value rotate is not a member of Int - did you mean Int.toByte?\n\e[31m\e\
    [31m-- Error: /tmp/tmpvu6se1n8.scala:16:88 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mrotatedString\e[0m = s.toCharArray.map(\e\
    [36mc\e[0m => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \   No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m            \
    \                              where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var result = \"\"\n        for(i <- 0 until s.length){\n            result\
    \ += alphabet(alphabet.indexOf(s)+2)\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n\
    \    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptwk7kxhg.scala:22)\n\tat Problem.main(tmptwk7kxhg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => (x - 2) % 26 + 2).toList\n\
    \        val newAlphabet2 = alphabet.map(x => (x - 2) % 26 + 2).toList\n     \
    \   val newAlphabet3 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet4 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet5\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet6 = alphabet.map(x\
    \ => (x - 2) % 26 + 2).toList\n        val newAlphabet7 = alphabet.map(x => (x\
    \ - 2) % 26 + 2).toList\n        val newAlphabet8 = alphabet.map(x => (x - 2)\
    \ % 26 + 2).toList\n        val newAlphabet9 = alphabet.map(x => (x - 2) % 26\
    \ + 2).toList\n        val newAlphabet10 = alphabet.map(x => (x - 2) % 26 + 2).toList\n\
    \        val newAlphabet11 = alphabet.map(x => (x - 2) % 26 + 2).toList\n    \
    \    val newAlphabet12 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet13 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet14\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2) % 26 + 2).toList\n        val newAlphabet16 = alphabet.map(x => (x\
    \ - 2) % 26 + 2).toList\n        val newAlphabet17 = alphabet.map(x => (x - 2)\
    \ % 26 + 2).toList\n        val newAlphabet18 = alphabet.map(x => (x - 2) % 26\
    \ + 2).toList\n        val newAlphabet19 = alphabet.map(x => (x - 2) % 26 + 2).toList\n\
    \        val newAlphabet20 = alphabet.map(x => (x - 2) % 26 + 2).toList\n    \
    \    val newAlphabet21 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val\
    \ newAlphabet22 = alphabet.map(x => (x - 2) % 26 + 2).toList\n        val newAlphabet23\
    \ = alphabet.map(x => (x - 2) % 26 + 2).toList\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcx4rkzye.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797881
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        val result = rotatedString.mkString\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpci0r0v87.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpci0r0v87.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpci0r0v87.scala:15)\n\
    \tat Problem$.main(tmpci0r0v87.scala:21)\n\tat Problem.main(tmpci0r0v87.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp4u05h623.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp4u05h623.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp4u05h623.scala:15)\n\
    \tat Problem$.main(tmp4u05h623.scala:20)\n\tat Problem.main(tmp4u05h623.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        new String(rotatedString)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpv76tarqu.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpv76tarqu.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpv76tarqu.scala:15)\n\
    \tat Problem$.main(tmpv76tarqu.scala:20)\n\tat Problem.main(tmpv76tarqu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp19eeko44.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp19eeko44.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 1))\n        val rotatedString = s.map(c => rotatedAlphabet(c))\n        rotatedString.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmph5lgri4j.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmph5lgri4j.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmph5lgri4j.scala:15)\n\
    \tat Problem$.main(tmph5lgri4j.scala:20)\n\tat Problem.main(tmph5lgri4j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp4u05h623.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp4u05h623.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp4u05h623.scala:15)\n\
    \tat Problem$.main(tmp4u05h623.scala:20)\n\tat Problem.main(tmp4u05h623.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c + 'z').map(c => c + 'y').map(c\
    \ => c + 'x').map(c => c + 'w').map(c => c + 'v').map(c => c + 'u').map(c => c\
    \ + 't').map(c => c + 's').map(c => c + 'r').map(c => c + 'q').map(c => c + 'p').map(c\
    \ => c + 'o').map(c => c + 'n').map(c => c + 'm').map(c => c + 'l').map(c => c\
    \ + 'k').map(c => c + 'j').map(c => c + 'h').map(c => c + 'g').map(c => c + 'f').map(c\
    \ => c + 'e').map(c => c + 'd').map(c => c + 'c').map(c => c + 'b').map(c => c\
    \ + 'a').map(c => c + 'z')\n        val rotatedString = s.map(c => rotatedAlphabet(c))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 104\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$27(tmpeahkw3g8.scala:16)\n\tat Problem$.$anonfun$adapted$2(tmpeahkw3g8.scala:16)\n\
    \tat scala.collection.StringOps$.map$extension(StringOps.scala:206)\n\tat Problem$.encrypt(tmpeahkw3g8.scala:16)\n\
    \tat Problem$.main(tmpeahkw3g8.scala:20)\n\tat Problem.main(tmpeahkw3g8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        var result = \"\"\n        var i = 0\n        while\
    \ (i < s.length) {\n            result += alphabet(alphabet.size - 1 - alphabet.indexOfAt(s.charAt(i)))\n\
    \            i += 1\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpic6cu072.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            result += alphabet(alphabet.size - \e[31m1\e\
    [0m - alphabet.indexOfAt(s.charAt(i)))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of String - did you mean\
    \ String.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpic6cu072.scala:18:60\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            result += alphabet(alphabet.size\
    \ - \e[31m1\e[0m - alphabet.indexOfAt(s.charAt(i)))\n\e[31m\e[31m   |\e[0m   \
    \                                                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue indexOfAt is not a member of List[Char] - did you mean List[Char].indexOf?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val result = new StringBuilder\n        for(i <- 0 until\
    \ s.length)\n            result.append(alphabet(alphabet.indexOf(s) + 2))\n  \
    \      result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmgg06kez.scala:21)\n\tat Problem.main(tmpmgg06kez.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0b228jat.scala:22:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnewAlphabet8\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,'\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0b228jat.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar).reverse\n       \
    \ val newString = s.map(x => newAlphabet(alphabet.indexOf(x)))\n        newString.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb68g7xbc.scala:20)\n\tat Problem.main(tmpb68g7xbc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4xn6qbhz.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4xn6qbhz.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 0))\n\
    \        val newAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 0))\n\
    \        val newAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 1))\n\
    \        val newAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 1))\n\
    \        val newAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x) -\
    \ 2))\n        val newAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet21 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet22 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3vcwbwg7.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3vcwbwg7.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetRotated = alphabet.map(x\
    \ => alphabet(alphabetLength - alphabet.indexOf(x)))\n        val alphabetLengthRotated\
    \ = alphabetRotated.length\n        val alphabetLengthRotated2 = alphabetLengthRotated\
    \ * 2\n        val alphabetLengthRotated3 = alphabetLengthRotated2 * 2\n     \
    \   val alphabetLengthRotated4 = alphabetLengthRotated3 * 2\n        val alphabetLengthRotated5\
    \ = alphabetLengthRotated4 * 2\n        val alphabetLengthRotated6 = alphabetLengthRotated5\
    \ * 2\n        val alphabetLengthRotated7 = alphabetLengthRotated6 * 2\n     \
    \   val alphabetLengthRotated8 = alphabetLengthRotated7 * 2\n        val alphabetLengthRotated9\
    \ = alphabetLengthRotated8 * 2\n        val alphabetLengthRotated10 = alphabetLengthRotated9\
    \ * 2\n        val alphabetLengthRotated11 = alphabetLengthRotated10 * 2\n   \
    \     val alphabetLengthRotated12 = alphabetLengthRotated11 * 2\n        val alphabetLengthRotated13\
    \ = alphabetLengthRotated12 * 2\n        val alphabetLengthRotated14 = alphabetLengthRotated13\
    \ * 2\n        val alphabetLengthRotated15 = alphabetLengthRotated14 * 2\n   \
    \     val alphabetLengthRotated16 = alphabetLengthRotated15 * 2\n        val alphabetLengthRotated17\
    \ = alphabetLengthRotated16 * 2\n        val alphabetLengthRotated18 = alphabetLengthRotated17\
    \ * 2\n        val alphabetLengthRotated19 = alphabetLengthRotated18 * 2\n   \
    \     val alphabetLengthRotated20 = alphabetLengthRotated19 * 2\n        val alphabetLengthRotated21\
    \ = alphabetLengthRotated20 * 2\n        val alphabetLengthRotated22 = alphabetLengthRotated21\
    \ * 2\n        val alphabetLengthRotated23 = alphabetLengthRotated22 * 2\n   \
    \     val alphabetLengthRotated24 = alphabetLengthRotated23 * 2\n        val alphabetLengthRotated25\
    \ = alphabetLengthRotated24 * 2\n        val alphabetLengthRotated26 = alphabetLengthRotated25\
    \ * 2\n        val alphabetLengthRotated27 = alphabetLengthRotated26 * 2\n   \
    \     val alphabetLengthRotated28 = alphabetLengthRotated27 * 2\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpg6e0ggjv.scala:45:11 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg6e0ggjv.scala:46:5 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwn907o5w.scala:22:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36malphabet9\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,\e[31m's'\e[0m,\e[31m't'\e[0m,\e[31m'u'\e[0m,\e[31m'v\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'v is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"v\" or an application Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{v} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn907o5w.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwn907o5w.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        new String(rotatedString)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpv76tarqu.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpv76tarqu.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpv76tarqu.scala:15)\n\
    \tat Problem$.main(tmpv76tarqu.scala:20)\n\tat Problem.main(tmpv76tarqu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797882
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x + 'z' - 'a' +\
    \ 1)\n        val newAlphabet2 = alphabet.map(x => x + 'z' - 'a' + 2)\n      \
    \  val newAlphabet3 = alphabet.map(x => x + 'z' - 'a' + 3)\n        val newAlphabet4\
    \ = alphabet.map(x => x + 'z' - 'a' + 4)\n        val newAlphabet5 = alphabet.map(x\
    \ => x + 'z' - 'a' + 5)\n        val newAlphabet6 = alphabet.map(x => x + 'z'\
    \ - 'a' + 6)\n        val newAlphabet7 = alphabet.map(x => x + 'z' - 'a' + 7)\n\
    \        val newAlphabet8 = alphabet.map(x => x + 'z' - 'a' + 8)\n        val\
    \ newAlphabet9 = alphabet.map(x => x + 'z' - 'a' + 9)\n        val newAlphabet10\
    \ = alphabet.map(x => x + 'z' - 'a' + 10)\n        val newAlphabet11 = alphabet.map(x\
    \ => x + 'z' - 'a' + 11)\n        val newAlphabet12 = alphabet.map(x => x + 'z'\
    \ - 'a' + 12)\n        val newAlphabet13 = alphabet.map(x => x + 'z' - 'a' + 13)\n\
    \        val newAlphabet14 = alphabet.map(x => x + 'z' - 'a' + 14)\n        val\
    \ newAlphabet15 = alphabet.map(x => x + 'z' - 'a' + 15)\n        val newAlphabet16\
    \ = alphabet.map(x => x + 'z' - 'a' + 16)\n        val newAlphabet17 = alphabet.map(x\
    \ => x + 'z' - 'a' + 17)\n        val newAlphabet18 = alphabet.map(x => x + 'z'\
    \ - 'a' + 18)\n        val newAlphabet19 = alphabet.map(x => x + 'z' - 'a' + 19)\n\
    \        val newAlphabet20 = alphabet.map(x => x + 'z' - 'a' + 20)\n        val\
    \ newAlphabet21 = alphabet.map(x => x + 'z' - 'a' + 21)\n        val newAlphabet22\
    \ = alphabet.map(x => x + 'z' - 'a' + 22)\n        val newAlphabet23 = alphabet.map(x\
    \ => x + 'z' - 'a' + \n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjkya1ewe.scala:37:61 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m - \e[31m'a'\e[0m + \n\e[31m\e[31m   |\e[0m  \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjkya1ewe.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet4 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet5 = alphabet.map(x => (x - 2) % 26 + 2)\n  \
    \      val newAlphabet6 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet7\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet8 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet9 = alphabet.map(x => (x - 2) %\
    \ 26 + 2)\n        val newAlphabet10 = alphabet.map(x => (x - 2) % 26 + 2)\n \
    \       val newAlphabet11 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet12\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet13 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet14 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet15 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet16 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet17 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet18\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2) % 26 + 2)\n        val newAlphabet20 = alphabet.map(x => (x - 2)\
    \ % 26 + 2)\n        val newAlphabet21 = alphabet.map(x => (x - 2) % 26 + 2)\n\
    \        val newAlphabet22 = alphabet.map(x => (x - 2) % 26 + 2)\n        val\
    \ newAlphabet23 = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet24\
    \ = alphabet.map(x => (x - 2) % 26 + 2)\n        val newAlphabet25 = alphabet.map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj9yax8i4.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj9yax8i4.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp95mbpzyf.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp95mbpzyf.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp95mbpzyf.scala:15)\n\
    \tat Problem$.main(tmp95mbpzyf.scala:20)\n\tat Problem.main(tmp95mbpzyf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        new String(rotatedString)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp9olgtjl9.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp9olgtjl9.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp9olgtjl9.scala:15)\n\
    \tat Problem$.main(tmp9olgtjl9.scala:20)\n\tat Problem.main(tmp9olgtjl9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797885
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => (x to (x + 2))).map(x => (x to\
    \ (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x\
    \ + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x +\
    \ 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x\
    \ => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x =>\
    \ (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x\
    \ to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to\
    \ (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x\
    \ + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x +\
    \ 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x\
    \ => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x =>\
    \ (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x\
    \ to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to\
    \ (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x\
    \ + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x +\
    \ 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x => (x to (x + 2))).map(x\
    \ => (x \n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplnz3ox8t.scala:16:4 ----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplnz3ox8t.scala:15:55 --------------------\e[0m\e[0m\n\e[31m15 |\e[0m\
    \        \e[33mval\e[0m \e[36mrotatedAlphabet\e[0m = alphabet.map(\e[36mx\e[0m\
    \ => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to\
    \ (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e\
    [0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to\
    \ (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e\
    [0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to\
    \ (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e\
    [0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to\
    \ (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e\
    [0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to\
    \ (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e\
    [0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e\
    [36mx\e[0m => (x to (x + \e[31m2\e[0m))).map(\e[36mx\e[0m => (x to (x + \e[31m2\e\
    [0m))).map(\e[36mx\e"
  stdout: ''
  timestamp: 1659797894
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet21 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo4ugcxzv.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwn907o5w.scala:22:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36malphabet9\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,\e[31m's'\e[0m,\e[31m't'\e[0m,\e[31m'u'\e[0m,\e[31m'v\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'v is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"v\" or an application Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{v} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn907o5w.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwn907o5w.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c + 'z').map(c => c + 'y').map(c\
    \ => c + 'x').map(c => c + 'w').map(c => c + 'v').map(c => c + 'u').map(c => c\
    \ + 't').map(c => c + 's').map(c => c + 'r').map(c => c + 'q').map(c => c + 'p').map(c\
    \ => c + 'o').map(c => c + 'n').map(c => c + 'm').map(c => c + 'l').map(c => c\
    \ + 'k').map(c => c + 'j').map(c => c + 'h').map(c => c + 'g').map(c => c + 'f').map(c\
    \ => c + 'e').map(c => c + 'd').map(c => c + 'c').map(c => c + 'b').map(c => c\
    \ + 'a').map(c => c + 'z')\n        val rotatedAlphabetReversed = rotatedAlphabet.reverse\n\
    \        val rotatedAlphabetReversedZipped = rotatedAlphabetReversed.zip(rotatedAlphabet)\n\
    \        val rotatedAlphabetZipped = rotatedAlphabet.zip(rotatedAlphabetReversed)\n\
    \        val rotatedAlphabetZippedZipped = rotatedAlphabetZipped.zip(rotatedAlphabetZipped)\n\
    \        val rotatedAlphabetZippedZippedZipped = rotatedAlphabetZippedZipped.zip(rotatedAlphabetZippedZipped)\n\
    \        val rotatedAlphabetZippedZippedZippedZipped = rotatedAlphabetZippedZippedZipped.zip(rotatedAlphabetZippedZippedZipped)\n\
    \        val rotatedAlphabetZippedZippedZippedZippedZipped = rotatedAlphabetZippedZippedZippedZipped.zip(rotatedAlphabetZippedZippedZippedZipped)\n\
    \        val rotatedAlphabetZippedZippedZippedZippedZippedZipped = rotatedAlphabetZippedZippedZippedZippedZipped.zip(rotatedAlphabetZippedZippedZippedZippedZipped)\n\
    \        val rotatedAlphabetZippedZippedZippedZip\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_g49e18b.scala:25:4 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_g49e18b.scala:25:5 ---------------------\e[0m\e[0m\n\e[31m25 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x => x + 'p').map(x\
    \ => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x + 'l').map(x => x\
    \ + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x => x + 'f').map(x\
    \ => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x + 'b').map(x => x\
    \ + 'a').map(x => x + 'z')\n        val newAlphabet2 = alphabet.map(x => x + 'z').map(x\
    \ => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x\
    \ + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x\
    \ => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x\
    \ + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x\
    \ => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x\
    \ + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z').map(x => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x\
    \ + 'v').map(x => x + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp66pmqb_y.scala:17:202 --------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m).map(\e[36mx\e[0m => x + \e[31m'y'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'x'\e[0m).map(\e[36mx\e[0m => x + \e[31m'w'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'v'\e[0m).map(\e[36mx\e[0m => x + \e[31m'u'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m't'\e[0m).map(\e[36mx\e[0m => x + \e[31m's'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'r'\e[0m).map(\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                            \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp66pmqb_y.scala:18:5 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpyda9hr9e.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpyda9hr9e.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpyda9hr9e.scala:15)\n\
    \tat Problem$.main(tmpyda9hr9e.scala:20)\n\tat Problem.main(tmpyda9hr9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2))).toMap\n        val newString = s.map(x => newAlphabet(x)).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpdvr0tahe.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpdvr0tahe.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpdvr0tahe.scala:15)\n\
    \tat Problem$.main(tmpdvr0tahe.scala:20)\n\tat Problem.main(tmpdvr0tahe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet21 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo4ugcxzv.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet5 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet6\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet7 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet8 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet9 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet10\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet11 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet12 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet13 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet14\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet15 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet16 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet18\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet19 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet20 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet21 = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet22\
    \ = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet23 = alphabet.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet24 = alphabet.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet25 = alphabet.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6p43896n.scala:39:41 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet25\e[0m = alphabet.map(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6p43896n.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        rotatedString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpyda9hr9e.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpyda9hr9e.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpyda9hr9e.scala:15)\n\
    \tat Problem$.main(tmpyda9hr9e.scala:20)\n\tat Problem.main(tmpyda9hr9e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar).map(x => alphabet(x)).mkString\n\
    \        val newString = s.map(x => newAlphabet(alphabet.indexOf(x) + 2))\n  \
    \      newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 95\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$2(tmpy7vmgynj.scala:15)\n\tat Problem$.$anonfun$adapted$2(tmpy7vmgynj.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:246)\n\tat Problem$.encrypt(tmpy7vmgynj.scala:15)\n\
    \tat Problem$.main(tmpy7vmgynj.scala:20)\n\tat Problem.main(tmpy7vmgynj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        val result = new String(rotatedString)\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmppit_l0eg.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmppit_l0eg.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmppit_l0eg.scala:15)\n\
    \tat Problem$.main(tmppit_l0eg.scala:21)\n\tat Problem.main(tmppit_l0eg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x.toUpperCase)\n        val newAlphabet2\
    \ = newAlphabet.map(x => x.toUpperCase)\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => x.toUpperCase)\n        val newAlphabet4 = newAlphabet3.map(x => x.toUpperCase)\n\
    \        val newAlphabet5 = newAlphabet4.map(x => x.toUpperCase)\n        val\
    \ newAlphabet6 = newAlphabet5.map(x => x.toUpperCase)\n        val newAlphabet7\
    \ = newAlphabet6.map(x => x.toUpperCase)\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => x.toUpperCase)\n        val newAlphabet9 = newAlphabet8.map(x => x.toUpperCase)\n\
    \        val newAlphabet10 = newAlphabet9.map(x => x.toUpperCase)\n        val\
    \ newAlphabet11 = newAlphabet10.map(x => x.toUpperCase)\n        val newAlphabet12\
    \ = newAlphabet11.map(x => x.toUpperCase)\n        val newAlphabet13 = newAlphabet12.map(x\
    \ => x.toUpperCase)\n        val newAlphabet14 = newAlphabet13.map(x => x.toUpperCase)\n\
    \        val newAlphabet15 = newAlphabet14.map(x => x.toUpperCase)\n        val\
    \ newAlphabet16 = newAlphabet15.map(x => x.toUpperCase)\n        val newAlphabet17\
    \ = newAlphabet16.map(x => x.toUpperCase)\n        val newAlphabet18 = newAlphabet17.map(x\
    \ => x.toUpperCase)\n        val newAlphabet19 = newAlphabet18.map(x => x.toUpperCase)\n\
    \        val newAlphabet20 = newAlphabet19.map(x => x.toUpperCase)\n        val\
    \ newAlphabet21 = newAlphabet20.map(x => x.toUpperCase)\n        val newAlphabet22\
    \ = newAlphabet21.map(x => x.toUpperCase)\n        val newAlphabet23 = newAlphabet22.map(x\
    \ => x.toUpperCase)\n        val newAlphabet24 = newAlphabet23.map(x => x.toUpperCase)\n\
    \        val newAlphabet25 = newAlphabet24.map(x => x.toUpperCase)\n        val\
    \ newAlphabet26\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6w35u53m.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6w35u53m.scala:15:46\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mnewAlphabet\e[0m = alphabet.map(\e[36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m\
    \   |\e[0m                                            ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value toUpperCase is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6w35u53m.scala:16:50 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet2\e[0m = newAlphabet.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         value toUpperCase is not a member of Nothing\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6w35u53m.scala:17:51 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = newAlphabet2.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          value toUpperCase is not a member of Nothing\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6w35u53m.scala:18:51 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet4\e[0m = newAlphabet3.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          value toUpperCase is not a member of Nothing\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6w35u53m.scala:19:51 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet5\e[0m = newAlphabet4.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \          value toUpperCase is not a member of Nothing"
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.zip(newAlphabet).map(x => x._1 + x._2).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp30pctkjr.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp30pctkjr.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp30pctkjr.scala:15)\n\
    \tat Problem$.main(tmp30pctkjr.scala:20)\n\tat Problem.main(tmp30pctkjr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x - 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x - 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaosisvpr.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpaosisvpr.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x => x + 'p').map(x\
    \ => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x + 'l').map(x => x\
    \ + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x => x + 'f').map(x\
    \ => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x + 'b').map(x => x\
    \ + 'a').map(x => x + 'z')\n        val newAlphabet2 = alphabet.map(x => x + 'z').map(x\
    \ => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x\
    \ + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x\
    \ => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x\
    \ + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x\
    \ => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x\
    \ + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z').map(x => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x\
    \ + 'v').map(x => x + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp66pmqb_y.scala:17:202 --------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m).map(\e[36mx\e[0m => x + \e[31m'y'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'x'\e[0m).map(\e[36mx\e[0m => x + \e[31m'w'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'v'\e[0m).map(\e[36mx\e[0m => x + \e[31m'u'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m't'\e[0m).map(\e[36mx\e[0m => x + \e[31m's'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'r'\e[0m).map(\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                            \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp66pmqb_y.scala:18:5 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => (c -> alphabet(alphabet.indexOf(c)\
    \ + 2)))\n        val rotatedString = s.map(c => rotatedAlphabet(c))\n       \
    \ rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmptvrfp8vd.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmptvrfp8vd.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmptvrfp8vd.scala:15)\n\
    \tat Problem$.main(tmptvrfp8vd.scala:20)\n\tat Problem.main(tmptvrfp8vd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 1)\n        val newAlphabet4 = alphabet.map(x => x - 2)\n        val newAlphabet5\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 1)\n        val newAlphabet7 = alphabet.map(x => x - 2)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet9 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet10 = alphabet.map(x => x + 1)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet12 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet13 = alphabet.map(x => x - 2)\n        val newAlphabet14\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet16 = alphabet.map(x => x + 1)\n        val newAlphabet17\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet18 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet19 = alphabet.map(x => x - 2)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet21 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet22 = alphabet.map(x => x + 1)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet24 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet25 = alphabet.map(x => x - 2)\n        val newAlphabet26\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet28 = alphabet.map(x => x + 1)\n        val newAlphabet29\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet30 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet31 = alphabet.map(x => x - 2)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi_kqgqh7.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 2))\n\
    \        val newAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x) - 4))\n\
    \        val newAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 4))\n\
    \        val newAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 6))\n\
    \        val newAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 8))\n\
    \        val newAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 10))\n\
    \        val newAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 12))\n\
    \        val newAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x) + 14))\n\
    \        val newAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x) +\
    \ 16))\n        val newAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 18))\n        val newAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 20))\n        val newAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 22))\n        val newAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 24))\n        val newAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 26))\n        val newAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 28))\n        val newAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 30))\n        val newAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 32))\n        val newAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 34))\n        val newAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 36))\n        val newAlphabet21 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 38))\n        val newAlphabet22 = alphabet.map(x => alphabet\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n\
    \    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt85epizr.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpt85epizr.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedAlphabet2 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val rotatedAlphabet3 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val rotatedAlphabet4 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val rotatedAlphabet5 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val rotatedAlphabet6 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val rotatedAlphabet7 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val rotatedAlphabet8 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val rotatedAlphabet9 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 18))\n        val rotatedAlphabet10 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 20))\n        val rotatedAlphabet11 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 22))\n        val rotatedAlphabet12 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 24))\n        val rotatedAlphabet13 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 26))\n        val rotatedAlphabet14 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 28))\n        val rotatedAlphabet15 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 30))\n        val rotatedAlphabet16 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 32))\n        val rotatedAlphabet17 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 34))\n        val rotatedAlphabet18 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 36))\n        val rotatedAlphabet19 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 38))\n        val rotatedAlphabet20 = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 40))\n        val rotatedAlphabet21 = alphabet.map(x => \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcu5o8svj.scala:35:49 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mrotatedAlphabet21\e[0m =\
    \ alphabet.map(\e[36mx\e[0m => \n\e[31m\e[31m   |\e[0m                       \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcu5o8svj.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797893
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c + 'z').map(c => c + 'y').map(c\
    \ => c + 'x').map(c => c + 'w').map(c => c + 'v').map(c => c + 'u').map(c => c\
    \ + 't').map(c => c + 's').map(c => c + 'r').map(c => c + 'q').map(c => c + 'p').map(c\
    \ => c + 'o').map(c => c + 'n').map(c => c + 'm').map(c => c + 'l').map(c => c\
    \ + 'k').map(c => c + 'j').map(c => c + 'h').map(c => c + 'g').map(c => c + 'f').map(c\
    \ => c + 'e').map(c => c + 'd').map(c => c + 'c').map(c => c + 'b').map(c => c\
    \ + 'a').map(c => c + 'z').map(c => c + 'y').map(c => c + 'x')\n        val rotatedAlphabet2\
    \ = alphabet.map(c => c + 'z').map(c => c + 'y').map(c => c + 'x').map(c => c\
    \ + 'w').map(c => c + 'v').map(c => c + 'u').map(c => c + 't').map(c => c + 's').map(c\
    \ => c + 'r').map(c => c + 'q').map(c => c + 'p').map(c => c + 'o').map(c => c\
    \ + 'n').map(c => c + 'm').map(c => c + 'l').map(c => c + 'k').map(c => c + 'j').map(c\
    \ => c + 'h').map(c => c + 'g').map(c => c + 'f').map(c => c + 'e').map(c => c\
    \ + 'd').map(c => c + 'c').map(c => c + 'b').map(c => c + 'a').map(c => c + 'z').map(c\
    \ => c + 'y').map(c => c + 'x')\n        val rotatedAlphabet3 = alphabet.map(c\
    \ => c + 'z').map(c => c + 'y').map(c => c + 'x').map(c => c + 'w').map(c => c\
    \ + 'v').\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu118utft.scala:18:4 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpu118utft.scala:18:5 ---------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797892
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9w31cbwl.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9w31cbwl.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.map(x => newAlphabet(alphabet.indexOf(x)))\n\
    \        newString.mkString(\"\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp_fwe63mq.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp_fwe63mq.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp_fwe63mq.scala:15)\n\
    \tat Problem$.main(tmp_fwe63mq.scala:20)\n\tat Problem.main(tmp_fwe63mq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val result = new StringBuilder()\n        for(i <- 0\
    \ until s.length)\n            result.append(alphabet(alphabet.indexOf(s.charAt(i))\
    \ + (alphabet.size/2)).toString)\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n\
    \    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3bbb7t0b.scala:21)\n\tat Problem.main(tmp3bbb7t0b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2))).toMap\n        val newString = s.map(x => newAlphabet.getOrElse(x, x))\n\
    \        newString.mkString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpwpuqw77x.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpwpuqw77x.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpwpuqw77x.scala:15)\n\
    \tat Problem$.main(tmpwpuqw77x.scala:20)\n\tat Problem.main(tmpwpuqw77x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphab\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9w31cbwl.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9w31cbwl.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797870
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet10 = List('j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet11 = List('k','l','m','n','\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5msmc5gx.scala:24:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36malphabet11\e[0m = List(\e\
    [31m'k'\e[0m,\e[31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,'\n\e[31m\e[31m   |\e\
    [0m                                              ^\e[0m\n\e[31m   |\e[0m     \
    \                                         unclosed character literal\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5msmc5gx.scala:25:5 ---------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797894
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => c -> alphabet(alphabet.indexOf(c)\
    \ + 2))\n        val rotatedString = s.map(c => rotatedAlphabet(alphabet.indexOf(c))).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpzjep8c69.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpzjep8c69.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpzjep8c69.scala:15)\n\
    \tat Problem$.main(tmpzjep8c69.scala:20)\n\tat Problem.main(tmpzjep8c69.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar).reverse\n       \
    \ val newString = s.toCharArray.zip(newAlphabet).map(x => x._1 + x._2).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpax8j81fq.scala:20)\n\tat Problem.main(tmpax8j81fq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 18))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 20))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 22))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 24))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 26))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 28))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 30))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 32))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 34))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 36))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 38))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphab\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd0y07i53.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd0y07i53.scala:34:60\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mnewAlphabet20\e[0m = alphabet.map(\e[36mx\e[0m => x -> alphabet(alphab\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m                                              \
    \         Not found: alphab\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpd0y07i53.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0b228jat.scala:22:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnewAlphabet8\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,'\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0b228jat.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hlzymis.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3hlzymis.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 8))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 9))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 10))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 11))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 12))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 13))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 14))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 15))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 16))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 17))\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8jfepuiy.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabet9 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwn907o5w.scala:22:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36malphabet9\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,\e[31m's'\e[0m,\e[31m't'\e[0m,\e[31m'u'\e[0m,\e[31m'v\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0msymbol literal 'v is no longer supported,\n\e[31m   |\e[0muse a string literal\
    \ \"v\" or an application Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in\
    \ braces '{v} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can\
    \ also `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe\
    \ idiom, but this possibility might no longer be available in the future.\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn907o5w.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwn907o5w.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet4 = alphabet.map(x => x - 1)\n        val newAlphabet5\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet7 = alphabet.map(x => x - 1)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet9 = alphabet.map(x => x +\
    \ 1)\n        val newAlphabet10 = alphabet.map(x => x - 2)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet12 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet13 = alphabet.map(x => x + 1)\n        val newAlphabet14\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet16 = alphabet.map(x => x + 2)\n        val newAlphabet17\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet18 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet19 = alphabet.map(x => x - 1)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet21 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet22 = alphabet.map(x => x - 2)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet24 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet25 = alphabet.map(x => x + 1)\n        val newAlphabet26\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet28 = alphabet.map(x => x + 2)\n        val newAlphabet29\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet30 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet31 = alphabet.map(x => x - 1)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2iqyecry.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet4 = alphabet.map(x => x - 1)\n        val newAlphabet5\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 2)\n        val newAlphabet7 = alphabet.map(x => x - 1)\n        val newAlphabet8\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet9 = alphabet.map(x => x +\
    \ 1)\n        val newAlphabet10 = alphabet.map(x => x - 2)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet12 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet13 = alphabet.map(x => x + 1)\n        val newAlphabet14\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet16 = alphabet.map(x => x + 2)\n        val newAlphabet17\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet18 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet19 = alphabet.map(x => x - 1)\n        val newAlphabet20\
    \ = alphabet.map(x => x + 2)\n        val newAlphabet21 = alphabet.map(x => x\
    \ + 1)\n        val newAlphabet22 = alphabet.map(x => x - 2)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 1)\n        val newAlphabet24 = alphabet.map(x => x\
    \ + 2)\n        val newAlphabet25 = alphabet.map(x => x + 1)\n        val newAlphabet26\
    \ = alphabet.map(x => x - 2)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 1)\n        val newAlphabet28 = alphabet.map(x => x + 2)\n        val newAlphabet29\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet30 = alphabet.map(x => x\
    \ - 2)\n        val newAlphabet31 = alphabet.map(x => x - 1)\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2iqyecry.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = newAlphabet.map(x => (x - 2).toChar)\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = newAlphabet3.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = newAlphabet4.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet6 = newAlphabet5.map(x => (x - 2).toChar)\n        val newAlphabet7\
    \ = newAlphabet6.map(x => (x - 2).toChar)\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet9 = newAlphabet8.map(x => (x - 2).toChar)\n\
    \        val newAlphabet10 = newAlphabet9.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet11 = newAlphabet10.map(x => (x - 2).toChar)\n        val newAlphabet12\
    \ = newAlphabet11.map(x => (x - 2).toChar)\n        val newAlphabet13 = newAlphabet12.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet14 = newAlphabet13.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet15 = newAlphabet14.map(x => (x - 2).toChar)\n\
    \        val newAlphabet16 = newAlphabet15.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet17 = newAlphabet16.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = newAlphabet17.map(x => (x - 2).toChar)\n        val newAlphabet19 = newAlphabet18.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = newAlphabet19.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet21 = newAlphabet20.map(x => (x - 2).toChar)\n\
    \        val newAlphabet22 = newAlphabet21.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet23 = newAlphabet22.map(x => (x - 2).toChar)\n        val newAlphabet24\
    \ = newAlphabet23.map(x => (x - 2).toChar)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8iuxn9d.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x.toUpperCase).reverse\n        val\
    \ newAlphabet2 = newAlphabet.map(x => x.toUpperCase).reverse\n        val newAlphabet3\
    \ = newAlphabet2.map(x => x.toUpperCase).reverse\n        val newAlphabet4 = newAlphabet3.map(x\
    \ => x.toUpperCase).reverse\n        val newAlphabet5 = newAlphabet4.map(x =>\
    \ x.toUpperCase).reverse\n        val newAlphabet6 = newAlphabet5.map(x => x.toUpperCase).reverse\n\
    \        val newAlphabet7 = newAlphabet6.map(x => x.toUpperCase).reverse\n   \
    \     val newAlphabet8 = newAlphabet7.map(x => x.toUpperCase).reverse\n      \
    \  val newAlphabet9 = newAlphabet8.map(x => x.toUpperCase).reverse\n        val\
    \ newAlphabet10 = newAlphabet9.map(x => x.toUpperCase).reverse\n        val newAlphabet11\
    \ = newAlphabet10.map(x => x.toUpperCase).reverse\n        val newAlphabet12 =\
    \ newAlphabet11.map(x => x.toUpperCase).reverse\n        val newAlphabet13 = newAlphabet12.map(x\
    \ => x.toUpperCase).reverse\n        val newAlphabet14 = newAlphabet13.map(x =>\
    \ x.toUpperCase).reverse\n        val newAlphabet15 = newAlphabet14.map(x => x.toUpperCase).reverse\n\
    \        val newAlphabet16 = newAlphabet15.map(x => x.toUpperCase).reverse\n \
    \       val newAlphabet17 = newAlphabet16.map(x => x.toUpperCase).reverse\n  \
    \      val newAlphabet18 = newAlphabet17.map(x => x.toUpperCase).reverse\n   \
    \     val newAlphabet19 = newAlphabet18.map(x => x.toUpperCase).reverse\n    \
    \    val newAlphabet20 = newAlphabet19.map(x => x.toUpperCase).reverse\n     \
    \   val newAlphabet21 = newAlphabet20.map(x => x.toUpperCase).reverse\n      \
    \  val newAlphabet22 = newAlphabet21.map(x => x.toUpperCase).reverse\n       \
    \ val newAlphabet23 = newAlphabet22.map(x => x.toUpperCase).reverse\n        val\
    \ newAlphabet24 = newAlphabet23.map(x => x.toUpperCase).reverse\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\"\
    )));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw33rkjzv.scala:15:46 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet\e[0m = alphabet.map(\e\
    [36mx\e[0m => x.toUpperCase).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpw33rkjzv.scala:16:50 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet2\e[0m = newAlphabet.map(\e\
    [36mx\e[0m => x.toUpperCase).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                 value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw33rkjzv.scala:17:51 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = newAlphabet2.map(\e\
    [36mx\e[0m => x.toUpperCase).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                  value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw33rkjzv.scala:18:51 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet4\e[0m = newAlphabet3.map(\e\
    [36mx\e[0m => x.toUpperCase).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                  value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw33rkjzv.scala:19:51 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet5\e[0m = newAlphabet4.map(\e\
    [36mx\e[0m => x.toUpperCase).reverse\n\e[31m\e[31m   |\e[0m                  \
    \                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                  value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpw33rkjzv.scala:20:51 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet6"
  stdout: ''
  timestamp: 1659797896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet2 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet3 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet4 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet5 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet6 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet7 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet8 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet9 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet10 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet11 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet12 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet13 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet14 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet15 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet16 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet17 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet18 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet19 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet20 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpodj50cze.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpodj50cze.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val newAlphabet2\
    \ = newAlphabet.map(x => x + 'z' - 'a')\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet4 = newAlphabet3.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet5 = newAlphabet4.map(x => x + 'z' - 'a')\n  \
    \      val newAlphabet6 = newAlphabet5.map(x => x + 'z' - 'a')\n        val newAlphabet7\
    \ = newAlphabet6.map(x => x + 'z' - 'a')\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet9 = newAlphabet8.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet10 = newAlphabet9.map(x => x + 'z' - 'a')\n \
    \       val newAlphabet11 = newAlphabet10.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet12 = newAlphabet11.map(x => x + 'z' - 'a')\n        val newAlphabet13\
    \ = newAlphabet12.map(x => x + 'z' - 'a')\n        val newAlphabet14 = newAlphabet13.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet15 = newAlphabet14.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet16 = newAlphabet15.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet17 = newAlphabet16.map(x => x + 'z' - 'a')\n        val\
    \ newAlphabet18 = newAlphabet17.map(x => x + 'z' - 'a')\n        val newAlphabet19\
    \ = newAlphabet18.map(x => x + 'z' - 'a')\n        val newAlphabet20 = newAlphabet19.map(x\
    \ => x + 'z' - 'a')\n        val newAlphabet21 = newAlphabet20.map(x => x + 'z'\
    \ - 'a')\n        val newAlphabet22 = newAlphabet21.map(x => x + 'z' - 'a')\n\
    \        val newAlphabet23 = newAlphabet22.map(x => x + 'z\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphz7w0all.scala:37:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                                ^\e[0m\n\e[31m   |\e[0msymbol literal 'z is no\
    \ longer supported,\n\e[31m   |\e[0muse a string literal \"z\" or an application\
    \ Symbol(\"z\") instead,\n\e[31m   |\e[0mor enclose in braces '{z} if you want\
    \ a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphz7w0all.scala:38:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmphz7w0all.scala:37:53 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet23\e[0m = newAlphabet22.map(\e\
    [36mx\e[0m => x + \e[31m'z\e[0m\n\e[31m\e[31m   |\e[0m                       \
    \                            ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float):\
    \ Float\n\e[31m   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e\
    [31m   |\e[0m  (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e\
    [0m  (x: Byte): Int\n\e[31m   |\e[0m  (x: String): String\n\e[31m   |\e[0m match\
    \ arguments (Symbol)\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphz7w0all.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659797860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0b228jat.scala:22:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnewAlphabet8\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,'\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0b228jat.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 20))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 22))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 24))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 26))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 28))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 30))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 32))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 34))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 36))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptnjv1j9m.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptnjv1j9m.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        var alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet2 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet3 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet4 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet5 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet6 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet7 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        var newAlphabet8 = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0b228jat.scala:22:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mnewAlphabet8\e[0m = List(\e\
    [31m'a'\e[0m,\e[31m'b'\e[0m,\e[31m'c'\e[0m,\e[31m'd'\e[0m,\e[31m'e'\e[0m,\e[31m'f'\e\
    [0m,\e[31m'g'\e[0m,\e[31m'h'\e[0m,\e[31m'i'\e[0m,\e[31m'j'\e[0m,\e[31m'k'\e[0m,\e\
    [31m'l'\e[0m,\e[31m'm'\e[0m,\e[31m'n'\e[0m,\e[31m'o'\e[0m,\e[31m'p'\e[0m,\e[31m'q'\e\
    [0m,\e[31m'r'\e[0m,'\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                              unclosed character\
    \ literal\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0b228jat.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newString = s.toCharArray.map(x => newAlphabet(alphabet.indexOf(x)).apply(x))\n\
    \        new String(newString)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpicz0s3yh.scala:16:24\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnewString\e\
    [0m = s.toCharArray.map(\e[36mx\e[0m => newAlphabet(alphabet.indexOf(x)).apply(x))\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Array[\n\e[31m   |\e[0m   \
    \                    (?1 : Int)\e[33m match \e[0m{\n\e[31m   |\e[0m          \
    \               case (\e[31m0\e[0m : Int) => Char\n\e[31m   |\e[0m           \
    \              case scala.compiletime.ops.int.S[n1] => \n\e[31m   |\e[0m     \
    \                      scala.Tuple.Elem[Char *: EmptyTuple.type, n1]\n\e[31m \
    \  |\e[0m                       }\n\e[31m   |\e[0m                     ]\n\e[31m\
    \   |\e[0m                     Required: Array[Any]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                     where:    ?\e[31m1\e[0m is an unknown value of type\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpicz0s3yh.scala:17:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mnew\e\
    [0m \e[35mString\e[0m(newString)\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mconstructor\e[0m \e\
    [35mString\e[0m in \e[33mclass\e[0m \e[35mString\e[0m with types\n\e[31m   |\e\
    [0m (x$0: StringBuilder): String\n\e[31m   |\e[0m (x$0: StringBuffer): String\n\
    \e[31m   |\e[0m (x$0: Array[Byte]): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e\
    [0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\
    \e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1:\
    \ Int, x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int,"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 8))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 9))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 10))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 11))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 12))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 13))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 14))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 15))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 16))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 17))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 18\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\"\
    )).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4xn6qbhz.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4xn6qbhz.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.map(x => x._1 + x._2).mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpmi7vdins.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpmi7vdins.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpmi7vdins.scala:15)\n\
    \tat Problem$.main(tmpmi7vdins.scala:20)\n\tat Problem.main(tmpmi7vdins.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetShift = alphabet.length/2\n\
    \        val alphabetShift2 = alphabet.length/2\n        val alphabetShift3 =\
    \ alphabet.length/2\n        val alphabetShift4 = alphabet.length/2\n        val\
    \ alphabetShift5 = alphabet.length/2\n        val alphabetShift6 = alphabet.length/2\n\
    \        val alphabetShift7 = alphabet.length/2\n        val alphabetShift8 =\
    \ alphabet.length/2\n        val alphabetShift9 = alphabet.length/2\n        val\
    \ alphabetShift10 = alphabet.length/2\n        val alphabetShift11 = alphabet.length/2\n\
    \        val alphabetShift12 = alphabet.length/2\n        val alphabetShift13\
    \ = alphabet.length/2\n        val alphabetShift14 = alphabet.length/2\n     \
    \   val alphabetShift15 = alphabet.length/2\n        val alphabetShift16 = alphabet.length/2\n\
    \        val alphabetShift17 = alphabet.length/2\n        val alphabetShift18\
    \ = alphabet.length/2\n        val alphabetShift19 = alphabet.length/2\n     \
    \   val alphabetShift20 = alphabet.length/2\n        val alphabetShift21 = alphabet.length/2\n\
    \        val alphabetShift22 = alphabet.length/2\n        val alphabetShift23\
    \ = alphabet.length/2\n        val alphabetShift24 = alphabet.length/2\n     \
    \   val alphabetShift25 = alphabet.length/2\n        val alphabetShift26 = alphabet.length/2\n\
    \        val alphabetShift27 = alphabet.length/2\n        val alphabetShift28\
    \ = alphabet.length/2\n        val alphabetShift29 = alphabet.length/2\n     \
    \   val alphabetShift30 = alphabet.length/2\n        val alphabetShift31 = alphabet.length/2\n\
    \        val alphabetShift32 = alphabet.length/2\n        val alphabetShift33\
    \ = alphabet.length/2\n        val alphabetShift34 = alphabet.length/2\n     \
    \   val alphabetShift35 = alphabet.length/2\n        val alphabetShift36 = alphabet.length/2\n\
    \        val alphabetShift37 = alphabet.length/2\n        val alphabetShift38\
    \ = alphabet.length/2\n        val alphabetShift39 = alphabet.length/2\n     \
    \   val alphabetShift40 = alphabet.length/2\n        val alphabetShift41 = alphabet.length/2\n\
    \        val alphabetShift42 = alphabet.length/2\n        val alphabetShift43\
    \ = alphabet.length/2\n        val alphabetShift44 = alphabet.length/2\n     \
    \   val alphabetShift45 = alphabet.length/2\n        val alphabetShift46 = alphabet.length/2\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg2ib96_l.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797895
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = newAlphabet.map(x => (x - 2).toChar)\n        val newAlphabet3 = newAlphabet2.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = newAlphabet3.map(x => (x - 2).toChar)\n\
    \        val newAlphabet5 = newAlphabet4.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet6 = newAlphabet5.map(x => (x - 2).toChar)\n        val newAlphabet7\
    \ = newAlphabet6.map(x => (x - 2).toChar)\n        val newAlphabet8 = newAlphabet7.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet9 = newAlphabet8.map(x => (x - 2).toChar)\n\
    \        val newAlphabet10 = newAlphabet9.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet11 = newAlphabet10.map(x => (x - 2).toChar)\n        val newAlphabet12\
    \ = newAlphabet11.map(x => (x - 2).toChar)\n        val newAlphabet13 = newAlphabet12.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet14 = newAlphabet13.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet15 = newAlphabet14.map(x => (x - 2).toChar)\n\
    \        val newAlphabet16 = newAlphabet15.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet17 = newAlphabet16.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = newAlphabet17.map(x => (x - 2).toChar)\n        val newAlphabet19 = newAlphabet18.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = newAlphabet19.map(x => (x -\
    \ 2).toChar)\n        val newAlphabet21 = newAlphabet20.map(x => (x - 2).toChar)\n\
    \        val newAlphabet22 = newAlphabet21.map(x => (x - 2).toChar)\n        val\
    \ newAlphabet23 = newAlphabet22.map(x => (x - 2).toChar)\n        val newAlphabet24\
    \ = newAlphabet23.map(x => (x - 2).toChar)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn8iuxn9d.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        new String(rotatedString)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp9olgtjl9.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp9olgtjl9.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp9olgtjl9.scala:15)\n\
    \tat Problem$.main(tmp9olgtjl9.scala:20)\n\tat Problem.main(tmp9olgtjl9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797885
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x) + 2))\n\
    \        val newString = s.toCharArray.map(x => newAlphabet(alphabet.indexOf(x)\
    \ + 2))\n        new String(newString)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpgdeeg5r5.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpgdeeg5r5.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpgdeeg5r5.scala:15)\n\
    \tat Problem$.main(tmpgdeeg5r5.scala:20)\n\tat Problem.main(tmpgdeeg5r5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x => x + 'p').map(x\
    \ => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x + 'l').map(x => x\
    \ + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x => x + 'f').map(x\
    \ => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x + 'b').map(x => x\
    \ + 'a').map(x => x + 'z')\n        val newAlphabet2 = alphabet.map(x => x + 'z').map(x\
    \ => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x\
    \ + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x\
    \ => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x\
    \ + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'h').map(x => x + 'g').map(x\
    \ => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x\
    \ + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newAlphabet3 = alphabet.map(x\
    \ => x + 'z').map(x => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x\
    \ + 'v').map(x => x + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp66pmqb_y.scala:17:202 --------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m).map(\e[36mx\e[0m => x + \e[31m'y'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'x'\e[0m).map(\e[36mx\e[0m => x + \e[31m'w'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'v'\e[0m).map(\e[36mx\e[0m => x + \e[31m'u'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m't'\e[0m).map(\e[36mx\e[0m => x + \e[31m's'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'r'\e[0m).map(\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                            \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp66pmqb_y.scala:18:5 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 0))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 0))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 3))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 3))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 4))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 4))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 5))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 5))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 6))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 6))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 7))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 7))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3hlzymis.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3hlzymis.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(x => x + 's').map(x => x + 'r').map(x => x + 'q').map(x => x + 'p').map(x\
    \ => x + 'o').map(x => x + 'n').map(x => x + 'm').map(x => x + 'l').map(x => x\
    \ + 'k').map(x => x + 'j').map(x => x + 'i').map(x => x + 'h').map(x => x + 'g').map(x\
    \ => x + 'f').map(x => x + 'e').map(x => x + 'd').map(x => x + 'c').map(x => x\
    \ + 'b').map(x => x + 'a').map(x => x + 'z')\n        val newAlphabet2 = alphabet.map(x\
    \ => x + 'z').map(x => x + 'y').map(x => x + 'x').map(x => x + 'w').map(x => x\
    \ + 'v').map(x => x + 'u').map(x => x + 't').map(x => x + 's').map(x => x + 'r').map(x\
    \ => x + 'q').map(x => x + 'p').map(x => x + 'o').map(x => x + 'n').map(x => x\
    \ + 'm').map(x => x + 'l').map(x => x + 'k').map(x => x + 'j').map(x => x + 'i').map(x\
    \ => x + 'h').map(x => x + 'g').map(x => x + 'f').map(x => x + 'e').map(x => x\
    \ + 'd').map(x => x + 'c').map(x => x + 'b').map(x => x + 'a').map(x => x + 'z')\n\
    \        val newAlphabet3 = alphabet.map(x => x + 'z').map(x => x + 'y').map(x\
    \ => x + 'x').map(x => x + 'w').map(x => x + 'v').map(x => x + 'u').map(x => x\
    \ + 't').map(\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpq4p5z7v0.scala:17:166 --------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet3\e[0m = alphabet.map(\e\
    [36mx\e[0m => x + \e[31m'z'\e[0m).map(\e[36mx\e[0m => x + \e[31m'y'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'x'\e[0m).map(\e[36mx\e[0m => x + \e[31m'w'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m'v'\e[0m).map(\e[36mx\e[0m => x + \e[31m'u'\e[0m).map(\e\
    [36mx\e[0m => x + \e[31m't'\e[0m).map(\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpq4p5z7v0.scala:18:5 ---------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797871
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet2\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet3 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet4 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet5 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet6\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet7 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet8 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet9 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet10\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet11 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet12 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet13 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet14\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet15 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet16 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet17 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet18\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet19 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet20 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet21 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet22\
    \ = alphabet.map(x => (x + 2).toChar)\n        val newAlphabet23 = alphabet.map(x\
    \ => (x - 2).toChar)\n        val newAlphabet24 = alphabet.map(x => (x + 2).toChar)\n\
    \        val newAlphabet25 = alphabet.map(x => (x - 2).toChar)\n        val newAlphabet26\
    \ = alphabet.map(x => (x + 2).toChar\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqwmg3a4.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvqwmg3a4.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(c => (c + 'z').toChar)\n        val\
    \ rotatedAlphabet2 = rotatedAlphabet.map(c => (c + 'y').toChar)\n        val rotatedAlphabet3\
    \ = rotatedAlphabet2.map(c => (c + 'x').toChar)\n        val rotatedAlphabet4\
    \ = rotatedAlphabet3.map(c => (c + 'w').toChar)\n        val rotatedAlphabet5\
    \ = rotatedAlphabet4.map(c => (c + 'v').toChar)\n        val rotatedAlphabet6\
    \ = rotatedAlphabet5.map(c => (c + 'u').toChar)\n        val rotatedAlphabet7\
    \ = rotatedAlphabet6.map(c => (c + 't').toChar)\n        val rotatedAlphabet8\
    \ = rotatedAlphabet7.map(c => (c + 's').toChar)\n        val rotatedAlphabet9\
    \ = rotatedAlphabet8.map(c => (c + 'r').toChar)\n        val rotatedAlphabet10\
    \ = rotatedAlphabet9.map(c => (c + 'q').toChar)\n        val rotatedAlphabet11\
    \ = rotatedAlphabet10.map(c => (c + 'p').toChar)\n        val rotatedAlphabet12\
    \ = rotatedAlphabet11.map(c => (c + 'o').toChar)\n        val rotatedAlphabet13\
    \ = rotatedAlphabet12.map(c => (c + 'n').toChar)\n        val rotatedAlphabet14\
    \ = rotatedAlphabet13.map(c => (c + 'm').toChar)\n        val rotatedAlphabet15\
    \ = rotatedAlphabet14.map(c => (c + 'l').toChar)\n        val rotatedAlphabet16\
    \ = rotatedAlphabet15.map(c => (c + 'k').toChar)\n        val rotatedAlphabet17\
    \ = rotatedAlphabet16.map(c => (c + 'j').toChar)\n        val rotatedAlphabet18\
    \ = rotatedAlphabet17.map(c => (c + 'i').toChar)\n        val rotatedAlphabet19\
    \ = rotatedAlphabet18.map(c => (c + 'h').toChar)\n        val rotatedAlphabet20\
    \ = rotatedAlphabet19.map(\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdsnl7x0q.scala:34:54 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mrotatedAlphabet20\e[0m =\
    \ rotatedAlphabet19.map(\n\e[31m\e[31m   |\e[0m                              \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \          expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpdsnl7x0q.scala:35:5 ---------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        val newAlphabet2 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 2)))\n        val newAlphabet3 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 4)))\n        val newAlphabet4 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 4)))\n        val newAlphabet5 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 8)))\n        val newAlphabet6 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 8)))\n        val newAlphabet7 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 12)))\n        val newAlphabet8 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 12)))\n        val newAlphabet9 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 16)))\n        val newAlphabet10 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 16)))\n        val newAlphabet11 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 20)))\n        val newAlphabet12 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 20)))\n        val newAlphabet13 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 24)))\n        val newAlphabet14 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 24)))\n        val newAlphabet15 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 28)))\n        val newAlphabet16 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 28)))\n        val newAlphabet17 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 32)))\n        val newAlphabet18 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ - 32)))\n        val newAlphabet19 = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 36)))\n        val newAlphabet20 = alphabet.map(x => (\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiw_s1fc7.scala:34:47 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet20\e[0m = alphabet.map(\e\
    [36mx\e[0m => (\n\e[31m\e[31m   |\e[0m                                       \
    \        ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpiw_s1fc7.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2))).toMap\n        val newString = s.toCharArray.map(x => newAlphabet(x)).mkString\n\
    \        newString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp2pg2tu6o.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp2pg2tu6o.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp2pg2tu6o.scala:15)\n\
    \tat Problem$.main(tmp2pg2tu6o.scala:20)\n\tat Problem.main(tmp2pg2tu6o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => (x -> alphabet(alphabet.indexOf(x)\
    \ + 2))).toMap\n        val rotatedString = s.map(x => rotatedAlphabet(x)).mkString\n\
    \        rotatedString\n    }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"\
    hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\"\
    )));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n    assert(encrypt((\"\
    et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\")).equals((\"\
    jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"lippsqcjvmirh\"\
    )));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")).equals((\"\
    hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"a\"\
    )).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpxrlr9f9b.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpxrlr9f9b.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpxrlr9f9b.scala:15)\n\
    \tat Problem$.main(tmpxrlr9f9b.scala:20)\n\tat Problem.main(tmpxrlr9f9b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet2 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet3 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet4 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet5 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet6 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet7 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet8 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet9 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet10 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet11 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet12 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet13 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet14 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet15 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet16 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet17 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val newAlphabet18 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 2))\n        val newAlphabet19 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ + 1))\n        val newAlphabet20 = alphabet.map(x => x -> alphabet(alphabet.indexOf(x)\
    \ - 1))\n        val newAlphabet2\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpokc7i992.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpokc7i992.scala:36:5 ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        rotatedString.mkString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpprksimlt.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmpprksimlt.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmpprksimlt.scala:15)\n\
    \tat Problem$.main(tmpprksimlt.scala:20)\n\tat Problem.main(tmpprksimlt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797848
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z')\n        val rotatedAlphabet = alphabet.map(x => alphabet(alphabet.indexOf(x)\
    \ + 2))\n        val rotatedString = s.toCharArray.map(x => rotatedAlphabet(alphabet.indexOf(x)))\n\
    \        new String(rotatedString)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"asdfghjkl\"\
    )).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"kj\")));\n\
    \    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"faewfawefaewg\"\
    )).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\")).equals((\"\
    lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 26\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp2a0f9kth.scala:15)\n\tat Problem$.$anonfun$adapted$1(tmp2a0f9kth.scala:15)\n\
    \tat scala.collection.immutable.List.map(List.scala:250)\n\tat Problem$.encrypt(tmp2a0f9kth.scala:15)\n\
    \tat Problem$.main(tmp2a0f9kth.scala:20)\n\tat Problem.main(tmp2a0f9kth.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val rotatedAlphabet = alphabet.map(x => x + 'z' - 'a')\n        val rotatedAlphabet2\
    \ = rotatedAlphabet.map(x => x + 'z' - 'a')\n        val rotatedAlphabet3 = rotatedAlphabet2.map(x\
    \ => x + 'z' - 'a')\n        val rotatedAlphabet4 = rotatedAlphabet3.map(x =>\
    \ x + 'z' - 'a')\n        val rotatedAlphabet5 = rotatedAlphabet4.map(x => x +\
    \ 'z' - 'a')\n        val rotatedAlphabet6 = rotatedAlphabet5.map(x => x + 'z'\
    \ - 'a')\n        val rotatedAlphabet7 = rotatedAlphabet6.map(x => x + 'z' - 'a')\n\
    \        val rotatedAlphabet8 = rotatedAlphabet7.map(x => x + 'z' - 'a')\n   \
    \     val rotatedAlphabet9 = rotatedAlphabet8.map(x => x + 'z' - 'a')\n      \
    \  val rotatedAlphabet10 = rotatedAlphabet9.map(x => x + 'z' - 'a')\n        val\
    \ rotatedAlphabet11 = rotatedAlphabet10.map(x => x + 'z' - 'a')\n        val rotatedAlphabet12\
    \ = rotatedAlphabet11.map(x => x + 'z' - 'a')\n        val rotatedAlphabet13 =\
    \ rotatedAlphabet12.map(x => x + 'z' - 'a')\n        val rotatedAlphabet14 = rotatedAlphabet13.map(x\
    \ => x + 'z' - 'a')\n        val rotatedAlphabet15 = rotatedAlphabet14.map(x =>\
    \ x + 'z' - 'a')\n        val rotatedAlphabet16 = rotatedAlphabet15.map(x => x\
    \ + 'z' - 'a')\n        val rotatedAlphabet17 = rotatedAlphabet16.map(x => x +\
    \ 'z' - 'a')\n        val rotatedAlphabet18 = rotatedAlphabet17.map(x => x + 'z'\
    \ - 'a')\n        val rotatedAlphabet19 = rotatedAlphabet18.map(x => x + 'z' -\
    \ 'a')\n        val rotatedAlphabet20 = rotatedAlphabet19.map(x => x + 'z' - 'a')\n\
    \        val rotatedAlphabet21 = rotated\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeqpy1l12.scala:35:32 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mrotatedAlphabet21\e[0m =\
    \ rotated\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                Not found: rotated\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeqpy1l12.scala:36:5 ---------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val alphabetLength = alphabet.length\n        val alphabetShift = alphabet.length\
    \ * 2\n        val alphabetShift2 = alphabet.length * 3\n        val alphabetShift3\
    \ = alphabet.length * 4\n        val alphabetShift4 = alphabet.length * 5\n  \
    \      val alphabetShift5 = alphabet.length * 6\n        val alphabetShift6 =\
    \ alphabet.length * 7\n        val alphabetShift7 = alphabet.length * 8\n    \
    \    val alphabetShift8 = alphabet.length * 9\n        val alphabetShift9 = alphabet.length\
    \ * 10\n        val alphabetShift10 = alphabet.length * 11\n        val alphabetShift11\
    \ = alphabet.length * 12\n        val alphabetShift12 = alphabet.length * 13\n\
    \        val alphabetShift13 = alphabet.length * 14\n        val alphabetShift14\
    \ = alphabet.length * 15\n        val alphabetShift15 = alphabet.length * 16\n\
    \        val alphabetShift16 = alphabet.length * 17\n        val alphabetShift17\
    \ = alphabet.length * 18\n        val alphabetShift18 = alphabet.length * 19\n\
    \        val alphabetShift19 = alphabet.length * 20\n        val alphabetShift20\
    \ = alphabet.length * 21\n        val alphabetShift21 = alphabet.length * 22\n\
    \        val alphabetShift22 = alphabet.length * 23\n        val alphabetShift23\
    \ = alphabet.length * 24\n        val alphabetShift24 = alphabet.length * 25\n\
    \        val alphabetShift25 = alphabet.length * 26\n        val alphabetShift26\
    \ = alphabet.length * 27\n        val alphabetShift27 = alphabet.length * 28\n\
    \        val alphabetShift28 = alphabet.length * 29\n        val alphabetShift29\
    \ = alphabet.length * 30\n        val alphabetShift30 = alphabet.length * 31\n\
    \        val alphabetShift31 = alphabet.length * 32\n        val alphabetShift32\
    \ = alphabet.length * 33\n        val alphabetShift33 = alphabet.length * 34\n\
    \        val alphabetShift34 = alphabet.length * 35\n        val alphabetShift35\
    \ = alphabet.length * 36\n        val alphabetShift36 = alphabet.length * 37\n\
    \        val alphabetShift37 = alphabet.length * 38\n        val alphabetShift38\
    \ = alphabet.length * 39\n        val alphabetShift39 = alphabet.length * 40\n\
    \        val alphabetShift40 = alphabet.length * 41\n        val alphabetShift41\
    \ = alphabet.length * 42\n        val alphabetShift42 = alphabet.length * \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"\
    lm\")));\n    assert(encrypt((\"asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"\
    gf\")).equals((\"kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n \
    \   assert(encrypt((\"faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"\
    hellomyfriend\")).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp17fe3gdd.scala:57:47 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36malphabetShift42\e[0m = alphabet.length\
    \ * \n\e[31m\e[31m   |\e[0m                                               ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp17fe3gdd.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function encrypt that takes a string as an argument and\n\
    \    // returns a string encrypted with the alphabet being rotated. \n    // The\
    \ alphabet should be rotated in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    // For example:\n    // encrypt('hi')\
    \ returns 'lm'\n    // encrypt('asdfghjkl') returns 'ewhjklnop'\n    // encrypt('gf')\
    \ returns 'kj'\n    // encrypt('et') returns 'ix'\n    def encrypt(s : String)\
    \ : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val newAlphabet = alphabet.map(x => x + 2)\n        val newAlphabet2\
    \ = alphabet.map(x => x + 1)\n        val newAlphabet3 = alphabet.map(x => x -\
    \ 1)\n        val newAlphabet4 = alphabet.map(x => x - 2)\n        val newAlphabet5\
    \ = alphabet.map(x => x - 3)\n        val newAlphabet6 = alphabet.map(x => x -\
    \ 4)\n        val newAlphabet7 = alphabet.map(x => x - 5)\n        val newAlphabet8\
    \ = alphabet.map(x => x - 6)\n        val newAlphabet9 = alphabet.map(x => x -\
    \ 7)\n        val newAlphabet10 = alphabet.map(x => x - 8)\n        val newAlphabet11\
    \ = alphabet.map(x => x - 9)\n        val newAlphabet12 = alphabet.map(x => x\
    \ - 10)\n        val newAlphabet13 = alphabet.map(x => x - 11)\n        val newAlphabet14\
    \ = alphabet.map(x => x - 12)\n        val newAlphabet15 = alphabet.map(x => x\
    \ - 13)\n        val newAlphabet16 = alphabet.map(x => x - 14)\n        val newAlphabet17\
    \ = alphabet.map(x => x - 15)\n        val newAlphabet18 = alphabet.map(x => x\
    \ - 16)\n        val newAlphabet19 = alphabet.map(x => x - 17)\n        val newAlphabet20\
    \ = alphabet.map(x => x - 18)\n        val newAlphabet21 = alphabet.map(x => x\
    \ - 19)\n        val newAlphabet22 = alphabet.map(x => x - 20)\n        val newAlphabet23\
    \ = alphabet.map(x => x - 21)\n        val newAlphabet24 = alphabet.map(x => x\
    \ - 22)\n        val newAlphabet25 = alphabet.map(x => x - 23)\n        val newAlphabet26\
    \ = alphabet.map(x => x - 24)\n        val newAlphabet27 = alphabet.map(x => x\
    \ - 25)\n        val newAlphabet28 = alphabet.map(x => x - 26)\n        val newAlphabet29\
    \ = alphabet.map(x => x - 27)\n        val newAlphabet30 = alphabet.map(x => x\
    \ - 28)\n        val newAlphabet31 = alphabet.map(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encrypt((\"hi\")).equals((\"lm\")));\n    assert(encrypt((\"\
    asdfghjkl\")).equals((\"ewhjklnop\")));\n    assert(encrypt((\"gf\")).equals((\"\
    kj\")));\n    assert(encrypt((\"et\")).equals((\"ix\")));\n    assert(encrypt((\"\
    faewfawefaewg\")).equals((\"jeiajeaijeiak\")));\n    assert(encrypt((\"hellomyfriend\"\
    )).equals((\"lippsqcjvmirh\")));\n    assert(encrypt((\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )).equals((\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")));\n    assert(encrypt((\"\
    a\")).equals((\"e\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp32b52f86.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp32b52f86.scala:45:41\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e\
    [36mnewAlphabet31\e[0m = alphabet.map(x \n\e[31m\e[31m   |\e[0m              \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \               Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp32b52f86.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659797899
