language: scala
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        val closestInt = math.round(closest)\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1twsjvze.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1twsjvze.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\".\").map(_.toInt)\n        val min = math.min(nums)\n        val\
    \ max = math.max(nums)\n        val diff = max - min\n        if (diff == 0) min\
    \ else min + diff\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu08gpod5.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu08gpod5.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into two parts\n        val part1 = parts(0).toLong\
    \ // First part is integer\n        val part2 = parts(1).toLong // Second part\
    \ is fraction\n        val difference = part1 - part2 // Difference between first\
    \ and second part\n        if (difference < 0)\n            part1 + difference\n\
    \        else\n            part1 - difference\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpky9kq5de.scala:20)\n\tat Problem$.main(tmpky9kq5de.scala:28)\n\
    \tat Problem.main(tmpky9kq5de.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        if (diff < 1)\
    \ {\n            val roundTo = diff / 2\n            min + roundTo\n        }\
    \ else {\n            val roundTo = diff / 2\n            max - roundTo\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpra1lmhxa.scala:32)\n\tat Problem.main(tmpra1lmhxa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val roundTowardZero = difference < 0\n        val roundAwayFromZero =\
    \ difference > 0\n        val roundTowardZeroOrAwayFromZero = roundTowardZero\
    \ || roundAwayFromZero\n        if (roundTowardZeroOrAwayFromZero) {\n       \
    \     math.round(largest - smallest)\n        } else {\n            math.round(smallest\
    \ + difference)\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0t5maci4.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0t5maci4.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.abs(nums(0)\
    \ - nums(1))\n        val closestNum = nums.minBy(math.abs)\n        val diff\
    \ = Math.abs(closestNum - nums(0))\n        if (diff < minDiff) {\n          \
    \  closestNum\n        } else {\n            closestNum - diff\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmphxdnv4gm.scala:19)\n\tat Problem$.main(tmphxdnv4gm.scala:29)\n\
    \tat Problem.main(tmphxdnv4gm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val diff = (largest - smallest).toInt\n\
    \        val closest = (smallest + diff) / 2\n        closest.toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpd5fpan5a.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpd5fpan5a.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closest = (largest + smallest) / 2\n        if (difference < smallest)\
    \ {\n            closest\n        } else {\n            math.round(closest)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc6s_x_4o.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc6s_x_4o.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val mid = math.round(min + (max - min)\
    \ / 2)\n        val diff = (mid - min).abs()\n        if (diff < 0.5) {\n    \
    \        mid\n        } else {\n            math.round(mid - diff)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgky1gvpe.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgky1gvpe.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val difference = abs(intValue - intValue)\n        val\
    \ closestInteger = intValue + difference\n        closestInteger\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp675u0w85.scala:18)\n\
    \tat Problem$.main(tmp675u0w85.scala:25)\n\tat Problem.main(tmp675u0w85.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDiff = intArraySum - intArray(0)\n        val intArrayDiffSquared\
    \ = intArrayDiff*intArrayDiff\n        val intArrayDiffSquaredLength = intArrayDiffSquared.length\n\
    \        val intArrayDiffSquaredSum = intArrayDiffSquared.sum\n        val intArrayDiffSquaredDiff\
    \ = intArrayDiffSquaredSum - intArrayDiffSquared(0)\n        val intArrayDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiff*intArrayDiffSquaredDiff\n        val intArrayDiffSquaredDiffSquaredLength\
    \ = intArrayDiffSquaredDiffSquared.length\n        val intArrayDiffSquaredDiffSquaredSum\
    \ = intArrayDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiff\
    \ = intArrayDiffSquaredDiffSquaredSum - intArrayDiffSquaredDiffSquared(0)\n  \
    \      val intArrayDiffSquaredDiffSquaredDiffSquared = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquaredDiffSquared(0)\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredLength\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.length\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredDiff\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum - intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared(0)\n\
    \        val intArrayDiffSquaredDiffSquared\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnidxs2n7.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnidxs2n7.scala:24:60\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffSquaredLength\e[0m = intArrayDiffSquared.length\n\e[31m\e[31m\
    \   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value length is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnidxs2n7.scala:25:57\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffSquaredSum\e[0m = intArrayDiffSquared.sum\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                     value sum is not a member of Int\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnidxs2n7.scala:31:56 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\e[31m\e[31m   |\e[0m   \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \    Recursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnidxs2n7.scala:35:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnidxs2n7.scala:40:5\
    \ -----------"
  stdout: ''
  timestamp: 1659805644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArrayDiff\
    \ = intArrayMax - intArrayMin\n        val intArrayDiffAbs = intArrayDiff.abs\n\
    \        val intArrayDiffAbsMin = intArrayDiffAbs.min\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsDiff = intArrayDiffAbsMax\
    \ - intArrayDiffAbsMin\n        val intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbs.min\n        val\
    \ intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n        val intArrayDiffAbsDiffAbsDiff\
    \ = intArrayDiffAbsDiffAbsMax - intArrayDiffAbsDiffAbsMin\n        val intArrayDiffAbsDiffAbsDiffAbs\
    \ = intArrayDiffAbsDiffAbsDiffAbs.abs\n        val intArrayDiffAbsDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsDiffAbsMax\
    \ = intArrayDiffAbsDiffAbsDiffAbs.max\n        val intArrayDiffAbsDiffAbsDiffAbsDiff\
    \ = intArrayDiffAbsDiffAbsDiffAbsMax - intArrayDiffAbsDiffAbsDiffAbsMin\n    \
    \    val intArrayDiffAbsDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiffAbsDiffAbsMax\
    \ - intArrayDiffAbsDiffAbsDiffAbsMin\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbsDiffAbsDiffAbsMax - intArrayDiffAbsDiffAbsDiffAbsMin\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbsDiffAbsDiffAbsMax\
    \ - intArrayDiffAbsDiffAbsDiffAbsMin\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwn10ue0t.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwn10ue0t.scala:27:53\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsDiff\e[0m = intArrayDiffAbsMax - intArrayDiffAbsMin\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of Int => Int, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwn10ue0t.scala:32:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsDiffAbsDiffAbs\e[0m = intArrayDiffAbsDiffAbsDiffAbs.abs\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsDiffAbsDiffAbs\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwn10ue0t.scala:38:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsDiffAbsDiffAbsDiffAbsMax\e[0m = intArrayDiffAbsDiffAbsDiffAbsDiffAbsMax\
    \ - intArrayDiffAbsDiffAbsDiffAbsMin\n\e[31m\e[31m   |\e[0m                  \
    \                                    ^\e[0m\n\e[31m   |\e[0m      Recursive \e\
    [33mvalue\e[0m \e[35mintArrayDiffAbsDiffAbsDiffAbsDiffAbsMax\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwn10ue0t.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDifference = intArraySum - intArray(0)\n        val intArrayDifferenceAbs\
    \ = intArrayDifference.abs\n        val intArrayDifferenceAbsMax = intArrayDifferenceAbs.max\n\
    \        val intArrayDifferenceAbsMin = intArrayDifferenceAbs.min\n        val\
    \ intArrayDifferenceAbsMaxIndex = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMax)\n\
    \        val intArrayDifferenceAbsMinIndex = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMin)\n\
    \        val intArrayDifferenceAbsMaxIndex2 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 1)\n        val intArrayDifferenceAbsMinIndex2 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 1)\n        val intArrayDifferenceAbsMaxIndex3 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 2)\n        val intArrayDifferenceAbsMinIndex3 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 2)\n        val intArrayDifferenceAbsMaxIndex4 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 3)\n        val intArrayDifferenceAbsMinIndex4 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 3)\n        val intArrayDifferenceAbsMaxIndex5 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 4)\n        val intArrayDifferenceAbsMinIndex5 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 4)\n        val intArrayDifferenceAbsMaxIndex6 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 5)\n        val intArrayDifferenceAbsMinIndex6 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 5)\n        val intArrayDifferenceAbsMaxIndex7 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 6)\n        val intArrayDifferenceAbsMinIndex7 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 6)\n        val intArrayDifferenceAbsMaxIndex8 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + 7)\n        val intArrayDifferenceAbsMinIndex8 = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex\
    \ - 7)\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ahqr6gy.scala:26:66 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceAbsMaxIndex\e\
    [0m = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMax)\n\e[31m\e[31m  \
    \ |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value indexOf is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ahqr6gy.scala:27:66\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDifferenceAbsMinIndex\e[0m = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMin)\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value indexOf is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ahqr6gy.scala:28:67\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDifferenceAbsMaxIndex2\e[0m = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                   value indexOf is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_ahqr6gy.scala:29:67 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceAbsMinIndex2\e\
    [0m = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMinIndex - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value indexOf is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ahqr6gy.scala:30:67\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDifferenceAbsMaxIndex3\e[0m = intArrayDifferenceAbs.indexOf(intArrayDifferenceAbsMaxIndex\
    \ + \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m "
  stdout: ''
  timestamp: 1659805645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff / 2) + min\n        closest.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpos3p7tii.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpos3p7tii.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\".\").map(_.toInt)\n        val min = math.min(nums.map(_.toLong))\n\
    \        val max = math.max(nums.map(_.toLong))\n        val diff = max - min\n\
    \        val closest = (min + diff) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqny4vn_0.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toLong))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Long])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqny4vn_0.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toLong))\n\e[31m\e[31m   |\e[0m     \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\").map(_.toInt)\n        val part1 = parts(0)\n        val part2\
    \ = parts(1)\n        val part3 = parts(2)\n        val part4 = parts(3)\n   \
    \     val part5 = parts(4)\n        val part6 = parts(5)\n        val part7 =\
    \ parts(6)\n        val part8 = parts(7)\n        val part9 = parts(8)\n     \
    \   val part10 = parts(9)\n        val part11 = parts(10)\n        val part12\
    \ = parts(11)\n        val part13 = parts(12)\n        val part14 = parts(13)\n\
    \        val part15 = parts(14)\n        val part16 = parts(15)\n        val part17\
    \ = parts(16)\n        val part18 = parts(17)\n        val part19 = parts(18)\n\
    \        val part20 = parts(19)\n        val part21 = parts(20)\n        val part22\
    \ = parts(21)\n        val part23 = parts(22)\n        val part24 = parts(23)\n\
    \        val part25 = parts(24)\n        val part26 = parts(25)\n        val part27\
    \ = parts(26)\n        val part28 = parts(27)\n        val part29 = parts(28)\n\
    \        val part30 = parts(29)\n        val part31 = parts(30)\n        val part32\
    \ = parts(31)\n        val part33 = parts(32)\n        val part34 = parts(33)\n\
    \        val part35 = parts(34)\n        val part36 = parts(35)\n        val part37\
    \ = parts(36)\n        val part38 = parts(37)\n        val part39 = parts(38)\n\
    \        val part40 = parts(39)\n        val part41 = parts(40)\n        val part42\
    \ = parts(41)\n        val part43 = parts(42)\n        val part44 = parts(43)\n\
    \        val part45 = parts(44)\n        val part46 = parts(45)\n        val part47\
    \ = parts(46)\n        val part48 = parts(47)\n        val part49 = parts(48)\n\
    \        val part50 = parts(49)\n        val part51 = parts(50)\n        val part52\
    \ = parts(51)\n        val part53 = parts(52)\n        val part54 = parts(53)\n\
    \        val part55 = parts(54)\n        val part56 = parts(55)\n        val part57\
    \ = parts(56)\n        val part58 = parts(57)\n        val part59 = parts(58)\n\
    \        val part60 = parts(59)\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4k22juej.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\".\").map(_.toInt)\n        val min = math.min(numbers)\n   \
    \     val max = math.max(numbers)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpna6ygnj9.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpna6ygnj9.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff * nums.last).toInt\n        math.abs(closest - value)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp71dnqgte.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp71dnqgte.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ diff = (afterInt - beforeInt)\n        if (diff > 0) {\n            afterInt\
    \ + diff\n        } else {\n            beforeInt - diff\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpzazbckke.scala:20)\n\tat Problem$.main(tmpzazbckke.scala:31)\n\
    \tat Problem.main(tmpzazbckke.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.min(numbers).toLong\
    \ - math.max(numbers).toLong\n        math.max(numbers).toLong + minDiff\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpshrjr1rh.scala:19:27 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.min(numbers).toLong\
    \ - math.max(numbers).toLong\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpshrjr1rh.scala:20:13 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        math.max(numbers).toLong + minDiff\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val diffAbs = Math.abs(diff)\n\
    \        val diffAbsMin = Math.abs(min)\n        val diffAbsMax = Math.abs(max)\n\
    \        val diffAbsMinAbs = Math.abs(diffAbsMin)\n        val diffAbsMaxAbs =\
    \ Math.abs(diffAbsMax)\n        val diffAbsMinAbsMax = Math.abs(diffAbsMin + diffAbsMax)\n\
    \        val diffAbsMinAbsMaxAbs = Math.abs(diffAbsMin + diffAbsMax + diffAbsMax)\n\
    \        val diffAbsMinAbsMaxAbsDiff = Math.abs(diffAbsMin + diffAbsMax + diffAbsMax\
    \ + diffAbs)\n        val diffAbsMinAbsMaxAbsDiffAbs = Math.abs(diffAbsMin + diffAbsMax\
    \ + diffAbsMax + diffAbs + diff)\n        val diffAbsMinAbsMaxAbsDiffAbsDiff =\
    \ Math.abs(diffAbsMin + diffAbsMax + diffAbsMax + diffAbs + diff + diff)\n   \
    \     val diffAbsMinAbsMaxAbsDiffAbsDiffAbs = Math.abs(diffAbsMin + diffAbsMax\
    \ + diffAbsMax + diffAbs + diff + diff + diff)\n        val diffAbsMinAbsMaxAbsDiffAbsDiffAbsDiff\
    \ = Math.abs(diffAbsMin + diffAbsMax + diffAbsMax + diffAbs + diff + diff + diff\
    \ + diff)\n        val diffAbsMinAbsMaxAbsDiffAbsDiffAbsDiffAbs = Math.abs(diffAbsMin\
    \ + diffAbsMax + diffAbsMax + diffAbs + diff + diff + diff + diff + diff)\n  \
    \      val diffAbsMinAbsMaxAbsDiffAbsDiffAbsDiffAbsDiff = Math.abs(diffAbsMin\
    \ + diffAbsMax + diffAbsMax + diffAbs + diff + diff + diff + diff + diff + diff)\n\
    \        val diffAbsMinAbsMaxAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(diffAbsMin\
    \ + diffAbsMax + diffAbsMax + diffAbs + diff + diff + diff + diff + diff + diff\
    \ + diff)\n        val diffAbsMinAbsMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2rmypvzt.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2rmypvzt.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = (max - min).abs\n        val closest = (min\
    \ + max) / 2\n        if (diff < closest) {\n            closest\n        } else\
    \ {\n            diff\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplu5v47p3.scala:31)\n\tat Problem.main(tmplu5v47p3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intValueAsLong = intValue.asInstanceOf[Long]\n\
    \        val intValueAsDouble = intValue.asInstanceOf[Double]\n        val intValueAsFloat\
    \ = intValue.asInstanceOf[Float]\n        val intValueAsInt = intValue.asInstanceOf[Int]\n\
    \        val intValueAsShort = intValue.asInstanceOf[Short]\n        val intValueAsByte\
    \ = intValue.asInstanceOf[Byte]\n        val intValueAsChar = intValue.asInstanceOf[Char]\n\
    \        val intValueAsBoolean = intValue.asInstanceOf[Boolean]\n        val intValueAsByteArray\
    \ = intValue.asInstanceOf[Array[Byte]]\n        val intValueAsCharArray = intValue.asInstanceOf[Array[Char]]\n\
    \        val intValueAsShortArray = intValue.asInstanceOf[Array[Short]]\n    \
    \    val intValueAsIntArray = intValue.asInstanceOf[Array[Int]]\n        val intValueAsLongArray\
    \ = intValue.asInstanceOf[Array[Long]]\n        val intValueAsFloatArray = intValue.asInstanceOf[Array[Float]]\n\
    \        val intValueAsDoubleArray = intValue.asInstanceOf[Array[Double]]\n  \
    \      val intValueAsBooleanArray = intValue.asInstanceOf[Array[Boolean]]\n  \
    \      val intValueAsByteArrayArray = intValue.asInstanceOf[Array[Array[Byte]]]\n\
    \        val intValueAsCharArrayArray = intValue.asInstanceOf[Array[Array[Char]]]\n\
    \        val intValueAsShortArrayArray = intValue.asInstanceOf[Array[Array[Short]]]\n\
    \        val intValueAsIntArrayArray = intValue.asInstanceOf[Array[Array[Int]]]\n\
    \        val intValueAsLongArrayArray = intValue.asInstanceOf[Array[Array[Long]]]\n\
    \        val intValueAsFloatArrayArray = intValue.asInstanceOf[Array[Array[Float]]]\n\
    \        val intValueAsDoubleArrayArray = intValue.asInstanceOf[Array[Array[Double]]]\n\
    \        val intValueAsBooleanArrayArray = intValue.asInstanceOf[Array[Array[Boolean]]]\n\
    \        val intValueAsByteArrayArrayArray = intValue.asInstanceOf[Array[Array[Array[Byte]]]]\n\
    \        val intValueAsCharArrayArrayArray = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvn_0cxpo.scala:44:43 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintValueAsCharArrayArrayArray\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                           ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvn_0cxpo.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into two parts separated by a dot\n  \
    \      val firstPart = parts(0).toInt // Convert the first part to an integer\n\
    \        val secondPart = parts(1).toInt // Convert the second part to an integer\n\
    \        val difference = secondPart - firstPart // Calculate the difference between\
    \ the two parts\n        val closestInteger = firstPart + difference // Calculate\
    \ the closest integer\n        closestInteger\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp0n359aal.scala:20)\n\tat Problem$.main(tmp0n359aal.scala:26)\n\
    \tat Problem.main(tmp0n359aal.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  if (closest == min) {\n            closestInt\n        } else {\n         \
    \   closestInt - diff\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmph9rfzgtc.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmph9rfzgtc.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = int\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp74bmjl3j.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp74bmjl3j.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = intArray.drop(intArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mintArray is already defined as \e[33mvalue\e[0m \e[35mintArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp74bmjl3j.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp74bmjl3j.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp74bmjl3j.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = intArray.drop(intArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659805653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = (max - min).toInt\n        val closest\
    \ = (min + diff) / 2\n        if (diff < 0)\n            closest - diff\n    \
    \    else\n            closest + diff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0vflrws8.scala:29)\n\tat Problem.main(tmp0vflrws8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val ints = numbers.map(_.toInt)\n \
    \       val diffs = ints.zip(diffs(ints))\n        val minDiff = diffs.minBy(_._2)._2\n\
    \        val closestInt = diffs.find(_._2 == minDiff)._1\n        closestInt *\
    \ -1\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2ayt3ist.scala:20:29 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = ints.zip(diffs(ints))\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Recursive \e[33mvalue\e[0m \e[35mdiffs\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp2ayt3ist.scala:21:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = diffs.minBy(_._2)._2\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter cmp of \e[33mmethod\e\
    [0m \e[35mminBy\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2ayt3ist.scala:22:53 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosestInt\e[0m = diffs.find(_._2\
    \ == minDiff)._1\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value _1 is not a member of Option[(Int,\
    \ Nothing)]\n3 errors found\n"
  stdout: ''
  timestamp: 1659805652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intValues = List(intValue, intValue+1)\n        val\
    \ diffs = intValues.map(x => Math.abs(x - intValue))\n        val minDiff = diffs.min\n\
    \        val closestValue = intValues.find(x => Math.abs(x - intValue) == minDiff)\n\
    \        closestValue.getOrElse(0)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp6l3hzeb4.scala:18)\n\
    \tat Problem$.main(tmp6l3hzeb4.scala:27)\n\tat Problem.main(tmp6l3hzeb4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        if (closest == 0) closest else closest.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmphly6gzqa.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmphly6gzqa.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + diff) / 2\n        if (closest == min) {\n            closest\n     \
    \   } else {\n            closest.toLong\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpepd998pb.scala:30)\n\tat Problem.main(tmpepd998pb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal point\n\
    \        val before = parts(0) // First part before decimal point\n        val\
    \ after = parts(1) // Second part after decimal point\n        val beforeInt =\
    \ before.toInt // Convert to integer\n        val afterInt = after.toInt // Convert\
    \ to integer\n        val diff = Math.abs(afterInt - beforeInt) // Difference\
    \ between before and after\n        val closestDiff = Math.abs(afterInt - beforeInt)\
    \ // Closest difference to before\n        if (diff == closestDiff) {\n      \
    \      afterInt // Return after integer\n        } else {\n            beforeInt\
    \ // Return before integer\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpsoktap3l.scala:20)\n\tat Problem$.main(tmpsoktap3l.scala:32)\n\
    \tat Problem.main(tmpsoktap3l.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\", \"8\",\
    \ \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\", \"\
    3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsLength =\
    \ nums.length\n        val numsLength = numsLength - 1\n        val closestNum\
    \ = nums(numsLength)\n        val closestNums = nums.filter(_ != closestNum)\n\
    \        val closestNumsLength = closestNums.length\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNumsLength = closestNumsLength -\
    \ 1\n        val closestNumsLength = closestNumsLength - 1\n        val closestNumsLength\
    \ = closestNumsLength - 1\n        val closestNum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa3wbpevq.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa3wbpevq.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnumsLength\e[0m = numsLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnumsLength is already\
    \ defined as \e[33mvalue\e[0m \e[35mnumsLength\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa3wbpevq.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestNumsLength\e[0m = closestNumsLength - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mclosestNumsLength is already defined as \e[33mvalue\e[0m \e[35mclosestNumsLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa3wbpevq.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mclosestNumsLength\e[0m = closestNumsLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumsLength is already defined as \e[33mvalue\e[0m \e\
    [35mclosestNumsLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa3wbpevq.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclosestNumsLength\e[0m =\
    \ closestNumsLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumsLength is already defined as \e[33mvalue\e[0m \e\
    [35mclosestNumsLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same g"
  stdout: ''
  timestamp: 1659805652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.asInstanceOf[String]\n\
    \        val numArray = num.toDouble.split('.').toList\n        val numArrayLength\
    \ = numArray.length\n        val numArrayLength = numArrayLength - 1\n       \
    \ val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\
    \ - 1\n        val numArrayLength = numArrayLength - 1\n        val numArrayLength\
    \ = numArrayLength - 1\n        val numArrayLength = numArrayLength - 1\n    \
    \    val numArrayLength = numArrayLength - 1\n        val numArrayLength = numArrayLength\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy8b1gqk_.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnumArrayLength\e[0m = numArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumArrayLength is already defined as \e[33mvalue\e[0m \e[35mnumArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy8b1gqk_.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mnumArrayLength\e[0m = numArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumArrayLength is already defined as \e[33mvalue\e[0m \e[35mnumArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy8b1gqk_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mnumArrayLength\e[0m = numArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumArrayLength is already defined as \e[33mvalue\e[0m \e[35mnumArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy8b1gqk_.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mnumArrayLength\e[0m = numArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumArrayLength is already defined as \e[33mvalue\e[0m \e[35mnumArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy8b1gqk_.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mnumArrayLength\e[0m = numArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArray = intArray.drop(intArrayLength)\n        val intArrayLength\
    \ = intArray.length\n        val intArrayLength = intArrayLength - 1\n       \
    \ val intArray = intArray.drop(intArrayLength)\n        val intArrayLength = intArray.length\n\
    \        val intArrayLength = intArrayLength - 1\n        val intArray = intArray.drop(intArrayLength)\n\
    \        val intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbnqc21p8.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnqc21p8.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayLength\e[0m = intArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mintArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnqc21p8.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArray\e[0m = intArray.drop(intArrayLength)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mintArray\
    \ is already defined as \e[33mvalue\e[0m \e[35mintArray\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnqc21p8.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayLength\e[0m = intArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbnqc21p8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming "
  stdout: ''
  timestamp: 1659805654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        if (diff\
    \ == 0) min else min + diff\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmppyca25wc.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmppyca25wc.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805652
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val min = math.min(num, math.min(num - 1, num - 2))\n        val max\
    \ = math.max(num, math.max(num - 1, num - 2))\n        val diff = max - min\n\
    \        if (diff == 0) min else min - diff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp39ilb40j.scala:25)\n\tat Problem.main(tmp39ilb40j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.min(nums.map(math.abs))\n\
    \        val maxDiff = math.max(nums.map(math.abs))\n        val closestNum =\
    \ nums.find(math.abs(_ - minDiff) == math.abs(_ - maxDiff))\n        closestNum.getOrElse(0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfh8a29hs.scala:19:27 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.min(nums.map(math.abs))\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Int])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfh8a29hs.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxDiff\e[0m = math.max(nums.map(math.abs))\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Int])\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpfh8a29hs.scala:21:40 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mclosestNum\e[0m = nums.find(math.abs(_\
    \ - minDiff) == math.abs(_ - maxDiff))\n\e[31m\e[31m   |\e[0m                \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments (<?> => <?>)\n3 errors found\n"
  stdout: ''
  timestamp: 1659805652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = (max - min).toDouble\n\
    \        val closest = (diff + min).toInt\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxagz0rmo.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxagz0rmo.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + diff) / 2\n        if (closest == min) {\n            min\n        }\
    \ else {\n            closest\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqeojuluf.scala:30)\n\tat Problem.main(tmpqeojuluf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc0503u_r.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        if (diff == 0) {\n            closest\n        }\
    \ else {\n            math.round(closest)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfkbhylwd.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpfkbhylwd.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray.reduce((a, b) => a + b)\n        val intArrayDiff = intArraySum -\
    \ intArrayMax\n        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsMin = intArrayDiffAbs.min\n\
    \        val intArrayDiffAbsMaxAbs = intArrayDiffAbsMax.abs\n        val intArrayDiffAbsMaxAbsMin\
    \ = intArrayDiffAbsMaxAbs.min\n        val intArrayDiffAbsMaxAbsMinAbs = intArrayDiffAbsMaxAbsMin.abs\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMin = intArrayDiffAbsMaxAbsMinAbs.min\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbs = intArrayDiffAbsMaxAbsMinAbsMin.abs\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMin = intArrayDiffAbsMaxAbsMinAbsMinAbs.min\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbs = intArrayDiffAbsMaxAbsMinAbsMinAbsMin.abs\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin.min\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbs = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin.abs\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin.min\n\
    \        val intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMinAbs = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin.abs\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpfdc1uiex.scala:39:11 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfdc1uiex.scala:28:55 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMaxAbs\e\
    [0m = intArrayDiffAbsMax.abs\n\e[31m\e[31m   |\e[0m                          \
    \          ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue abs is not a member\
    \ of Int => Int, but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpfdc1uiex.scala:35:57 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin\e\
    [0m = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin.min\n\e[31m\e[31m   |\e[0m  \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \   Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfdc1uiex.scala:37:63\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin\e[0m = intArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin.min\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsMaxAbsMinAbsMinAbsMinAbsMinAbsMin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E0"
  stdout: ''
  timestamp: 1659805657
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + max) / 2\n        if (diff < 0)\n            closest - diff\n       \
    \ else\n            closest + diff\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwng1eqg9.scala:30)\n\tat Problem.main(tmpwng1eqg9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue - 1, intValue + 1, intValue\
    \ - 2, intValue + 2)\n        val closest = (ints min intValue).toLong\n     \
    \   closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3af3fgc4.scala:20:32\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mclosest\e\
    [0m = (ints min intValue).toLong\n\e[31m\e[31m   |\e[0m                      \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:\
    \    (intValue : Int)\n\e[31m   |\e[0m                                Required:\
    \ Ordering[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = mutable.ArrayBuffer.empty[Long]\n        val numsSorted =\
    \ mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8fzt7bkv.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8fzt7bkv.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ d"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.asInstanceOf[Array[Double]]\n\
    \        val intArrayLength = intArray.length\n        val intArrayIndex = (intArrayLength\
    \ - 1)/2\n        val intArrayIndex2 = intArrayIndex + 1\n        val intArrayIndex3\
    \ = intArrayIndex + 2\n        val intArrayIndex4 = intArrayIndex + 3\n      \
    \  val intArrayIndex5 = intArrayIndex + 4\n        val intArrayIndex6 = intArrayIndex\
    \ + 5\n        val intArrayIndex7 = intArrayIndex + 6\n        val intArrayIndex8\
    \ = intArrayIndex + 7\n        val intArrayIndex9 = intArrayIndex + 8\n      \
    \  val intArrayIndex10 = intArrayIndex + 9\n        val intArrayIndex11 = intArrayIndex\
    \ + 10\n        val intArrayIndex12 = intArrayIndex + 11\n        val intArrayIndex13\
    \ = intArrayIndex + 12\n        val intArrayIndex14 = intArrayIndex + 13\n   \
    \     val intArrayIndex15 = intArrayIndex + 14\n        val intArrayIndex16 =\
    \ intArrayIndex + 15\n        val intArrayIndex17 = intArrayIndex + 16\n     \
    \   val intArrayIndex18 = intArrayIndex + 17\n        val intArrayIndex19 = intArrayIndex\
    \ + 18\n        val intArrayIndex20 = intArrayIndex + 19\n        val intArrayIndex21\
    \ = intArrayIndex + 20\n        val intArrayIndex22 = intArrayIndex + 21\n   \
    \     val intArrayIndex23 = intArrayIndex + 22\n        val intArrayIndex24 =\
    \ intArrayIndex + 23\n        val intArrayIndex25 = intArrayIndex + 24\n     \
    \   val intArrayIndex26 = intArrayIndex + 25\n        val intArrayIndex27 = intArrayIndex\
    \ + 26\n        val intArrayIndex28 = intArrayIndex + 27\n        val intArrayIndex29\
    \ = intArrayIndex + 28\n        val intArrayIndex30 = intArrayIndex + 29\n   \
    \     val intArrayIndex31 = intArrayIndex + 30\n        val intArrayIndex32 =\
    \ intArrayIndex + 31\n        val intArrayIndex33 = intArrayIndex + 32\n     \
    \   val intArrayIndex34 = intArrayIndex + 33\n        val intArrayIndex35 = intArrayIndex\
    \ + 34\n        val intArrayIndex36 = intArrayIndex + 35\n        val intArrayIndex37\
    \ = intArrayIndex + 36\n        val intArrayIndex38\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4lraxl0h.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp4lraxl0h.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val closest = (diff +\
    \ min) / 2\n        val diff2 = closest - nums.min\n        val diff3 = closest\
    \ - nums.max\n        val diff4 = closest - nums.sum\n        val diff5 = closest\
    \ - nums.product\n        val diff6 = closest - nums.foldLeft(0)((x, y) => x +\
    \ y)\n        val diff7 = closest - nums.foldRight(0)((x, y) => x + y)\n     \
    \   val diff8 = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff9\
    \ = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff10 = closest\
    \ - nums.foldRight(0)((x, y) => x + y)\n        val diff11 = closest - nums.foldRight(0)((x,\
    \ y) => x + y)\n        val diff12 = closest - nums.foldRight(0)((x, y) => x +\
    \ y)\n        val diff13 = closest - nums.foldRight(0)((x, y) => x + y)\n    \
    \    val diff14 = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff15\
    \ = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff16 = closest\
    \ - nums.foldRight(0)((x, y) => x + y)\n        val diff17 = closest - nums.foldRight(0)((x,\
    \ y) => x + y)\n        val diff18 = closest - nums.foldRight(0)((x, y) => x +\
    \ y)\n        val diff19 = closest - nums.foldRight(0)((x, y) => x + y)\n    \
    \    val diff20 = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff21\
    \ = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff22 = closest\
    \ - nums.foldRight(0)((x, y) => x + y)\n        val diff23 = closest - nums.foldRight(0)((x,\
    \ y) => x + y)\n        val diff24 = closest - nums.foldRight(0)((x, y) => x +\
    \ y)\n        val diff25 = closest - nums.foldRight(0)((x, y) => x + y)\n    \
    \    val diff26 = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff27\
    \ = closest - nums.foldRight(0)((x, y) => x + y)\n        val diff28 = closest\
    \ - nums.foldRight(0)((x, y) => x + y)\n        val diff29 = closest - nums.foldRight(0)((x,\
    \ y) => x + y)\n        val \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpclyx82wu.scala:51:11 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpclyx82wu.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val difference = max - min\n   \
    \     val closest = (min + max) / 2\n        if (difference < closest) {\n   \
    \         closest\n        } else {\n            math.round(closest)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsxzwhpbv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsxzwhpbv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        if (diff < 0)\n            math.round(closest)\n\
    \        else\n            math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgnuq7rg9.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgnuq7rg9.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805660
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val beforeDecimal = parts(0).toLong // Convert to long\n    \
    \    val afterDecimal = parts(1).toLong // Convert to long\n        val difference\
    \ = afterDecimal - beforeDecimal\n        if (difference < 0)\n            afterDecimal\
    \ + difference\n        else\n            beforeDecimal - difference\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpx78dtz0o.scala:20)\n\tat Problem$.main(tmpx78dtz0o.scala:28)\n\
    \tat Problem.main(tmpx78dtz0o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = mutable.ArrayBuffer.empty[Long]\n        val numsSorted =\
    \ mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[Long]\n        val numsSorted\
    \ = mutable.ArrayBuffer.empty[Long]\n        val numsSorted = mutable.ArrayBuffer.empty[Long]\n\
    \        val numsSorted = mutable.ArrayBuffer.empty[\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8fzt7bkv.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8fzt7bkv.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8fzt7bkv.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mnumsSorted\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumsSorted is already defined as \e[33mvalue\e[0m \e[35mnumsSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ d"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff == 0) ? min : min + (diff / 2)\n        closest\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp33wehpo2.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp33wehpo2.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp33wehpo2.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        if (diff\
    \ < 0)\n            min - diff\n        else\n            max + diff\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp13f07l4m.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp13f07l4m.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val closestInteger = smallest + difference\n        return closestInteger\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpev5i7u0j.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpev5i7u0j.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2 - (diff / 2)\n        math.round(closest)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgywif4pv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgywif4pv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12.5\", \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\"\
    , \"8\", \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\"\
    , \"3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsSorted\
    \ = nums.sortWith(_ < _)\n        val closestNum = numsSorted.last\n        val\
    \ closestNumIndex = numsSorted.lastIndex\n        val closestNumDistance = numsSorted.take(closestNumIndex).map(num\
    \ => Math.abs(num - num)).sum\n        val closestNumDistanceAbs = closestNumDistance.abs\n\
    \        val closestNumDistanceAbsMin = closestNumDistanceAbs.min\n        val\
    \ closestNumDistanceAbsMax = closestNumDistanceAbs.max\n        val closestNumDistanceAbsSum\
    \ = closestNumDistanceAbs.sum\n        val closestNumDistanceAbsSumMin = closestNumDistanceAbsSum.min\n\
    \        val closestNumDistanceAbsSumMax = closestNumDistanceAbsSum.max\n    \
    \    val closestNumDistanceAbsSumSum = closestNumDistanceAbsSum.sum\n        val\
    \ closestNumDistanceAbsSumSumMin = closestNumDistanceAbsSumSum.min\n        val\
    \ closestNumDistanceAbsSumSumMax = closestNumDistanceAbsSumSum.max\n        val\
    \ closestNumDistanceAbsSumSumSum = closestNumDistanceAbsSumSum.sum\n        val\
    \ closestNumDistanceAbsSumSumSumMin = closestNumDistanceAbsSumSumSum.min\n   \
    \     val closestNumDistanceAbsSumSumSumMax = closestNumDistanceAbsSumSumSum.max\n\
    \        val closestNumDistanceAbsSumSumSumSum = closestNumDistanceAbsSumSumSum.sum\n\
    \        val closestNumDistanceAbsSumSumSumSumMin = closestNumDistanceAbsSumSumSum.min\n\
    \        val closestNumDistanceAbsSumSumSumMax = closestNumDistanceAbsSumSumSum.max\n\
    \        val closestNumDistanceAbsSumSumSumSum = closestNumDistanceAbsSumSumSum.sum\n\
    \        val closestNumDistanceAbsSumSumSumSumMin = closestNumDistanceAbsSumSumSumSum.min\n\
    \        val closestNumDistanceAbsSumSumSumSumMax = closestNumDistanceAbsSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcq9wa8b2.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mclosestNumDistanceAbsSumSumSumMax\e\
    [0m = closestNumDistanceAbsSumSumSum.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDistanceAbsSumSumSumMax is already defined as \e\
    [33mvalue\e[0m \e[35mclosestNumDistanceAbsSumSumSumMax\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcq9wa8b2.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestNumDistanceAbsSumSumSumSum\e[0m = closestNumDistanceAbsSumSumSum.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDistanceAbsSumSumSumSum is already defined as \e\
    [33mvalue\e[0m \e[35mclosestNumDistanceAbsSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcq9wa8b2.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestNumDistanceAbsSumSumSumSumMin\e[0m = closestNumDistanceAbsSumSumSumSum.min\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclosestNumDistanceAbsSumSumSumSumMin is already defined as\
    \ \e[33mvalue\e[0m \e[35mclosestNumDistanceAbsSumSumSumSumMin\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcq9wa8b2.scala:22:41\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclosestNumIndex\e[0m = numsSorted.lastIndex\n\e[31m\e[31m   |\e[0m       \
    \                       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex\
    \ is not a member of List[String] - did you mean numsSorted."
  stdout: ''
  timestamp: 1659805664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArraySum = intArray(0)\
    \ + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum - intArrayMin\n\
    \        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsMin = intArrayDiffAbs.min\n\
    \        val intArrayDiffAbsSum = intArrayDiffAbs.sum\n        val intArrayDiffAbsSumMax\
    \ = intArrayDiffAbsSum.max\n        val intArrayDiffAbsSumMin = intArrayDiffAbsSum.min\n\
    \        val intArrayDiffAbsSumSum = intArrayDiffAbsSum.sum\n        val intArrayDiffAbsSumSumMax\
    \ = intArrayDiffAbsSumSum.max\n        val intArrayDiffAbsSumSumMin = intArrayDiffAbsSumSum.min\n\
    \        val intArrayDiffAbsSumSumSum = intArrayDiffAbsSumSum.sum\n        val\
    \ intArrayDiffAbsSumSumSumMax = intArrayDiffAbsSumSumSum.max\n        val intArrayDiffAbsSumSumSumMin\
    \ = intArrayDiffAbsSumSumSum.min\n        val intArrayDiffAbsSumSumSumSum = intArrayDiffAbsSumSumSum.sum\n\
    \        val intArrayDiffAbsSumSumSumSumMax = intArrayDiffAbsSumSumSumSum.max\n\
    \        val intArrayDiffAbsSumSumSumSumMin = intArrayDiffAbsSumSumSumSum.min\n\
    \        val intArrayDiffAbsSumSumSumSumSum = intArrayDiffAbsSumSumSumSum.sum\n\
    \        val intArrayDiffAbsSumSumSumSumMax = intArrayDiffAbsSumSumSumSum.max\n\
    \        val intArrayDiffAbsSumSumSumSumMin = intArrayDiffAbsSumSumSumSum.min\n\
    \        val intArrayDiffAbsSumSumSumSumSum = intArrayDiffAbsSumSumSumSum.sum\n\
    \        val intArrayDiffAbsSumSumSumSumMax = intArrayDiffAbsSumSumSumSum.max\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13sytpbq.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSumSumSumSumMax\e\
    [0m = intArrayDiffAbsSumSumSumSum.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDiffAbsSumSumSumSumMax is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDiffAbsSumSumSumSumMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13sytpbq.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSumSumSumSumMin\e\
    [0m = intArrayDiffAbsSumSumSumSum.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDiffAbsSumSumSumSumMin is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDiffAbsSumSumSumSumMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13sytpbq.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSumSumSumSumSum\e\
    [0m = intArrayDiffAbsSumSumSumSum.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDiffAbsSumSumSumSumSum is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDiffAbsSumSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp13sytpbq.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSumSumSumSumMax\e\
    [0m = intArrayDiffAbsSumSumSumSum.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDiffAbsSumSumSumSumMax is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDiffAbsSumSum"
  stdout: ''
  timestamp: 1659805665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        if (diff\
    \ == 0) min else min + math.ceil(diff / 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmps50_172_.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmps50_172_.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805662
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val difference = abs(intValue - intValue)\n        val\
    \ closestInteger = intValue + difference\n        closestInteger\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp675u0w85.scala:18)\n\
    \tat Problem$.main(tmp675u0w85.scala:25)\n\tat Problem.main(tmp675u0w85.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArrayMid = (intArrayMin\
    \ + intArrayMax) / 2\n        val intArrayMidLength = intArrayMid.length\n   \
    \     val intArrayMidMin = intArrayMid.min\n        val intArrayMidMax = intArrayMid.max\n\
    \        val intArrayMidMid = (intArrayMidMin + intArrayMidMax) / 2\n        val\
    \ intArrayMidMidLength = intArrayMidMid.length\n        val intArrayMidMidMin\
    \ = intArrayMidMid.min\n        val intArrayMidMidMax = intArrayMidMid.max\n \
    \       val intArrayMidMidMid = (intArrayMidMidMin + intArrayMidMidMax) / 2\n\
    \        val intArrayMidMidMidLength = intArrayMidMidMid.length\n        val intArrayMidMidMidMin\
    \ = intArrayMidMidMid.min\n        val intArrayMidMidMidMax = intArrayMidMidMid.max\n\
    \        val intArrayMidMidMidMid = (intArrayMidMidMidMin + intArrayMidMidMidMax)\
    \ / 2\n        val intArrayMidMidMidLength = intArrayMidMidMid.length\n      \
    \  val intArrayMidMidMidMin = intArrayMidMidMid.min\n        val intArrayMidMidMidMax\
    \ = intArrayMidMidMid.max\n        val intArrayMidMidMidMid = (intArrayMidMidMidMin\
    \ + intArrayMidMidMidMax) / 2\n        val intArrayMidMidMidLength = intArrayMidMidMid.length\n\
    \        val intArrayMidMidMidMin = intArrayMidMidMid.min\n        val intArrayMidMidMidMax\
    \ = intArrayMidMidMid.max\n        val intArrayMidMidMidMid = (intArrayMidMidMidMin\
    \ + intArrayMidMidMidMax) / 2\n        val intArrayMidMidMidLength = intArrayMidMidMid.length\n\
    \        val intArrayMidMidMidMin = intArrayMidMidMid.min\n        val intArrayMidMidMidMax\
    \ = intArrayMidMidMid.max\n        val intArrayMidMidMidMid = (intArrayMidMidMidMin\
    \ + intArrayMidMidMidMax) / 2\n        val intArrayMidMidMidLength = intArrayMidMidMid.length\n\
    \        val intArrayMidMidMidMin = intArrayMidMidMid\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplshoeb5c.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mintArrayMidMidMidLength\e\
    [0m = intArrayMidMidMid.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayMidMidMidLength is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayMidMidMidLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplshoeb5c.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mintArrayMidMidMidMin\e[0m\
    \ = intArrayMidMidMid.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayMidMidMidMin is already defined as \e[33mvalue\e[0m\
    \ \e[35mintArrayMidMidMidMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplshoeb5c.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mintArrayMidMidMidMax\e[0m\
    \ = intArrayMidMidMid.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayMidMidMidMax is already defined as \e[33mvalue\e[0m\
    \ \e[35mintArrayMidMidMidMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplshoeb5c.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mintArrayMidMidMidMid\e[0m\
    \ = (intArrayMidMidMidMin + intArrayMidMidMidMax) / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayMidMidMidMid is already defined as \e[33mvalue\e[0m\
    \ \e[35mintArrayMidMidMidMid\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Namin"
  stdout: ''
  timestamp: 1659805665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12.5\", \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\"\
    , \"8\", \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\"\
    , \"3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsSorted\
    \ = nums.sortWith(_ < _)\n        val numsSortedLength = numsSorted.length\n \
    \       val closestNum = numsSorted.last\n        val closestNumIndex = numsSorted.lastIndexOf(value)\n\
    \        val closestNumDistance = numsSortedLength - closestNumIndex\n       \
    \ val closestNumDistanceAbs = closestNumDistance * closestNumDistance\n      \
    \  val closestNumDistanceAbsMinus1 = closestNumDistanceAbs - 1\n        val closestNumDistanceAbsMinus2\
    \ = closestNumDistanceAbs - 2\n        val closestNumDistanceAbsMinus3 = closestNumDistanceAbs\
    \ - 3\n        val closestNumDistanceAbsMinus4 = closestNumDistanceAbs - 4\n \
    \       val closestNumDistanceAbsMinus5 = closestNumDistanceAbs - 5\n        val\
    \ closestNumDistanceAbsMinus6 = closestNumDistanceAbs - 6\n        val closestNumDistanceAbsMinus7\
    \ = closestNumDistanceAbs - 7\n        val closestNumDistanceAbsMinus8 = closestNumDistanceAbs\
    \ - 8\n        val closestNumDistanceAbsMinus9 = closestNumDistanceAbs - 9\n \
    \       val closestNumDistanceAbsMinus10 = closestNumDistanceAbs - 10\n      \
    \  val closestNumDistanceAbsMinus11 = closestNumDistanceAbs - 11\n        val\
    \ closestNumDistanceAbsMinus12 = closestNumDistanceAbs - 12\n        val closestNumDistanceAbsMinus13\
    \ = closestNumDistanceAbs - 13\n        val closestNumDistanceAbsMinus14 = closestNumDistanceAbs\
    \ - 14\n        val closestNumDistanceAbsMinus15 = closestNumDistanceAbs - 15\n\
    \        val closestNumDistanceAbsMinus16 = closestNumDistanceAbs - 16\n     \
    \   val closestNumDistanceAbsMinus17 = closestNumDistanceAbs - 17\n        val\
    \ closestNumDistanceAbsMinus18 = closestNumDistanceAbs - 18\n        val closestNumDistanceAbsMinus19\
    \ = closestNumDistanceAbs - 19\n        val closestNumDistanceAbsMinus20 = closestNumDistanceAbs\
    \ - \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5sdim2ds.scala:45:66 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mclosestNumDistanceAbsMinus20\e\
    [0m = closestNumDistanceAbs - \n\e[31m\e[31m   |\e[0m                        \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5sdim2ds.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805665
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into integer and fractional part\n   \
    \     val fractionalPart = parts(1).toLong // Get fractional part\n        val\
    \ integerPart = parts(0).toLong // Get integer part\n        val diff = (fractionalPart\
    \ - integerPart).abs // Get difference between fractional and integer parts\n\
    \        val closest = (diff + integerPart).abs % 10 // Get closest integer\n\
    \        closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmprni7cn_4.scala:19)\n\tat Problem$.main(tmprni7cn_4.scala:26)\n\
    \tat Problem.main(tmprni7cn_4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val difference = max - min\n   \
    \     if (difference < 0)\n            min - difference\n        else\n      \
    \      max + difference\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsxew_c1f.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsxew_c1f.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff / numbers.last).toInt\n        closest + min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpz031p40u.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpz031p40u.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArraySum = intArray(0)\
    \ + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum - intArrayMax\n\
    \        val intArrayDiffAbs = intArrayDiff < 0 ? -intArrayDiff : intArrayDiff\n\
    \        val intArrayDiffAbsMin = intArrayDiffAbs < 0 ? -intArrayDiffAbs : intArrayDiffAbs\n\
    \        val intArrayDiffAbsMax = intArrayDiffAbs > 0 ? intArrayDiffAbs : -intArrayDiffAbs\n\
    \        val intArrayDiffAbsMaxMin = intArrayDiffAbsMax < intArrayDiffAbsMin ?\
    \ intArrayDiffAbsMax : intArrayDiffAbsMin\n        val intArrayDiffAbsMaxMinDiff\
    \ = intArrayDiffAbsMaxMin - intArrayDiffAbsMax\n        val intArrayDiffAbsMaxMinDiffAbs\
    \ = intArrayDiffAbsMaxMinDiff < 0 ? -intArrayDiffAbsMaxMinDiff : intArrayDiffAbsMaxMinDiff\n\
    \        val intArrayDiffAbsMaxMinDiffAbsMin = intArrayDiffAbsMaxMinDiffAbs <\
    \ 0 ? -intArrayDiffAbsMaxMinDiffAbs : intArrayDiffAbsMaxMinDiffAbs\n        val\
    \ intArrayDiffAbsMaxMinDiffAbsMax = intArrayDiffAbsMaxMinDiffAbs > 0 ? intArrayDiffAbsMaxMinDiffAbs\
    \ : -intArrayDiffAbsMaxMinDiffAbs\n        val intArrayDiffAbsMaxMinDiffAbsMaxMin\
    \ = intArrayDiffAbsMaxMinDiffAbsMax < intArrayDiffAbsMaxMinDiffAbsMin ? intArrayDiffAbsMaxMinDiffAbsMax\
    \ : intArrayDiffAbsMaxMinDiffAbsMin\n        val intArrayDiffAbsMaxMinDiffAbsMaxMinDiff\
    \ = intArrayDiffAbsMaxMinDiffAbsMaxMin - intArrayDiffAbsMaxMinDiffAbsMax\n   \
    \     val intArrayDiffAbsMaxMinDiffAbsMaxMinDiffAbs = intArrayDiffAbsMaxMinDiffAbsMaxMinDiff\
    \ < 0 ? -intArrayDiffAbsMaxMinDiffAbsMaxMin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ln9xroy.scala:28:0 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMaxMin\e\
    [0m = intArrayDiffAbsMax < intArrayDiffAbsMin ? intArrayDiffAbsMax : \e[35mintArrayDiffAbsMin\e\
    [0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0man identifier expected, but\
    \ 'end of statement' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8ln9xroy.scala:33:0 ----------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsMaxMinDiffAbsMaxMin\e[0m =\
    \ intArrayDiffAbsMaxMinDiffAbsMax < intArrayDiffAbsMaxMinDiffAbsMin ? intArrayDiffAbsMaxMinDiffAbsMax\
    \ : \e[35mintArrayDiffAbsMaxMinDiffAbsMin\e[0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\
    \e[31m   |\e[0man identifier expected, but 'end of statement' found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ln9xroy.scala:19:50 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = intValue.toString.toDouble.split(\e\
    [31m'.'\e[0m).map(_.toInt)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value split is not a member of Double\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ln9xroy.scala:25:65 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbs\e[0m = intArrayDiff\
    \ < \e[31m0\e[0m ? -intArrayDiff : \e[35mintArrayDiff\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                                 ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ intArrayDiff\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8ln9xroy.scala:26:74\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffAbsMin\e[0m = intArrayDiffAbs < \e[31m0\e[0m ? -intArrayDiffAbs\
    \ : \e[35mintArrayDiffAbs\e[0m\n\e[31m\e"
  stdout: ''
  timestamp: 1659805669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue).sorted\n        val closest\
    \ = (ints.head - ints.last) / 2\n        closest.toLong\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoyf47n59.scala:24)\n\tat Problem.main(tmpoyf47n59.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = Math.min(numbers)\n\
    \        val largest = Math.max(numbers)\n        val diff = (largest - smallest).toInt\n\
    \        val closest = (smallest + diff) / 2\n        closest.toLong\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzd7fcye2.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = Math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\
    \e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1:\
    \ Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpzd7fcye2.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = Math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\
    \e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float,\
    \ x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val closestToZero = parts.foldLeft(0)((acc,\
    \ x) => math.min(acc, x))\n        val closestToOne = parts.foldLeft(1)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTwo = parts.foldLeft(2)((acc,\
    \ x) => math.min(acc, x))\n        val closestToThree = parts.foldLeft(3)((acc,\
    \ x) => math.min(acc, x))\n        val closestToFour = parts.foldLeft(4)((acc,\
    \ x) => math.min(acc, x))\n        val closestToFive = parts.foldLeft(5)((acc,\
    \ x) => math.min(acc, x))\n        val closestToSix = parts.foldLeft(6)((acc,\
    \ x) => math.min(acc, x))\n        val closestToSeven = parts.foldLeft(7)((acc,\
    \ x) => math.min(acc, x))\n        val closestToEight = parts.foldLeft(8)((acc,\
    \ x) => math.min(acc, x))\n        val closestToNine = parts.foldLeft(9)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTen = parts.foldLeft(10)((acc,\
    \ x) => math.min(acc, x))\n        val closestToEleven = parts.foldLeft(11)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTwelve = parts.foldLeft(12)((acc,\
    \ x) => math.min(acc, x))\n        val closestToThirteen = parts.foldLeft(13)((acc,\
    \ x) => math.min(acc, x))\n        val closestToFourteen = parts.foldLeft(14)((acc,\
    \ x) => math.min(acc, x))\n        val closestToFifteen = parts.foldLeft(15)((acc,\
    \ x) => math.min(acc, x))\n        val closestToSixteen = parts.foldLeft(16)((acc,\
    \ x) => math.min(acc, x))\n        val closestToSeventeen = parts.foldLeft(17)((acc,\
    \ x) => math.min(acc, x))\n        val closestToEighteen = parts.foldLeft(18)((acc,\
    \ x) => math.min(acc, x))\n        val closestToNineteen = parts.foldLeft(19)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTwenty = parts.foldLeft(20)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTwentyOne = parts.foldLeft(21)((acc,\
    \ x) => math.min(acc, x))\n        val closestToTwentyTwo = parts.foldLef\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_lt5mhfv.scala:41:39 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mclosestToTwentyTwo\e[0m\
    \ = parts.foldLef\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value foldLef is not a member\
    \ of Array[Int]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_lt5mhfv.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum\
    \ - intArrayMax\n        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMax = intArrayDiffAbs.max\n\
    \        val intArrayDiffAbsSum = intArrayDiffAbs(0) + intArrayDiffAbs(1) + intArrayDiffAbs(2)\n\
    \        val intArrayDiffAbsDiff = intArrayDiffAbsSum - intArrayMax\n        val\
    \ intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1)\
    \ + intArrayDiffAbsDiffAbs(2)\n        val intArrayDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbsDiffAbs(0)\
    \ + intArrayDiffAbsDiffAbsDiffAbs(1) + intArrayDiffAbsDiffAbsDiffAbs(2)\n    \
    \    val intArrayDiffAbsDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAb\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5wk2qj4c.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp5wk2qj4c.scala:28:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e\
    [0m \e[36mintArrayDiffAbsSum\e[0m = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e\
    [31m1\e[0m) + intArrayDiffAbs(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         \e[33mvalue\e[0m \e[35mintArrayDiffAbs\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5wk2qj4c.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        if (diff > 0)\
    \ min else max\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsuc2ho_l.scala:26)\n\tat Problem.main(tmpsuc2ho_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            largest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpa_mt4cw2.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpa_mt4cw2.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val integers = numbers.map(_.toInt)\n\
    \        val diffs = numbers.zip(integers).map { case (number, integer) => math.abs(number\
    \ - integer) }\n        val min = diffs.min\n        val max = diffs.max\n   \
    \     if (min == max) {\n            numbers(diffs.indexOf(min))\n        } else\
    \ {\n            val closestIndex = diffs.indexOf(min)\n            numbers(closestIndex\
    \ + 1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpw8g6w5n7.scala:20:90 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = numbers.zip(integers).map\
    \ { \e[33mcase\e[0m (number, integer) => math.abs(number - integer) }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpw8g6w5n7.scala:21:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = diffs.min\n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mmin\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ Error: /tmp/tmpw8g6w5n7.scala:22:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmax\e[0m = diffs.max\n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpw8g6w5n7.scala:24:19 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            numbers(diffs.indexOf(min))\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \      Found:    String\n\e"
  stdout: ''
  timestamp: 1659805673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15.3\", \"14.5\", \"14\", \"13.5\", \"13\"\
    , \"12\", \"11.5\", \"11\", \"10.5\", \"10\", \"9.5\", \"9\", \"8.5\", \"8\",\
    \ \"7.5\", \"7\", \"6.5\", \"6\", \"5.5\", \"5\", \"4.5\", \"4\", \"3.5\", \"\
    3\", \"2.5\", \"2\", \"1.5\", \"1\", \"0.5\", \"0\")\n        val numsSorted =\
    \ nums.sortWith(_ < _)\n        val closestNum = numsSorted.last\n        val\
    \ closestNumIndex = numsSorted.lastIndex\n        val closestNumDistance = numsSorted.zipWithIndex.filter(_._1\
    \ == num).map(_._2).sum\n        val closestNumDistanceAbs = closestNumDistance\
    \ / closestNum\n        val closestNumDistanceAbsIndex = closestNumDistanceAbs.lastIndex\n\
    \        val closestNumDistanceAbsDistance = closestNumDistanceAbs.zipWithIndex.filter(_._1\
    \ == num).map(_._2).sum\n        val closestNumDistanceAbsDistanceAbs = closestNumDistanceAbsDistance\
    \ / closestNumDistanceAbs\n        val closestNumDistanceAbsDistanceAbsIndex =\
    \ closestNumDistanceAbsDistanceAbs.lastIndex\n        val closestNumDistanceAbsDistanceAbsDistance\
    \ = closestNumDistanceAbsDistanceAbs.zipWithIndex.filter(_._1 == num).map(_._2).sum\n\
    \        val closestNumDistanceAbsDistanceAbsDistanceAbs = closestNumDistanceAbsDistanceAbsDistance\
    \ / closestNumDistanceAbsDistanceAbs\n        val closestNumDistanceAbsDistanceAbsDistanceAbsIndex\
    \ = closestNumDistanceAbsDistanceAbsDistanceAbs.lastIndex\n        val closestNumDistanceAbsDistanceAbsDistanceAbsDistance\
    \ = closestNumDistanceAbsDistanceAbsDistanceAbs.zipWithIndex.filter(_._1 == num).map(_._2).sum\n\
    \        val closestNumDistanceAbsDistanceAbsDistanceAbsDistanceAbs = closestNumDistanceAbsDistanceAbsDistanceAbsDistance\
    \ / closestNumDistanceAbsDistanceAbsDistanceAbs\n        val closestNumDistanceAbsDistanceAbsDistanceAbsDistanceAbsIndex\
    \ = closestNumDistanceAbsDistanceAbsDistanceAbsDistanceAbs.lastIndex\n       \
    \ val closestNumDistanceAbsDistanceAbsDistanceAbsDistanceAbsDistance = closestNumDistanceAbsDistanceAbsDistanceAbsDistanceAbs.zipWithIndex.filter(_._1\
    \ == num).map(_._2).sum\n        val closestNumDistance\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkagy5d2u.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkagy5d2u.scala:22:41\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclosestNumIndex\e[0m = numsSorted.lastIndex\n\e[31m\e[31m   |\e[0m       \
    \                       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue lastIndex\
    \ is not a member of List[String] - did you mean numsSorted.lastIndexOf?\n\e[31m\e\
    [31m-- Error: /tmp/tmpkagy5d2u.scala:23:64 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestNumDistance\e[0m\
    \ = numsSorted.zipWithIndex.filter(_._1 == num).map(_._2).sum\n\e[31m\e[31m  \
    \ |\e[0m                                                                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types String @uncheckedVariance and Long cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpkagy5d2u.scala:24:55\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mclosestNumDistanceAbs\e[0m = closestNumDistance / closestNum\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m/\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m   |\e[0m  (x: Long): Long\n\
    \e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m  (x: Char): Int\n\e[31m   |\e\
    [0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte): Int\n\e[31m   |\e[0m match arguments\
    \ ((closestNum : String))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkagy5d2u.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue)\n        val intsSet = ints.toSet\n\
    \        val intsSetSize = intsSet.size\n        val intsSetIterator = intsSet.iterator\n\
    \        val intsSetIteratorNext = intsSetIterator.next\n        val intsSetIteratorNextValue\
    \ = intsSetIteratorNext.get\n        val intsSetIteratorNextNext = intsSetIteratorNext.next\n\
    \        val intsSetIteratorNextNextValue = intsSetIteratorNextNext.get\n    \
    \    val intsSetIteratorNextNextNext = intsSetIteratorNextNext.next\n        val\
    \ intsSetIteratorNextNextNextValue = intsSetIteratorNextNextNext.get\n       \
    \ val intsSetIteratorNextNextNextNext = intsSetIteratorNextNextNext.next\n   \
    \     val intsSetIteratorNextNextNextNextValue = intsSetIteratorNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNext = intsSetIteratorNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNextNextNextNext.next\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNextValue = intsSetIteratorNextNextNextNextNextNextNextNextNextNextNext.get\n\
    \        val intsSetIteratorNextNextNextNextNextNextNextNextNextNext = intsSetIteratorNextNextNextNextNextNextNextNextNextNext\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpphyxnfg7.scala:24:59 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintsSetIteratorNextValue\e\
    [0m = intsSetIteratorNext.get\n\e[31m\e[31m   |\e[0m                         \
    \              ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      value get is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpphyxnfg7.scala:25:58 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintsSetIteratorNextNext\e[0m\
    \ = intsSetIteratorNext.next\n\e[31m\e[31m   |\e[0m                          \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                    value next is not a member of Int\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpphyxnfg7.scala:35:58 ---------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mintsSetIteratorNextNextNextNextNextNextNext\e\
    [0m = intsSetIteratorNextNextNextNextNextNextNext.next\n\e[31m\e[31m   |\e[0m\
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0m  Recursive \e[33mvalue\e[0m \e[35mintsSetIteratorNextNextNextNextNextNextNext\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpphyxnfg7.scala:37:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintsSetIteratorNextNextNextNextNextNextNextNext\e[0m = intsSetIteratorNextNextNextNextNextNextNextNext.next\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintsSetIteratorNextNextNextNextNextNextNextNext\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpphyxnfg7.scala:41:70\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintsSetIteratorNextNextNextNextNextNextNextNextNextNext\e[0m = intsSetIteratorNextNextNextNextNextNextNextNextNextNext\n\
    \e[31m\e[31m   |\e[0m            "
  stdout: ''
  timestamp: 1659805672
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        if (diff < 1)\
    \ {\n            val roundTo = min + diff\n            val roundFrom = numbers.min\n\
    \            val roundDiff = roundFrom - roundTo\n            if (roundDiff <\
    \ 1) {\n                roundTo\n            } else {\n                roundFrom\n\
    \            }\n        } else {\n            min\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw0v72p39.scala:37)\n\tat Problem.main(tmpw0v72p39.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minNum = math.min(nums)\n \
    \       val maxNum = math.max(nums)\n        val diff = (maxNum - minNum).toInt\n\
    \        val closestNum = math.round(minNum + diff / 2)\n        closestNum.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2usytjri.scala:19:26 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminNum\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2usytjri.scala:20:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmaxNum\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float,\
    \ y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m\
    \ (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff * nums.last).toLong\n        math.round(closest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptn6etpfz.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptn6etpfz.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2) + intArray(3) + intArray(4) + intArray(5)\
    \ + intArray(6)\n        val intArrayDiff = intArraySum - intArrayMax\n      \
    \  val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin = intArrayDiffAbs.min\n\
    \        val intArrayDiffAbsMax = intArrayDiffAbs.max\n        val intArrayDiffAbsSum\
    \ = intArrayDiffAbs(0) + intArrayDiffAbs(1) + intArrayDiffAbs(2) + intArrayDiffAbs(3)\
    \ + intArrayDiffAbs(4) + intArrayDiffAbs(5) + intArrayDiffAbs(6)\n        val\
    \ intArrayDiffAbsDiff = intArrayDiffAbsSum - intArrayMin\n        val intArrayDiffAbsDiffAbs\
    \ = intArrayDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n        val\
    \ intArrayDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1)\
    \ + intArrayDiffAbsDiffAbs(2) + intArrayDiffAbsDiffAbs(3) + intArrayDiffAbsDiffAbs(4)\
    \ + intArrayDiffAbsDiffAbs(5) + intArrayDiffAbsDiffAbs(6)\n        val intArrayDiffAbsDiffAbsDiff\
    \ = intArrayDiffAbsDiffAbsSum - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbs\
    \ = intArrayDiffAbsDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsDiffAbsMax\
    \ = intArrayDiffAbsDiffAbsDiffAbs.max\n        val intArrayDiffAbsDiffAbsDiffAbsSum\
    \ = intArrayDiffAbsDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbsDiffAbs(1) + intArrayDiffAb\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp3tsh9_f3.scala:28:33 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffAbsSum\e[0m\
    \ = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e[31m1\e[0m) + intArrayDiffAbs(\e\
    [31m2\e[0m) + intArrayDiffAbs(\e[31m3\e[0m) + intArrayDiffAbs(\e[31m4\e[0m) +\
    \ intArrayDiffAbs(\e[31m5\e[0m) + intArrayDiffAbs(\e[31m6\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          \e[33mvalue\e[0m \e[35mintArrayDiffAbs\e[0m does\
    \ not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3tsh9_f3.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.min(numbers).toLong\
    \ - math.max(numbers).toLong\n        math.max(numbers).toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpq95aunzz.scala:19:27 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.min(numbers).toLong\
    \ - math.max(numbers).toLong\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpq95aunzz.scala:20:13 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        math.max(numbers).toLong\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9wzdnnt9.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp9wzdnnt9.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val roundTo = math.round(difference)\n        roundTo\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp23bnf2k8.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp23bnf2k8.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805671
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ difference = afterInt - beforeInt\n        if (difference < 0)\n           \
    \ beforeInt + difference\n        else\n            beforeInt - difference\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpybo2ryr_.scala:20)\n\tat Problem$.main(tmpybo2ryr_.scala:30)\n\
    \tat Problem.main(tmpybo2ryr_.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.asInstanceOf[String]\n\
    \        val numAsLong = num.toLong\n        val numAsDouble = num.toDouble\n\
    \        val numAsInt = num.toInt\n        val numAsLongs = num.toLong\n     \
    \   val numAsDoubles = num.toDouble\n        val numAsInts = num.toInt\n     \
    \   val numAsLongsOrDoubles = num.toLongOrDouble\n        val numAsDoublesOrInts\
    \ = num.toDoubleOrInt\n        val numAsLongsOrDoublesOrInts = num.toLongOrDoubleOrInt\n\
    \        val numAsDoublesOrIntsOrLongs = num.toDoubleOrIntOrLong\n        val\
    \ numAsDoublesOrIntsOrLongsOrDoubles = num.toDoubleOrIntOrLongOrDouble\n     \
    \   val numAsDoublesOrIntsOrLongsOrDoublesOrInts = num.toDoubleOrIntOrLongOrDoubleOrInt\n\
    \        val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongs = num.toDoubleOrIntOrLongOrDoubleOrIntOrLong\n\
    \        val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoubles = num.toDoubleOrIntOrLongOrDoubleOrIntOrLongOrDouble\n\
    \        val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrInts =\
    \ num.toDoubleOrIntOrLongOrDoubleOrIntOrLongOrDoubleOrInt\n        val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrIntsOrLongs\
    \ = num.toDoubleOrIntOrLongOrDoubleOrIntOrLongOrDoubleOrIntOrLong\n        val\
    \ numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoubles\
    \ = num.toDoubleOrIntOrLongOrDoubleOrIntOrLongOrDoubleOrIntOrLongOrDouble\n  \
    \      val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrInts\
    \ = num.toDoubleOrIntOrLongOrDoubleOrIntOrLongOrDoubleOrIntOrLongOrDoubleOrInt\n\
    \        val numAsDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOrDoublesOrIntsOrLongsOr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4eoqtme2.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4eoqtme2.scala:25:38\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mnumAsLongsOrDoubles\e[0m = num.toLongOrDouble\n\e[31m\e[31m   |\e[0m     \
    \                             ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                   value toLongOrDouble is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4eoqtme2.scala:26:37 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnumAsDoublesOrInts\e[0m\
    \ = num.toDoubleOrInt\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value toDoubleOrInt is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4eoqtme2.scala:27:44\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mnumAsLongsOrDoublesOrInts\e[0m = num.toLongOrDoubleOrInt\n\e[31m\e[31m   |\e\
    [0m                                        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     value toLongOrDoubleOrInt is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4eoqtme2.scala:28:44 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mnumAsDoublesOrIntsOrLongs\e\
    [0m = num.toDoubleOrIntOrLong\n\e[31m\e[31m   |\e[0m                         \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \     value toDoubleOrIntOrLong is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4eoqtme2.scala:29:53 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mnumAsDoublesOrIntsOrLongsOrDoubles\e\
    [0m = num.toDoubleOrIntOrLongOrDouble\n\e[31m\e[31m   |\e[0m                 \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m             value toDoubleOrIntOrLongOrDouble is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp"
  stdout: ''
  timestamp: 1659805678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val integers = numbers.map(_.toInt)\n\
    \        val differences = numbers.zip(integers).map {\n            case (number,\
    \ integer) => Math.abs(number - integer)\n        }\n        val closestDifference\
    \ = differences.min\n        val closestInteger = closestDifference match {\n\
    \            case 0 => numbers(0)\n            case _ => numbers(0)\n        }\n\
    \        closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwl2shzea.scala:21:54 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m (number, integer) => Math.abs(number\
    \ - integer)\n\e[31m\e[31m   |\e[0m                                          \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpwl2shzea.scala:23:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mclosestDifference\e[0m =\
    \ differences.min\n\e[31m\e[31m   |\e[0m                                     \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type\
    \ Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659805676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        if (diff\
    \ < 0)\n            min - diff\n        else\n            max + diff\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp13f07l4m.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp13f07l4m.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val differences = numbers.zip(numbers.tail).map\
    \ { case (x, y) => x - y }\n        val closestDifference = differences.min\n\
    \        val closestInteger = closestDifference + numbers.head\n        closestInteger\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.closestInteger(tmpvrqjuww8.scala:20)\n\tat Problem$.main(tmpvrqjuww8.scala:25)\n\
    \tat Problem.main(tmpvrqjuww8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        val diff2 = closest - nums.head\n        if (diff2\
    \ > 0) closest else -closest\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmppmzlrwr2.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmppmzlrwr2.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc0503u_r.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into two parts\n        val int1 = parts(0).toLong\
    \ // First part is integer\n        val int2 = parts(1).toLong // Second part\
    \ is integer\n        val diff = (int2 - int1)\n        val diffAbs = Math.abs(diff)\n\
    \        val closestInteger = int1 + diff / diffAbs\n        closestInteger.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpz0r1d_hf.scala:20)\n\tat Problem$.main(tmpz0r1d_hf.scala:27)\n\
    \tat Problem.main(tmpz0r1d_hf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805677
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvc5y16g1.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvc5y16g1.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split on decimal point\n        val intPart = parts(0).toInt\
    \ // First part is integer\n        val fractionPart = parts(1).toInt // Second\
    \ part is fraction\n        val fraction = fractionPart * 1.0 / 10 // Convert\
    \ fraction to decimal\n        val difference = fractionPart - intPart * fraction\n\
    \        val closestInteger = intPart + difference\n        closestInteger\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0nzok1wt.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        closestInteger\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (closestInteger\
    \ : Double)\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.asInstanceOf[String]\n\
    \        val numAsLong = num.toLong\n        val numAsDouble = num.toDouble\n\
    \        val numAsInt = num.toInt\n        val numAsLongArray = num.toLongArray\n\
    \        val numAsDoubleArray = num.toDoubleArray\n        val numAsIntArray =\
    \ num.toIntArray\n        val numAsLongBuffer = num.toLongBuffer\n        val\
    \ numAsDoubleBuffer = num.toDoubleBuffer\n        val numAsIntBuffer = num.toIntBuffer\n\
    \        val numAsLongArrayBuffer = num.toLongArrayBuffer\n        val numAsDoubleArrayBuffer\
    \ = num.toDoubleArrayBuffer\n        val numAsIntArrayBuffer = num.toIntArrayBuffer\n\
    \        val numAsLongArraySeq = num.toLongArraySeq\n        val numAsDoubleArraySeq\
    \ = num.toDoubleArraySeq\n        val numAsIntArraySeq = num.toIntArraySeq\n \
    \       val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDoubleArraySeqBuffer\n        val numAsIntArraySeqBuffer = num.toIntArraySeqBuffer\n\
    \        val numAsLongArraySeqBuffer = num.toLongArraySeqBuffer\n        val numAsDoubleArraySeqBuffer\
    \ = num.toDouble\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyd71e1ym.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mnumAsLongArraySeqBuffer\e\
    [0m = num.toLongArraySeqBuffer\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsLongArraySeqBuffer is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsLongArraySeqBuffer\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyd71e1ym.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mnumAsDoubleArraySeqBuffer\e\
    [0m = num.toDoubleArraySeqBuffer\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsDoubleArraySeqBuffer is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsDoubleArraySeqBuffer\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyd71e1ym.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mnumAsIntArraySeqBuffer\e\
    [0m = num.toIntArraySeqBuffer\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsIntArraySeqBuffer is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsIntArraySeqBuffer\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyd71e1ym.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mnumAsLongArraySeqBuffer\e\
    [0m = num.toLongArraySeqBuffer\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnumAsLongArraySeqBuffer is already defined as \e[33mvalue\e\
    [0m \e[35mnumAsLongArraySeqBuffer\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1659805683
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ difference = afterInt - beforeInt\n        if (difference < 0)\n           \
    \ beforeInt + difference\n        else\n            beforeInt - difference\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpfsztifgh.scala:20)\n\tat Problem$.main(tmpfsztifgh.scala:30)\n\
    \tat Problem.main(tmpfsztifgh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\".\").map(_.toInt)\n        val closest = (numbers(0) + numbers(1)).abs.min\n\
    \        if (closest == numbers(0)) {\n            numbers(1)\n        } else\
    \ {\n            numbers(0)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2ix2wry0.scala:20:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (closest == numbers(\e[31m0\e[0m))\
    \ {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m     Values of types Int => Int and Int cannot be compared with == or !=\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc0503u_r.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intValues = mutable.ListBuffer(intValue)\n      \
    \  val intValueCount = intValues.size\n        val intValueSum = intValues.sum\n\
    \        val intValueSumSquare = intValues.sum * intValues.sum\n        val intValueSumSquareDiff\
    \ = intValueSumSquare - intValueCount * intValueSum\n        val intValueSumSquareDiffAbs\
    \ = intValueSumSquareDiff / intValueCount\n        val intValueSumSquareDiffAbsDiff\
    \ = intValueSumSquareDiffAbs - intValueSum\n        val intValueSumSquareDiffAbsDiffAbs\
    \ = intValueSumSquareDiffAbsDiff / intValueCount\n        val intValueSumSquareDiffAbsDiffAbsDiff\
    \ = intValueSumSquareDiffAbsDiffAbs - intValueSum\n        val intValueSumSquareDiffAbsDiffAbsDiffAbs\
    \ = intValueSumSquareDiffAbsDiffAbsDiff / intValueCount\n        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiff\
    \ = intValueSumSquareDiffAbsDiffAbsDiffAbs - intValueSum\n        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs\
    \ = intValueSumSquareDiffAbsDiffAbsDiffAbsDiff / intValueCount\n        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs\
    \ = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs - intValueSum\n        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiff\
    \ = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - intValueSum\n     \
    \   val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ - intValueSum\n        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\
    \ = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs - intValueSum\n\
    \        val intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ - intValueSum\n\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg5sjoqut.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mintValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs\e\
    [0m = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs - intValueSum\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs is already defined\
    \ as \e[33mvalue\e[0m \e[35mintValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpg5sjoqut.scala:19:24 ------------------------\e[0m\e[0m\n\e[31m19 |\e\
    [0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ListBuffer(intValue)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpg5sjoqut.scala:35:74 ------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mintValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\e\
    [0m = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ - intValueSum\n\e[31m\e[31m   |\e[0m                                       \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg5sjoqut.scala:34:71\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mintValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiff\e[0m = intValueSumSquareDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs\
    \ - intValueSum\n\e[31m\e[31m   |\e[0m                                       \
    \                   "
  stdout: ''
  timestamp: 1659805682
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val difference = parts.zip(parts).map\
    \ {\n            case (first, second) =>\n                math.abs(first - second)\n\
    \        }.max\n        val closestPart = parts.zip(parts).map {\n           \
    \ case (first, second) =>\n                if (math.abs(first - second) < difference)\
    \ {\n                    math.abs(first - second)\n                } else {\n\
    \                    math.abs(second - first)\n                }\n        }.max\n\
    \        closestPart.toLong\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0maz_3g3.scala:34)\n\tat Problem.main(tmp0maz_3g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        if\
    \ (diff < 0)\n            min - diff\n        else\n            max + diff\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxyqys4eh.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpxyqys4eh.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = (max - min).toInt\n\
    \        val closest = (min + diff) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpneuxle7_.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpneuxle7_.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805680
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val differences = numbers.zip(numbers.tail).map\
    \ { case (first, second) =>\n            Math.abs(first - second)\n        }\n\
    \        val closestDifference = differences.min\n        val closestInteger =\
    \ math.ceil(closestDifference / 2).toLong\n        closestInteger\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.closestInteger(tmpqyl7f7v8.scala:22)\n\tat Problem$.main(tmpqyl7f7v8.scala:27)\n\
    \tat Problem.main(tmpqyl7f7v8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805685
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val difference = abs(intValue - intValue)\n        val\
    \ closestInteger = intValue + difference\n        closestInteger\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp675u0w85.scala:18)\n\
    \tat Problem$.main(tmp675u0w85.scala:25)\n\tat Problem.main(tmp675u0w85.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = List(\"10\", \"15\", \"20\", \"25\", \"30\", \"35\", \"40\"\
    , \"45\", \"50\", \"55\", \"60\", \"65\", \"70\", \"75\", \"80\", \"85\", \"90\"\
    , \"95\", \"100\")\n        val numsIndex = nums.indexOf(value)\n        val numsIndex2\
    \ = nums.indexOf(value.substring(0,1))\n        val numsIndex3 = nums.indexOf(value.substring(0,2))\n\
    \        val numsIndex4 = nums.indexOf(value.substring(0,3))\n        val numsIndex5\
    \ = nums.indexOf(value.substring(0,4))\n        val numsIndex6 = nums.indexOf(value.substring(0,5))\n\
    \        val numsIndex7 = nums.indexOf(value.substring(0,6))\n        val numsIndex8\
    \ = nums.indexOf(value.substring(0,7))\n        val numsIndex9 = nums.indexOf(value.substring(0,8))\n\
    \        val numsIndex10 = nums.indexOf(value.substring(0,9))\n        val numsIndex11\
    \ = nums.indexOf(value.substring(0,10))\n        val numsIndex12 = nums.indexOf(value.substring(0,11))\n\
    \        val numsIndex13 = nums.indexOf(value.substring(0,12))\n        val numsIndex14\
    \ = nums.indexOf(value.substring(0,13))\n        val numsIndex15 = nums.indexOf(value.substring(0,14))\n\
    \        val numsIndex16 = nums.indexOf(value.substring(0,15))\n        val numsIndex17\
    \ = nums.indexOf(value.substring(0,16))\n        val numsIndex18 = nums.indexOf(value.substring(0,17))\n\
    \        val numsIndex19 = nums.indexOf(value.substring(0,18))\n        val numsIndex20\
    \ = nums.indexOf(value.substring(0,19))\n        val numsIndex21 = nums.indexOf(value.substring(0,20))\n\
    \        val numsIndex22 = nums.indexOf(value.substring(0,21))\n        val numsIndex23\
    \ = nums.indexOf(value.substring(0,22))\n        val numsIndex24 = nums.indexOf(value.substring(0,23))\n\
    \        val numsIndex25 = nums.indexOf(value.substring(0,24))\n        val numsIndex26\
    \ = nums.indexOf(value.substring(0,25))\n        val numsIndex27 = nums.indexOf(value.substring(0,26))\n\
    \        val numsIndex28 = nums.indexOf(value.substring(0,27))\n        val numsIndex29\
    \ = nums.indexOf(value.substring(\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuieznspk.scala:48:55 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mnumsIndex29\e[0m = nums.indexOf(value.substring(\n\
    \e[31m\e[31m   |\e[0m                                                       ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpuieznspk.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val roundTo\
    \ = math.round(diff * 0.5).toLong\n        roundTo\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv278x2r6.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpv278x2r6.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805681
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.abs(numbers.min\
    \ - numbers.max)\n        val closestDiff = math.abs(numbers.min - numbers.max)\n\
    \        val closestDiffIndex = numbers.indexOf(minDiff)\n        if (closestDiffIndex\
    \ == -1) minDiff\n        else closestDiffIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfa680cv4.scala:26)\n\tat Problem.main(tmpfa680cv4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val min = math.min(num, math.min(num - 10, num - 15))\n        val max\
    \ = math.max(num, math.max(num - 10, num - 15))\n        val diff = max - min\n\
    \        val roundTo = math.abs(diff)\n        val roundToInt = math.round(roundTo)\n\
    \        val roundToIntInt = math.abs(roundToInt)\n        val roundToIntIntInt\
    \ = math.round(roundToIntInt)\n        val roundToIntIntIntInt = math.abs(roundToIntIntInt)\n\
    \        val roundToIntIntIntIntInt = math.round(roundToIntIntIntInt)\n      \
    \  val roundToIntIntIntIntIntInt = math.abs(roundToIntIntIntIntInt)\n        val\
    \ roundToIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntInt)\n  \
    \      val roundToIntIntIntIntIntIntIntIntInt = math.abs(roundToIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntInt = math.abs(roundToIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.abs(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.abs(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val roundToIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgztupshd.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgztupshd.scala:29:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mroundToIntIntIntIntIntIntInt\e[0m = math.round(roundToIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mroundToIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgztupshd.scala:30:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mroundToIntIntIntIntIntIntIntIntInt\e[0m = math.abs(roundToIntIntIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^\e[0m\n\e[31m   |\e[0m           Recursive \e[33mvalue\e[0m \e[35mroundToIntIntIntIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgztupshd.scala:31:63\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mroundToIntIntIntIntIntIntIntIntIntInt\e[0m = math.round(roundToIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \              Not found: roundToIntIntIntIntIntIntIntIntIntIntIntInt\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgztupshd.scala:32:64 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mroundToIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m = math.abs(roundToIntIntIntIntIntIntIntIntIntIntIntInt)\n\e[31m\e[31m   |\e\
    [0m                                                                ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805683
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.abs(nums(0)\
    \ - nums(1))\n        val maxDiff = math.abs(nums(0) - nums(2))\n        val minDiffIndex\
    \ = math.min(minDiff, maxDiff)\n        val maxDiffIndex = math.max(minDiff, maxDiff)\n\
    \        val index = math.min(minDiffIndex, maxDiffIndex)\n        nums(0)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpnix0hmg9.scala:19)\n\tat Problem$.main(tmpnix0hmg9.scala:27)\n\
    \tat Problem.main(tmpnix0hmg9.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp64abstej.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp64abstej.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805682
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqtmpvgct.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqtmpvgct.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArraySum = intArray(0)\
    \ + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum - intArrayMax\n\
    \        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMax = intArrayDiffAbs.max\n\
    \        val intArrayDiffAbsSum = intArrayDiffAbs(0) + intArrayDiffAbs(1) + intArrayDiffAbs(2)\n\
    \        val intArrayDiffAbsDiff = intArrayDiffAbsSum - intArrayMax\n        val\
    \ intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1)\
    \ + intArrayDiffAbsDiffAbs(2)\n        val intArrayDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbsDiffAbs(0)\
    \ + intArrayDiffAbsDiffAbsDiffAbs(1) + intArrayDiffAbsDiffAbsDiffAbs(2)\n    \
    \    val intArrayDiffAbsDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiff\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptatardg_.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmptatardg_.scala:28:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e\
    [0m \e[36mintArrayDiffAbsSum\e[0m = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e\
    [31m1\e[0m) + intArrayDiffAbs(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         \e[33mvalue\e[0m \e[35mintArrayDiffAbs\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptatardg_.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805684
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = parts.min\n        val\
    \ max = parts.max\n        val diff = max - min\n        val roundTo = diff /\
    \ 2\n        val roundFrom = min - roundTo\n        val round = roundTo + roundFrom\n\
    \        val roundedValue = if (round < min) min else round\n        roundedValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv4_i9w4b.scala:30)\n\tat Problem.main(tmpv4_i9w4b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDiff = intArraySum - intArray(0)\n        val intArrayDiffLength\
    \ = intArrayDiff.length\n        val intArrayDiffSum = intArrayDiff.sum\n    \
    \    val intArrayDiffSumLength = intArrayDiffSum.length\n        val intArrayDiffSumLength\
    \ = intArrayDiffSumLength\n        val intArrayDiffSumLength2 = intArrayDiffSumLength\
    \ * intArrayDiffSumLength\n        val intArrayDiffSumLength3 = intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength\n        val intArrayDiffSumLength4\
    \ = intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\n\
    \        val intArrayDiffSumLength5 = intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\n\
    \        val intArrayDiffSumLength6 = intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\n  \
    \      val intArrayDiffSumLength7 = intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength * intArrayDiffSumLength\
    \ * intArrayDiffSumLength * int\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm43jvidl.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSumLength\e\
    [0m = intArrayDiffSumLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDiffSumLength is already defined as \e[33mvalue\e\
    [0m \e[35mintArrayDiffSumLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm43jvidl.scala:23:46 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffLength\e[0m\
    \ = intArrayDiff.length\n\e[31m\e[31m   |\e[0m                               \
    \  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 value\
    \ length is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm43jvidl.scala:24:43\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffSum\e[0m = intArrayDiff.sum\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \           value sum is not a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpm43jvidl.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (diff == 0) ? min : min + (diff / 2)\n        val diff2 = closest - numbers.last\n\
    \        val diff3 = numbers.last - closest\n        val diff4 = numbers.last\
    \ - numbers.last\n        val diff5 = numbers.last - numbers.last\n        val\
    \ diff6 = numbers.last - numbers.last\n        val diff7 = numbers.last - numbers.last\n\
    \        val diff8 = numbers.last - numbers.last\n        val diff9 = numbers.last\
    \ - numbers.last\n        val diff10 = numbers.last - numbers.last\n        val\
    \ diff11 = numbers.last - numbers.last\n        val diff12 = numbers.last - numbers.last\n\
    \        val diff13 = numbers.last - numbers.last\n        val diff14 = numbers.last\
    \ - numbers.last\n        val diff15 = numbers.last - numbers.last\n        val\
    \ diff16 = numbers.last - numbers.last\n        val diff17 = numbers.last - numbers.last\n\
    \        val diff18 = numbers.last - numbers.last\n        val diff19 = numbers.last\
    \ - numbers.last\n        val diff20 = numbers.last - numbers.last\n        val\
    \ diff21 = numbers.last - numbers.last\n        val diff22 = numbers.last - numbers.last\n\
    \        val diff23 = numbers.last - numbers.last\n        val diff24 = numbers.last\
    \ - numbers.last\n        val diff25 = numbers.last - numbers.last\n        val\
    \ diff26 = numbers.last - numbers.last\n        val diff27 = numbers.last - numbers.last\n\
    \        val diff28 = numbers.last - numbers.last\n        val diff29 = numbers.last\
    \ - numbers.last\n        val diff30 = numbers.last - numbers.last\n        val\
    \ diff31 = numbers.last - numbers.last\n        val diff32 = numbers.last - numbers.last\n\
    \        val diff33 = numbers.last - numbers.last\n        val diff34 = numbers.last\
    \ - numbers.last\n        val diff35 = numbers.last - numbers.last\n        val\
    \ diff36 = numbers.last - numbers.last\n        val diff37 = numbers.last - numbers.last\n\
    \        val diff38 = numbers.last - numbers.last\n        val diff39 = numbers.last\
    \ - numbers.last\n        val diff40 = numbers.last - numbers.last\n        val\
    \ diff41 = numbers.last - numbers.last\n        val diff42 = numbers.last - numbers.last\n\
    \        val diff43 = numbers.last - numbers.last\n        val diff44 = numbers.last\
    \ - numbers.last\n        val diff45 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnkuu7bb9.scala:66:20 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e[36mdiff45\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnkuu7bb9.scala:22:46 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff == \e[31m0\e[0m) ? min :\
    \ \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e[0m \e[31m2\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                              Not found: type +\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkuu7bb9.scala:22:34\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclosest\e[0m = (diff == \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m\
    \ (\e[35mdiff\e[0m \e[35m/\e[0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value ?\
    \ is not a member of Boolean\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnkuu7bb9.scala:67:5\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = (max - min).toInt\n \
    \       val closest = (diff + min).toLong\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpiozip6r4.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpiozip6r4.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = (max - min).toInt\n \
    \       val closest = (min + diff) / 2\n        math.round(closest)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmprzpye6ek.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprzpye6ek.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805687
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into integer and fraction\n        val fraction\
    \ = parts(1).toLong // Get fraction\n        val integer = parts(0).toLong //\
    \ Get integer\n        val difference = fraction - integer // Calculate difference\n\
    \        if (difference < 0)\n            difference + Integer.MAX_VALUE\n   \
    \     else\n            difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpyq815iol.scala:19)\n\tat Problem$.main(tmpyq815iol.scala:28)\n\
    \tat Problem.main(tmpyq815iol.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\".\").map(_.toInt)\n        val min = math.min(nums)\n        val\
    \ max = math.max(nums)\n        val diff = (max - min).toInt\n        val closest\
    \ = (min + diff) / 2\n        val closestInteger = math.round(closest)\n     \
    \   closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf8ltuy_p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf8ltuy_p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue.toLong - intValue.toLong % intValue.toLong,\
    \ intValue.toLong)\n        ints.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmp1qielqth.scala:18)\n\
    \tat Problem$.main(tmp1qielqth.scala:24)\n\tat Problem.main(tmp1qielqth.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.split('.').map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvc5y16g1.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvc5y16g1.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvc5y16g1.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805678
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArray2 = intArray.drop(intArrayLength-1)\n\
    \        val intArray3 = intArray2.drop(intArray2.length-1)\n        val intArray4\
    \ = intArray3.drop(intArray3.length-1)\n        val intArray5 = intArray4.drop(intArray4.length-1)\n\
    \        val intArray6 = intArray5.drop(intArray5.length-1)\n        val intArray7\
    \ = intArray6.drop(intArray6.length-1)\n        val intArray8 = intArray7.drop(intArray7.length-1)\n\
    \        val intArray9 = intArray8.drop(intArray8.length-1)\n        val intArray10\
    \ = intArray9.drop(intArray9.length-1)\n        val intArray11 = intArray10.drop(intArray10.length-1)\n\
    \        val intArray12 = intArray11.drop(intArray11.length-1)\n        val intArray13\
    \ = intArray12.drop(intArray12.length-1)\n        val intArray14 = intArray13.drop(intArray13.length-1)\n\
    \        val intArray15 = intArray14.drop(intArray14.length-1)\n        val intArray16\
    \ = intArray15.drop(intArray15.length-1)\n        val intArray17 = intArray16.drop(intArray16.length-1)\n\
    \        val intArray18 = intArray17.drop(intArray17.length-1)\n        val intArray19\
    \ = intArray18.drop(intArray18.length-1)\n        val intArray20 = intArray19.drop(intArray19.length-1)\n\
    \        val intArray21 = intArray20.drop(intArray20.length-1)\n        val intArray22\
    \ = intArray21.drop(intArray21.length-1)\n        val intArray23 = intArray22.drop(intArray22.length-1)\n\
    \        val intArray24 = intArray23.drop(intArray23.length-1)\n        val intArray25\
    \ = intArray24.drop(intArray24.length-1)\n        val intArray26 = intArray25.drop(intArray25.length-1)\n\
    \        val intArray27 = intArray26.drop(intArray26.length-1)\n        val intArray28\
    \ = intArray27.drop(intArray27.length-1)\n        val intArray29 = intArray28.drop(intArray28.length-1)\n\
    \        val intArray30 = intArray29.drop(intArray29.length-1)\n        val intArray31\
    \ = intArray30.drop(intArray30.length-1)\n        val intArray32 = intArray31.drop\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxo_ephvk.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val intArrayLength = intArrayLength.toInt\n\
    \        val intArrayLength = intArrayLength.toInt\n        val intArrayLength\
    \ = intArrayLength.toInt\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpmigzhn1z.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpmigzhn1z.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmigzhn1z.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmigzhn1z.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmigzhn1z.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote "
  stdout: ''
  timestamp: 1659805691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").toList\n        val ints = numbers.map(_.toInt)\n \
    \       val diffs = ints.zip(diffs(ints))\n        val minDiff = diffs.minBy(_._2)._2\n\
    \        val minDiffIndex = diffs.indexOf(minDiff)\n        val minDiffIndex =\
    \ minDiffIndex.toLong\n        val closestIndex = minDiffIndex - 1\n        val\
    \ closestValue = ints(closestIndex)\n        val closestInteger = closestValue.toLong\n\
    \        return closestInteger\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprvryi9di.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mminDiffIndex\e[0m = minDiffIndex.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminDiffIndex is already defined as \e[33mvalue\e[0m \e[35mminDiffIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmprvryi9di.scala:20:29 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = ints.zip(diffs(ints))\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Recursive \e[33mvalue\e[0m \e[35mdiffs\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmprvryi9di.scala:21:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = diffs.minBy(_._2)._2\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mLong\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter cmp of \e[33mmethod\e\
    [0m \e[35mminBy\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0)\n        val after = parts(1)\n       \
    \ val beforeInt = before.toInt\n        val afterInt = after.toInt\n        val\
    \ diff = Math.abs(afterInt - beforeInt)\n        if (diff == 0) {\n          \
    \  afterInt\n        } else {\n            beforeInt + diff\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpxpqer_c2.scala:20)\n\tat Problem$.main(tmpxpqer_c2.scala:31)\n\
    \tat Problem.main(tmpxpqer_c2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val round\
    \ = math.round(diff * 0.5).toLong\n        math.max(min, round)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67ahxz58.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67ahxz58.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = (max - min).toDouble\n\
    \        val closest = (min + diff) / 2\n        val closestInt = closest.toInt\n\
    \        closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpkpyzgcyn.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpkpyzgcyn.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = numbers.min\n     \
    \   val max = numbers.max\n        val diff = max - min\n        val closest =\
    \ (min + diff) / 2\n        if (diff < 0)\n            closest - min\n       \
    \ else\n            closest + min\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsx3z2n3i.scala:29)\n\tat Problem.main(tmpsx3z2n3i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805696
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val mid = math.round((min + max) / 2)\n\
    \        if (mid == min) {\n            return mid\n        }\n        if (mid\
    \ == max) {\n            return mid\n        }\n        if (mid - min == max -\
    \ mid) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ + 1) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 1) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 2) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 3) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 4) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 5) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 6) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 7) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 8) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 9) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 10) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 11) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 12) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 13) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 14) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 15) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 16) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 17) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 18) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 19) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 20) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 21) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 22) {\n            return mid\n        }\n        if (mid - min == max - mid\
    \ - 23) {\n            return mid\n        }\n        if (mid - min == max - \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpav06ro03.scala:103:30 --------------------------\e\
    [0m\e[0m\n\e[31m103 |\e[0m        \e[33mif\e[0m (mid - min == max - \n\e[31m\e\
    [31m    |\e[0m                              ^\e[0m\n\e[31m    |\e[0m         \
    \                     expression expected but \e[31m'}'\e[0m found\n\e[31m   \
    \ |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpav06ro03.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpav06ro03.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n3 errors found\n"
  stdout: ''
  timestamp: 1659805691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff / numbers.last).toInt\n        math.abs(closest - min)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpd0mq4m7s.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpd0mq4m7s.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        val difference = largest - smallest\n\
    \        val differenceAbs = math.abs(difference)\n        val closestInteger\
    \ = smallest + math.min(differenceAbs, differenceAbs * differenceAbs)\n      \
    \  closestInteger.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp14c40p6a.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp14c40p6a.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m\
    \ with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intValues = mutable.ArrayBuffer.empty[Long]\n   \
    \     val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues =\
    \ mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbrk5xo9r.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayB"
  stdout: ''
  timestamp: 1659805695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue.toLong, intValue.toLong - 1,\
    \ intValue.toLong - 2, intValue.toLong - 3, intValue.toLong - 4, intValue.toLong\
    \ - 5, intValue.toLong - 6, intValue.toLong - 7, intValue.toLong - 8, intValue.toLong\
    \ - 9, intValue.toLong - 10, intValue.toLong - 11, intValue.toLong - 12, intValue.toLong\
    \ - 13, intValue.toLong - 14, intValue.toLong - 15, intValue.toLong - 16, intValue.toLong\
    \ - 17, intValue.toLong - 18, intValue.toLong - 19, intValue.toLong - 20, intValue.toLong\
    \ - 21, intValue.toLong - 22, intValue.toLong - 23, intValue.toLong - 24, intValue.toLong\
    \ - 25, intValue.toLong - 26, intValue.toLong - 27, intValue.toLong - 28, intValue.toLong\
    \ - 29, intValue.toLong - 30, intValue.toLong - 31, intValue.toLong - 32, intValue.toLong\
    \ - 33, intValue.toLong - 34, intValue.toLong - 35, intValue.toLong - 36, intValue.toLong\
    \ - 37, intValue.toLong - 38, intValue.toLong - 39, intValue.toLong - 40, intValue.toLong\
    \ - 41, intValue.toLong - 42, intValue.toLong - 43, intValue.toLong - 44, intValue.toLong\
    \ - 45, intValue.toLong - 46, intValue.toLong - 47, intValue.toLong - 48, intValue.toLong\
    \ - 49, intValue.toLong - 50, intValue.toLong - 51, intValue.toLong - 52, intValue.toLong\
    \ - 53, intValue.toLong - 54, intValue.toLong - 55, intValue.toLong - 56, intValue.toLong\
    \ - 57, intValue.toLong - 58, intValue.toLong - 59, intValue.toLong - 60, intValue.toLong\
    \ - 61, intValue.toLong - 62, intValue.toLong - 63, intValue.toLong - 64, intValue.toLong\
    \ - 65, intValue.toLong - 66, intValue.toLong - 67, intValue.toLong - 68, intValue.toLong\
    \ - 69, intValue.toLong - 70, intValue.toLong - 71, intValue.toLong - 72, intValue.toLong\
    \ - 73, intValue.toLong - 74, intValue.toLong - 75, intValue.toLong - 76, intValue.toLong\
    \ - 77, intValue.toLong - 78, intValue.toLong - 79, intValue.to\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_ildk3yv.scala:20:4 ----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp_ildk3yv.scala:19:1779\
    \ ----------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mints\e\
    [0m = List(intValue.toLong, intValue.toLong - \e[31m1\e[0m, intValue.toLong -\
    \ \e[31m2\e[0m, intValue.toLong - \e[31m3\e[0m, intValue.toLong - \e[31m4\e[0m,\
    \ intValue.toLong - \e[31m5\e[0m, intValue.toLong - \e[31m6\e[0m, intValue.toLong\
    \ - \e[31m7\e[0m, intValue.toLong - \e[31m8\e[0m, intValue.toLong - \e[31m9\e\
    [0m, intValue.toLong - \e[31m10\e[0m, intValue.toLong - \e[31m11\e[0m, intValue.toLong\
    \ - \e[31m12\e[0m, intValue.toLong - \e[31m13\e[0m, intValue.toLong - \e[31m14\e\
    [0m, intValue.toLong - \e[31m15\e[0m, intValue.toLong - \e[31m16\e[0m, intValue.toLong\
    \ - \e[31m17\e[0m, intValue.toLong - \e[31m18\e[0m, intValue.toLong - \e[31m19\e\
    [0m, intValue.toLong - \e[31m20\e[0m, intValue.toLong - \e[31m21\e[0m, intValue.toLong\
    \ - \e[31m22\e[0m, intValue.toLong - \e[31m23\e[0m, intValue.toLong - \e[31m24\e\
    [0m, intValue.toLong - \e[31m25\e[0m, intValue.toLong - \e[31m26\e[0m, intValue.toLong\
    \ - \e[31m27\e[0m, intValue.toLong - \e[31m28\e[0m, intValue.toLong - \e[31m29\e\
    [0m, intValue.toLong - \e[31m30\e[0m, intValue.toLong - \e[31m31\e[0m, intValue.toLong\
    \ - \e[31m32\e[0m, intValue.toLong - \e[31m33\e[0m, intValue.toLong - \e[31m34\e\
    [0m, intValue.toLong - \e[31m35\e[0m, intValue.toLong - \e[31m36\e[0m, intValue.toLong\
    \ - \e[31m37\e[0m, intValue.toLong - \e[31m38\e[0m, intValue.toLong - \e[31m39\e\
    [0m, intValue.toLong - \e[31m40\e[0m, intValue.toLong - \e[31m41\e[0m, intValue.toLong\
    \ - \e[31m42\e[0m, intValue.toLong - \e[31m43\e[0m, intValue.toLong - \e[31m44\e\
    [0m, intValue.toLong - \e[31m45\e[0m, intValue.toLong - \e[31m46\e[0m, intValue.toLong\
    \ - \e[31m47\e[0m, intValue.toLong - \e[31m48\e[0m, intValue.toLong - \e[31m49\e\
    [0m, intValue.toLong - \e[31m50\e[0m, intValue.toLong - \e[31m51\e[0m, intValue.toLong\
    \ - \e[31m52\e[0m, intValue.toLong - \e[31m53\e[0m, intValue.toLong - \e[31m54\e\
    [0m, intValue.toLong - \e[3"
  stdout: ''
  timestamp: 1659805695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff / nums.last).toInt\n        math.round(min + closest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpve9rt39_.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpve9rt39_.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        math.abs(closest - value)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1j7qahhc.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1j7qahhc.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val mid = math.round(min + (max - min)\
    \ / 2)\n        val diff = math.abs(mid - min)\n        if (diff > 0) mid else\
    \ min\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu2kofjzy.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu2kofjzy.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805694
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into two parts separated by \".\"\n  \
    \      val part1 = parts(0).toLong // Convert the first part to a long\n     \
    \   val part2 = parts(1).toLong // Convert the second part to a long\n       \
    \ val diff = (part1 - part2).abs // Calculate the difference between the two parts\n\
    \        val closest = (diff + part2).abs % part2 // Calculate the closest integer\n\
    \        closest\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmpowczlzeg.scala:20)\n\tat Problem$.main(tmpowczlzeg.scala:26)\n\
    \tat Problem.main(tmpowczlzeg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val minDiff = math.abs(numbers.min()\
    \ - numbers.max())\n        val closestDiff = math.abs(numbers.min() - numbers.max())\n\
    \        val closestDiffIndex = numbers.indexOf(0)\n        val closestDiffIndex2\
    \ = numbers.indexOf(0)\n        val closestDiffIndex3 = numbers.indexOf(0)\n \
    \       val closestDiffIndex4 = numbers.indexOf(0)\n        val closestDiffIndex5\
    \ = numbers.indexOf(0)\n        val closestDiffIndex6 = numbers.indexOf(0)\n \
    \       val closestDiffIndex7 = numbers.indexOf(0)\n        val closestDiffIndex8\
    \ = numbers.indexOf(0)\n        val closestDiffIndex9 = numbers.indexOf(0)\n \
    \       val closestDiffIndex10 = numbers.indexOf(0)\n        val closestDiffIndex11\
    \ = numbers.indexOf(0)\n        val closestDiffIndex12 = numbers.indexOf(0)\n\
    \        val closestDiffIndex13 = numbers.indexOf(0)\n        val closestDiffIndex14\
    \ = numbers.indexOf(0)\n        val closestDiffIndex15 = numbers.indexOf(0)\n\
    \        val closestDiffIndex16 = numbers.indexOf(0)\n        val closestDiffIndex17\
    \ = numbers.indexOf(0)\n        val closestDiffIndex18 = numbers.indexOf(0)\n\
    \        val closestDiffIndex19 = numbers.indexOf(0)\n        val closestDiffIndex20\
    \ = numbers.indexOf(0)\n        val closestDiffIndex21 = numbers.indexOf(0)\n\
    \        val closestDiffIndex22 = numbers.indexOf(0)\n        val closestDiffIndex23\
    \ = numbers.indexOf(0)\n        val closestDiffIndex24 = numbers.indexOf(0)\n\
    \        val closestDiffIndex25 = numbers.indexOf(0)\n        val closestDiffIndex26\
    \ = numbers.indexOf(0)\n        val closestDiffIndex27 = numbers.indexOf(0)\n\
    \        val closestDiffIndex28 = numbers.indexOf(0)\n        val closestDiffIndex29\
    \ = numbers.indexOf(0)\n        val closestDiffIndex30 = numbers.indexOf(0)\n\
    \        val closestDiffIndex31 = numbers.indexOf(0)\n        val closestDiffIndex32\
    \ = numbers.indexOf(0)\n        val closestDiffIndex33 = numbers.indexOf(0)\n\
    \        val closestDiffIndex34 = numbers.indexOf(0)\n        val closestDiffIndex35\
    \ = numbers.indexOf(0)\n        val closestDiffIndex36 = numbers.indexOf(0)\n\
    \        val closestDiffIndex37 = numbers.indexOf(0)\n        val closestDiffIndex38\
    \ = numbers.indexOf(0)\n        val closestDiffIndex39 = numbers.indexOf(0)\n\
    \        val closestDiffIndex40 = numbers.indexOf(0)\n        val closestDiffIndex41\
    \ = numbers.indexOf(0)\n        val closestDiffIndex42 = numbers.indexOf(0)\n\
    \        val closestDiffIndex43 = numbers.indexOf(0)\n        val closestDiffIndex44\
    \ = numbers.indexOf(0)\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5wd3abzo.scala:19:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminDiff\e[0m = math.abs(numbers.min()\
    \ - numbers.max())\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter ord of \e[33mmethod\e[0m \e\
    [35mmin\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (\e[33mimplicit \e\
    [0mord: Ordering[B]): Int\n\e[31m\e[31m-- Error: /tmp/tmp5wd3abzo.scala:20:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mclosestDiff\e[0m = math.abs(numbers.min() - numbers.max())\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmissing argument for parameter ord of \e[33mmethod\e[0m \e[35mmin\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m: (\e[33mimplicit \e[0mord:\
    \ Ordering[B]): Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5wd3abzo.scala:65:5\
    \ ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805698
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.asInstanceOf[Array[Double]]\n\
    \        val intArrayLength = intArray.length\n        val closestInteger = intArray\n\
    \            .zipWithIndex\n            .sortWith((x, y) => x._1 - y._1)\n   \
    \         .last\n            .map(_._2)\n            .head\n        closestInteger\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdjkq07_5.scala:23:32\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            .sortWith((x, y)\
    \ => x._1 - y._1)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Found:    Double\n\e[31m \
    \  |\e[0m                                Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpdjkq07_5.scala:25:17 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            .map(_._2)\n\e[31m\e[31m   |\e[0m       \
    \          ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded\
    \ function:\n\e[31m   |\e[0m   _$1 => _$1._2.\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpdjkq07_5.scala:27:8 ---------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        closestInteger\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mFound:    (closestInteger : Tuple.Head[Nothing *: Nothing\
    \ *: EmptyTuple])\n\e[31m   |\e[0mRequired: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = (max - min).toInt\n        val\
    \ closest = (min + diff) / 2\n        val closestInt = closest.toLong\n      \
    \  closestInt\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpanzteu90.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = nums.min\n        val\
    \ max = nums.max\n        val diff = max - min\n        val closest = (min + max)\
    \ / 2.0\n        if (diff > 0) closest else closest - diff\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkp302a6m.scala:23:22\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (diff >\
    \ \e[31m0\e[0m) closest \e[33melse\e[0m closest - diff\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Found:\
    \    (closest : Double)\n\e[31m   |\e[0m                      Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkp302a6m.scala:23:35\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (diff >\
    \ \e[31m0\e[0m) closest \e[33melse\e[0m closest - diff\n\e[31m\e[31m   |\e[0m\
    \                                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                              Found:    Double\n\e[31m   |\e[0m             \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805699
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDiff = intArraySum - intArray(0)\n        val intArrayDiffSquared\
    \ = intArrayDiff * intArrayDiff\n        val intArrayDiffSquaredLength = intArrayDiffSquared.length\n\
    \        val intArrayDiffSquaredSum = intArrayDiffSquared.sum\n        val intArrayDiffSquaredDiff\
    \ = intArrayDiffSquaredSum - intArrayDiffSquared(0)\n        val intArrayDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiff * intArrayDiffSquaredDiff\n        val intArrayDiffSquaredDiffSquaredLength\
    \ = intArrayDiffSquaredDiffSquared.length\n        val intArrayDiffSquaredDiffSquaredSum\
    \ = intArrayDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiff\
    \ = intArrayDiffSquaredDiffSquaredSum - intArrayDiffSquaredDiffSquared(0)\n  \
    \      val intArrayDiffSquaredDiffSquaredDiffSquared = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquaredDiffSquared(0)\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredLength\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.length\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredDiff\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum - intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared(0)\n\
    \        val intArrayDiffSquaredDiff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjpjqubzq.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjpjqubzq.scala:24:60\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffSquaredLength\e[0m = intArrayDiffSquared.length\n\e[31m\e[31m\
    \   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value length is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjpjqubzq.scala:25:57\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mintArrayDiffSquaredSum\e[0m = intArrayDiffSquared.sum\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                     value sum is not a member of Int\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjpjqubzq.scala:31:56 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n\e[31m\e[31m   |\e[0m   \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \    Recursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjpjqubzq.scala:35:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjpjqubzq.scala:40:5\
    \ -----------"
  stdout: ''
  timestamp: 1659805700
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff / 2).round()\n        math.abs(closest - min)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpeoopgmi5.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpeoopgmi5.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805697
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val difference = num - num.abs\n        val closest = (difference / num.abs).ceil\n\
    \        val closestInt = num.abs - closest * num.abs\n        closestInt\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpffunrqpe.scala:20:45 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (difference\
    \ / num.abs).ceil\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value ceil is not a member of Long.\n\e[31m   |\e[0m\
    \      An extension method was tried, but could not be fully constructed:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m          doubleWrapper(difference./(longWrapper(num).abs))\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805696
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // split into two parts, one before the decimal and one\
    \ after\n        val before = parts(0).toLong // convert first part to long\n\
    \        val after = parts(1).toLong // convert second part to long\n        val\
    \ diff = Math.abs(after - before) // get the difference between the two numbers\n\
    \        val closest = (diff + before) / 2 // find the closest number\n      \
    \  closest.toLong // return the closest number\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmp3p1og4go.scala:20)\n\tat Problem$.main(tmp3p1og4go.scala:26)\n\
    \tat Problem.main(tmp3p1og4go.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArraySum\
    \ = intArray.sum\n        val intArrayDiff = intArraySum - intArray(0)\n     \
    \   val intArrayDiffSquared = intArrayDiff * intArrayDiff\n        val intArrayDiffSquaredLength\
    \ = intArrayDiffSquared.length\n        val intArrayDiffSquaredSum = intArrayDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiff = intArrayDiffSquaredSum - intArrayDiffSquared(0)\n\
    \        val intArrayDiffSquaredDiffSquared = intArrayDiffSquaredDiff * intArrayDiffSquaredDiff\n\
    \        val intArrayDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquared(0)\n        val intArrayDiffSquaredDiffSquaredDiffSquared\
    \ = intArrayDiffSquaredDiffSquaredDiffSquared.asInstanceOf[Int]\n        val intArrayDiffSquaredDiffSquaredDiffSquaredLength\
    \ = intArrayDiffSquaredDiffSquaredDiffSquared.length\n        val intArrayDiffSquaredDiffSquaredDiffSquaredSum\
    \ = intArrayDiffSquaredDiffSquaredDiffSquared.sum\n        val intArrayDiffSquaredDiffSquaredDiffSquaredDiff\
    \ = intArrayDiffSquaredDiffSquaredDiffSquaredSum - intArrayDiffSquaredDiffSquaredDiffSquared(0)\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.asInstanceOf[Int]\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredLength = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.length\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.sum\n\
    \        val intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredDiff = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquaredSum\
    \ - intArrayDiffSquaredDiffSquaredDiffSquaredDiff\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6hqfs53x.scala:24:60 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredLength\e\
    [0m = intArrayDiffSquared.length\n\e[31m\e[31m   |\e[0m                      \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                           value length is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6hqfs53x.scala:25:57 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredSum\e\
    [0m = intArrayDiffSquared.sum\n\e[31m\e[31m   |\e[0m                         \
    \            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  value sum is not a member of Int\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp6hqfs53x.scala:31:56 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m = intArrayDiffSquaredDiffSquaredDiffSquared.asInstanceOf[\e[35mInt\e[0m]\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m    Recursive \e[33mvalue\e[0m \e[35mintArrayDiffSquaredDiffSquaredDiffSquared\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6hqfs53x.scala:35:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m = intArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared.asInstanceOf[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                                         \
    \                          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mintArrayDiffSquaredDiffSquaredDiffSquaredDiffSquared\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6hqfs53x.scala:39:5 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659805702
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue).sorted\n        val closest\
    \ = (ints(ints.length - 1) + ints(ints.length - 2))/2\n        if (closest ==\
    \ intValue) closest else closest.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.closestInteger(tmp6112cvoy.scala:20)\n\tat Problem$.main(tmp6112cvoy.scala:24)\n\
    \tat Problem.main(tmp6112cvoy.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val num = value.toLong\n\
    \        val nums = mutable.ArrayBuffer.empty[Long]\n        val nums2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums3 = mutable.ArrayBuffer.empty[Long]\n        val nums4 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums5 = mutable.ArrayBuffer.empty[Long]\n        val nums6 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums7 = mutable.ArrayBuffer.empty[Long]\n        val nums8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums9 = mutable.ArrayBuffer.empty[Long]\n        val nums10 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums11 = mutable.ArrayBuffer.empty[Long]\n        val nums12 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums13 = mutable.ArrayBuffer.empty[Long]\n        val nums14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums15 = mutable.ArrayBuffer.empty[Long]\n        val nums16 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums17 = mutable.ArrayBuffer.empty[Long]\n        val nums18 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums19 = mutable.ArrayBuffer.empty[Long]\n        val nums20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums21 = mutable.ArrayBuffer.empty[Long]\n        val nums22 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums23 = mutable.ArrayBuffer.empty[Long]\n        val nums24 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums25 = mutable.ArrayBuffer.empty[Long]\n        val nums26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums27 = mutable.ArrayBuffer.empty[Long]\n        val nums28 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums29 = mutable.ArrayBuffer.empty[Long]\n        val nums30 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums31 = mutable.ArrayBuffer.empty[Long]\n        val nums32 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums33 = mutable.ArrayBuffer.empty[Long]\n        val nums34 = mutable.ArrayBuffer.empty[Long]\n\
    \        val nums35 = mutable.ArrayBuffer.empty\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnums2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnums3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnums4\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mnums5\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgb7jhpfv.scala:24:20 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnums6\e[0"
  stdout: ''
  timestamp: 1659805702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toLong\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2lvwg56.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz2lvwg56.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz2lvwg56.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz2lvwg56.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz2lvwg56.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + diff) / 2\n        val closestInt = math.round(closest)\n        closestInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmw3u7z7n.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpmw3u7z7n.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val smallest = Math.min(numbers)\n\
    \        val largest = Math.max(numbers)\n        val difference = largest - smallest\n\
    \        if (difference < 0)\n            smallest + difference\n        else\n\
    \            smallest - difference\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf9tlihdu.scala:19:28 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msmallest\e[0m = Math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mobject\e\
    [0m \e[35mMath\e[0m with types\n\e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\
    \e[31m   |\e[0m (x$0: Float, x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1:\
    \ Long): Long\n\e[31m   |\e[0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpf9tlihdu.scala:20:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mlargest\e[0m = Math.max(numbers)\n\e[31m\e[31m   |\e[0m            \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mobject\e[0m \e[35mMath\e[0m with types\n\
    \e[31m   |\e[0m (x$0: Double, x$1: Double): Double\n\e[31m   |\e[0m (x$0: Float,\
    \ x$1: Float): Float\n\e[31m   |\e[0m (x$0: Long, x$1: Long): Long\n\e[31m   |\e\
    [0m (x$0: Int, x$1: Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (min + diff) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp088j75ju.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp088j75ju.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805701
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        val diffClosest = math.abs(closest - diff)\n    \
    \    if (diff == 0) {\n            return closest\n        }\n        if (diffClosest\
    \ < diff) {\n            return closest\n        }\n        return closest - diff\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsvg2sxca.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsvg2sxca.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805702
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpc0503u_r.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpc0503u_r.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2) + intArray(3) + intArray(4) + intArray(5)\
    \ + intArray(6) + intArray(7) + intArray(8) + intArray(9)\n        val intArrayDiff\
    \ = intArraySum - intArrayMax\n        val intArrayDiffAbs = intArrayDiff.abs\n\
    \        val intArrayDiffAbsMin = intArrayDiffAbs.min\n        val intArrayDiffAbsMax\
    \ = intArrayDiffAbs.max\n        val intArrayDiffAbsSum = intArrayDiffAbs(0) +\
    \ intArrayDiffAbs(1) + intArrayDiffAbs(2) + intArrayDiffAbs(3) + intArrayDiffAbs(4)\
    \ + intArrayDiffAbs(5) + intArrayDiffAbs(6) + intArrayDiffAbs(7) + intArrayDiffAbs(8)\
    \ + intArrayDiffAbs(9)\n        val intArrayDiffAbsDiff = intArrayDiffAbsSum -\
    \ intArrayMin\n        val intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbs.min\n        val\
    \ intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n        val intArrayDiffAbsDiffAbsSum\
    \ = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1) + intArrayDiffAbsDiffAbs(2)\
    \ + intArrayDiffAbsDiffAbs(3) + intArrayDiffAbsDiffAbs(4) + intArrayDiffAbsDiffAbs(5)\
    \ + intArrayDiffAbsDiffAbs(6) + intArrayDiffAbsDiffAbs(7) + intArrayDiffAbsDiffAbs(8)\
    \ + intArrayDiffAbsDiffAbs(9)\n        val intArrayDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiff\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp90drju7z.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp90drju7z.scala:28:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e\
    [0m \e[36mintArrayDiffAbsSum\e[0m = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e\
    [31m1\e[0m) + intArrayDiffAbs(\e[31m2\e[0m) + intArrayDiffAbs(\e[31m3\e[0m) +\
    \ intArrayDiffAbs(\e[31m4\e[0m) + intArrayDiffAbs(\e[31m5\e[0m) + intArrayDiffAbs(\e\
    [31m6\e[0m) + intArrayDiffAbs(\e[31m7\e[0m) + intArrayDiffAbs(\e[31m8\e[0m) +\
    \ intArrayDiffAbs(\e[31m9\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \          ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \e[33mvalue\e\
    [0m \e[35mintArrayDiffAbs\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp90drju7z.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqtmpvgct.scala:68:28 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqtmpvgct.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqtmpvgct.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0min"
  stdout: ''
  timestamp: 1659805685
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\") // Split value into two parts separated by \".\"\n  \
    \      val part1 = parts(0)\n        val part2 = parts(1)\n        val part1Int\
    \ = part1.toInt\n        val part2Int = part2.toInt\n        val part1Diff = part1Int\
    \ - part2Int\n        val part2Diff = part2Int - part1Int\n        val part1DiffAbs\
    \ = Math.abs(part1Diff)\n        val part2DiffAbs = Math.abs(part2Diff)\n    \
    \    val closestDiffAbs = part1DiffAbs + part2DiffAbs\n        val closestDiff\
    \ = closestDiffAbs.min(part1DiffAbs, part2DiffAbs)\n        val closestDiffInt\
    \ = closestDiff.toInt\n        val closestDiffIntAbs = Math.abs(closestDiffInt)\n\
    \        val closestDiffAbsMin = closestDiffAbsMin.min(part1DiffAbs, part2DiffAbs)\n\
    \        val closestDiffAbsMinInt = closestDiffAbsMin.toInt\n        val closestDiffAbsMinIntAbs\
    \ = Math.abs(closestDiffAbsMinInt)\n        val closestDiffAbsMinMin = closestDiffAbsMinMin.min(part1DiffAbs,\
    \ part2DiffAbs)\n        val closestDiffAbsMinMinInt = closestDiffAbsMinMin.toInt\n\
    \        val closestDiffAbsMinMinIntAbs = Math.abs(closestDiffAbsMinMinInt)\n\
    \        val closestDiffAbsMinMinMin = closestDiffAbsMinMinMin.min(part1DiffAbs,\
    \ part2DiffAbs)\n        val closestDiffAbsMinMinMinInt = closestDiffAbsMinMinMin.toInt\n\
    \        val closestDiffAbsMinMinMinIntAbs = Math.abs(closestDiffAbsMinMinMinInt)\n\
    \        val closestDiffAbsMinMinMinMin = closestDiffAbsMinMinMinMin.min(part1DiffAbs,\
    \ part2DiffAbs)\n        val closestDiffAbsMinMinMinMinInt = closestDiffAbsMinMinMinMin.toInt\n\
    \        val closestDiffAbsMinMinMinMinIntAbs = Math.abs(closestDiffAbsMinMinMinMinInt)\n\
    \        val closestDiffAbsMinMinMinMinMin = closestDiffAbsMinMinMinMinMin.min(part1DiffAbs,\
    \ part2DiffAbs)\n        val closestDiffAbsMinMinMinMinMinInt = closestDiffAbsMinMinMinMinMin.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj4c38cr0.scala:28:45\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mclosestDiff\e\
    [0m = closestDiffAbs.min(part1DiffAbs, part2DiffAbs)\n\e[31m\e[31m   |\e[0m  \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                             Found:    (Int, Int)\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj4c38cr0.scala:31:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffAbsMin\e[0m = closestDiffAbsMin.min(part1DiffAbs, part2DiffAbs)\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                           Recursive \e[33mvalue\e[0m \e[35mclosestDiffAbsMin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj4c38cr0.scala:34:35\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffAbsMinMin\e[0m = closestDiffAbsMinMin.min(part1DiffAbs, part2DiffAbs)\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                         Recursive \e[33mvalue\e[0m \e[35mclosestDiffAbsMinMin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj4c38cr0.scala:37:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclosestDiffAbsMinMinMin\e[0m = closestDiffAbsMinMinMin.min(part1DiffAbs,\
    \ part2DiffAbs)\n\e[31m\e[31m   |\e[0m                                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35mclosestDiffAbsMinMinMin\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj4c38cr0.scala:40:41\
    \ ---------------------------\e[0m\e[0m\n\e[31m4"
  stdout: ''
  timestamp: 1659805705
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intValues = List(intValue, intValue + 1, intValue\
    \ + 2, intValue + 3, intValue + 4, intValue + 5, intValue + 6, intValue + 7, intValue\
    \ + 8, intValue + 9, intValue + 10, intValue + 11, intValue + 12, intValue + 13,\
    \ intValue + 14, intValue + 15, intValue + 16, intValue + 17, intValue + 18, intValue\
    \ + 19, intValue + 20, intValue + 21, intValue + 22, intValue + 23, intValue +\
    \ 24, intValue + 25, intValue + 26, intValue + 27, intValue + 28, intValue + 29,\
    \ intValue + 30, intValue + 31, intValue + 32, intValue + 33, intValue + 34, intValue\
    \ + 35, intValue + 36, intValue + 37, intValue + 38, intValue + 39, intValue +\
    \ 40, intValue + 41, intValue + 42, intValue + 43, intValue + 44, intValue + 45,\
    \ intValue + 46, intValue + 47, intValue + 48, intValue + 49, intValue + 50, intValue\
    \ + 51, intValue + 52, intValue + 53, intValue + 54, intValue + 55, intValue +\
    \ 56, intValue + 57, intValue + 58, intValue + 59, intValue + 60, intValue + 61,\
    \ intValue + 62, intValue + 63, intValue + 64, intValue + 65, intValue + 66, intValue\
    \ + 67, intValue + 68, intValue + 69, intValue + 70, intValue + 71, intValue +\
    \ 72, intValue + 73, intValue + 74, intValue + 75, intValue + 76, intValue + 77,\
    \ intValue + 78, intValue + 79, intValue + 80, intValue + 81, intValue + 82, intValue\
    \ + 83, intValue + 84, intValue + 85, intValue + 86, intValue + 87, intValue +\
    \ 88, intValue + 89, intValue + 90, intValue + 91, intValue + 92, intValue + 93,\
    \ intValue + 94, intValue + 95, intValue + 96, intValue + 97, intValue + 98, intValue\
    \ + 99, intValue + 100, intValue + 101, intValue + 102, intValue + 103, intValue\
    \ + 104, intValue + 105, intValue + 106, intValue + 107, intValue + 108, intValue\
    \ + 109, intValue + 110, intValue + 111, intValue + 112, intValue + 113, intValue\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnt9tdya_.scala:20:4 ----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpnt9tdya_.scala:20:5 ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        val closestInteger = math.round(closest)\n\
    \        closestInteger\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptiy7s0ei.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptiy7s0ei.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.reduce(_\
    \ + _)\n        val intArrayDifference = intArraySum - intValue\n        val intArrayDifferenceLength\
    \ = intArrayDifference.length\n        val intArrayDifferenceSum = intArrayDifference.reduce(_\
    \ + _)\n        val intArrayDifferenceDifference = intArrayDifferenceSum - intArraySum\n\
    \        val intArrayDifferenceDifferenceLength = intArrayDifferenceDifference.length\n\
    \        val intArrayDifferenceDifferenceSum = intArrayDifferenceDifference.reduce(_\
    \ + _)\n        val intArrayDifferenceDifferenceDifference = intArrayDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceLength = intArrayDifferenceDifferenceDifference.length\n\
    \        val intArrayDifferenceDifferenceDifferenceSum = intArrayDifferenceDifferenceDifference.reduce(_\
    \ + _)\n        val intArrayDifferenceDifferenceDifferenceDifference = intArrayDifferenceDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceDifferenceLength\
    \ = intArrayDifferenceDifferenceDifferenceDifference.length\n        val intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n        val\
    \ intArrayDifferenceDifferenceDifferenceDifferenceDifference = intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceDifferenceLength\
    \ = intArrayDifferenceDifferenceDifferenceDifference.length\n        val intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n        val\
    \ intArrayDifferenceDifferenceDifferenceDifferenceDifference = intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceDifferenceLength\
    \ = intArrayDifferenceDifferenceDifferenceDifference.length\n        val intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n        val\
    \ intArrayDifferenceDifferenceDifferenceDifferenceDifference = intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceDifferenceLength\
    \ = intArrayDifferenceDifferenceDifferenceDifference.length\n        val intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n        val\
    \ intArrayDifferenceDifferenceDifferenceDifferenceDifference = intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ - intArraySum\n        val intArrayDifferenceDifferenceDifferenceDifferenceLength\
    \ = intArrayDifferenceDifferenceDifferenceDifference.length\n        val intArrayDifferenceDifferenceDifferenceDifferenceSum\
    \ = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n        val\
    \ intArrayDifferenceDifferenceDifferenceDifferenceDifference = int\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcszw74la.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceDifferenceDifferenceDifferenceLength\e\
    [0m = intArrayDifferenceDifferenceDifferenceDifference.length\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceDifferenceDifferenceDifferenceLength is\
    \ already defined as \e[33mvalue\e[0m \e[35mintArrayDifferenceDifferenceDifferenceDifferenceLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcszw74la.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceDifferenceDifferenceDifferenceSum\e\
    [0m = intArrayDifferenceDifferenceDifferenceDifference.reduce(_ + _)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceDifferenceDifferenceDifferenceSum is already\
    \ defined as \e[33mvalue\e[0m \e[35mintArrayDifferenceDifferenceDifferenceDifferenceSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcszw74la.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceDifferenceDifferenceDifferenceDifference\e\
    [0m = intArrayDifferenceDifferenceDifferenceDifferenceSum - intArraySum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayDifferenceDifferenceDifferenceDifferenceDifference\
    \ is already defined as \e[33mvalue\e[0m \e[35mintArrayDifferenceDifferenceDifferenceDifferenceDifference\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must "
  stdout: ''
  timestamp: 1659805706
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue - 1, intValue + 1, intValue)\n\
    \        val diffs = ints.map(x => Math.abs(x - intValue))\n        val minDiff\
    \ = diffs.min\n        val index = diffs.indexOf(minDiff)\n        ints(index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.NumberFormatException: For input string: \"14.5\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\
    \tat java.base/java.lang.Integer.parseInt(Integer.java:668)\n\tat java.base/java.lang.Integer.parseInt(Integer.java:786)\n\
    \tat scala.collection.StringOps$.toInt$extension(StringOps.scala:915)\n\tat Problem$.closestInteger(tmpk6tamgr5.scala:18)\n\
    \tat Problem$.main(tmpk6tamgr5.scala:27)\n\tat Problem.main(tmpk6tamgr5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (min + max) / 2\n        if (diff < closest) {\n            closest\n    \
    \    } else {\n            math.round(closest)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0k6q278j.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp0k6q278j.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDoubleArray\n    \
    \    val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArraySum = intArray.reduce((x,\
    \ y) => x + y)\n        val intArrayDiff = intArraySum - intArrayMax\n       \
    \ val intArrayDiffSquared = intArrayDiff * intArrayDiff\n        val intArrayDiffSquaredMinusOne\
    \ = intArrayDiffSquared - 1.0\n        val intArrayDiffSquaredMinusTwo = intArrayDiffSquared\
    \ - 2.0\n        val intArrayDiffSquaredMinusThree = intArrayDiffSquared - 3.0\n\
    \        val intArrayDiffSquaredMinusFour = intArrayDiffSquared - 4.0\n      \
    \  val intArrayDiffSquaredMinusFive = intArrayDiffSquared - 5.0\n        val intArrayDiffSquaredMinusSix\
    \ = intArrayDiffSquared - 6.0\n        val intArrayDiffSquaredMinusSeven = intArrayDiffSquared\
    \ - 7.0\n        val intArrayDiffSquaredMinusEight = intArrayDiffSquared - 8.0\n\
    \        val intArrayDiffSquaredMinusNine = intArrayDiffSquared - 9.0\n      \
    \  val intArrayDiffSquaredMinusTen = intArrayDiffSquared - 10.0\n        val intArrayDiffSquaredMinusEleven\
    \ = intArrayDiffSquared - 11.0\n        val intArrayDiffSquaredMinusTwelve = intArrayDiffSquared\
    \ - 12.0\n        val intArrayDiffSquaredMinusThirteen = intArrayDiffSquared -\
    \ 13.0\n        val intArrayDiffSquaredMinusFourteen = intArrayDiffSquared - 14.0\n\
    \        val intArrayDiffSquaredMinusFifteen = intArrayDiffSquared - 15.0\n  \
    \      val intArrayDiffSquaredMinusSixteen = intArrayDiffSquared - 16.0\n    \
    \    val intArrayDiffSquaredMinusSeventeen = intArrayDiffSquared - 17.0\n    \
    \    val intArrayDiffSquaredMinusEighteen = intArrayDiffSquared - 18.0\n     \
    \   val intArrayDiffSquaredMinusNineteen = intArrayDiffSquared - 19.0\n      \
    \  val intArrayDiffSquaredMinusTwenty = intArrayDiffSquared - 20.0\n        val\
    \ intArrayDiffSquaredMinusTwentyOne = intArrayDiffSquared - 21.0\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmptwhladcx.scala:47:11 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmptwhladcx.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintArray\e[0m = intValue.toString.toDoubleArray\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value toDoubleArray is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptwhladcx.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayMin = intArray.min\n\
    \        val intArrayMax = intArray.max\n        val intArraySum = intArray(0)\
    \ + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum - intArrayMax\n\
    \        val intArrayDiffAbs = intArrayDiff.abs\n        val intArrayDiffAbsMin\
    \ = intArrayDiffAbs.min\n        val intArrayDiffAbsMax = intArrayDiffAbs.max\n\
    \        val intArrayDiffAbsSum = intArrayDiffAbs(0) + intArrayDiffAbs(1) + intArrayDiffAbs(2)\n\
    \        val intArrayDiffAbsDiff = intArrayDiffAbsSum - intArrayMax\n        val\
    \ intArrayDiffAbsDiffAbs = intArrayDiffAbsDiff.abs\n        val intArrayDiffAbsDiffAbsMin\
    \ = intArrayDiffAbsDiffAbs.min\n        val intArrayDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbs(0) + intArrayDiffAbsDiffAbs(1)\
    \ + intArrayDiffAbsDiffAbs(2)\n        val intArrayDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMin = intArrayDiffAbsDiffAbsDiffAbs.min\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsMax = intArrayDiffAbsDiffAbsDiffAbs.max\n\
    \        val intArrayDiffAbsDiffAbsDiffAbsSum = intArrayDiffAbsDiffAbsDiffAbs(0)\
    \ + intArrayDiffAbsDiffAbsDiffAbs(1) + intArrayDiffAbsDiffAbsDiffAbs(2)\n    \
    \    val intArrayDiffAbsDiffAbsDiffAbsDiff = intArrayDiffAbsDiffAbsDiffAbsSum\
    \ - intArrayMax\n        val intArrayDiffAbsDiffAbsDiffAbsDiffAbs = intArrayDiffAbsDiffAbsDiffAbsDiff.abs\n\
    \        val intArrayDiffAbsDiff\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptatardg_.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmptatardg_.scala:28:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e\
    [0m \e[36mintArrayDiffAbsSum\e[0m = intArrayDiffAbs(\e[31m0\e[0m) + intArrayDiffAbs(\e\
    [31m1\e[0m) + intArrayDiffAbs(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \         \e[33mvalue\e[0m \e[35mintArrayDiffAbs\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptatardg_.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805684
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.toDouble.asInstanceOf[Array[Double]]\n\
    \        val intArrayLength = intArray.length\n        val intArrayIndex = (intArrayLength\
    \ - 1) - (intArrayLength % 2)\n        val intArrayIndex2 = (intArrayLength -\
    \ 1) - (intArrayLength % 2)\n        val intArrayIndex3 = (intArrayLength - 1)\
    \ - (intArrayLength % 2)\n        val intArrayIndex4 = (intArrayLength - 1) -\
    \ (intArrayLength % 2)\n        val intArrayIndex5 = (intArrayLength - 1) - (intArrayLength\
    \ % 2)\n        val intArrayIndex6 = (intArrayLength - 1) - (intArrayLength %\
    \ 2)\n        val intArrayIndex7 = (intArrayLength - 1) - (intArrayLength % 2)\n\
    \        val intArrayIndex8 = (intArrayLength - 1) - (intArrayLength % 2)\n  \
    \      val intArrayIndex9 = (intArrayLength - 1) - (intArrayLength % 2)\n    \
    \    val intArrayIndex10 = (intArrayLength - 1) - (intArrayLength % 2)\n     \
    \   val intArrayIndex11 = (intArrayLength - 1) - (intArrayLength % 2)\n      \
    \  val intArrayIndex12 = (intArrayLength - 1) - (intArrayLength % 2)\n       \
    \ val intArrayIndex13 = (intArrayLength - 1) - (intArrayLength % 2)\n        val\
    \ intArrayIndex14 = (intArrayLength - 1) - (intArrayLength % 2)\n        val intArrayIndex15\
    \ = (intArrayLength - 1) - (intArrayLength % 2)\n        val intArrayIndex16 =\
    \ (intArrayLength - 1) - (intArrayLength % 2)\n        val intArrayIndex17 = (intArrayLength\
    \ - 1) - (intArrayLength % 2)\n        val intArrayIndex18 = (intArrayLength -\
    \ 1) - (intArrayLength % 2)\n        val intArrayIndex19 = (intArrayLength - 1)\
    \ - (intArrayLength % 2)\n        val intArrayIndex20 = (intArrayLength - 1) -\
    \ (intArrayLength % 2)\n        val intArrayIndex21 = (intArrayLength - 1) - (intArrayLength\
    \ % 2)\n        val intArrayIndex22 = (intArrayLength - 1) - (intArrayLength %\
    \ 2)\n        val intArrayIndex23 = (intArrayLength - 1) - (intArrayLength % 2)\n\
    \        val intArrayIndex24 = (intArrayLength - 1) - (intArrayLength % 2)\n \
    \       val intArrayIndex25 = (intArrayLength - 1) - (intArrayLength % 2)\n  \
    \      \n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp69tr7i8h.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val smallest = math.min(parts(0),\
    \ parts(1))\n        val largest = math.max(parts(0), parts(1))\n        val diff\
    \ = largest - smallest\n        val roundTo = diff / 2\n        smallest + roundTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length\
    \ 1\n\tat Problem$.closestInteger(tmppdnzsbbn.scala:19)\n\tat Problem$.main(tmppdnzsbbn.scala:26)\n\
    \tat Problem.main(tmppdnzsbbn.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff + min) / 2\n        math.round(closest)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) ==\
    \ (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpsx7n1kjv.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff == 0) ? min : min + (diff / 2)\n        closest.toLong\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n\
    \    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgk4c5wq9.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpgk4c5wq9.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpgk4c5wq9.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclosest\e[0m = (diff ==\
    \ \e[31m0\e[0m) ? min : \e[35mmin\e[0m \e[35m+\e[0m (\e[35mdiff\e[0m \e[35m/\e\
    [0m \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \  Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805706
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArrayLength - 1\n        val intArrayLength = intArrayLength - 1\n    \
    \    val intArrayLength = intArrayLength - 1\n        val intArrayLength = intArrayLength\
    \ - 1\n        val intArrayLength = intArrayLength - 1\n        val intArrayLength\
    \ = intArray\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpq2tsgyj5.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq2tsgyj5.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq2tsgyj5.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq2tsgyj5.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintArrayLength is already defined as \e[33mvalue\e[0m \e[35mintArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpq2tsgyj5.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mintArrayLength\e[0m = intArrayLength\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums.map(_.toDouble))\n\
    \        val max = math.max(nums.map(_.toDouble))\n        val diff = max - min\n\
    \        val closest = (diff / nums.last).toInt\n        math.round(closest)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_vlitcnh.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums.map(_.toDouble))\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments (Array[Double])\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp_vlitcnh.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums.map(_.toDouble))\n\e[31m\e[31m   |\e[0m   \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch arguments (Array[Double])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.asInstanceOf[String]\n        val intArray = intValue.split(\"\\\\.\"\
    ).map(_.toInt)\n        val intArrayLength = intArray.length\n        val intArrayMin\
    \ = intArray.min\n        val intArrayMax = intArray.max\n        val intArraySum\
    \ = intArray(0) + intArray(1) + intArray(2)\n        val intArrayDiff = intArraySum\
    \ - intArrayMax\n        val intArrayDiffAbs = intArrayDiff / intArrayLength\n\
    \        val intArrayDiffAbsFloor = math.floor(intArrayDiffAbs)\n        val intArrayDiffAbsCeil\
    \ = math.ceil(intArrayDiffAbs)\n        val intArrayDiffAbsFloorFloor = math.floor(intArrayDiffAbsFloor)\n\
    \        val intArrayDiffAbsCeilFloor = math.ceil(intArrayDiffAbsFloor)\n    \
    \    val intArrayDiffAbsFloorCeil = math.floor(intArrayDiffAbsCeil)\n        val\
    \ intArrayDiffAbsCeilCeil = math.ceil(intArrayDiffAbsCeil)\n        val intArrayDiffAbsFloorFloorFloor\
    \ = math.floor(intArrayDiffAbsFloorFloor)\n        val intArrayDiffAbsCeilFloorFloor\
    \ = math.ceil(intArrayDiffAbsCeilFloorFloor)\n        val intArrayDiffAbsFloorCeilFloor\
    \ = math.floor(intArrayDiffAbsFloorCeilFloor)\n        val intArrayDiffAbsCeilCeilFloor\
    \ = math.ceil(intArrayDiffAbsCeilCeilFloor)\n        val intArrayDiffAbsFloorFloorCeil\
    \ = math.floor(intArrayDiffAbsFloorFloorCeil)\n        val intArrayDiffAbsCeilFloorFloorCeil\
    \ = math.ceil(intArrayDiffAbsCeilFloorFloorCeil)\n        val intArrayDiffAbsFloorCeilFloorFloor\
    \ = math.floor(intArrayDiffAbsFloorCeilFloorFloor)\n        val intArrayDiffAbsCeilCeilFloorFloor\
    \ = math.ceil(intArrayDiffAbsCeilCeilFloorFloor)\n        val intArrayDiffAbsFloorCeilCeilFloor\
    \ = math.floor(intArrayDiffAbsFloorCeilCeilFloorFloor)\n        val intArrayDiffAbsFloorFloorFloorFloor\
    \ = math.floor(intArrayDiff\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"14.5\"\
    )) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt4mhkzj1.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4mhkzj1.scala:33:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsCeilFloorFloor\e[0m = math.ceil(intArrayDiffAbsCeilFloorFloor)\n\
    \e[31m\e[31m   |\e[0m                                                      ^\e\
    [0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsCeilFloorFloor\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4mhkzj1.scala:34:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsFloorCeilFloor\e[0m = math.floor(intArrayDiffAbsFloorCeilFloor)\n\
    \e[31m\e[31m   |\e[0m                                                       ^\e\
    [0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsFloorCeilFloor\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4mhkzj1.scala:35:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsCeilCeilFloor\e[0m = math.ceil(intArrayDiffAbsCeilCeilFloor)\n\
    \e[31m\e[31m   |\e[0m                                                     ^\e\
    [0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsCeilCeilFloor\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt4mhkzj1.scala:36:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mintArrayDiffAbsFloorFloorCeil\e[0m = math.floor(intArrayDiffAbsFloorFloorCeil)\n\
    \e[31m\e[31m   |\e[0m                                                       ^\e\
    [0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mintArrayDiffAbsFloorFloorCeil\e\
    [0m needs type\n\e[31"
  stdout: ''
  timestamp: 1659805708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intArray = intValue.toString.split(\"\\\\.\").map(_.toInt)\n\
    \        val intArrayLength = intArray.length\n        val intArraySum = intArray.sum\n\
    \        val intArrayDifference = intArraySum - intArray(0)\n        val intArrayDifferenceAbs\
    \ = intArrayDifference * intArrayDifference\n        val intArrayDifferenceAbsSquared\
    \ = intArrayDifferenceAbs * intArrayDifferenceAbs\n        val intArrayDifferenceSquared\
    \ = intArrayDifference * intArrayDifference\n        val intArrayDifferenceSquaredSum\
    \ = intArrayDifferenceSquared.sum\n        val intArrayDifferenceSquaredDifference\
    \ = intArrayDifferenceSquaredSum - intArrayArray(0)\n        val intArrayDifferenceSquaredDifferenceAbs\
    \ = intArrayDifferenceSquaredDifference * intArrayDifferenceSquaredDifference\n\
    \        val intArrayDifferenceSquaredDifferenceAbsSquared = intArrayDifferenceSquaredDifferenceAbs\
    \ * intArrayDifferenceSquaredDifferenceAbs\n        val intArrayDifferenceSquaredDifferenceSquared\
    \ = intArrayDifferenceSquaredDifference * intArrayDifferenceSquaredDifference\n\
    \        val intArrayDifferenceSquaredDifferenceSquaredSum = intArrayDifferenceSquaredDifferenceSquared.sum\n\
    \        val intArrayDifferenceSquaredDifferenceSquaredDifference = intArrayDifferenceSquaredDifferenceSquaredSum\
    \ - intArrayArray(0)\n        val intArrayDifferenceSquaredDifferenceSquaredDifferenceAbs\
    \ = intArrayDifferenceSquaredDifferenceSquaredDifference * intArrayDifferenceSquaredDifferenceSquaredDifference\n\
    \        val intArrayDifferenceSquaredDifferenceSquaredDifferenceAbsSquared =\
    \ intArrayDifferenceSquaredDifferenceSquaredDifferenceAbs * intArrayDifferenceSquaredDifferenceSquaredDifferenceAbs\n\
    \        val intArrayDifferenceSquaredDifferenceSquaredDifferenceSquared = intArrayDifferenceSquaredDifferenceSquaredDifference\
    \ * intArrayDifferenceSquaredDifferenceSquaredDifference\n        val intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredSum\
    \ = intArrayDifferenceSquaredDifferenceSquaredDifferenceSquared.sum\n        val\
    \ intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference = intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredSum\
    \ - intArrayArray(0)\n        val intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceAbs\
    \ = intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference * intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifference\n\
    \        val intArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceAbsSquared\
    \ = int\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjw3de0q8.scala:26:69 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceSquaredSum\e\
    [0m = intArrayDifferenceSquared.sum\n\e[31m\e[31m   |\e[0m                   \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                       value sum is not a member of Int\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjw3de0q8.scala:39:94 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mintArrayDifferenceSquaredDifferenceSquaredDifferenceSquaredDifferenceAbsSquared\e\
    [0m = int\n\e[31m\e[31m   |\e[0m                                             \
    \                                                 ^^^\e[0m\n\e[31m   |\e[0m  \
    \                                                        Not found: int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjw3de0q8.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        val closestInt = math.round(closest)\n        closestInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"10\"\
    )) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8x6tsfrb.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp8x6tsfrb.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val intValues = mutable.ArrayBuffer.empty[Long]\n   \
    \     val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues =\
    \ mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n        val intValues = mutable.ArrayBuffer.empty[Long]\n\
    \        val intValues = mutable.ArrayBuffer.empty[Long]\n        val intValues\
    \ = mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbrk5xo9r.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mintValues is already defined as \e[33mvalue\e[0m \e[35mintValues\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbrk5xo9r.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mintValues\e[0m = mutable.ArrayB"
  stdout: ''
  timestamp: 1659805695
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(nums)\n    \
    \    val max = math.max(nums)\n        val diff = max - min\n        val closest\
    \ = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(nums)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((nums : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2wdsy8ir.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(nums)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m  \
    \ |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((nums : Array[Int]))\n2 errors found\n"
  stdout: ''
  timestamp: 1659805651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val parts =\
    \ value.split(\".\").map(_.toInt)\n        val closest = (parts diff parts.last).max\n\
    \        closest.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4dq5pb53.scala:19:40\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclosest\e\
    [0m = (parts diff parts.last).max\n\e[31m\e[31m   |\e[0m                     \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \   Found:    Int\n\e[31m   |\e[0m                                  Required:\
    \ scala.collection.Seq[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val numbers\
    \ = value.split(\"\\\\.\").map(_.toInt)\n        val min = math.min(numbers)\n\
    \        val max = math.max(numbers)\n        val diff = max - min\n        val\
    \ closest = (diff + min) / 2\n        math.round(closest)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:19:23 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmin\e[0m = math.min(numbers)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((numbers : Array[Int]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp67wagm7p.scala:20:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e\
    [0m \e[36mmax\e[0m = math.max(numbers)\n\e[31m\e[31m   |\e[0m                \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e\
    [31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y:\
    \ Int): Int\n\e[31m   |\e[0mmatch arguments ((numbers : Array[Int]))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val nums =\
    \ value.split(\"\\\\.\").map(_.toInt)\n        val numsSorted = nums.sortWith(_\
    \ < _)\n        val closestNum = numsSorted.last\n        val closestNumIndex\
    \ = numsSorted.indexWhere(_ == closestNum)\n        val closestNumDiff = closestNum\
    \ - nums(closestNumIndex)\n        val closestNumDiffAbs = Math.abs(closestNumDiff)\n\
    \        val closestNumDiffAbsIndex = numsSorted.indexWhere(_ == closestNumDiffAbs)\n\
    \        val closestNumDiffAbsDiff = closestNumDiffAbs - nums(closestNumDiffAbsIndex)\n\
    \        val closestNumDiffAbsDiffAbs = Math.abs(closestNumDiffAbsDiff)\n    \
    \    val closestNumDiffAbsDiffAbsIndex = numsSorted.indexWhere(_ == closestNumDiffAbsDiffAbs)\n\
    \        val closestNumDiffAbsDiffAbsDiff = closestNumDiffAbsDiffAbs - nums(closestNumDiffAbsDiffAbsIndex)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbs = Math.abs(closestNumDiffAbsDiffAbsDiff)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbsIndex = numsSorted.indexWhere(_ ==\
    \ closestNumDiffAbsDiffAbsDiffAbs)\n        val closestNumDiffAbsDiffAbsDiffAbsDiff\
    \ = closestNumDiffAbsDiffAbsDiffAbs - nums(closestNumDiffAbsDiffAbsDiffAbsIndex)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(closestNumDiffAbsDiffAbsDiffAbsDiff)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbsDiffAbsIndex = numsSorted.indexWhere(_\
    \ == closestNumDiffAbsDiffAbsDiffAbsDiffAbs)\n        val closestNumDiffAbsDiffAbsDiffAbsDiffAbsDiff\
    \ = closestNumDiffAbsDiffAbsDiffAbsDiffAbs - nums(closestNumDiffAbsDiffAbsDiffAbsDiffAbsIndex)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs = Math.abs(closestNumDiffAbsDiffAbsDiffAbsDiffAbsDiff)\n\
    \        val closestNumDiffAbsDiffAbsDiffAbsDiffAbsDiffAbsIndex = numsSorted.indexWhere(_\
    \ == closestNumDiffAbsDiffAbsDiffAbsDiffAbsDiffAbs)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(closestInteger((\"10\")) == (10l));\n    assert(closestInteger((\"\
    14.5\")) == (15l));\n    assert(closestInteger((\"-15.5\")) == (-16l));\n    assert(closestInteger((\"\
    15.3\")) == (15l));\n    assert(closestInteger((\"0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphlu4my0i.scala:37:5\
    \ ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Create a function that takes a value (string) representing a number\n\
    \    // and returns the closest integer to it. If the number is equidistant\n\
    \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
    \ closest_integer(\"10\")\n    // 10\n    // >>> closest_integer(\"15.3\")\n \
    \   // 15\n    // Note:\n    // Rounding away from zero means that if the given\
    \ number is equidistant\n    // from two integers, the one you should return is\
    \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
    14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return\
    \ -15.\n    def closestInteger(value : String) : Long = {\n        val intValue\
    \ = value.toInt\n        val ints = List(intValue, intValue+1, intValue+2, intValue+3,\
    \ intValue+4, intValue+5, intValue+6, intValue+7, intValue+8, intValue+9, intValue+10,\
    \ intValue+11, intValue+12, intValue+13, intValue+14, intValue+15, intValue+16,\
    \ intValue+17, intValue+18, intValue+19, intValue+20, intValue+21, intValue+22,\
    \ intValue+23, intValue+24, intValue+25, intValue+26, intValue+27, intValue+28,\
    \ intValue+29, intValue+30, intValue+31, intValue+32, intValue+33, intValue+34,\
    \ intValue+35, intValue+36, intValue+37, intValue+38, intValue+39, intValue+40,\
    \ intValue+41, intValue+42, intValue+43, intValue+44, intValue+45, intValue+46,\
    \ intValue+47, intValue+48, intValue+49, intValue+50, intValue+51, intValue+52,\
    \ intValue+53, intValue+54, intValue+55, intValue+56, intValue+57, intValue+58,\
    \ intValue+59, intValue+60, intValue+61, intValue+62, intValue+63, intValue+64,\
    \ intValue+65, intValue+66, intValue+67, intValue+68, intValue+69, intValue+70,\
    \ intValue+71, intValue+72, intValue+73, intValue+74, intValue+75, intValue+76,\
    \ intValue+77, intValue+78, intValue+79, intValue+80, intValue+81, intValue+82,\
    \ intValue+83, intValue+84, intValue+85, intValue+86, intValue+87, intValue+88,\
    \ intValue+89, intValue+90, intValue+91, intValue+92, intValue+93, intValue+94,\
    \ intValue+95, intValue+96, intValue+97, intValue+98, intValue+99, intValue+100,\
    \ intValue+101, intValue+102, intValue+103, intValue+104, intValue+105, intValue+106,\
    \ intValue+107, intValue+108, intValue+109, intValue+110, intValue+111, intValue+112,\
    \ intValue+113, intValue\n    }\n    def main(args: Array[String]) = {\n    assert(closestInteger((\"\
    10\")) == (10l));\n    assert(closestInteger((\"14.5\")) == (15l));\n    assert(closestInteger((\"\
    -15.5\")) == (-16l));\n    assert(closestInteger((\"15.3\")) == (15l));\n    assert(closestInteger((\"\
    0\")) == (0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8h0ks4bp.scala:20:4 ----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8h0ks4bp.scala:20:5 ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805708
