language: scala
name: HumanEval_73_smallest_change
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val maxChange = arr.foldLeft(0) { (acc, x) =>\
    \ if (x == m) acc else acc + 1 }\n        val maxChange2 = arr.foldRight(0) {\
    \ (acc, x) => if (x == m) acc else acc + 1 }\n        if (maxChange == maxChange2)\
    \ maxChange\n        else 0\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdwukvxd1.scala:15:68\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxChange2\e\
    [0m = arr.foldRight(\e[31m0\e[0m) { (\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e\
    [0m (x == m) acc \e[33melse\e[0m acc + \e[31m1\e[0m }\n\e[31m\e[31m   |\e[0m \
    \                                                                   ^^^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (acc\
    \ : Long)\n\e[31m   |\e[0m                                                  Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdwukvxd1.scala:15:77\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxChange2\e\
    [0m = arr.foldRight(\e[31m0\e[0m) { (\e[36macc\e[0m, \e[36mx\e[0m) => \e[33mif\e\
    [0m (x == m) acc \e[33melse\e[0m acc + \e[31m1\e[0m }\n\e[31m\e[31m   |\e[0m \
    \                                                                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \ Found:    Long\n\e[31m   |\e[0m                                            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexSet\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSetSize = minChangeIndexSet.size\n\
    \        val minChangeIndexSetIterator = minChangeIndexSet.iterator\n        val\
    \ minChangeIndexSetIteratorSize = minChangeIndexSetIterator.size\n        val\
    \ minChangeIndexSetIteratorIterator = minChangeIndexSetIterator.iterator\n   \
    \     val minChangeIndexSetIteratorIteratorSize = minChangeIndexSetIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIterator = minChangeIndexSetIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIterator = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorSize = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexSetIteratorIteratorIteratorIteratorIteratorIterator\
    \ = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n        val minChangeIndexSetIteratorIteratorIteratorIteratorIteratorSize\
    \ = minChangeIndexSetIteratorIteratorIteratorIterator.size\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpugn9nqn8.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetIteratorIteratorIteratorSize\e\
    [0m = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetIteratorIteratorIteratorSize is already defined\
    \ as \e[33mvalue\e[0m \e[35mminChangeIndexSetIteratorIteratorIteratorSize\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpugn9nqn8.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetIteratorIteratorIteratorIterator\e\
    [0m = minChangeIndexSetIteratorIteratorIteratorIterator.iterator\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetIteratorIteratorIteratorIterator is already\
    \ defined as \e[33mvalue\e[0m \e[35mminChangeIndexSetIteratorIteratorIteratorIterator\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpugn9nqn8.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetIteratorIteratorIteratorIteratorSize\e\
    [0m = minChangeIndexSetIteratorIteratorIteratorIterator.size\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetIteratorIteratorIteratorIteratorSize is already\
    \ defined as \e[33mvalue\e[0m \e[35mminChangeIndexSetIteratorIteratorIteratorIteratorSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var count = 0\n\
    \        var i = 0\n        var j = 0\n        while(i < len) {\n            while(j\
    \ < len) {\n                if(arr(i) == arr(j)) {\n                    j++\n\
    \                }\n                else {\n                    if(arr(i) < arr(j))\
    \ {\n                        min = Math.min(min, j-i)\n                      \
    \  count = count + 1\n                    }\n                    j++\n       \
    \         }\n            }\n            i += 1\n            j = i\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpg6lv_mb_.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpg6lv_mb_.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg6lv_mb_.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpg6lv_mb_.scala:25:28\
    \ -----------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                   \
    \     min = Math.min(min, j-i)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val min\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromic = mutable.ArrayBuffer.empty[Long]\n        val change\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChange = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        var j = 0\n        while (i < n) {\n            val\
    \ k = arr(i)\n            if (k == m) {\n                changes += k\n      \
    \          i += 1\n            } else if (k == m) {\n                changes +=\
    \ k\n                i += 1\n                j += 1\n            } else if (k\
    \ == m) {\n                changes += k\n                i += 1\n            \
    \    j += 1\n            } else if (k == m) {\n                changes += k\n\
    \                i += 1\n                j += 1\n            } else if (k == m)\
    \ {\n                changes += k\n                i += 1\n                j +=\
    \ 1\n            } else if (k == m) {\n                changes += k\n        \
    \        i += 1\n                j += 1\n            } else if (k == m) {\n  \
    \              changes += k\n                i += 1\n                j += 1\n\
    \            } else if (k == m) {\n                changes += k\n            \
    \    i += 1\n                j += 1\n            } else if (k == m) {\n      \
    \          changes += k\n                i += 1\n                j += 1\n    \
    \        } else if (k == m) {\n                changes += k\n                i\
    \ += 1\n                j += 1\n            } else if (k == m) {\n           \
    \     changes += k\n                i += 1\n                j += 1\n         \
    \   } else if (k == m) {\n                changes += k\n                i += 1\n\
    \                j += 1\n            } else if (k == m) {\n                changes\
    \ += k\n                i += 1\n                j += 1\n            } else if\
    \ (k == m) {\n                changes += k\n                i += 1\n         \
    \       j += 1\n            } else if (k == m) {\n                changes += k\n\
    \                i += 1\n                j += 1\n            } else if (k == m)\
    \ {\n                changes += k\n                i += 1\n                j +=\
    \ 1\n            } else if (k == m) {\n                changes += k\n        \
    \        i += 1\n                j += 1\n            } else if (k == m) {\n  \
    \              changes += k\n                i += 1\n                j += 1\n\
    \            } else if (k == m) {\n                changes += k\n            \
    \    i += 1\n                j += 1\n            } else if (k == m) {\n      \
    \          changes += k\n                i += 1\n                j += 1\n    \
    \        } else if (k == m) {\n                changes += k\n                i\
    \ += 1\n                j += 1\n            } else if (k == m) {\n           \
    \     changes += k\n                i += 1\n                j += 1\n         \
    \   } else if (k == m) {\n                changes += k\n                i += 1\n\
    \                j += 1\n            } else if (k == m) {\n                changes\
    \ += k\n                i += 1\n                j += 1\n            } else if\
    \ (k == m) {\n                changes += k\n                i += 1\n         \
    \       j += 1\n            } else if (k == \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprdt8g6ja.scala:121:27 --------------------------\e\
    [0m\e[0m\n\e[31m121 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (k == \n\
    \e[31m\e[31m    |\e[0m                           ^\e[0m\n\e[31m    |\e[0m    \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \   |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprdt8g6ja.scala:135:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m135 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprdt8g6ja.scala:14:22 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprdt8g6ja.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmprdt8g6ja.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmprdt8g6ja.scala:17:32 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChange\e[0m =\
    \ mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \       N"
  stdout: ''
  timestamp: 1659805324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val minChange = math.min(math.floor(n/2), math.floor(m/2))\n\
    \        val maxChange = math.min(math.floor(n/2), math.floor(m/2))\n        val\
    \ changes = mutable.ArrayBuffer(0)\n        val change = mutable.ArrayBuffer(0)\n\
    \        val changed = mutable.ArrayBuffer(0)\n        val changeIndex = mutable.ArrayBuffer(0)\n\
    \        val changeIndex2 = mutable.ArrayBuffer(0)\n        val changeIndex3 =\
    \ mutable.ArrayBuffer(0)\n        val changeIndex4 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex5 = mutable.ArrayBuffer(0)\n        val changeIndex6 =\
    \ mutable.ArrayBuffer(0)\n        val changeIndex7 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex8 = mutable.ArrayBuffer(0)\n        val changeIndex9 =\
    \ mutable.ArrayBuffer(0)\n        val changeIndex10 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex11 = mutable.ArrayBuffer(0)\n        val changeIndex12\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex13 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex14 = mutable.ArrayBuffer(0)\n        val changeIndex15\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex16 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex17 = mutable.ArrayBuffer(0)\n        val changeIndex18\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex19 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex20 = mutable.ArrayBuffer(0)\n        val changeIndex21\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex22 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex23 = mutable.ArrayBuffer(0)\n        val changeIndex24\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex25 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex26 = mutable.ArrayBuffer(0)\n        val changeIndex27\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex28 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex29 = mutable.ArrayBuffer(0)\n        val changeIndex30\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex31 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex32 = mutable.ArrayBuffer(0)\n        val changeIndex33\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex34 = mutable.ArrayBuffer(0)\n\
    \        val changeIndex35 = mutable.ArrayBuffer(0)\n        val changeIndex36\
    \ = mutable.ArrayBuffer(0)\n        val changeIndex37 = mutable.ArrayBuffer(0)\n\
    \        val change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp695zs4.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptp695zs4.scala:16:22\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptp695zs4.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptp695zs4.scala:18:22\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptp695zs4.scala:19:26\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndex\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptp695zs4.scala:20:27 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ArrayBuffer(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m lon"
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        while (i < len) {\n            while (j < len) {\n              \
    \  if (arr(i) == arr(j)) {\n                    count += 1\n                 \
    \   j++\n                }\n                else {\n                    j++\n\
    \                }\n            }\n            i += 1\n            j = 0\n   \
    \     }\n        if (count < min) {\n            count = min\n        }\n    \
    \    if (count > max) {\n            count = max\n        }\n        count\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgmi6la6p.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpgmi6la6p.scala:27:23 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgmi6la6p.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805316
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        val changed = mutable.ArrayBuffer.empty[Int]\n        val change = mutable.ArrayBuffer.empty[Int]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var changeCount\
    \ = 0\n        while (i < n) {\n            while (j < n && arr(j) == arr(n -\
    \ 1 - j)) {\n                j += 1\n            }\n            while (k < n &&\
    \ arr(k) == arr(n - 1 - k)) {\n                k += 1\n            }\n       \
    \     if (j == k) {\n                changeCount += 1\n                changes\
    \ += changeCount\n                changed += i\n                change += i\n\
    \                i += 1\n                j = 0\n                k = 0\n      \
    \      } else {\n                i += 1\n            }\n        }\n        if\
    \ (changeCount == 0) {\n            return 0\n        }\n        val minChange\
    \ = changes.min\n        val minChangeIndex = changed.min\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\
    \        val minChangeIndex = minChangeIndex.index\n        val minChangeIndex\
    \ = minChangeIndex.index\n        val minChangeIndex = minChangeIndex.index\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz0x_865u.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex.index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz0x_865u.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex.index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz0x_865u.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex.index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz0x_865u.scala:49:12 ---------------------------\e[0m\e[0m\n\e\
    [31m49 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex.index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpz0x_865u.scala:50:12 ---------------------------\e[0m\e[0m\n\e\
    [31m50 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex.index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^"
  stdout: ''
  timestamp: 1659805324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val min = len / 2\n        val max\
    \ = len - min\n        val mid = len / 2\n        val changes = min until max\n\
    \        val changed = arr.take(mid)\n        val notChanged = arr.drop(mid)\n\
    \        val changed = changed.zip(notChanged).map { case (old, new) => old -\
    \ new }\n        val notChanged = notChanged.zip(changed).map { case (old, new)\
    \ => new - old }\n        val changed = changed.sum\n        val notChanged =\
    \ notChanged.sum\n        if (changed > notChanged) {\n            smallestChange(changed)\n\
    \        } else {\n            smallestChange(notChanged)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp8eb4oekc.scala:20:63 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = changed.zip(notChanged).map\
    \ { \e[33mcase\e[0m (old, \e[33mnew\e[0m) => old - \e[33mnew\e[0m }\n\e[31m\e\
    [31m   |\e[0m                                                               ^^^\e\
    [0m\n\e[31m   |\e[0m                                                        pattern\
    \ expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8eb4oekc.scala:20:81\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanged\e[0m = changed.zip(notChanged).map { \e[33mcase\e[0m (old, \e\
    [33mnew\e[0m) => old - \e[33mnew\e[0m }\n\e[31m\e[31m   |\e[0m               \
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0m                                   an identifier expected, but '}'\
    \ found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp8eb4oekc.scala:21:66 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnotChanged\e[0m = notChanged.zip(changed).map\
    \ { \e[33mcase\e[0m (old, \e[33mnew\e[0m) => \e[33mnew\e[0m \e[35m-\e[0m old }\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^\e[0m\n\e[31m   |\e[0m                                         \
    \               pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp8eb4oekc.scala:21:84 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mnotChanged\e[0m = notChanged.zip(changed).map\
    \ { \e[33mcase\e[0m (old, \e[33mnew\e[0m) => \e[33mnew\e[0m \e[35m-\e[0m old }\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp8eb4oekc.sc"
  stdout: ''
  timestamp: 1659805315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.size\n    \
    \    val n = arr.last\n        val d = arr.last\n        val r = arr.last\n  \
    \      val c = arr.last\n        val s = arr.last\n        val t = arr.last\n\
    \        val u = arr.last\n        val v = arr.last\n        val w = arr.last\n\
    \        val x = arr.last\n        val y = arr.last\n        val z = arr.last\n\
    \        val a = arr.last\n        val b = arr.last\n        val c = arr.last\n\
    \        val d = arr.last\n        val e = arr.last\n        val f = arr.last\n\
    \        val g = arr.last\n        val h = arr.last\n        val i = arr.last\n\
    \        val j = arr.last\n        val k = arr.last\n        val l = arr.last\n\
    \        val m = arr.last\n        val n = arr.last\n        val o = arr.last\n\
    \        val p = arr.last\n        val q = arr.last\n        val r = arr.last\n\
    \        val s = arr.last\n        val t = arr.last\n        val u = arr.last\n\
    \        val v = arr.last\n        val w = arr.last\n        val x = arr.last\n\
    \        val y = arr.last\n        val z = arr.last\n        val a = arr.last\n\
    \        val b = arr.last\n        val c = arr.last\n        val d = arr.last\n\
    \        val e = arr.last\n        val f = arr.last\n        val g = arr.last\n\
    \        val h = arr.last\n        val i = arr.last\n        val j = arr.last\n\
    \        val k = arr.last\n        val l = arr.last\n        val m = arr.last\n\
    \        val n = arr.last\n        val o = arr.last\n        val p = arr.last\n\
    \        val q = arr.last\n        val r = arr.last\n        val s = arr.last\n\
    \        val t = arr.last\n        val u = arr.last\n        val v = arr.last\n\
    \        val w = arr.last\n        val x = arr.last\n        val y = arr.last\n\
    \        val z = arr.last\n        val a = arr.last\n        val b = arr.last\n\
    \        val c = arr.last\n        val d = arr.last\n        val e = arr.last\n\
    \        val f = arr.last\n        val g = arr.last\n        val h = arr.last\n\
    \        val i = arr.last\n        val j = arr.last\n        val k = arr.last\n\
    \        val l = arr.last\n        val m = arr.last\n        val n = arr.last\n\
    \        val o = arr.last\n        val p = arr.last\n        val q = arr.last\n\
    \        val r = arr.last\n        val s = arr.last\n        val t = arr.last\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp7d2wkaqk.scala:97:11 ---------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp7d2wkaqk.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mc is already defined\
    \ as \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7d2wkaqk.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7d2wkaqk.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7d2wkaqk.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7d2wkaqk.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr i"
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_).reverse\n\
    \        var count = 0\n        var i = 0\n        var j = arr.length - 1\n  \
    \      while (i < j) {\n            if (arr(i) != arr(j)) {\n                count\
    \ += 1\n                i += 1\n                j -= 1\n            } else {\n\
    \                i += 1\n                j -= 1\n            }\n        }\n  \
    \      count\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpc9cvtcw6.scala:12:29 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc9cvtcw6.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805316
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var temp = 0\n        var count = 0\n\
    \        while (i < len) {\n            while (j < len) {\n                if\
    \ (arr(i) == arr(j)) {\n                    temp = arr(i)\n                  \
    \  arr(i) = arr(j)\n                    arr(j) = temp\n                    k =\
    \ j\n                    j = k\n                    i = i + 1\n              \
    \      count = count + 1\n                }\n                else {\n        \
    \            j = j + 1\n                }\n            }\n            i = i +\
    \ 1\n        }\n        if (count < min) {\n            min = count\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp36bojalv.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp36bojalv.scala:38:16 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            min = count\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val min\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805315
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.HashSet[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var change =\
    \ 0\n        while (i < n) {\n            while (j < n) {\n                if\
    \ (arr(i) == arr(j)) {\n                    change = change + 1\n            \
    \        changes.add(change)\n                    j++\n                }\n   \
    \             else {\n                    j++\n                }\n           \
    \ }\n            i = i + 1\n            j = 0\n            change = 0\n      \
    \  }\n        val min = changes.min\n        if (min == 0) 0 else {\n        \
    \    val change = changes.min\n            val changes = changes.filter(_ != change)\n\
    \            val change = changes.min\n            val changes = changes.filter(_\
    \ != change)\n            val change = changes.min\n            val changes =\
    \ changes.filter(_ != change)\n            val change = changes.min\n        \
    \    val changes = changes.filter(_ != change)\n            val change = changes.min\n\
    \            val changes = changes.filter(_ != change)\n            val change\
    \ = changes.min\n            val changes = changes.filter(_ != change)\n     \
    \       val change = changes.min\n            val changes = changes.filter(_ !=\
    \ change)\n            val change = changes.min\n            val changes = changes.filter(_\
    \ != change)\n            val change = changes.min\n            val changes =\
    \ changes.filter(_ != change)\n            val change = changes.min\n        \
    \    val changes = changes.filter(_ != change)\n            val change = changes.min\n\
    \            val changes = changes.filter(_ != change)\n            val change\
    \ = changes.min\n            val changes = changes.filter(_ != change)\n     \
    \       val change = changes.min\n            val changes = changes.filter(_ !=\
    \ change)\n            val change = changes.min\n            val changes = changes.filter(_\
    \ != change)\n            val change = changes.min\n            val changes =\
    \ changes.filter(_ != change)\n            val change = changes.min\n        \
    \    val changes = changes.filter(_ != change)\n            val change = changes.min\n\
    \            val changes = changes.filter(_ != change)\n            val change\
    \ = changes.min\n            val changes = changes.filter(_ != change)\n     \
    \       val change = changes.min\n            val changes = changes.filter(_ !=\
    \ change)\n            val change = changes.min\n            val changes = changes.filter(_\
    \ != change)\n            val change = changes.min\n            val changes =\
    \ changes.filter(_ != change)\n            val change = changes.min\n        \
    \    val changes = changes.filter(_ != \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaw1avruw.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpaw1avruw.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaw1avruw.scala:80:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m80 |\e[0m            \e[33mval\e\
    [0m \e[36mchanges\e[0m = changes.filter(_ != \n\e[31m\e[31m   |\e[0m         \
    \                                    ^\e[0m\n\e[31m   |\e[0m                 \
    \                      expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaw1avruw.scala:94:0 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaw1avruw.scala:14:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaw1avruw.scala:15:22\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-expl"
  stdout: ''
  timestamp: 1659805324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      val len = arr.length\n        val min = len / 2\n        var count = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ == arr(j)) {\n                    count += 1\n                    j++\n    \
    \            }\n                else {\n                    j++\n            \
    \    }\n            }\n            i += 1\n            j += 1\n        }\n   \
    \     while(i < len) {\n            while(j < len) {\n                if(arr(i)\
    \ != arr(j)) {\n                    count += 1\n                    j++\n    \
    \            }\n                else {\n                    j++\n            \
    \    }\n            }\n            i += 1\n            j += 1\n        }\n   \
    \     if(count < min) {\n            min = count\n        }\n        min\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph3jl96xc.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmph3jl96xc.scala:27:23 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph3jl96xc.scala:37:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmph3jl96xc.scala:40:23 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmph3jl96xc.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmph3jl96xc.scala:47:16 -----------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m            min = count\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val min\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation ava"
  stdout: ''
  timestamp: 1659805316
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.size\n    \
    \    val n = arr.size\n        val d = new Array[Long](m)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n\
    \        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n\
    \        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n\
    \        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n\
    \        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n\
    \        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n\
    \        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n\
    \        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n\
    \        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n\
    \        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n\
    \        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n\
    \        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n\
    \        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n\
    \        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n\
    \        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n\
    \        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n\
    \        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n\
    \        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n\
    \        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n\
    \        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n\
    \        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n\
    \        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n\
    \        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n\
    \        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mvar\e[0m \e[36md\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkjgaqdmr.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0"
  stdout: ''
  timestamp: 1659805324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndex2 = len\n        val minChangeIndex3 = len\n\
    \        val minChangeIndex4 = len\n        val minChangeIndex5 = len\n      \
    \  val minChangeIndex6 = len\n        val minChangeIndex7 = len\n        val minChangeIndex8\
    \ = len\n        val minChangeIndex9 = len\n        val minChangeIndex10 = len\n\
    \        val minChangeIndex11 = len\n        val minChangeIndex12 = len\n    \
    \    val minChangeIndex13 = len\n        val minChangeIndex14 = len\n        val\
    \ minChangeIndex15 = len\n        val minChangeIndex16 = len\n        val minChangeIndex17\
    \ = len\n        val minChangeIndex18 = len\n        val minChangeIndex19 = len\n\
    \        val minChangeIndex20 = len\n        val minChangeIndex21 = len\n    \
    \    val minChangeIndex22 = len\n        val minChangeIndex23 = len\n        val\
    \ minChangeIndex24 = len\n        val minChangeIndex25 = len\n        val minChangeIndex26\
    \ = len\n        val minChangeIndex27 = len\n        val minChangeIndex28 = len\n\
    \        val minChangeIndex29 = len\n        val minChangeIndex30 = len\n    \
    \    val minChangeIndex31 = len\n        val minChangeIndex32 = len\n        val\
    \ minChangeIndex33 = len\n        val minChangeIndex34 = len\n        val minChangeIndex35\
    \ = len\n        val minChangeIndex36 = len\n        val minChangeIndex37 = len\n\
    \        val minChangeIndex38 = len\n        val minChangeIndex39 = len\n    \
    \    val minChangeIndex40 = len\n        val minChangeIndex41 = len\n        val\
    \ minChangeIndex42 = len\n        val minChangeIndex43 = len\n        val minChangeIndex44\
    \ = len\n        val minChangeIndex45 = len\n        val minChangeIndex46 = len\n\
    \        val minChangeIndex47 = len\n        val minChangeIndex48 = len\n    \
    \    val minChangeIndex49 = len\n        val minChangeIndex50 = len\n        val\
    \ minChangeIndex51 = len\n        val minChangeIndex52 = len\n        val minChangeIndex53\
    \ = len\n        val minChangeIndex54 = len\n        val minChangeIndex55 = len\n\
    \        val minChangeIndex56 = len\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfph2hjrf.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfph2hjrf.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val result = new Array[Long](n)\n        val\
    \ change = new Array[Long](n)\n        val changeIndex = new Array[Int](n)\n \
    \       val changeIndexMap = new mutable.HashMap[Long, Int]()\n        val changeIndexMap2\
    \ = new mutable.HashMap[Int, Long]()\n        val changeIndexMap3 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap4 = new mutable.HashMap[Int, Int]()\n    \
    \    val changeIndexMap5 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap6\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap7 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap8 = new mutable.HashMap[Int, Int]()\n    \
    \    val changeIndexMap9 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap10\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap11 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap12 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap13 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap14\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap15 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap16 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap17 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap18\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap19 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap20 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap21 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap22\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap23 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap24 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap25 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap26\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap27 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap28 = new mutable.Hash\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7fnhzure.scala:17:33 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7fnhzure.scala:18:34 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap2\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7fnhzure.scala:19:34 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap3\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7fnhzure.scala:20:34 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap4\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7fnhzure.scala:21:34 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap5\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val maxLen4 = maxLen\
    \ / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6 = maxLen / 6\n  \
    \      val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen / 8\n        val\
    \ maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n        val maxLen11\
    \ = maxLen / 11\n        val maxLen12 = maxLen / 12\n        val maxLen13 = maxLen\
    \ / 13\n        val maxLen14 = maxLen / 14\n        val maxLen15 = maxLen / 15\n\
    \        val maxLen16 = maxLen / 16\n        val maxLen17 = maxLen / 17\n    \
    \    val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen / 19\n        val\
    \ maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n        val maxLen22\
    \ = maxLen / 22\n        val maxLen23 = maxLen / 23\n        val maxLen24 = maxLen\
    \ / 24\n        val maxLen25 = maxLen / 25\n        val maxLen26 = maxLen / 26\n\
    \        val maxLen27 = maxLen / 27\n        val maxLen28 = maxLen / 28\n    \
    \    val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen / 30\n        val\
    \ maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n        val maxLen33\
    \ = maxLen / 33\n        val maxLen34 = maxLen / 34\n        val maxLen35 = maxLen\
    \ / 35\n        val maxLen36 = maxLen / 36\n        val maxLen37 = maxLen / 37\n\
    \        val maxLen38 = maxLen / 38\n        val maxLen39 = maxLen / 39\n    \
    \    val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen / 41\n        val\
    \ maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n        val maxLen44\
    \ = maxLen / 44\n        val maxLen45 = maxLen / 45\n        val maxLen46 = maxLen\
    \ / 46\n        val maxLen47 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp75bnhsm8.scala:60:22 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp75bnhsm8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp75bnhsm8.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ min = len\n        var changes = 0\n        while (i < len) {\n            while\
    \ (j < len) {\n                if (arr(i) != arr(j)) {\n                    changes\
    \ += 1\n                    min = Math.min(min, changes)\n                }\n\
    \                j++\n            }\n            i += 1\n            j = 0\n \
    \       }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8t5lho0n.scala:24:19 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8t5lho0n.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var change = 0\n        while (i\
    \ < len) {\n            while (j < len) {\n                if (arr(i) == arr(j))\
    \ {\n                    j++\n                }\n                else {\n    \
    \                change = arr(i) - arr(j)\n                    if (change < minChange)\
    \ {\n                        minChange = change\n                    }\n     \
    \               j++\n                }\n            }\n            i += 1\n  \
    \          j = 0\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf5wk4kpg.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpf5wk4kpg.scala:29:23 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf5wk4kpg.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpf5wk4kpg.scala:27:34\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                   \
    \     minChange = change\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val minChange\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805317
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var change =\
    \ 0\n        while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n  \
    \              change += 1\n                i += 1\n            } else if (arr(i)\
    \ > arr(j)) {\n                change -= 1\n                j += 1\n         \
    \   } else {\n                i += 1\n                j += 1\n            }\n\
    \        }\n        if (change == 0) {\n            change = 1\n        }\n  \
    \      changes += change\n        val maxChange = changes.max\n        if (maxChange\
    \ == 0) {\n            return 0\n        }\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var change = 0\n        while (i < n && j < n)\
    \ {\n            if (arr(i) < arr(j)) {\n                change += 1\n       \
    \         i += 1\n            } else if (arr(i) > arr(j)) {\n                change\
    \ -= 1\n                j += 1\n            } else {\n                i += 1\n\
    \                j += 1\n            }\n        }\n        if (change == 0) {\n\
    \            change = 1\n        }\n        changes += change\n        val maxChange\
    \ = changes.max\n        if (maxChange == 0) {\n            return 0\n       \
    \ }\n        var i = 0\n        var j = 0\n        var k = 0\n        var change\
    \ = 0\n        while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n\
    \                change += 1\n                i += 1\n            } else if (arr(i)\
    \ > arr(j)) {\n                change -= 1\n                j += 1\n         \
    \   } else {\n                i += 1\n                j += 1\n            }\n\
    \        }\n        if (change == 0) {\n            change = 1\n        }\n  \
    \      changes += change\n        val maxChange = changes.max\n        if (maxChange\
    \ == 0) {\n            return 0\n        }\n        var i = 0\n        var j =\
    \ 0\n        var k = 0\n        var change = 0\n        while (i < n && j < n)\
    \ {\n            if (arr(i) < arr(j)) {\n                change += 1\n       \
    \         i += 1\n            } else if (arr(i) > arr(j)) {\n                change\
    \ -= 1\n                j += 1\n            } else {\n                i += 1\n\
    \                j += 1\n            }\n        }\n        if (change == 0) {\n\
    \            change = 1\n        }\n        changes += change\n        val maxChange\
    \ = changes.max\n        if (maxChange == 0) {\n            return 0\n       \
    \ }\n        var i = 0\n        var j = 0\n        var k = 0\n        var change\
    \ = 0\n        while (i < n && j < n) {\n            if (arr(i) < arr(j)) {\n\
    \                change += 1\n                i += 1\n            } else if (arr(i)\
    \ > arr(j)) {\n                change -= 1\n                j += 1\n         \
    \   } else {\n                i += 1\n                j += 1\n            }\n\
    \        }\n        if (change == 0) {\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp511ws5l9.scala:143:0 ---------------------------\e\
    [0m\e[0m\n\e[31m143 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp511ws5l9.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp511ws5l9.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp511ws5l9.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp511ws5l9.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mvar\e[0m \e[36mchange\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is\
    \ already defined as \e[33mvariable\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp511ws5l9.scala:60:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxChange\e[0m = changes.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChange is already defined as \e[33mvalue\e[0m \e[35mmaxChange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659805325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.HashSet[Long]()\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var k1 = n -\
    \ 1\n        var k2 = n - 1\n        var k3 = n - 1\n        var k4 = n - 1\n\
    \        var k5 = n - 1\n        var k6 = n - 1\n        var k7 = n - 1\n    \
    \    var k8 = n - 1\n        var k9 = n - 1\n        var k10 = n - 1\n       \
    \ var k11 = n - 1\n        var k12 = n - 1\n        var k13 = n - 1\n        var\
    \ k14 = n - 1\n        var k15 = n - 1\n        var k16 = n - 1\n        var k17\
    \ = n - 1\n        var k18 = n - 1\n        var k19 = n - 1\n        var k20 =\
    \ n - 1\n        var k21 = n - 1\n        var k22 = n - 1\n        var k23 = n\
    \ - 1\n        var k24 = n - 1\n        var k25 = n - 1\n        var k26 = n -\
    \ 1\n        var k27 = n - 1\n        var k28 = n - 1\n        var k29 = n - 1\n\
    \        var k30 = n - 1\n        var k31 = n - 1\n        var k32 = n - 1\n \
    \       var k33 = n - 1\n        var k34 = n - 1\n        var k35 = n - 1\n  \
    \      var k36 = n - 1\n        var k37 = n - 1\n        var k38 = n - 1\n   \
    \     var k39 = n - 1\n        var k40 = n - 1\n        var k41 = n - 1\n    \
    \    var k42 = n - 1\n        var k43 = n - 1\n        var k44 = n - 1\n     \
    \   var k45 = n - 1\n        var k46 = n - 1\n        var k47 = n - 1\n      \
    \  var k48 = n - 1\n        var k49 = n - 1\n        var k50 = n - 1\n       \
    \ var k51 = n - 1\n        var k52 = n - 1\n        var k53 = n - 1\n        var\
    \ k54 = n - 1\n        var k55 = n - 1\n        var k56 = n - 1\n        var k57\
    \ = n - 1\n        var k58 = n - 1\n        var k59 = n - 1\n        var k60 =\
    \ n - 1\n        var k61 = n - 1\n        var k62 = n - 1\n        var k63 = n\
    \ - 1\n        var k64 = n - 1\n        var k65 = n - 1\n        var k66 = n -\
    \ 1\n        var k67 = n - 1\n        var k68 = n - 1\n        var k69 = n - 1\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp17m1slx_.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp17m1slx_.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.HashSet[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp17m1slx_.scala:89:5 ---------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val mid2 = len / 2\n        val mid3 = len\
    \ / 2\n        val mid4 = len / 2\n        val mid5 = len / 2\n        val mid6\
    \ = len / 2\n        val mid7 = len / 2\n        val mid8 = len / 2\n        val\
    \ mid9 = len / 2\n        val mid10 = len / 2\n        val mid11 = len / 2\n \
    \       val mid12 = len / 2\n        val mid13 = len / 2\n        val mid14 =\
    \ len / 2\n        val mid15 = len / 2\n        val mid16 = len / 2\n        val\
    \ mid17 = len / 2\n        val mid18 = len / 2\n        val mid19 = len / 2\n\
    \        val mid20 = len / 2\n        val mid21 = len / 2\n        val mid22 =\
    \ len / 2\n        val mid23 = len / 2\n        val mid24 = len / 2\n        val\
    \ mid25 = len / 2\n        val mid26 = len / 2\n        val mid27 = len / 2\n\
    \        val mid28 = len / 2\n        val mid29 = len / 2\n        val mid30 =\
    \ len / 2\n        val mid31 = len / 2\n        val mid32 = len / 2\n        val\
    \ mid33 = len / 2\n        val mid34 = len / 2\n        val mid35 = len / 2\n\
    \        val mid36 = len / 2\n        val mid37 = len / 2\n        val mid38 =\
    \ len / 2\n        val mid39 = len / 2\n        val mid40 = len / 2\n        val\
    \ mid41 = len / 2\n        val mid42 = len / 2\n        val mid43 = len / 2\n\
    \        val mid44 = len / 2\n        val mid45 = len / 2\n        val mid46 =\
    \ len / 2\n        val mid47 = len / 2\n        val mid48 = len / 2\n        val\
    \ mid49 = len / 2\n        val mid50 = len / 2\n        val mid51 = len / 2\n\
    \        val mid52 = len / 2\n        val mid53 = len / 2\n        val mid54 =\
    \ len / 2\n        val mid55 = len / 2\n        val mid5\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoe_r_whf.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoe_r_whf.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoe_r_whf.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexSet = mutable.HashSet[Int]()\n        val minChangeIndexSet2\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet3 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet4 = mutable.HashSet[Int]()\n        val minChangeIndexSet5\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet6 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet7 = mutable.HashSet[Int]()\n        val minChangeIndexSet8\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet9 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet10 = mutable.HashSet[Int]()\n        val minChangeIndexSet11\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet12 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet13 = mutable.HashSet[Int]()\n        val minChangeIndexSet14\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet15 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet16 = mutable.HashSet[Int]()\n        val minChangeIndexSet17\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet18 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet19 = mutable.HashSet[Int]()\n        val minChangeIndexSet20\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet21 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet22 = mutable.HashSet[Int]()\n        val minChangeIndexSet23\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet24 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet25 = mutable.HashSet[Int]()\n        val minChangeIndexSet26\
    \ = mutable.HashSet[Int]()\n        val minChangeIndexSet27 = mutable.HashSet[Int]()\n\
    \        val minChangeIndexSet28 = mutable.HashSet[Int]()\n        val minChangeIndexSet29\
    \ = mutable.HashSet[Int]()\n        val minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzoww6bhq.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzoww6bhq.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzoww6bhq.scala:16:32\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexSet\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzoww6bhq.scala:17:33 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSet2\e[0m\
    \ = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzoww6bhq.scala:18:33\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexSet3\e[0m = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzoww6bhq.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSet4\e[0m\
    \ = mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^^^\e[0m\n"
  stdout: ''
  timestamp: 1659805323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val d = new Array[Long](n + 1)\n        val dp\
    \ = new Array[Long](n + 1)\n        dp(0) = m\n        for(i<-1 to n) {\n    \
    \        dp(i) = dp(i-1) + arr(i)\n        }\n        val maxDp = dp.max\n   \
    \     val maxDpIndex = dp.indexWhere(x => x == maxDp)\n        val maxDpIndexInRange\
    \ = maxDpIndex - 1\n        val maxDpIndexInRangeInRange = maxDpIndexInRange -\
    \ 1\n        val maxDpIndexInRangeInRangeInRange = maxDpIndexInRangeInRange -\
    \ 1\n        val maxDpIndexInRangeInRangeInRangeInRange = maxDpIndexInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRange = maxDpIndexInRangeInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRange = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange - 1\n        val\
    \ maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange - 1\n \
    \       val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ - 1\n        val maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeIn\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb2qovq_k.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb2qovq_k.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpb2qovq_k.scala:27:67 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m = maxDpIndexInRangeInRangeInRangeInRangeInRangeInRange - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxDpIndexInRangeInRangeInRangeInRangeInRangeInRange\e\
    [0m "
  stdout: ''
  timestamp: 1659805337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var changes = 0\n        var maxChanges = 0\n        var minChanges =\
    \ 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n      \
    \  var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n        var minChangesIndex = 0\n        var maxChangesIndex\
    \ = 0\n        var minChangesIndex = 0\n        var maxChangesIndex = 0\n    \
    \    var minChangesIndex = 0\n        var maxChangesIndex = 0\n        var minChangesIndex\
    \ = 0\n        var maxChangesIndex = 0\n        var minChangesIndex = 0\n    \
    \    var maxChangesIndex = 0\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2_iwp7vt.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mminChangesIndex\e[0m = \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mminChangesIndex is already defined as \e[33mvariable\e[0m \e[35mminChangesIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2_iwp7vt.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mvar\e[0m \e[36mmaxChangesIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangesIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangesIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2_iwp7vt.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mvar\e[0m \e[36mminChangesIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangesIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mminChangesIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2_iwp7vt.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mvar\e[0m \e[36mmaxChangesIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxChangesIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxChangesIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2_iwp7vt.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mvar\e[0m \e[36mminChangesIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangesIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mm"
  stdout: ''
  timestamp: 1659805336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val maxLen4 = maxLen\
    \ / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6 = maxLen / 6\n  \
    \      val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen / 8\n        val\
    \ maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n        val maxLen11\
    \ = maxLen / 11\n        val maxLen12 = maxLen / 12\n        val maxLen13 = maxLen\
    \ / 13\n        val maxLen14 = maxLen / 14\n        val maxLen15 = maxLen / 15\n\
    \        val maxLen16 = maxLen / 16\n        val maxLen17 = maxLen / 17\n    \
    \    val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen / 19\n        val\
    \ maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n        val maxLen22\
    \ = maxLen / 22\n        val maxLen23 = maxLen / 23\n        val maxLen24 = maxLen\
    \ / 24\n        val maxLen25 = maxLen / 25\n        val maxLen26 = maxLen / 26\n\
    \        val maxLen27 = maxLen / 27\n        val maxLen28 = maxLen / 28\n    \
    \    val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen / 30\n        val\
    \ maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n        val maxLen33\
    \ = maxLen / 33\n        val maxLen34 = maxLen / 34\n        val maxLen35 = maxLen\
    \ / 35\n        val maxLen36 = maxLen / 36\n        val maxLen37 = maxLen / 37\n\
    \        val maxLen38 = maxLen / 38\n        val maxLen39 = maxLen / 39\n    \
    \    val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen / 41\n        val\
    \ maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n        val maxLen44\
    \ = maxLen / 44\n        val maxLen45 = maxLen / 45\n        val maxLen46 = maxLen\
    \ / 46\n        val maxLen47 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp75bnhsm8.scala:60:22 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp75bnhsm8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp75bnhsm8.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.size\n\
    \        val changes = mutable.ArrayBuffer(arr.size)\n        val changed = mutable.ArrayBuffer(arr.size)\n\
    \        val changeCounts = mutable.ArrayBuffer(arr.size)\n        val changeCount\
    \ = 0\n        val changeCountMax = arr.size\n        val changeCountMin = 0\n\
    \        val changeCountMaxMin = 0\n        val changeCountMinMax = 0\n      \
    \  val changeCountMinMaxMin = 0\n        val changeCountMinMaxMinMin = 0\n   \
    \     val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMaxMinMinMin\
    \ = 0\n        val changeCountMinMaxMinMinMin = 0\n        val changeCountMinMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_aotq5sc.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_aotq5sc.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCountMinMaxMinMinMin\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_aotq5sc.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMinMin\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvalue\e[0m\
    \ \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_aotq5sc.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvalue\e\
    [0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_aotq5sc.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mchangeCountMinMaxMinMinMin\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCountMinMaxMinMinMin is already defined as \e[33mvalue\e\
    [0m \e[35mchangeCountMinMaxMinMinMin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must al"
  stdout: ''
  timestamp: 1659805337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val mid1 = len / 2 - 1\n        val mid2 =\
    \ len / 2 + 1\n        val mid3 = len / 3\n        val mid4 = len / 4\n      \
    \  val mid5 = len / 5\n        val mid6 = len / 6\n        val mid7 = len / 7\n\
    \        val mid8 = len / 8\n        val mid9 = len / 9\n        val mid10 = len\
    \ / 10\n        val mid11 = len / 11\n        val mid12 = len / 12\n        val\
    \ mid13 = len / 13\n        val mid14 = len / 14\n        val mid15 = len / 15\n\
    \        val mid16 = len / 16\n        val mid17 = len / 17\n        val mid18\
    \ = len / 18\n        val mid19 = len / 19\n        val mid20 = len / 20\n   \
    \     val mid21 = len / 21\n        val mid22 = len / 22\n        val mid23 =\
    \ len / 23\n        val mid24 = len / 24\n        val mid25 = len / 25\n     \
    \   val mid26 = len / 26\n        val mid27 = len / 27\n        val mid28 = len\
    \ / 28\n        val mid29 = len / 29\n        val mid30 = len / 30\n        val\
    \ mid31 = len / 31\n        val mid32 = len / 32\n        val mid33 = len / 33\n\
    \        val mid34 = len / 34\n        val mid35 = len / 35\n        val mid36\
    \ = len / 36\n        val mid37 = len / 37\n        val mid38 = len / 38\n   \
    \     val mid39 = len / 39\n        val mid40 = len / 40\n        val mid41 =\
    \ len / 41\n        val mid42 = len / 42\n        val mid43 = len / 43\n     \
    \   val mid44 = len / 44\n        val mid45 = len / 45\n        val mid46 = len\
    \ / 46\n        val mid47 = len / 47\n        val mid48 = len / 48\n        val\
    \ mid49 = len / 49\n        val mid50 = len / 50\n        val mid51 = len / 51\n\
    \        val mid52 = len / 52\n        val mid53 = len / 53\n        val mid54\
    \ = len / 54\n        val mid\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpje6rfc5z.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpje6rfc5z.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpje6rfc5z.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805337
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer(m)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var change = 0\n        while (i < n) {\n            while (j < n) {\n\
    \                if (arr(i) == arr(j)) {\n                    temp += 1\n    \
    \                j += 1\n                } else {\n                    temp =\
    \ 0\n                    j += 1\n                }\n            }\n          \
    \  change = temp\n            changes += change\n            i += 1\n        \
    \    j = 0\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsx23b7ij.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsx23b7ij.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805331
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexArr: List[Int] = new Array[Int](len)\n      \
    \  val minChangeIndexArr2 = new Array[Int](len)\n        val minChangeIndexArr3\
    \ = new Array[Int](len)\n        val minChangeIndexArr4 = new Array[Int](len)\n\
    \        val minChangeIndexArr5 = new Array[Int](len)\n        val minChangeIndexArr6\
    \ = new Array[Int](len)\n        val minChangeIndexArr7 = new Array[Int](len)\n\
    \        val minChangeIndexArr8 = new Array[Int](len)\n        val minChangeIndexArr9\
    \ = new Array[Int](len)\n        val minChangeIndexArr10 = new Array[Int](len)\n\
    \        val minChangeIndexArr11 = new Array[Int](len)\n        val minChangeIndexArr12\
    \ = new Array[Int](len)\n        val minChangeIndexArr13 = new Array[Int](len)\n\
    \        val minChangeIndexArr14 = new Array[Int](len)\n        val minChangeIndexArr15\
    \ = new Array[Int](len)\n        val minChangeIndexArr16 = new Array[Int](len)\n\
    \        val minChangeIndexArr17 = new Array[Int](len)\n        val minChangeIndexArr18\
    \ = new Array[Int](len)\n        val minChangeIndexArr19 = new Array[Int](len)\n\
    \        val minChangeIndexArr20 = new Array[Int](len)\n        val minChangeIndexArr21\
    \ = new Array[Int](len)\n        val minChangeIndexArr22 = new Array[Int](len)\n\
    \        val minChangeIndexArr23 = new Array[Int](len)\n        val minChangeIndexArr24\
    \ = new Array[Int](len)\n        val minChangeIndexArr25 = new Array[Int](len)\n\
    \        val minChangeIndexArr26 = new Array[Int](len)\n        val minChangeIndexArr27\
    \ = new Array[Int](len)\n        val minChangeIndexArr28 = new Array[Int](len)\n\
    \        val minChangeIndexArr29 = new Array[Int](len)\n        val minChangeIndexArr30\
    \ = new Array[Int](len)\n        val minChangeIndexArr31 = new Array[Int](len)\n\
    \        val minChangeIndexArr32 = new Array[Int](len)\n        val minChangeIndexArr33\
    \ = new Array[Int](len)\n        val minChangeIndexArr34 = new Array[Int](len)\n\
    \        val minChangeIndex\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwk2x3iw1.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwk2x3iw1.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwk2x3iw1.scala:16:43\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArr\e\
    [0m: \e[35mList\e[0m[\e[35mInt\e[0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e\
    [0m](len)\n\e[31m\e[31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Found:    \e[1m\e\
    [31mArray\e[0m[Int]\n\e[31m   |\e[0m                                         \
    \  Required: \e[1m\e[32mList\e[0m[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwk2x3iw1.scala:51:5 ---------------------\e[0m\e\
    [0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val m = arr.max\n        val dp = new Array[Long](n\
    \ + 1)\n        dp(0) = 1\n        val dp1 = new Array[Long](n + 1)\n        dp1(0)\
    \ = 1\n        val dp2 = new Array[Long](n + 1)\n        dp2(0) = 1\n        val\
    \ dp3 = new Array[Long](n + 1)\n        dp3(0) = 1\n        val dp4 = new Array[Long](n\
    \ + 1)\n        dp4(0) = 1\n        val dp5 = new Array[Long](n + 1)\n       \
    \ dp5(0) = 1\n        val dp6 = new Array[Long](n + 1)\n        dp6(0) = 1\n \
    \       val dp7 = new Array[Long](n + 1)\n        dp7(0) = 1\n        val dp8\
    \ = new Array[Long](n + 1)\n        dp8(0) = 1\n        val dp9 = new Array[Long](n\
    \ + 1)\n        dp9(0) = 1\n        val dp10 = new Array[Long](n + 1)\n      \
    \  dp10(0) = 1\n        val dp11 = new Array[Long](n + 1)\n        dp11(0) = 1\n\
    \        val dp12 = new Array[Long](n + 1)\n        dp12(0) = 1\n        val dp13\
    \ = new Array[Long](n + 1)\n        dp13(0) = 1\n        val dp14 = new Array[Long](n\
    \ + 1)\n        dp14(0) = 1\n        val dp15 = new Array[Long](n + 1)\n     \
    \   dp15(0) = 1\n        val dp16 = new Array[Long](n + 1)\n        dp16(0) =\
    \ 1\n        val dp17 = new Array[Long](n + 1)\n        dp17(0) = 1\n        val\
    \ dp18 = new Array[Long](n + 1)\n        dp18(0) = 1\n        val dp19 = new Array[Long](n\
    \ + 1)\n        dp19(0) = 1\n        val dp20 = new Array[Long](n + 1)\n     \
    \   dp20(0) = 1\n        val dp21 = new Array[Long](n + 1)\n        dp21(0) =\
    \ 1\n        val dp22 = new Array[Long](n + 1)\n        dp22(0) = 1\n        val\
    \ dp23 = new Array[Long](n + 1)\n        dp23(0) = 1\n        val dp24 = new Array[Long](n\
    \ + 1)\n        dp24(0) = 1\n        val dp25 = new Array[Long](n + 1)\n     \
    \   dp25(0) = 1\n        val dp26 = new Array[Long](n + 1)\n        dp26(0) =\
    \ 1\n        val dp27 = new Array[Long](n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4m0p1kv0.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4m0p1kv0.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4m0p1kv0.scala:70:5\
    \ ---------------------\e[0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_).reverse\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        while(i < arr.length && j < arr.length) {\n            if(arr(i) == arr(j))\
    \ {\n                i += 1\n                j += 1\n                k += 1\n\
    \            } else {\n                if(arr(i) < arr(j)) {\n               \
    \     i += 1\n                } else {\n                    j += 1\n         \
    \       }\n            }\n            if(k == arr.length) {\n                min\
    \ = Math.min(min, i - j)\n                k = 0\n            }\n        }\n  \
    \      min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp_0w7s31t.scala:12:29 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_0w7s31t.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805332
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ while (j < len) {\n                if (arr(i) != arr(j)) {\n               \
    \     minChange = minChange - 1\n                    k = j\n                }\n\
    \                j++\n            }\n            i = i + 1\n            j = 0\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptd18buc0.scala:24:19 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptd18buc0.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmptd18buc0.scala:21:30\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                   \
    \ minChange = minChange - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.sortWith(_ < _)\n        val len\
    \ = arr.length\n        val p = new Array[Long](len + 1)\n        val p1 = new\
    \ Array[Long](len + 1)\n        val p2 = new Array[Long](len + 1)\n        val\
    \ p3 = new Array[Long](len + 1)\n        val p4 = new Array[Long](len + 1)\n \
    \       val p5 = new Array[Long](len + 1)\n        val p6 = new Array[Long](len\
    \ + 1)\n        val p7 = new Array[Long](len + 1)\n        val p8 = new Array[Long](len\
    \ + 1)\n        val p9 = new Array[Long](len + 1)\n        val p10 = new Array[Long](len\
    \ + 1)\n        val p11 = new Array[Long](len + 1)\n        val p12 = new Array[Long](len\
    \ + 1)\n        val p13 = new Array[Long](len + 1)\n        val p14 = new Array[Long](len\
    \ + 1)\n        val p15 = new Array[Long](len + 1)\n        val p16 = new Array[Long](len\
    \ + 1)\n        val p17 = new Array[Long](len + 1)\n        val p18 = new Array[Long](len\
    \ + 1)\n        val p19 = new Array[Long](len + 1)\n        val p20 = new Array[Long](len\
    \ + 1)\n        val p21 = new Array[Long](len + 1)\n        val p22 = new Array[Long](len\
    \ + 1)\n        val p23 = new Array[Long](len + 1)\n        val p24 = new Array[Long](len\
    \ + 1)\n        val p25 = new Array[Long](len + 1)\n        val p26 = new Array[Long](len\
    \ + 1)\n        val p27 = new Array[Long](len + 1)\n        val p28 = new Array[Long](len\
    \ + 1)\n        val p29 = new Array[Long](len + 1)\n        val p30 = new Array[Long](len\
    \ + 1)\n        val p31 = new Array[Long](len + 1)\n        val p32 = new Array[Long](len\
    \ + 1)\n        val p33 = new Array[Long](len + 1)\n        val p34 = new Array[Long](len\
    \ + 1)\n        val p35 = new Array[Long](len + 1)\n        val p36 = new Array[Long](len\
    \ + 1)\n        val p37 = new Array[Long](len + 1)\n        val p38 = new Array[Long](len\
    \ + 1)\n        val p39 = new Array[Long](len + 1)\n        val p\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpleaduq08.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpleaduq08.scala:14:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpleaduq08.scala:57:5\
    \ ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = arr.take(len/2)\n     \
    \   val maxChange = arr.drop(len/2)\n        val changes = minChange.zip(maxChange).filter(_._1\
    \ != _._1).map(_._2).sum\n        val maxChanges = maxChange.foldLeft(0)(_ + arr.lastIndexOf(_))\n\
    \        val change = changes + maxChanges\n        change\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplvfctd3w.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805335
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        val mid = len / 2\n        val left = arr.take(mid)\n       \
    \ val right = arr.drop(mid)\n        val leftMin = smallestChange(left)\n    \
    \    val rightMin = smallestChange(right)\n        if (leftMin == rightMin) {\n\
    \            return leftMin\n        }\n        if (leftMin > rightMin) {\n  \
    \          return leftMin\n        }\n        return rightMin\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpes8dbioc.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805336
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var min = len\n        var i = 0\n    \
    \    var j = 0\n        while (i < len) {\n            while (j < len) {\n   \
    \             if (arr(i) != arr(j)) {\n                    min = Math.min(min,\
    \ j-i)\n                }\n                j++\n            }\n            i++\n\
    \        }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf38npitc.scala:22:19 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf38npitc.scala:24:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpf38npitc.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        val min = len\n        val max = (len /\
    \ 2) + 1\n        var i = 0\n        var j = 0\n        var k = 0\n        var\
    \ minChange = 0\n        var maxChange = 0\n        while (i < len) {\n      \
    \      while (j < len) {\n                if (arr(i) == arr(j)) {\n          \
    \          j++\n                }\n                else {\n                  \
    \  j++\n                    k++\n                }\n            }\n          \
    \  while (k < len) {\n                if (arr(i) == arr(k)) {\n              \
    \      k++\n                }\n                else {\n                    k++\n\
    \                    j++\n                }\n            }\n            minChange\
    \ = minChange.max(j - i)\n            maxChange = maxChange.max(k - i)\n     \
    \       i = j\n            j = k\n        }\n        if (min == max) {\n     \
    \       minChange\n        }\n        else {\n            minChange.max(maxChange)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3skdpptx.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp3skdpptx.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3skdpptx.scala:33:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp3skdpptx.scala:37:23 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3skdpptx.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3skdpptx.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m                    value ++ is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Foun"
  stdout: ''
  timestamp: 1659805345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = arr.head\n        var minChangeCount\
    \ = 0\n        var maxChangeCount = 0\n        var maxChange = arr.head\n    \
    \    var maxChangeIndex = -1\n        var minChangeIndex = -1\n        var maxChangeIndex2\
    \ = -1\n        var minChangeIndex2 = -1\n        var maxChangeIndex3 = -1\n \
    \       var minChangeIndex3 = -1\n        var maxChangeIndex4 = -1\n        var\
    \ minChangeIndex4 = -1\n        var maxChangeIndex5 = -1\n        var minChangeIndex5\
    \ = -1\n        var maxChangeIndex6 = -1\n        var minChangeIndex6 = -1\n \
    \       var maxChangeIndex7 = -1\n        var minChangeIndex7 = -1\n        var\
    \ maxChangeIndex8 = -1\n        var minChangeIndex8 = -1\n        var maxChangeIndex9\
    \ = -1\n        var minChangeIndex9 = -1\n        var maxChangeIndex10 = -1\n\
    \        var minChangeIndex10 = -1\n        var maxChangeIndex11 = -1\n      \
    \  var minChangeIndex11 = -1\n        var maxChangeIndex12 = -1\n        var minChangeIndex12\
    \ = -1\n        var maxChangeIndex13 = -1\n        var minChangeIndex13 = -1\n\
    \        var maxChangeIndex14 = -1\n        var minChangeIndex14 = -1\n      \
    \  var maxChangeIndex15 = -1\n        var minChangeIndex15 = -1\n        var maxChangeIndex16\
    \ = -1\n        var minChangeIndex16 = -1\n        var maxChangeIndex17 = -1\n\
    \        var minChangeIndex17 = -1\n        var maxChangeIndex18 = -1\n      \
    \  var minChangeIndex18 = -1\n        var maxChangeIndex19 = -1\n        var minChangeIndex19\
    \ = -1\n        var maxChangeIndex20 = -1\n        var minChangeIndex20 = -1\n\
    \        var maxChangeIndex21 = -1\n        var minChangeIndex21 = -1\n      \
    \  var maxChangeIndex22 = -1\n        var minChangeIndex22 = -1\n        var maxChangeIndex23\
    \ = -1\n        var minChangeIndex23 = -1\n        var maxChangeIndex24 = -1\n\
    \        var minChangeIndex24 = -1\n        var maxChangeIndex25 = -1\n      \
    \  var minChangeIndex25 = -1\n        var maxChangeIndex26 = -1\n        var minChangeIndex26\
    \ = -1\n        var maxChangeIndex27 = -1\n        var minChangeIndex27 = -1\n\
    \        var maxChangeIndex28 = -1\n        var minChangeIndex28 = -1\n      \
    \  var maxChangeIndex29 = -1\n        var minChangeIndex29 = -1\n        var maxChangeIndex30\
    \ = -1\n        var minChangeIndex30 = -1\n        var maxChangeIndex31 = -1\n\
    \        var minChangeIndex31 = -1\n        var maxChangeIndex32 = -1\n      \
    \  var minChangeIndex32 = -1\n        var maxChangeIndex33 = -1\n        var minChangeIndex33\
    \ = -1\n        var maxChangeIndex34 = -1\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmprea3ozlf.scala:85:11 ---------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmprea3ozlf.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprea3ozlf.scala:86:5 ---------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805343
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val d = arr.last\n        val r = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m1 = m\n        var m2 = m\n        var m3 = m\n        var m4 =\
    \ m\n        var m5 = m\n        var m6 = m\n        var m7 = m\n        var m8\
    \ = m\n        var m9 = m\n        var m10 = m\n        var m11 = m\n        var\
    \ m12 = m\n        var m13 = m\n        var m14 = m\n        var m15 = m\n   \
    \     var m16 = m\n        var m17 = m\n        var m18 = m\n        var m19 =\
    \ m\n        var m20 = m\n        var m21 = m\n        var m22 = m\n        var\
    \ m23 = m\n        var m24 = m\n        var m25 = m\n        var m26 = m\n   \
    \     var m27 = m\n        var m28 = m\n        var m29 = m\n        var m30 =\
    \ m\n        var m31 = m\n        var m32 = m\n        var m33 = m\n        var\
    \ m34 = m\n        var m35 = m\n        var m36 = m\n        var m37 = m\n   \
    \     var m38 = m\n        var m39 = m\n        var m40 = m\n        var m41 =\
    \ m\n        var m42 = m\n        var m43 = m\n        var m44 = m\n        var\
    \ m45 = m\n        var m46 = m\n        var m47 = m\n        var m48 = m\n   \
    \     var m49 = m\n        var m50 = m\n        var m51 = m\n        var m52 =\
    \ m\n        var m53 = m\n        var m54 = m\n        var m55 = m\n        var\
    \ m56 = m\n        var m57 = m\n        var m58 = m\n        var m59 = m\n   \
    \     var m60 = m\n        var m61 = m\n        var m62 = m\n        var m63 =\
    \ m\n        var m64 = m\n        var m65 = m\n        var m66 = m\n        var\
    \ m67 = m\n        var m68 = m\n        var m69 = m\n        var m70 = m\n   \
    \     var m71 = m\n        var m72 = m\n        var m73 = m\n        var m74 =\
    \ m\n        var m75 = m\n        var m76 = m\n        var m77 = m\n        var\
    \ m78 = m\n        var m79 = m\n        var m80 = m\n        var m81 = m\n   \
    \     var m82 = m\n        var m83 = m\n        var m84 = m\n        var m85 =\
    \ m\n        var m86 = m\n        var m87 = m\n        var m88 = m\n        var\
    \ m89 = m\n        var m90 = m\n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwn5bj9pp.scala:111:5\
    \ --------------------\e[0m\e[0m\n\e[31m111 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        val max = len\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var minChange\
    \ = 0\n        var maxChange = 0\n        while (i < len) {\n            while\
    \ (j < len) {\n                if (arr(i) == arr(j)) {\n                    j++\n\
    \                }\n                else {\n                    j = 0\n      \
    \          }\n            }\n            while (k < len) {\n                if\
    \ (arr(i) == arr(k)) {\n                    k++\n                }\n         \
    \       else {\n                    k = 0\n                }\n            }\n\
    \            if (i < len && j < len) {\n                if (arr(i) < arr(j)) {\n\
    \                    minChange = minChange+1\n                }\n            \
    \    else {\n                    maxChange = maxChange+1\n                }\n\
    \            }\n            i = j\n            j = k\n        }\n        if (minChange\
    \ > maxChange) {\n            minChange = maxChange\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx9lo0iyh.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpx9lo0iyh.scala:32:23 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx9lo0iyh.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      var i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n\
    \        var count = 0\n        while (i < arr.length) {\n            while (j\
    \ < arr.length) {\n                if (arr(i) == arr(j)) {\n                 \
    \   count += 1\n                    j++\n                } else {\n          \
    \          count = 0\n                    j++\n                }\n           \
    \ }\n            if (count < min) {\n                min = count\n           \
    \     k = i\n            }\n            count = 0\n            j++\n        }\n\
    \        return k\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxusmf64s.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpxusmf64s.scala:25:23 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxusmf64s.scala:33:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            j++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpxusmf64s.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805339
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var temp = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n \
    \       var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90\
    \ = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n\
    \        var temp94 = 0\n        var temp95 = 0\n        var temp96 = 0\n    \
    \    var temp\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_rzi1rqy.scala:115:4 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_rzi1rqy.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_rzi1rqy.scala:115:5\
    \ --------------------\e[0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = math.min(arr.take(arr.length/2).last,\
    \ arr.last)\n        val maxChange = math.max(arr.take(arr.length/2).last, arr.last)\n\
    \        val change = maxChange - minChange\n        val changes = arr.filter(_\
    \ - minChange < change)\n        val changeCount = changes.size\n        val changes\
    \ = changes.toList\n        val changeCount = changeCount.toLong\n        val\
    \ changes = changes.reverse\n        val changeCount = changeCount.toLong\n  \
    \      val changeCount = changeCount / 2\n        val changeCount = changeCount.toLong\n\
    \        val changeCount = changeCount * 2\n        val changeCount = changeCount.toLong\n\
    \        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = changeCount\
    \ * 2\n        val changeCount = changeCount * 2\n        val changeCount = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcciutp1_.scala:66:25 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpcciutp1_.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcciutp1_.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCount\e[0m = changeCount.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcciutp1_.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes.reverse\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcciutp1_.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCount\e[0m = changeCount.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all "
  stdout: ''
  timestamp: 1659805344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.last\n        val arr = arr.dropRight(1)\n        val arr2\
    \ = arr.takeRight(n)\n        val arr3 = arr2.reverse\n        val arr4 = arr3.takeRight(n)\n\
    \        val arr5 = arr4.dropRight(1)\n        val arr6 = arr5.takeRight(n)\n\
    \        val arr7 = arr6.dropRight(1)\n        val arr8 = arr7.takeRight(n)\n\
    \        val arr9 = arr8.dropRight(1)\n        val arr10 = arr9.takeRight(n)\n\
    \        val arr11 = arr10.dropRight(1)\n        val arr12 = arr11.takeRight(n)\n\
    \        val arr13 = arr12.dropRight(1)\n        val arr14 = arr13.takeRight(n)\n\
    \        val arr15 = arr14.dropRight(1)\n        val arr16 = arr15.takeRight(n)\n\
    \        val arr17 = arr16.dropRight(1)\n        val arr18 = arr17.takeRight(n)\n\
    \        val arr19 = arr18.dropRight(1)\n        val arr20 = arr19.takeRight(n)\n\
    \        val arr21 = arr20.dropRight(1)\n        val arr22 = arr21.takeRight(n)\n\
    \        val arr23 = arr22.dropRight(1)\n        val arr24 = arr23.takeRight(n)\n\
    \        val arr25 = arr24.dropRight(1)\n        val arr26 = arr25.takeRight(n)\n\
    \        val arr27 = arr26.dropRight(1)\n        val arr28 = arr27.takeRight(n)\n\
    \        val arr29 = arr28.dropRight(1)\n        val arr30 = arr29.takeRight(n)\n\
    \        val arr31 = arr30.dropRight(1)\n        val arr32 = arr31.takeRight(n)\n\
    \        val arr33 = arr32.dropRight(1)\n        val arr34 = arr33.takeRight(n)\n\
    \        val arr35 = arr34.dropRight(1)\n        val arr36 = arr35.takeRight(n)\n\
    \        val arr37 = arr36.dropRight(1)\n        val arr38 = arr37.takeRight(n)\n\
    \        val arr39 = arr38.dropRight(1)\n        val arr40 = arr39.takeRight(n)\n\
    \        val arr41 = arr40.dropRight(1)\n        val arr42 = arr41.takeRight(n)\n\
    \        val arr43 = arr42.dropRight(1)\n        val arr44 = arr43.takeRight(n)\n\
    \        val arr45 = arr44.dropRight(1)\n        val arr46 = arr45.takeRight(n)\n\
    \        val arr47 = arr\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9mbc8hhh.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m  \
    \                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9mbc8hhh.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.length\n\
    \        val reversed = arr.reverse\n        var i = 0\n        var j = 0\n  \
    \      var k = 0\n        var count = 0\n        while (i < minChange && j < reversed.length)\
    \ {\n            if (arr(i) == reversed(j)) {\n                count += 1\n  \
    \              i += 1\n                j += 1\n            } else if (arr(i) <\
    \ reversed(j)) {\n                i += 1\n            } else {\n             \
    \   j += 1\n            }\n        }\n        if (count < minChange) {\n     \
    \       minChange = count\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpiorx4pob.scala:30:22 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            minChange = count\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to\
    \ val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ minChange = 0\n        while(i < len) {\n            while(j < len) {\n    \
    \            if(arr(i) == arr(j)) {\n                    j++\n               \
    \ }\n                else {\n                    minChange = minChange + 1\n \
    \                   j = 0\n                }\n            }\n            i++\n\
    \            j = 0\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcqvn8kh2.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpcqvn8kh2.scala:28:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpcqvn8kh2.scala:12:18 ---------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcqvn8kh2.scala:27:13 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m            value ++ is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1659805345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.takeWhile(_ < 0).length\n        val k = arr.takeWhile(_ >\
    \ 0).length\n        val p = new Array[Long](k)\n        val q = new Array[Long](k)\n\
    \        val r = new Array[Long](k)\n        val s = new Array[Long](k)\n    \
    \    val t = new Array[Long](k)\n        val u = new Array[Long](k)\n        val\
    \ v = new Array[Long](k)\n        val w = new Array[Long](k)\n        val x =\
    \ new Array[Long](k)\n        val y = new Array[Long](k)\n        val z = new\
    \ Array[Long](k)\n        val a = new Array[Long](k)\n        val b = new Array[Long](k)\n\
    \        val c = new Array[Long](k)\n        val d = new Array[Long](k)\n    \
    \    val e = new Array[Long](k)\n        val f = new Array[Long](k)\n        val\
    \ g = new Array[Long](k)\n        val h = new Array[Long](k)\n        val i =\
    \ new Array[Long](k)\n        val j = new Array[Long](k)\n        val k = new\
    \ Array[Long](k)\n        val l = new Array[Long](k)\n        val m = new Array[Long](k)\n\
    \        val n = new Array[Long](k)\n        val o = new Array[Long](k)\n    \
    \    val p1 = new Array[Long](k)\n        val p2 = new Array[Long](k)\n      \
    \  val p3 = new Array[Long](k)\n        val p4 = new Array[Long](k)\n        val\
    \ p5 = new Array[Long](k)\n        val p6 = new Array[Long](k)\n        val p7\
    \ = new Array[Long](k)\n        val p8 = new Array[Long](k)\n        val p9 =\
    \ new Array[Long](k)\n        val p10 = new Array[Long](k)\n        val p11 =\
    \ new Array[Long](k)\n        val p12 = new Array[Long](k)\n        val p13 =\
    \ new Array[Long](k)\n        val p14 = new Array[Long](k)\n        val p15 =\
    \ new Array[Long](k)\n        val p16 = new Array[Long](k)\n        val p17 =\
    \ new Array[Long](k)\n        val p18 = new Array[Long](k)\n        val p19 =\
    \ new Array[Long](k)\n        val p20 = new Array[Long](k)\n        val p21 =\
    \ new \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphw4mg2d_.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphw4mg2d_.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mk\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](k)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mk is already defined as \e[33mvalue\e[0m \e[35mk\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphw4mg2d_.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](k)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphw4mg2d_.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](k)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphw4mg2d_.scala:62:5 ---------------------\e[0m\e[0m\n\e[31m62\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.last\n        val max = (n - 1) / 2\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var min = 0\n        var changes =\
    \ 0\n        var isPalindromic = false\n        while (i < n && j < n) {\n   \
    \         if (arr(i) < arr(j)) {\n                val temp = arr(i)\n        \
    \        arr(i) = arr(j)\n                arr(j) = temp\n                changes\
    \ += 1\n                isPalindromic = true\n            }\n            i +=\
    \ 1\n            j += 1\n        }\n        if (changes == 0) {\n            return\
    \ 0\n        }\n        if (changes > max) {\n            changes = max\n    \
    \    }\n        if (changes < min) {\n            changes = min\n        }\n \
    \       if (changes == 1) {\n            changes = 0\n        }\n        if (changes\
    \ == 2) {\n            changes = 1\n        }\n        if (changes == 3) {\n \
    \           changes = 2\n        }\n        if (changes == 4) {\n            changes\
    \ = 3\n        }\n        if (changes == 5) {\n            changes = 4\n     \
    \   }\n        if (changes == 6) {\n            changes = 5\n        }\n     \
    \   if (changes == 7) {\n            changes = 6\n        }\n        if (changes\
    \ == 8) {\n            changes = 7\n        }\n        if (changes == 9) {\n \
    \           changes = 8\n        }\n        if (changes == 10) {\n           \
    \ changes = 9\n        }\n        if (changes == 11) {\n            changes =\
    \ 10\n        }\n        if (changes == 12) {\n            changes = 11\n    \
    \    }\n        if (changes == 13) {\n            changes = 12\n        }\n  \
    \      if (changes == 14) {\n            changes = 13\n        }\n        if (changes\
    \ == 15) {\n            changes = 14\n        }\n        if (changes == 16) {\n\
    \            changes = 15\n        }\n        if (changes == 17) {\n         \
    \   changes = 16\n        }\n        if (changes == 18) {\n            changes\
    \ = 17\n        }\n        if (changes == 19) {\n            changes = 18\n  \
    \      }\n        if (changes == 20) {\n            changes = 19\n        }\n\
    \        if (changes == 21) {\n            changes = 20\n        }\n        if\
    \ (changes == 22) {\n            changes = 21\n        }\n        if (changes\
    \ == 23) {\n            changes = 22\n        }\n        if (changes == 24) {\n\
    \            changes = 23\n        }\n        if (changes == 25) {\n         \
    \   changes = 24\n        }\n        if (changes == 26) {\n            changes\
    \ = 25\n        }\n        if (changes == 27) {\n            changes = 26\n  \
    \      }\n        if (changes == 28) {\n            changes = 27\n        }\n\
    \        if (changes == 29) {\n            changes = 28\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8sb7h0zr.scala:24:16 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8sb7h0zr.scala:25:16\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8sb7h0zr.scala:125:8 --------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m        \e[33mif\e[0m (changes == \e[31m29\e[0m) {\n\
    \e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:    Unit\n\
    \e[31m    |\e[0m        Required: Long\n\e[31m    |\e[0m        Maybe you are\
    \ missing an else part for the conditional?\n\e[31m126 |\e[0m            changes\
    \ = \e[31m28\e[0m\n\e[31m127 |\e[0m        }\n\e[31m    |\e[0m\n\e[31m    |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val min = len / 2\n        val max\
    \ = len - min\n        var i = 0\n        var j = 0\n        var k = 0\n     \
    \   var count = 0\n        var temp = 0\n        while(i < min && j < max) {\n\
    \            temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) =\
    \ temp\n            i += 1\n            j += 1\n            k += 1\n         \
    \   count += 1\n        }\n        if(count < min) {\n            smallestChange(arr.take(min))\n\
    \        } else {\n            smallestChange(arr.take(max))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8wx5zrz.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805351
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeIndexList = mutable.ListBuffer[Int]()\n        val\
    \ minChangeIndexList2 = mutable.ListBuffer[Int]()\n        val minChangeIndexList3\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList4 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList5 = mutable.ListBuffer[Int]()\n        val minChangeIndexList6\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList7 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList8 = mutable.ListBuffer[Int]()\n        val minChangeIndexList9\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList10 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList11 = mutable.ListBuffer[Int]()\n        val minChangeIndexList12\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList13 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList14 = mutable.ListBuffer[Int]()\n        val minChangeIndexList15\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList16 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList17 = mutable.ListBuffer[Int]()\n        val minChangeIndexList18\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList19 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList20 = mutable.ListBuffer[Int]()\n        val minChangeIndexList21\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList22 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList23 = mutable.ListBuffer[Int]()\n        val minChangeIndexList24\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList25 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList26 = mutable.ListBuffer[Int]()\n        val minChangeIndexList27\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList28 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList29 = mutable.ListBuffer[Int]()\n        val minChangeIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1jf0tz2o.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1jf0tz2o.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1jf0tz2o.scala:16:33\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexList\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1jf0tz2o.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexList2\e[0m\
    \ = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1jf0tz2o.scala:18:34 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mminChangeIndexList3\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1jf0tz2o.scala:19:34 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexList4\e[0m\
    \ = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \         "
  stdout: ''
  timestamp: 1659805356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndex2 = len\n        val minChangeIndex3 = len\n\
    \        val minChangeIndex4 = len\n        val minChangeIndex5 = len\n      \
    \  val minChangeIndex6 = len\n        val minChangeIndex7 = len\n        val minChangeIndex8\
    \ = len\n        val minChangeIndex9 = len\n        val minChangeIndex10 = len\n\
    \        val minChangeIndex11 = len\n        val minChangeIndex12 = len\n    \
    \    val minChangeIndex13 = len\n        val minChangeIndex14 = len\n        val\
    \ minChangeIndex15 = len\n        val minChangeIndex16 = len\n        val minChangeIndex17\
    \ = len\n        val minChangeIndex18 = len\n        val minChangeIndex19 = len\n\
    \        val minChangeIndex20 = len\n        val minChangeIndex21 = len\n    \
    \    val minChangeIndex22 = len\n        val minChangeIndex23 = len\n        val\
    \ minChangeIndex24 = len\n        val minChangeIndex25 = len\n        val minChangeIndex26\
    \ = len\n        val minChangeIndex27 = len\n        val minChangeIndex28 = len\n\
    \        val minChangeIndex29 = len\n        val minChangeIndex30 = len\n    \
    \    val minChangeIndex31 = len\n        val minChangeIndex32 = len\n        val\
    \ minChangeIndex33 = len\n        val minChangeIndex34 = len\n        val minChangeIndex35\
    \ = len\n        val minChangeIndex36 = len\n        val minChangeIndex37 = len\n\
    \        val minChangeIndex38 = len\n        val minChangeIndex39 = len\n    \
    \    val minChangeIndex40 = len\n        val minChangeIndex41 = len\n        val\
    \ minChangeIndex42 = len\n        val minChangeIndex43 = len\n        val minChangeIndex44\
    \ = len\n        val minChangeIndex45 = len\n        val minChangeIndex46 = len\n\
    \        val minChangeIndex47 = len\n        val minChangeIndex48 = len\n    \
    \    val minChangeIndex49 = len\n        val minChangeIndex50 = len\n        val\
    \ minChangeIndex51 = len\n        val minChangeIndex52 = len\n        val minChangeIndex53\
    \ = len\n        val minChangeIndex54 = len\n        val minChangeIndex55 = len\n\
    \        val minChangeIndex56 = len\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfph2hjrf.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpfph2hjrf.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n + 1)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ minIndex = 0\n        var maxIndex = 0\n        while (i < n) {\n          \
    \  p(i) = arr(i)\n            i += 1\n        }\n        while (j < n) {\n   \
    \         if (p(j) != p(j - 1))\n                k += 1\n            j += 1\n\
    \        }\n        if (k > 0) {\n            while (k < n) {\n              \
    \  p(k) = 0\n                k += 1\n            }\n            while (j < n)\
    \ {\n                if (p(j) != p(j - 1))\n                    k += 1\n     \
    \           j += 1\n            }\n        }\n        while (j < n) {\n      \
    \      if (p(j) != p(j - 1))\n                k += 1\n            j += 1\n   \
    \     }\n        if (k > 0) {\n            while (k < n) {\n                p(k)\
    \ = 0\n                k += 1\n            }\n            while (j < n) {\n  \
    \              if (p(j) != p(j - 1))\n                    k += 1\n           \
    \     j += 1\n            }\n        }\n        while (j < n) {\n            if\
    \ (p(j) != p(j - 1))\n                k += 1\n            j += 1\n        }\n\
    \        if (k > 0) {\n            while (k < n) {\n                p(k) = 0\n\
    \                k += 1\n            }\n            while (j < n) {\n        \
    \        if (p(j) != p(j - 1))\n                    k += 1\n                j\
    \ += 1\n            }\n        }\n        while (j < n) {\n            if (p(j)\
    \ != p(j - 1))\n                k += 1\n            j += 1\n        }\n      \
    \  if (k > 0) {\n            while (k < n) {\n                p(k) = 0\n     \
    \           k += 1\n            }\n            while (j < n) {\n             \
    \   if (p(j) != p(j - 1))\n                    k += 1\n                j += 1\n\
    \            }\n        }\n        while (j < n) {\n            if (p(j) != p(j\
    \ - 1))\n                k += 1\n            j += 1\n        }\n        if (k\
    \ > 0) {\n            while (k < n) {\n                p(k) = 0\n            \
    \    k += 1\n            }\n            while (j < n) {\n                if (p(j)\
    \ != p(j - 1))\n                    k += 1\n                j += 1\n         \
    \   }\n        }\n        while (j < n) {\n            if (p(j) != p(j - 1))\n\
    \                k += 1\n            j += 1\n        }\n        if (k > 0) {\n\
    \            while (k < n) {\n                p(k) = 0\n                k += 1\n\
    \            }\n            while (j < n) {\n                if (p(j) != p(j -\
    \ 1))\n                    k += 1\n                j += 1\n            }\n   \
    \     }\n        while (j < n) {\n            if (p(j) != p(j - 1))\n        \
    \        k += 1\n            j += 1\n        }\n        if (k > 0) {\n       \
    \     \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsjubq7ps.scala:141:0 ---------------------------\e\
    [0m\e[0m\n\e[31m141 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsjubq7ps.scala:140:1\
    \ --------------------\e[0m\e[0m\n\e[31m140 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Long\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpsjubq7ps.scala:129:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m129 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n2 errors found\n"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = arr.take(n/2).foldLeft(0)((acc,\
    \ x) => acc + (x - arr(n/2)))\n        val maxChange = arr.take(n/2).foldLeft(0)((acc,\
    \ x) => acc + (arr(n/2) - x))\n        minChange < maxChange ? minChange : maxChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps5aj_s87.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps5aj_s87.scala:16:44 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        minChange < maxChange ? minChange : \e[35mmaxChange\e\
    [0m\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805349
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val max = (arr(0) + arr(n-1))/2\n       \
    \ val min = arr(0)\n        val maxIndex = 0\n        val minIndex = 0\n     \
    \   val changes = 0\n        val changed = new Array[Boolean](n)\n        val\
    \ change = new Array[Long](n)\n        val changeIndex = new Array[Int](n)\n \
    \       val changeIndexMap = new mutable.HashMap[Long, Int]()\n        val changeIndexMap2\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap3 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap4 = new mutable.HashMap[Int, Int]()\n    \
    \    val changeIndexMap5 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap6\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap7 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap8 = new mutable.HashMap[Int, Int]()\n    \
    \    val changeIndexMap9 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap10\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap11 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap12 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap13 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap14\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap15 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap16 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap17 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap18\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap19 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap20 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap21 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap22\
    \ = new mutable.HashMap[Int, Int]()\n        val changeIndexMap23 = new mutable.HashMap[Int,\
    \ Int]()\n        val changeIndexMap24 = new mutable.HashMap[Int, Int]()\n   \
    \     val changeIndexMap25 = new mutable.HashMap[Int, Int]()\n        val changeIndexMap26\
    \ = new \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp19gc91sv.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp19gc91sv.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp19gc91sv.scala:22:33 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeIndexMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp19gc91sv.scala:23:34\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mchangeIndexMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp19gc91sv.scala:24:34 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap3\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                  ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp19gc91sv.scala:25:34 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap4\e[0m = \e\
    [33mnew\e"
  stdout: ''
  timestamp: 1659805357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n)\n        val r = new\
    \ Array[Long](n)\n        val p1 = new Array[Long](n)\n        val p2 = new Array[Long](n)\n\
    \        val p3 = new Array[Long](n)\n        val p4 = new Array[Long](n)\n  \
    \      val p5 = new Array[Long](n)\n        val p6 = new Array[Long](n)\n    \
    \    val p7 = new Array[Long](n)\n        val p8 = new Array[Long](n)\n      \
    \  val p9 = new Array[Long](n)\n        val p10 = new Array[Long](n)\n       \
    \ val p11 = new Array[Long](n)\n        val p12 = new Array[Long](n)\n       \
    \ val p13 = new Array[Long](n)\n        val p14 = new Array[Long](n)\n       \
    \ val p15 = new Array[Long](n)\n        val p16 = new Array[Long](n)\n       \
    \ val p17 = new Array[Long](n)\n        val p18 = new Array[Long](n)\n       \
    \ val p19 = new Array[Long](n)\n        val p20 = new Array[Long](n)\n       \
    \ val p21 = new Array[Long](n)\n        val p22 = new Array[Long](n)\n       \
    \ val p23 = new Array[Long](n)\n        val p24 = new Array[Long](n)\n       \
    \ val p25 = new Array[Long](n)\n        val p26 = new Array[Long](n)\n       \
    \ val p27 = new Array[Long](n)\n        val p28 = new Array[Long](n)\n       \
    \ val p29 = new Array[Long](n)\n        val p30 = new Array[Long](n)\n       \
    \ val p31 = new Array[Long](n)\n        val p32 = new Array[Long](n)\n       \
    \ val p33 = new Array[Long](n)\n        val p34 = new Array[Long](n)\n       \
    \ val p35 = new Array[Long](n)\n        val p36 = new Array[Long](n)\n       \
    \ val p37 = new Array[Long](n)\n        val p38 = new Array[Long](n)\n       \
    \ val p39 = new Array[Long](n)\n        val p40 = new Array[Long](n)\n       \
    \ val p41 = new Array[Long](n)\n        val p42 = new Array[Long](n)\n       \
    \ val p43 = new Array[Long](n)\n        val p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk9gx647z.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpk9gx647z.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val palindromic\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChanges = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChanged = mutable.ArrayBuffer.empty[Long]\n        val\
    \ palindromicChangesLeft = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesLeftLeft\
    \ = mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesLeftRight =\
    \ mutable.ArrayBuffer.empty[Long]\n        val palindromicChangesRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightLeftRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightLeftLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftRightRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightLeftRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightRightLeftRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRightRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightLeftRightRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRightRightRight = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesRightRightLeftRightLeft = mutable.ArrayBuffer.empty[Long]\n\
    \        val palindromicChangesLeftLeftRightRightRight = mutable.Array\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjwu69ti.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mpalindromicChangesLeftLeftRightRight\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChangesLeftLeftRightRight is already defined as\
    \ \e[33mvalue\e[0m \e[35mpalindromicChangesLeftLeftRightRight\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzjwu69ti.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mpalindromicChangesLeftLeftRightRightRight\e[0m = mutable.Array\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChangesLeftLeftRightRightRight is already defined\
    \ as \e[33mvalue\e[0m \e[35mpalindromicChangesLeftLeftRightRightRight\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzjwu69ti.scala:14:22 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzjwu69ti.scala:15:22 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzjwu69ti.scala:16:26 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpalin"
  stdout: ''
  timestamp: 1659805357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var minChangeIndex = 0\n      \
    \  var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n        var minChangeIndex4\
    \ = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6 = 0\n    \
    \    var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n        var minChangeIndex9\
    \ = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11 = 0\n  \
    \      var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n        var\
    \ minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var minChangeIndex16\
    \ = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18 = 0\n  \
    \      var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n        var\
    \ minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var minChangeIndex23\
    \ = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25 = 0\n  \
    \      var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n        var\
    \ minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var minChangeIndex30\
    \ = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32 = 0\n  \
    \      var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n        var\
    \ minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var minChangeIndex37\
    \ = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39 = 0\n  \
    \      var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n        var\
    \ minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var minChangeIndex44\
    \ = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46 = 0\n  \
    \      var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n        var\
    \ minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var minChangeIndex51\
    \ = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53 = 0\n  \
    \      var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n        var\
    \ minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var minChangeIndex58\
    \ = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60 = 0\n  \
    \      var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n        var\
    \ minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var minChangeIndex65\
    \ = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67 = 0\n  \
    \      var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg9ld5jht.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpg9ld5jht.scala:87:5 ---------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val maxChange = arr.foldLeft(0)((acc, x) => acc + (x % 2 == 0 ? 1 : -1))\n\
    \        val minChange = arr.foldLeft(0)((acc, x) => acc + (x % 2 == 0 ? 1 : -1))\n\
    \        val maxChangePalindromic = arr.foldLeft(0)((acc, x) => acc + (x % 2 ==\
    \ 0 ? 1 : -1))\n        val minChangePalindromic = arr.foldLeft(0)((acc, x) =>\
    \ acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic2 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic2 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic3 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic3 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic4 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic4 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic5 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic5 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic6 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic6 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic7 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic7 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic8 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val minChangePalindromic8 = arr.foldLeft(0)((acc,\
    \ x) => acc + (x % 2 == 0 ? 1 : -1))\n        val maxChangePalindromic9 = arr.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9giul5iy.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp9giul5iy.scala:13:70 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e[0m = arr.foldLeft(\e[31m0\e[0m)((\e\
    [36macc\e[0m, \e[36mx\e[0m) => acc + (x % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e\
    [0m : -\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                 \
    \                                   ^^^\e[0m\n\e[31m   |\e[0m                \
    \                          value ? is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9giul5iy.scala:14:70 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = arr.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x % \e[31m2\e[0m == \e[31m0\e\
    [0m ? \e[31m1\e[0m : -\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \                                                  ^^^\e[0m\n\e[31m   |\e[0m \
    \                                         value ? is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9giul5iy.scala:15:81 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxChangePalindromic\e[0m\
    \ = arr.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x % \e\
    [31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m : -\e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \     ^^^\e[0m\n\e[31m   |\e[0m                                          value\
    \ ? is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9giul5iy.scala:16:81\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangePalindromic\e[0m = arr.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e\
    [36mx\e[0m) => acc + (x % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m : -\e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \                              ^^^\e[0m\n\e[31m   |\e[0m                     \
    \                     value ? is not a m"
  stdout: ''
  timestamp: 1659805365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val maxLen4 = maxLen\
    \ / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6 = maxLen / 6\n  \
    \      val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen / 8\n        val\
    \ maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n        val maxLen11\
    \ = maxLen / 11\n        val maxLen12 = maxLen / 12\n        val maxLen13 = maxLen\
    \ / 13\n        val maxLen14 = maxLen / 14\n        val maxLen15 = maxLen / 15\n\
    \        val maxLen16 = maxLen / 16\n        val maxLen17 = maxLen / 17\n    \
    \    val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen / 19\n        val\
    \ maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n        val maxLen22\
    \ = maxLen / 22\n        val maxLen23 = maxLen / 23\n        val maxLen24 = maxLen\
    \ / 24\n        val maxLen25 = maxLen / 25\n        val maxLen26 = maxLen / 26\n\
    \        val maxLen27 = maxLen / 27\n        val maxLen28 = maxLen / 28\n    \
    \    val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen / 30\n        val\
    \ maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n        val maxLen33\
    \ = maxLen / 33\n        val maxLen34 = maxLen / 34\n        val maxLen35 = maxLen\
    \ / 35\n        val maxLen36 = maxLen / 36\n        val maxLen37 = maxLen / 37\n\
    \        val maxLen38 = maxLen / 38\n        val maxLen39 = maxLen / 39\n    \
    \    val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen / 41\n        val\
    \ maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n        val maxLen44\
    \ = maxLen / 44\n        val maxLen45 = maxLen / 45\n        val maxLen46 = maxLen\
    \ / 46\n        val maxLen47 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp75bnhsm8.scala:60:22 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp75bnhsm8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp75bnhsm8.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.length\n\
    \        val palindromic = arr.toSet\n        val reversed = arr.toList.reverse\n\
    \        val changed = reversed.filter(palindromic)\n        val change = changed.length\n\
    \        if (change < minChange) {\n            minChange = change\n        }\n\
    \        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpl251k_xn.scala:18:22 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            minChange = change\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var minChanges\
    \ = -1\n        while (i < m && j < n) {\n            if (arr(i) < arr(j)) {\n\
    \                changes += k\n                i += 1\n            } else {\n\
    \                changes += k\n                j += 1\n            }\n       \
    \     k += 1\n        }\n        if (i < m) {\n            while (i < m) {\n \
    \               changes += k\n                i += 1\n                k += 1\n\
    \            }\n        }\n        if (j < n) {\n            while (j < n) {\n\
    \                changes += k\n                j += 1\n                k += 1\n\
    \            }\n        }\n        if (changes.length < minChanges) {\n      \
    \      minChanges = changes.length\n        }\n        minChanges\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpav2052l2.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpav2052l2.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.toSet.size // number of unique elements\n        val dp = new\
    \ Array[Long](m+1)\n        dp(0) = 0\n        for (i <- 0 until n) {\n      \
    \      val j = arr.indexOf(i)\n            if (j == -1) continue\n           \
    \ val k = arr.lastIndexOf(j)\n            if (k == -1) continue\n            val\
    \ x = arr(j) - arr(k)\n            dp(j) = Math.min(dp(j), dp(k) + x)\n      \
    \  }\n        dp(n)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz5awfzc7.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mif\e[0m (j == -\e[31m1\e[0m) continue\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz5awfzc7.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (k == -\e[31m1\e[0m) continue\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        Not found: continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.min\n        val max = (n-1).toLong\n        val min = (n-1).toLong\n\
    \        val max1 = (max-1).toLong\n        val min1 = (min-1).toLong\n      \
    \  val max2 = (n-2).toLong\n        val min2 = (n-2).toLong\n        val max3\
    \ = (max-2).toLong\n        val min3 = (min-2).toLong\n        val max4 = (n-3).toLong\n\
    \        val min4 = (n-3).toLong\n        val max5 = (max-3).toLong\n        val\
    \ min5 = (min-3).toLong\n        val max6 = (n-4).toLong\n        val min6 = (n-4).toLong\n\
    \        val max7 = (max-4).toLong\n        val min7 = (min-4).toLong\n      \
    \  val max8 = (n-5).toLong\n        val min8 = (n-5).toLong\n        val max9\
    \ = (max-5).toLong\n        val min9 = (min-5).toLong\n        val max10 = (n-6).toLong\n\
    \        val min10 = (n-6).toLong\n        val max11 = (max-6).toLong\n      \
    \  val min11 = (min-6).toLong\n        val max12 = (n-7).toLong\n        val min12\
    \ = (n-7).toLong\n        val max13 = (max-7).toLong\n        val min13 = (min-7).toLong\n\
    \        val max14 = (n-8).toLong\n        val min14 = (n-8).toLong\n        val\
    \ max15 = (max-8).toLong\n        val min15 = (min-8).toLong\n        val max16\
    \ = (n-9).toLong\n        val min16 = (n-9).toLong\n        val max17 = (max-9).toLong\n\
    \        val min17 = (min-9).toLong\n        val max18 = (n-10).toLong\n     \
    \   val min18 = (n-10).toLong\n        val max19 = (max-10).toLong\n        val\
    \ min19 = (min-10).toLong\n        val max20 = (n-11).toLong\n        val min20\
    \ = (n-11).toLong\n        val max21 = (max-11).toLong\n        val min21 = (min-11).toLong\n\
    \        val max22 = (n-12).toLong\n        val min22 = (n-12).toLong\n      \
    \  val max23 = (max-12).toLong\n        val min23 = (min-12).toLong\n        val\
    \ max24 = (n-13).toLong\n        val min24 = (n-13).toLong\n        val max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8ctu_05.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpi8ctu_05.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        var i = 0\n        var j = 0\n \
    \       var min = Integer.MAX_VALUE\n        while(i < len) {\n            while(j\
    \ < len && arr(i) == arr(j)) {\n                j += 1\n            }\n      \
    \      val k = j - 1\n            val tmp = arr(i)\n            arr(i) = arr(k)\n\
    \            arr(k) = tmp\n            val tmp = len - k\n            val c =\
    \ len - i\n            val d = len - j\n            val minChange = tmp + c +\
    \ d\n            if(minChange < min) {\n                min = minChange\n    \
    \        }\n            i += 1\n            j += 1\n        }\n        min\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb92dvcgg.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb92dvcgg.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mtmp\e[0m = len - k\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtmp is\
    \ already defined as \e[33mvalue\e[0m \e[35mtmp\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659805357
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n     \
    \       val temp = arr(i)\n            while (j < len) {\n                if (arr(j)\
    \ != temp) {\n                    minChange = minChange\n                    minChangeIndex\
    \ = j\n                    break\n                }\n                j++\n   \
    \         }\n            i++\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpibjrj88l.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpibjrj88l.scala:28:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpibjrj88l.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpibjrj88l.scala:22:30 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m                    minChange = minChange\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpibjrj88l.scala:23:35 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m                    minChangeIndex = j\n\e[31m\e[31m   |\e[0m        \
    \            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Reassignment\
    \ to val minChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpibjrj88l.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explana"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        var count = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        while(i < len) {\n            while(j\
    \ < len) {\n                if(arr(i) == arr(j)) {\n                    count\
    \ += 1\n                    j++\n                } else {\n                  \
    \  j++\n                }\n            }\n            i += 1\n            j +=\
    \ 1\n        }\n        count + k\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp34qz6a1v.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp34qz6a1v.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp34qz6a1v.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m   |\e[0m                  ^\e\
    [0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        var i = 0\n        var j = 0\n        while (i < len) {\n     \
    \       val temp = arr(i)\n            while (j < len) {\n                if (arr(j)\
    \ != temp) {\n                    minChange = minChangeIndex\n               \
    \     break\n                }\n                j += 1\n            }\n      \
    \      i += 1\n            minChangeIndex = minChangeIndex + 1\n        }\n  \
    \      minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwxtju0ol.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpwxtju0ol.scala:22:30 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    minChange = minChangeIndex\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwxtju0ol.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpwxtju0ol.scala:28:27 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            minChangeIndex = minChangeIndex + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            Reassignment to val minChangeIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        var i = 0\n        var j = 0\n \
    \       var changes = 0\n        while (i < len) {\n            while (j < len\
    \ && arr(i) == arr(j)) {\n                j += 1\n            }\n            if\
    \ (j == len) {\n                changes += 1\n                j = 0\n        \
    \    }\n            i += 1\n        }\n        changes\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5bkvrlyj.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      val len = arr.length\n        var count = 0\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        var temp = 0\n        while (i < len)\
    \ {\n            while (j < len) {\n                if (arr(i) == arr(j)) {\n\
    \                    count += 1\n                    j++\n                }\n\
    \                else {\n                    j++\n                }\n        \
    \    }\n            i += 1\n            j = 0\n            count += 1\n      \
    \  }\n        if (count < len) {\n            count = 0\n        }\n        count\
    \ = count + 1\n        return count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpufrey2bq.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpufrey2bq.scala:26:23 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpufrey2bq.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sort\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = math.min(math.max(arr(0) -\
    \ arr(arr.size - 1), 0), n - 1)\n        val maxChange = math.min(math.max(arr(arr.size\
    \ - 1) - arr(0), 0), n - 1)\n        minChange.min(maxChange)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwy6i7qzo.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val minChange = len\n        var minChangeIndex = 0\n        var minChangeIndex2\
    \ = len\n        var minChangeIndex3 = len\n        var minChangeIndex4 = len\n\
    \        var minChangeIndex5 = len\n        var minChangeIndex6 = len\n      \
    \  var minChangeIndex7 = len\n        var minChangeIndex8 = len\n        var minChangeIndex9\
    \ = len\n        var minChangeIndex10 = len\n        var minChangeIndex11 = len\n\
    \        var minChangeIndex12 = len\n        var minChangeIndex13 = len\n    \
    \    var minChangeIndex14 = len\n        var minChangeIndex15 = len\n        var\
    \ minChangeIndex16 = len\n        var minChangeIndex17 = len\n        var minChangeIndex18\
    \ = len\n        var minChangeIndex19 = len\n        var minChangeIndex20 = len\n\
    \        var minChangeIndex21 = len\n        var minChangeIndex22 = len\n    \
    \    var minChangeIndex23 = len\n        var minChangeIndex24 = len\n        var\
    \ minChangeIndex25 = len\n        var minChangeIndex26 = len\n        var minChangeIndex27\
    \ = len\n        var minChangeIndex28 = len\n        var minChangeIndex29 = len\n\
    \        var minChangeIndex30 = len\n        var minChangeIndex31 = len\n    \
    \    var minChangeIndex32 = len\n        var minChangeIndex33 = len\n        var\
    \ minChangeIndex34 = len\n        var minChangeIndex35 = len\n        var minChangeIndex36\
    \ = len\n        var minChangeIndex37 = len\n        var minChangeIndex38 = len\n\
    \        var minChangeIndex39 = len\n        var minChangeIndex40 = len\n    \
    \    var minChangeIndex41 = len\n        var minChangeIndex42 = len\n        var\
    \ minChangeIndex43 = len\n        var minChangeIndex44 = len\n        var minChangeIndex45\
    \ = len\n        var minChangeIndex46 = len\n        var minChangeIndex47 = len\n\
    \        var minChangeIndex48 = len\n        var minChangeIndex49 = len\n    \
    \    var minChangeIndex50 = len\n        var minChangeIndex51 = len\n        var\
    \ minChangeIndex52 = len\n        var minChangeIndex53 = len\n        var minChangeIndex54\
    \ = len\n        var minChangeIndex55 = len\n        var minChangeIndex56 = len\n\
    \        var minChangeIndex57 = len\n        var minChangeIndex58 = len\n    \
    \    var minChangeIndex59 = len\n        var minChangeIndex60 = len\n        var\
    \ minChangeIndex61 = len\n        var minChangeIndex62 = len\n        var minChangeIndex63\
    \ = len\n        var minChangeIndex64 = len\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmvxf3no3.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var minChangeCount = 0\n      \
    \  var minChangeIndex = 0\n        while(i < len) {\n            while(j < len)\
    \ {\n                if(arr(i) == arr(j)) {\n                    j++\n       \
    \             k = 0\n                } else {\n                    k++\n     \
    \           }\n            }\n            if(k == len) {\n                minChange\
    \ = minChange\n                minChangeCount = minChangeCount+1\n           \
    \     minChangeIndex = i\n                j = 0\n                k = 0\n     \
    \           i++\n            }\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8o6rqr9u.scala:24:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    k = \e[31m0\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                      end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8o6rqr9u.scala:26:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp8o6rqr9u.scala:35:19 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                i++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8o6rqr9u.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8o6rqr9u.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m           \
    \         value ++ is not a member of Int\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp8o6rqr9u.scala:30:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                minChange\
    \ = minChange\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    6 errors found\n"
  stdout: ''
  timestamp: 1659805370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val change = mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n        val changed = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.ArrayBuffer.empty[Long]\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6cg_j91r.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6cg_j91r.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6cg_j91r.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6cg_j91r.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6cg_j91r.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e["
  stdout: ''
  timestamp: 1659805372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val arr = arr.toArray\n        val arr2 = arr.clone()\n\
    \        val arr3 = arr.clone()\n        val arr4 = arr.clone()\n        val arr5\
    \ = arr.clone()\n        val arr6 = arr.clone()\n        val arr7 = arr.clone()\n\
    \        val arr8 = arr.clone()\n        val arr9 = arr.clone()\n        val arr10\
    \ = arr.clone()\n        val arr11 = arr.clone()\n        val arr12 = arr.clone()\n\
    \        val arr13 = arr.clone()\n        val arr14 = arr.clone()\n        val\
    \ arr15 = arr.clone()\n        val arr16 = arr.clone()\n        val arr17 = arr.clone()\n\
    \        val arr18 = arr.clone()\n        val arr19 = arr.clone()\n        val\
    \ arr20 = arr.clone()\n        val arr21 = arr.clone()\n        val arr22 = arr.clone()\n\
    \        val arr23 = arr.clone()\n        val arr24 = arr.clone()\n        val\
    \ arr25 = arr.clone()\n        val arr26 = arr.clone()\n        val arr27 = arr.clone()\n\
    \        val arr28 = arr.clone()\n        val arr29 = arr.clone()\n        val\
    \ arr30 = arr.clone()\n        val arr31 = arr.clone()\n        val arr32 = arr.clone()\n\
    \        val arr33 = arr.clone()\n        val arr34 = arr.clone()\n        val\
    \ arr35 = arr.clone()\n        val arr36 = arr.clone()\n        val arr37 = arr.clone()\n\
    \        val arr38 = arr.clone()\n        val arr39 = arr.clone()\n        val\
    \ arr40 = arr.clone()\n        val arr41 = arr.clone()\n        val arr42 = arr.clone()\n\
    \        val arr43 = arr.clone()\n        val arr44 = arr.clone()\n        val\
    \ arr45 = arr.clone()\n        val arr46 = arr.clone()\n        val arr47 = arr.clone()\n\
    \        val arr48 = arr.clone()\n        val arr49 = arr.clone()\n        val\
    \ arr50 = arr.clone()\n        val arr51 = arr.clone()\n        val arr52 = arr.clone()\n\
    \        val arr53 = arr.clone()\n        val arr54 = arr.clone()\n        val\
    \ arr55 = arr.clone()\n        val arr56 = arr.clone()\n        val arr57 = arr.clone()\n\
    \        val arr58 = arr.clone()\n        val arr59 = arr.clone()\n        val\
    \ arr60 = arr.clone()\n        val arr61 = arr.clone()\n        val arr62 = arr.clone()\n\
    \        val arr63 = arr.clone()\n        val arr64 = arr.clone()\n\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc73a3v1x.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc73a3v1x.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.last\n        val max = (n-1)/2\n        val min = (n-1)/2\n\
    \        val maxChange = arr.take(max).reverse.take(max).sum\n        val minChange\
    \ = arr.take(min).reverse.take(min).sum\n        val change = maxChange - minChange\n\
    \        change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk0h8cg6s.scala:22)\n\tat Problem.main(tmpk0h8cg6s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        val minChange = math.min(math.ceil(n/2), math.ceil(m/2))\n\
    \        val changes = mutable.ArrayBuffer.empty[Long]\n        val changed =\
    \ mutable.HashSet.empty[Long]\n        val change = mutable.HashMap.empty[Long,\
    \ Long]\n        val changeSet = mutable.HashSet.empty[Long]\n        val changeSet2\
    \ = mutable.HashSet.empty[Long]\n        val changeSet3 = mutable.HashSet.empty[Long]\n\
    \        val changeSet4 = mutable.HashSet.empty[Long]\n        val changeSet5\
    \ = mutable.HashSet.empty[Long]\n        val changeSet6 = mutable.HashSet.empty[Long]\n\
    \        val changeSet7 = mutable.HashSet.empty[Long]\n        val changeSet8\
    \ = mutable.HashSet.empty[Long]\n        val changeSet9 = mutable.HashSet.empty[Long]\n\
    \        val changeSet10 = mutable.HashSet.empty[Long]\n        val changeSet11\
    \ = mutable.HashSet.empty[Long]\n        val changeSet12 = mutable.HashSet.empty[Long]\n\
    \        val changeSet13 = mutable.HashSet.empty[Long]\n        val changeSet14\
    \ = mutable.HashSet.empty[Long]\n        val changeSet15 = mutable.HashSet.empty[Long]\n\
    \        val changeSet16 = mutable.HashSet.empty[Long]\n        val changeSet17\
    \ = mutable.HashSet.empty[Long]\n        val changeSet18 = mutable.HashSet.empty[Long]\n\
    \        val changeSet19 = mutable.HashSet.empty[Long]\n        val changeSet20\
    \ = mutable.HashSet.empty[Long]\n        val changeSet21 = mutable.HashSet.empty[Long]\n\
    \        val changeSet22 = mutable.HashSet.empty[Long]\n        val changeSet23\
    \ = mutable.HashSet.empty[Long]\n        val changeSet24 = mutable.HashSet.empty[Long]\n\
    \        val changeSet25 = mutable.HashSet.empty[Long]\n        val changeSet26\
    \ = mutable.HashSet.empty[Long]\n        val changeSet27 = mutable.HashSet.empty[Long]\n\
    \        val changeSet28 = mutable.HashSet.empty[Long]\n        val changeSet29\
    \ = mutable.HashSet.empty[Long]\n        val changeSet30 = mutable.HashSet.empty[Long]\n\
    \        val change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy3_qcs8v.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy3_qcs8v.scala:15:22\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy3_qcs8v.scala:16:22\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mchanged\e[0m = mutable.HashSet.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy3_qcs8v.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mchange\e[0m = mutable.HashMap.empty[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpy3_qcs8v.scala:18:24 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mchangeSet\e[0m = mutable.HashSet.empty[\e[35mLong\e\
    [0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpy3_qcs8v.scala:19:25 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeSet2\e[0m = mutable.HashSet.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Not found: mutable"
  stdout: ''
  timestamp: 1659805375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val minChange = arr.take(n).foldLeft(0)((acc, x) => acc + smallestChangeHelper(x,\
    \ n))\n        smallestChangeHelper(arr.last, n)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjoivjc9w.scala:13:66 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mminChange\e[0m = arr.take(n).foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + smallestChangeHelper(x, n))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                 Not found: smallestChangeHelper\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjoivjc9w.scala:14:8 -------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        smallestChangeHelper(arr.last, n)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Not found:\
    \ smallestChangeHelper\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.length\n\
    \        val changes = mutable.ListBuffer[Long]()\n        val reversed = arr.reverse\n\
    \        val change = arr.length\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while(i < reversed.length) {\n            val currentChange\
    \ = reversed(i) - reversed(i-1)\n            changes += currentChange\n      \
    \      i += 1\n        }\n        val change = changes.min\n        minChange\
    \ = change\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaoszcvqz.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaoszcvqz.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = changes.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is already\
    \ defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaoszcvqz.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpaoszcvqz.scala:24:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        minChange =\
    \ change\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val dp = new Array[Long](m+1)\n        dp(0)\
    \ = 1\n        for(i <- 1 to m){\n            val left = (i-1) * n\n         \
    \   val right = i * n\n            dp(i) = if (arr(i) < arr(left)) dp(i-1) else\
    \ dp(i-1)\n        }\n        dp(m)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8__rfb67.scala:19:37\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            dp(i) = \e[33mif\e\
    [0m (arr(i) < arr(left)) dp(i-\e[31m1\e[0m) \e[33melse\e[0m dp(i-\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                     Found:    (left : Long)\n\e[31m \
    \  |\e[0m                                     Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.head\n        val result = new Array[Long](n + 1)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var change = 0\n        var flag = false\n        var temp\
    \ = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n \
    \       var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphsiykr35.scala:115:4 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmphsiykr35.scala:115:5 --------------------\e[0m\e[0m\n\e[31m115 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805378
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(_)\n        val m = arr.length\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4oxl2ldi.scala:85:11 ---------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp4oxl2ldi.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4oxl2ldi.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4oxl2ldi.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4oxl2ldi.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4oxl2ldi.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805378
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var min = len\n        var i = 0\n    \
    \    var j = 0\n        while (i < len) {\n            val temp = arr(i)\n   \
    \         while (j < len) {\n                if (arr(j) != temp) {\n         \
    \           min = Math.min(min, j - i)\n                    break\n          \
    \      }\n                j++\n            }\n            i += 1\n        }\n\
    \        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi3flr6oo.scala:24:19 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi3flr6oo.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi3flr6oo.scala:22:20\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ min = Integer.MAX_VALUE\n        var count = 0\n        while (i < len) {\n\
    \            while (j < len) {\n                if (arr(i) != arr(j)) {\n    \
    \                count += 1\n                    j++\n                }\n    \
    \            else {\n                    j++\n                }\n            }\n\
    \            if (count < min) {\n                min = count\n            }\n\
    \            count = 0\n            i++\n        }\n        min\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdkf9laks.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpdkf9laks.scala:25:23 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdkf9laks.scala:32:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdkf9laks.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        val max = (len /\
    \ 2)\n        val mid = len / 2\n        val mid2 = len / 2\n        val mid3\
    \ = len / 2\n        val mid4 = len / 2\n        val mid5 = len / 2\n        val\
    \ mid6 = len / 2\n        val mid7 = len / 2\n        val mid8 = len / 2\n   \
    \     val mid9 = len / 2\n        val mid10 = len / 2\n        val mid11 = len\
    \ / 2\n        val mid12 = len / 2\n        val mid13 = len / 2\n        val mid14\
    \ = len / 2\n        val mid15 = len / 2\n        val mid16 = len / 2\n      \
    \  val mid17 = len / 2\n        val mid18 = len / 2\n        val mid19 = len /\
    \ 2\n        val mid20 = len / 2\n        val mid21 = len / 2\n        val mid22\
    \ = len / 2\n        val mid23 = len / 2\n        val mid24 = len / 2\n      \
    \  val mid25 = len / 2\n        val mid26 = len / 2\n        val mid27 = len /\
    \ 2\n        val mid28 = len / 2\n        val mid29 = len / 2\n        val mid30\
    \ = len / 2\n        val mid31 = len / 2\n        val mid32 = len / 2\n      \
    \  val mid33 = len / 2\n        val mid34 = len / 2\n        val mid35 = len /\
    \ 2\n        val mid36 = len / 2\n        val mid37 = len / 2\n        val mid38\
    \ = len / 2\n        val mid39 = len / 2\n        val mid40 = len / 2\n      \
    \  val mid41 = len / 2\n        val mid42 = len / 2\n        val mid43 = len /\
    \ 2\n        val mid44 = len / 2\n        val mid45 = len / 2\n        val mid46\
    \ = len / 2\n        val mid47 = len / 2\n        val mid48 = len / 2\n      \
    \  val mid49 = len / 2\n        val mid50 = len / 2\n        val mid51 = len /\
    \ 2\n        val mid52 = len / 2\n        val mid53 = len / 2\n        val mid54\
    \ = len / 2\n        val mid55 = len / 2\n        val mid\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx_uq_23n.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx_uq_23n.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx_uq_23n.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805378
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.takeRight(n).reverse.take(n).toList\n        val palindromic\
    \ = arr.takeRight(n).reverse.take(n).toList == arr\n        val changes = arr.takeRight(n).reverse.take(n).toList\
    \ - m\n        val changesToMakePalindromic = changes.length\n        if (palindromic)\
    \ {\n            changesToMakePalindromic\n        } else {\n            changesToMakePalindromic\
    \ - changes.length\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphjrg_11e.scala:15:62 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = arr.takeRight(n).reverse.take(n).toList\
    \ - m\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659805380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.size\n    \
    \    val n = arr.last\n        val arr = arr.sortWith(_ < _)\n        val changes\
    \ = arr.foldLeft(0)(_ + _)\n        val change = changes / n\n        val remainder\
    \ = changes % n\n        val changes = if (remainder == 0) 1 else change\n   \
    \     val change = if (change > 0) change else 1\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val changes = if (change\
    \ > 1) change else 0\n        val change = if (change > 1) change else 0\n   \
    \     val changes = if (change > 1) change else 0\n        val change = if (change\
    \ > 1) change else 0\n        val changes = if (change > 1) change else 0\n  \
    \      val change = if (change > 1) change else 0\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp3w9sc2ak.scala:56:11 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp3w9sc2ak.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = \e[33mif\e\
    [0m (remainder == \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m change\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp3w9sc2ak.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = \e[33mif\e[0m (change > \e\
    [31m0\e[0m) change \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is already\
    \ defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3w9sc2ak.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchanges\e[0m = \e[33mif\e[0m (change > \e[31m1\e[0m) change \e[33melse\e\
    [0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanges is already defined as \e[33mvalue\e[0m \e[35mchanges\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3w9sc2ak.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = \e[33mif\e[0m (change\
    \ > \e[31m1\e[0m) change \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e"
  stdout: ''
  timestamp: 1659805379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.takeRight(n).reverse.take(n).length\n        val changes =\
    \ mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            val left = arr(i)\n \
    \           val right = arr(n - 1 - i)\n            if (left == right) {\n   \
    \             changes += left\n                change += left\n              \
    \  i += 1\n            } else {\n                val diff = left - right\n   \
    \             if (diff > 0) {\n                    changes += diff\n         \
    \           change += diff\n                } else {\n                    changes\
    \ += diff\n                    change += -diff\n                }\n          \
    \  }\n        }\n        val change = changes.toList\n        val changeCount\
    \ = change.count\n        if (changeCount == 0) {\n            return 0\n    \
    \    }\n        val changeCount = change.count\n        if (changeCount > m) {\n\
    \            return changeCount\n        }\n        val changeCount = change.count\n\
    \        if (changeCount < m) {\n            return m\n        }\n        val\
    \ changeCount = change.count\n        if (changeCount > n) {\n            return\
    \ changeCount\n        }\n        val changeCount = change.count\n        if (changeCount\
    \ < n) {\n            return n\n        }\n        val changeCount = change.count\n\
    \        if (changeCount > n) {\n            return changeCount\n        }\n \
    \       val changeCount = change.count\n        if (changeCount < n) {\n     \
    \       return n\n        }\n        val changeCount = change.count\n        if\
    \ (changeCount > n) {\n            return changeCount\n        }\n        val\
    \ changeCount = change.count\n        if (changeCount < n) {\n            return\
    \ n\n        }\n        val changeCount = change.count\n        if (changeCount\
    \ > n) {\n            return changeCount\n        }\n        val changeCount =\
    \ change.count\n        if (changeCount < n) {\n            return n\n       \
    \ }\n        val changeCount = change.count\n        if (changeCount > n) {\n\
    \            return changeCount\n        }\n        val changeCount = change.count\n\
    \        if (changeCount < n) {\n            return n\n        }\n        val\
    \ changeCount = change.count\n        if (changeCount > n) {\n            return\
    \ changeCount\n        }\n        val changeCount = change.count\n        if (changeCount\
    \ < n) {\n            return n\n        }\n        val changeCount = change.count\n\
    \        if (changeCount > n) {\n            return changeCount\n        }\n \
    \       val changeCount = change.count\n        if (changeCount < n) {\n     \
    \       return n\n        }\n        val changeCount = change.count\n        if\
    \ (changeCount > n) {\n            return changeCount\n        }\n        val\
    \ changeCount = change.count\n        if (changeCount < n) {\n            return\
    \ n\n        }\n        val changeCount = change.count\n        if (changeCount\
    \ > n) {\n            return changeCount\n        }\n        val changeCount =\
    \ change.\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0auqs445.scala:117:4 ---------------------------\e\
    [0m\e[0m\n\e[31m117 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0auqs445.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = changes.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchange is already\
    \ defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0auqs445.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCount\e[0m = change.count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0auqs445.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mchangeCount\e[0m = change.count\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchangeCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0auqs445.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchangeCount\e[0m = change.count\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchangeCount is already defined as \e[33mvalue\e[0m \e[35mchangeCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0auqs445.scala:52:12 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m        \e[33mval\e[0m \e[3"
  stdout: ''
  timestamp: 1659805379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_).reverse\n\
    \        val len = arr.length\n        var count = 0\n        var i = 0\n    \
    \    var j = 0\n        while (i < len) {\n            while (j < len && arr(i)\
    \ == arr(j)) {\n                j += 1\n            }\n            count += 1\n\
    \            i += 1\n        }\n        count * arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp4437zpql.scala:12:29 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4437zpql.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val dp = new Array[Long](n + 1)\n        dp(0)\
    \ = 0\n        for (i<-0 until n) {\n            val j = i\n            val k\
    \ = n - 1\n            while (j >= 0 && k >= 0) {\n                if (arr(j)\
    \ < arr(k)) {\n                    dp(j + 1) = dp(j) + 1\n                   \
    \ j -= 1\n                } else {\n                    dp(k + 1) = dp(k) + 1\n\
    \                    k -= 1\n                }\n            }\n        }\n   \
    \     dp(n)\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpogp1q7gs.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ -= is not a member of Int - did you mean j.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpogp1q7gs.scala:25:22 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    k -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                    value -= is not a member\
    \ of Int - did you mean k.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659805381
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val minChange = math.min(math.min(arr(n - 1), arr(n - 2)), arr(n - 3))\n\
    \        val maxChange = math.max(math.max(arr(n - 1), arr(n - 2)), arr(n - 3))\n\
    \        val change = minChange + maxChange\n        if (change == 0) 1\n    \
    \    else change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc6wzl40h.scala:20)\n\tat Problem.main(tmpc6wzl40h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.dropRight(1)\n        val arr2\
    \ = arr.takeRight(1)\n        val arr3 = arr.dropRight(1).takeRight(1)\n     \
    \   val arr4 = arr.dropRight(1).takeRight(1).takeRight(1)\n        val arr5 =\
    \ arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1)\n        val arr6 =\
    \ arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n     \
    \   val arr7 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr8 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr9 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr10 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr11 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr12 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr13 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr14 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr15 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1)\n\
    \        val arr16 = arr.dropRight(1).takeRight(1).takeRight(1).takeRight(1).takeRight(1).take\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3uwb1tql.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m  \
    \                Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3uwb1tql.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805380
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.last\n        val arr = arr.sortWith(_ < _)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var count = 0\n        while (i < n) {\n            while (j\
    \ < n) {\n                if (arr(i) == arr(j)) {\n                    count +=\
    \ 1\n                    j++\n                }\n                else {\n    \
    \                j++\n                }\n            }\n            if (count\
    \ > max) {\n                max = count\n                min = k\n           \
    \ }\n            count = 0\n            k = j\n            j = 0\n           \
    \ i += 1\n        }\n        min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3jpjtpm0.scala:25:23 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp3jpjtpm0.scala:28:23 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3jpjtpm0.scala:14:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        while (i < len) {\n            val temp = arr(i)\n\
    \            while (j < len) {\n                if (arr(j) != temp) {\n      \
    \              minChange = minChange - 1\n                    i = i + 1\n    \
    \                j = j + 1\n                } else {\n                    j =\
    \ j + 1\n                }\n            }\n        }\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp44ee1eb9.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp44ee1eb9.scala:21:30 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    minChange = minChange - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805380
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val maxChange = arr.foldLeft(0) { (acc, x) =>\
    \ if (x == m) acc else acc + 1 }\n        val minChange = arr.foldLeft(0) { (acc,\
    \ x) => if (x == 0) acc else acc + 1 }\n        if (maxChange == minChange) 0\n\
    \        else if (maxChange > minChange) maxChange\n        else minChange\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnh7yn18j.scala:21)\n\tat Problem.main(tmpnh7yn18j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexSet = Set[Int]()\n        val minChangeIndexSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSet = Set[Int]()\n        val\
    \ minChangeIndexSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSet = Set[Int]()\n     \
    \   val minChangeIndexSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSet = Set[Int]()\n     \
    \   val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet\
    \ = Set[Int]()\n        val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n  \
    \      val minChangeIndexSetSetSetSetSetSet = Set[Int]()\n        \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphvd4hfbu.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetSetSetSet\e\
    [0m = Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mminChangeIndexSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphvd4hfbu.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetSetSetSetSet\e\
    [0m = Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mminChangeIndexSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphvd4hfbu.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetSetSetSetSet\e\
    [0m = Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mminChangeIndexSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphvd4hfbu.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexSetSetSetSetSet\e\
    [0m = Set[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mminChangeIndexSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming E"
  stdout: ''
  timestamp: 1659805388
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.takeRight(n).reverse.take(n).length\n        val p = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var minChange\
    \ = 0\n        while(i < n && j < m) {\n            if(i == j) {\n           \
    \     p(i) = arr(i)\n                i += 1\n                j += 1\n        \
    \    } else if(arr(i) < arr(j)) {\n                p(i) = arr(i)\n           \
    \     i += 1\n            } else {\n                p(i) = arr(j)\n          \
    \      j += 1\n            }\n            k += 1\n            if(k == m) {\n \
    \               minChange = j - i + 1\n                k = 0\n            }\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjazqti8.scala:40)\n\tat Problem.main(tmphjazqti8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.head\n        val p = new Array[Long](m)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n\
    \        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n\
    \        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n\
    \        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n\
    \        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m = 0\n        var n = 0\n        var p = 0\n        var q = 0\n\
    \        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n\
    \        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n\
    \        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n\
    \        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n\
    \        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var m = 0\n        var n = 0\n        var p = 0\n\
    \        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n\
    \        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n\
    \        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n\
    \        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n\
    \        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n\
    \        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n\
    \        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n\
    \        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n\
    \        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n\
    \        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var p = 0\n        var q = 0\n        var r = 0\n\
    \        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n\
    \        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n\
    \        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n\
    \        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mp\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mp is already defined\
    \ as \e[33mvalue\e[0m \e[35mp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp14at5hnh.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ val temp = arr(i)\n            val temp2 = arr(j)\n            val temp3 = arr(k)\n\
    \            if (temp == temp2) {\n                i += 1\n                j +=\
    \ 1\n                k += 1\n            } else if (temp == temp3) {\n       \
    \         i += 1\n                j += 1\n            } else {\n             \
    \   minChange = math.min(minChange, i - j)\n                i += 1\n         \
    \       j += 1\n                k += 1\n            }\n        }\n        minChange\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp78_1_njm.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp78_1_njm.scala:30:26 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                minChange = math.min(minChange, i - j)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.size\n\
    \        val minChangeIndex = 0\n        val minChangeValue = arr(0)\n       \
    \ val minChangeIndexValue = arr(0)\n        val minChangeIndexValue2 = arr(0)\n\
    \        val minChangeIndexValue3 = arr(0)\n        val minChangeIndexValue4 =\
    \ arr(0)\n        val minChangeIndexValue5 = arr(0)\n        val minChangeIndexValue6\
    \ = arr(0)\n        val minChangeIndexValue7 = arr(0)\n        val minChangeIndexValue8\
    \ = arr(0)\n        val minChangeIndexValue9 = arr(0)\n        val minChangeIndexValue10\
    \ = arr(0)\n        val minChangeIndexValue11 = arr(0)\n        val minChangeIndexValue12\
    \ = arr(0)\n        val minChangeIndexValue13 = arr(0)\n        val minChangeIndexValue14\
    \ = arr(0)\n        val minChangeIndexValue15 = arr(0)\n        val minChangeIndexValue16\
    \ = arr(0)\n        val minChangeIndexValue17 = arr(0)\n        val minChangeIndexValue18\
    \ = arr(0)\n        val minChangeIndexValue19 = arr(0)\n        val minChangeIndexValue20\
    \ = arr(0)\n        val minChangeIndexValue21 = arr(0)\n        val minChangeIndexValue22\
    \ = arr(0)\n        val minChangeIndexValue23 = arr(0)\n        val minChangeIndexValue24\
    \ = arr(0)\n        val minChangeIndexValue25 = arr(0)\n        val minChangeIndexValue26\
    \ = arr(0)\n        val minChangeIndexValue27 = arr(0)\n        val minChangeIndexValue28\
    \ = arr(0)\n        val minChangeIndexValue29 = arr(0)\n        val minChangeIndexValue30\
    \ = arr(0)\n        val minChangeIndexValue31 = arr(0)\n        val minChangeIndexValue32\
    \ = arr(0)\n        val minChangeIndexValue33 = arr(0)\n        val minChangeIndexValue34\
    \ = arr(0)\n        val minChangeIndexValue35 = arr(0)\n        val minChangeIndexValue36\
    \ = arr(0)\n        val minChangeIndexValue37 = arr(0)\n        val minChangeIndexValue38\
    \ = arr(0)\n        val minChangeIndexValue39 = arr(0)\n        val minChangeIndexValue40\
    \ = arr(0)\n        val minChangeIndexValue41 = arr(0)\n        val minChangeIndexValue42\
    \ = arr(0)\n        val minChangeIndexValue43 = arr(0)\n        val minChangeIndexValue44\
    \ = arr(0)\n        val minChangeIndexValue45 = arr(0)\n        val minChangeIndexValue4\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpla6wvjar.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpla6wvjar.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val max = (m / 2).toInt\n        val min = (m\
    \ / 2).toInt\n        val max1 = (max / 2).toInt\n        val min1 = (min / 2).toInt\n\
    \        val max2 = (max / 2).toInt\n        val min2 = (min / 2).toInt\n    \
    \    val max3 = (max / 2).toInt\n        val min3 = (min / 2).toInt\n        val\
    \ max4 = (max / 2).toInt\n        val min4 = (min / 2).toInt\n        val max5\
    \ = (max / 2).toInt\n        val min5 = (min / 2).toInt\n        val max6 = (max\
    \ / 2).toInt\n        val min6 = (min / 2).toInt\n        val max7 = (max / 2).toInt\n\
    \        val min7 = (min / 2).toInt\n        val max8 = (max / 2).toInt\n    \
    \    val min8 = (min / 2).toInt\n        val max9 = (max / 2).toInt\n        val\
    \ min9 = (min / 2).toInt\n        val max10 = (max / 2).toInt\n        val min10\
    \ = (min / 2).toInt\n        val max11 = (max / 2).toInt\n        val min11 =\
    \ (min / 2).toInt\n        val max12 = (max / 2).toInt\n        val min12 = (min\
    \ / 2).toInt\n        val max13 = (max / 2).toInt\n        val min13 = (min /\
    \ 2).toInt\n        val max14 = (max / 2).toInt\n        val min14 = (min / 2).toInt\n\
    \        val max15 = (max / 2).toInt\n        val min15 = (min / 2).toInt\n  \
    \      val max16 = (max / 2).toInt\n        val min16 = (min / 2).toInt\n    \
    \    val max17 = (max / 2).toInt\n        val min17 = (min / 2).toInt\n      \
    \  val max18 = (max / 2).toInt\n        val min18 = (min / 2).toInt\n        val\
    \ max19 = (max / 2).toInt\n        val min19 = (min / 2).toInt\n        val max20\
    \ = (max / 2).toInt\n        val min20 = (min / 2).toInt\n        val max21 =\
    \ (max / 2).toInt\n        val min21 = (min / 2).toInt\n        val max22 = (max\
    \ / 2).toInt\n        val min22 = (min / \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjel5r6p8.scala:59:26 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mmin22\e[0m = (min / \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjel5r6p8.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var minChangeIndex = 0\n      \
    \  var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n        var minChangeIndex4\
    \ = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6 = 0\n    \
    \    var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n        var minChangeIndex9\
    \ = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11 = 0\n  \
    \      var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n        var\
    \ minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var minChangeIndex16\
    \ = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18 = 0\n  \
    \      var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n        var\
    \ minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var minChangeIndex23\
    \ = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25 = 0\n  \
    \      var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n        var\
    \ minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var minChangeIndex30\
    \ = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32 = 0\n  \
    \      var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n        var\
    \ minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var minChangeIndex37\
    \ = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39 = 0\n  \
    \      var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n        var\
    \ minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var minChangeIndex44\
    \ = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46 = 0\n  \
    \      var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n        var\
    \ minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var minChangeIndex51\
    \ = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53 = 0\n  \
    \      var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n        var\
    \ minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var minChangeIndex58\
    \ = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60 = 0\n  \
    \      var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n        var\
    \ minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var minChangeIndex65\
    \ = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67 = 0\n  \
    \      var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg9ld5jht.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpg9ld5jht.scala:87:5 ---------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = Integer.MAX_VALUE\n        while (i < len) {\n    \
    \        val temp = arr(i)\n            val temp2 = arr(j)\n            if (temp\
    \ != temp2) {\n                arr(i) = temp2\n                arr(j) = temp\n\
    \                min = Math.min(min, i - k + 1)\n                k = i\n     \
    \       }\n            i += 1\n            j += 1\n        }\n        min\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpju46_cxx.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        val arr = arr.sortWith(_ < _)\n        val m = arr.max\n\
    \        val changes = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var change = 0\n        while (i <\
    \ n) {\n            while (j < n && arr(i) == arr(j)) {\n                j +=\
    \ 1\n            }\n            while (k < n && arr(i) != arr(k)) {\n        \
    \        k += 1\n            }\n            if (j == k) {\n                change\
    \ += 1\n                j += 1\n                k += 1\n            }\n      \
    \      i += 1\n        }\n        changes += change\n        changes.min\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpecoks4ku.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.max\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpecoks4ku.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpecoks4ku.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeIndexList = ListBuffer[Int]()\n        val minChangeIndexList2\
    \ = ListBuffer[Int]()\n        val minChangeIndexList3 = ListBuffer[Int]()\n \
    \       val minChangeIndexList4 = ListBuffer[Int]()\n        val minChangeIndexList5\
    \ = ListBuffer[Int]()\n        val minChangeIndexList6 = ListBuffer[Int]()\n \
    \       val minChangeIndexList7 = ListBuffer[Int]()\n        val minChangeIndexList8\
    \ = ListBuffer[Int]()\n        val minChangeIndexList9 = ListBuffer[Int]()\n \
    \       val minChangeIndexList10 = ListBuffer[Int]()\n        val minChangeIndexList11\
    \ = ListBuffer[Int]()\n        val minChangeIndexList12 = ListBuffer[Int]()\n\
    \        val minChangeIndexList13 = ListBuffer[Int]()\n        val minChangeIndexList14\
    \ = ListBuffer[Int]()\n        val minChangeIndexList15 = ListBuffer[Int]()\n\
    \        val minChangeIndexList16 = ListBuffer[Int]()\n        val minChangeIndexList17\
    \ = ListBuffer[Int]()\n        val minChangeIndexList18 = ListBuffer[Int]()\n\
    \        val minChangeIndexList19 = ListBuffer[Int]()\n        val minChangeIndexList20\
    \ = ListBuffer[Int]()\n        val minChangeIndexList21 = ListBuffer[Int]()\n\
    \        val minChangeIndexList22 = ListBuffer[Int]()\n        val minChangeIndexList23\
    \ = ListBuffer[Int]()\n        val minChangeIndexList24 = ListBuffer[Int]()\n\
    \        val minChangeIndexList25 = ListBuffer[Int]()\n        val minChangeIndexList26\
    \ = ListBuffer[Int]()\n        val minChangeIndexList27 = ListBuffer[Int]()\n\
    \        val minChangeIndexList28 = ListBuffer[Int]()\n        val minChangeIndexList29\
    \ = ListBuffer[Int]()\n        val minChangeIndexList30 = ListBuffer[Int]()\n\
    \        val minChangeIndexList31 = ListBuffer[Int]()\n        val minChangeIndexList32\
    \ = ListBuffer[Int]()\n        val minChangeIndexList33 = ListBuffer[Int]()\n\
    \        val min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0d2ptd6z.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0d2ptd6z.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0d2ptd6z.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var min = Integer.MAX_VALUE\n        while (i < len)\
    \ {\n            val temp = arr(i)\n            while (j < len) {\n          \
    \      if (arr(j) == temp) {\n                    arr(j) = arr(j + 1)\n      \
    \              arr(j + 1) = temp\n                    j++\n                  \
    \  k++\n                    min = Math.min(min, k - j)\n                }\n  \
    \              else {\n                    j++\n                }\n          \
    \  }\n            i += 1\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpheqth306.scala:26:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    min = Math.min(min, k - j)\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       end of statement expected but '=' found\n\e[31m\e[31m-- [E018] Syntax\
    \ Error: /tmp/tmpheqth306.scala:29:23 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                  \
    \     ^\e[0m\n\e[31m   |\e[0m                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpheqth306.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \            ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpheqth306.scala:24:21 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m                    j++\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\
    \e[31m   |\e[0m                    value ++ is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1659805397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = len / 4\n        val maxLen3 = len / 8\n        val maxLen4 = len / 16\n \
    \       val maxLen5 = len / 32\n        val maxLen6 = len / 64\n        val maxLen7\
    \ = len / 128\n        val maxLen8 = len / 256\n        val maxLen9 = len / 512\n\
    \        val maxLen10 = len / 1024\n        val maxLen11 = len / 2048\n      \
    \  val maxLen12 = len / 4096\n        val maxLen13 = len / 8192\n        val maxLen14\
    \ = len / 16384\n        val maxLen15 = len / 32768\n        val maxLen16 = len\
    \ / 65536\n        val maxLen17 = len / 131072\n        val maxLen18 = len / 262144\n\
    \        val maxLen19 = len / 524288\n        val maxLen20 = len / 1048576\n \
    \       val maxLen21 = len / 2097152\n        val maxLen22 = len / 4194304\n \
    \       val maxLen23 = len / 8388608\n        val maxLen24 = len / 16777216\n\
    \        val maxLen25 = len / 33554432\n        val maxLen26 = len / 67108864\n\
    \        val maxLen27 = len / 134217728\n        val maxLen28 = len / 268435456\n\
    \        val maxLen29 = len / 536870912\n        val maxLen30 = len / 1073741824\n\
    \        val maxLen31 = len / 2147483648\n        val maxLen32 = len / 4294967296\n\
    \        val maxLen33 = len / 8589934592\n        val maxLen34 = len / 17179869184\n\
    \        val maxLen35 = len / 34359738368\n        val maxLen36 = len / 68719476736\n\
    \        val maxLen37 = len / 137438953472\n        val maxLen38 = len / 274877906944\n\
    \        val maxLen39 = len / 549755813888\n        val maxLen40 = len / 1099511627776\n\
    \        val maxLen41 = len / 2199023255552\n        val maxLen42 = len / 4398046511104\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpao07gpt6.scala:56:11 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpao07gpt6.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpao07gpt6.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val maxLen4 = maxLen\
    \ / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6 = maxLen / 6\n  \
    \      val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen / 8\n        val\
    \ maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n        val maxLen11\
    \ = maxLen / 11\n        val maxLen12 = maxLen / 12\n        val maxLen13 = maxLen\
    \ / 13\n        val maxLen14 = maxLen / 14\n        val maxLen15 = maxLen / 15\n\
    \        val maxLen16 = maxLen / 16\n        val maxLen17 = maxLen / 17\n    \
    \    val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen / 19\n        val\
    \ maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n        val maxLen22\
    \ = maxLen / 22\n        val maxLen23 = maxLen / 23\n        val maxLen24 = maxLen\
    \ / 24\n        val maxLen25 = maxLen / 25\n        val maxLen26 = maxLen / 26\n\
    \        val maxLen27 = maxLen / 27\n        val maxLen28 = maxLen / 28\n    \
    \    val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen / 30\n        val\
    \ maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n        val maxLen33\
    \ = maxLen / 33\n        val maxLen34 = maxLen / 34\n        val maxLen35 = maxLen\
    \ / 35\n        val maxLen36 = maxLen / 36\n        val maxLen37 = maxLen / 37\n\
    \        val maxLen38 = maxLen / 38\n        val maxLen39 = maxLen / 39\n    \
    \    val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen / 41\n        val\
    \ maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n        val maxLen44\
    \ = maxLen / 44\n        val maxLen45 = maxLen / 45\n        val maxLen46 = maxLen\
    \ / 46\n        val maxLen47 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp75bnhsm8.scala:60:22 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp75bnhsm8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp75bnhsm8.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val min = len / 2\n        val\
    \ max = (len - min) / 2\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var count = 0\n        while (i < min && j < max) {\n           \
    \ if (arr(i) == arr(j)) {\n                count += 1\n                i += 1\n\
    \                j += 1\n            } else {\n                if (arr(i) < arr(j))\
    \ {\n                    i += 1\n                } else {\n                  \
    \  j += 1\n                }\n            }\n        }\n        if (count < min)\
    \ {\n            count = min\n        }\n        if (count > max) {\n        \
    \    count = max\n        }\n        count\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7ld6q46d.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        val palindromic = arr.takeRight(len).reverse.take(len).reverse\
    \ == arr\n        if (palindromic)\n            0\n        else\n            len\
    \ - smallestChange(arr.takeRight(len))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0t71y11w.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val minChange = math.min(math.abs(n - m), math.abs(n\
    \ - m / 2))\n        val changes = mutable.ArrayBuffer.empty[Long]\n        var\
    \ i = 0\n        while (i < n) {\n            val curr = arr(i)\n            val\
    \ next = (i + 1) % n\n            if (curr == next) {\n                changes\
    \ += curr\n                i += 1\n            } else {\n                val change\
    \ = math.min(math.abs(n - curr), math.abs(n - curr / 2))\n                if (change\
    \ < minChange) {\n                    minChange = change\n                   \
    \ changes = ArrayBuffer(curr)\n                } else {\n                    changes\
    \ += curr\n                }\n                i += 1\n            }\n        }\n\
    \        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1eiifj6k.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp1eiifj6k.scala:26:30 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    minChange = change\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp1eiifj6k.scala:27:28 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    changes = ArrayBuffer(curr)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Reassignment to val changes\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeValue = arr(0)\n        val minChangeValueIndex =\
    \ -1\n        val minChangeValueValue = arr(0)\n        val minChangeValueIndex2\
    \ = -1\n        val minChangeValueValue2 = arr(0)\n        val minChangeValueIndex3\
    \ = -1\n        val minChangeValueValue3 = arr(0)\n        val minChangeValueIndex4\
    \ = -1\n        val minChangeValueValue4 = arr(0)\n        val minChangeValueIndex5\
    \ = -1\n        val minChangeValueValue5 = arr(0)\n        val minChangeValueIndex6\
    \ = -1\n        val minChangeValueValue6 = arr(0)\n        val minChangeValueIndex7\
    \ = -1\n        val minChangeValueValue7 = arr(0)\n        val minChangeValueIndex8\
    \ = -1\n        val minChangeValueValue8 = arr(0)\n        val minChangeValueIndex9\
    \ = -1\n        val minChangeValueValue9 = arr(0)\n        val minChangeValueIndex10\
    \ = -1\n        val minChangeValueValue10 = arr(0)\n        val minChangeValueIndex11\
    \ = -1\n        val minChangeValueValue11 = arr(0)\n        val minChangeValueIndex12\
    \ = -1\n        val minChangeValueValue12 = arr(0)\n        val minChangeValueIndex13\
    \ = -1\n        val minChangeValueValue13 = arr(0)\n        val minChangeValueIndex14\
    \ = -1\n        val minChangeValueValue14 = arr(0)\n        val minChangeValueIndex15\
    \ = -1\n        val minChangeValueValue15 = arr(0)\n        val minChangeValueIndex16\
    \ = -1\n        val minChangeValueValue16 = arr(0)\n        val minChangeValueIndex17\
    \ = -1\n        val minChangeValueValue17 = arr(0)\n        val minChangeValueIndex18\
    \ = -1\n        val minChangeValueValue18 = arr(0)\n        val minChangeValueIndex19\
    \ = -1\n        val minChangeValueValue19 = arr(0)\n        val minChangeValueIndex20\
    \ = -1\n        val minChangeValueValue20 = arr(0)\n        val minChangeValueIndex21\
    \ = -1\n        val minChangeValueValue21 = arr(0)\n        val minChangeValueIndex22\
    \ = -1\n        val minChangeValueValue22 = arr(0)\n        val minChangeValueIndex23\
    \ = -1\n        val minChangeValueValue23 = arr(0)\n        val minChangeValueIndex24\
    \ = -1\n        val minChangeValueValue24 = arr(0)\n        val minChangeValueIndex25\
    \ = -1\n        \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps0cfm46o.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmps0cfm46o.scala:67:5 ---------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = len / 2\n        var count\
    \ = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var temp\
    \ = 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n \
    \       var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93 = 0\n        var temp94 = 0\n        var temp95 = 0\n\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc7241z8l.scala:115:5\
    \ --------------------\e[0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer(0)\n\
    \        val maxChanges = mutable.ArrayBuffer(0)\n        val maxChangesCount\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n\
    \        val maxChangesCounts_ = mutable.ArrayBuffer(0)\n        val maxChangesCounts_\
    \ = mutable.ArrayBuffer(0)\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6e86r_bp.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxChangesCounts_\e[0m =\
    \ mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangesCounts_ is already defined as \e[33mvalue\e[0m \e\
    [35mmaxChangesCounts_\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6e86r_bp.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxChangesCounts_\e[0m =\
    \ mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangesCounts_ is already defined as \e[33mvalue\e[0m \e\
    [35mmaxChangesCounts_\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6e86r_bp.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxChangesCounts_\e[0m =\
    \ mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangesCounts_ is already defined as \e[33mvalue\e[0m \e\
    [35mmaxChangesCounts_\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6e86r_bp.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxChangesCounts_\e[0m =\
    \ mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxChangesCounts_ is already defined as \e[33mvalue\e[0m \e\
    [35mmaxChangesCounts_\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6e86r_bp.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m"
  stdout: ''
  timestamp: 1659805399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var change = 0\n        while (i\
    \ < len) {\n            while (j < len) {\n                if (arr(i) == arr(j))\
    \ {\n                    j++\n                }\n                else {\n    \
    \                k++\n                }\n            }\n            change = k\n\
    \            if (change < minChange) {\n                minChange = change\n \
    \           }\n            i += 1\n            j = 0\n            k = 0\n    \
    \    }\n        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6iejaqiy.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp6iejaqiy.scala:25:23 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6iejaqiy.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp6iejaqiy.scala:30:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                minChange\
    \ = change\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \        val n = arr.last\n        val arr = arr.sortBy(-_)\n        val m = arr.length\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23_a3_fd.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already\
    \ defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23_a3_fd.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23_a3_fd.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp23_a3_fd.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp23_a3_fd.scala:19:12 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.last\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e\
    [0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp23_a3_fd.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m2"
  stdout: ''
  timestamp: 1659805400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n + 1)\n        val q\
    \ = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n        val\
    \ s = new Array[Long](n + 1)\n        val t = new Array[Long](n + 1)\n       \
    \ val u = new Array[Long](n + 1)\n        val v = new Array[Long](n + 1)\n   \
    \     val w = new Array[Long](n + 1)\n        val x = new Array[Long](n + 1)\n\
    \        val y = new Array[Long](n + 1)\n        val z = new Array[Long](n + 1)\n\
    \        val a = new Array[Long](n + 1)\n        val b = new Array[Long](n + 1)\n\
    \        val c = new Array[Long](n + 1)\n        val d = new Array[Long](n + 1)\n\
    \        val e = new Array[Long](n + 1)\n        val f = new Array[Long](n + 1)\n\
    \        val g = new Array[Long](n + 1)\n        val h = new Array[Long](n + 1)\n\
    \        val i = new Array[Long](n + 1)\n        val j = new Array[Long](n + 1)\n\
    \        val k = new Array[Long](n + 1)\n        val l = new Array[Long](n + 1)\n\
    \        val m = new Array[Long](n + 1)\n        val n = new Array[Long](n + 1)\n\
    \        val o = new Array[Long](n + 1)\n        val p1 = new Array[Long](n +\
    \ 1)\n        val p2 = new Array[Long](n + 1)\n        val p3 = new Array[Long](n\
    \ + 1)\n        val p4 = new Array[Long](n + 1)\n        val p5 = new Array[Long](n\
    \ + 1)\n        val p6 = new Array[Long](n + 1)\n        val p7 = new Array[Long](n\
    \ + 1)\n        val p8 = new Array[Long](n + 1)\n        val p9 = new Array[Long](n\
    \ + 1)\n        val p10 = new Array[Long](n + 1)\n        val p11 = new Array[Long](n\
    \ + 1)\n        val p12 = new Array[Long](n + 1)\n        val p13 = new Array[Long](n\
    \ + 1)\n        val p14 = new Array[Long](n + 1)\n        val p15 = new Array[Long](n\
    \ + 1)\n        val p16 = new Array[Long](n + 1)\n        val p17 = new Array[Long](n\
    \ + 1)\n        val p18 = new Array[Long](n + 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfmjp1lx7.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfmjp1lx7.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfmjp1lx7.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.head\n        val p = new Array[Long](m)\n        val r = new\
    \ Array[Long](m)\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var min = 0\n        var max = 0\n        var count = 0\n        var isPalindromic\
    \ = true\n        while (i < m && j < m) {\n            if (arr(i) < arr(j)) {\n\
    \                p(k) = arr(i)\n                i += 1\n                k += 1\n\
    \            } else {\n                p(k) = arr(j)\n                j += 1\n\
    \                k += 1\n            }\n        }\n        while (i < m) {\n \
    \           p(k) = arr(i)\n            i += 1\n            k += 1\n        }\n\
    \        while (j < m) {\n            p(k) = arr(j)\n            j += 1\n    \
    \        k += 1\n        }\n        while (i < m && j < m) {\n            if (arr(i)\
    \ < arr(j)) {\n                p(k) = arr(i)\n                i += 1\n       \
    \         k += 1\n            } else {\n                p(k) = arr(j)\n      \
    \          j += 1\n                k += 1\n            }\n        }\n        while\
    \ (i < m) {\n            p(k) = arr(i)\n            i += 1\n            k += 1\n\
    \        }\n        while (j < m) {\n            p(k) = arr(j)\n            j\
    \ += 1\n            k += 1\n        }\n        while (i < m && j < m) {\n    \
    \        if (arr(i) < arr(j)) {\n                p(k) = arr(i)\n             \
    \   i += 1\n                k += 1\n            } else {\n                p(k)\
    \ = arr(j)\n                j += 1\n                k += 1\n            }\n  \
    \      }\n        while (i < m) {\n            p(k) = arr(i)\n            i +=\
    \ 1\n            k += 1\n        }\n        while (j < m) {\n            p(k)\
    \ = arr(j)\n            j += 1\n            k += 1\n        }\n        while (i\
    \ < m && j < m) {\n            if (arr(i) < arr(j)) {\n                p(k) =\
    \ arr(i)\n                i += 1\n                k += 1\n            } else {\n\
    \                p(k) = arr(j)\n                j += 1\n                k += 1\n\
    \            }\n        }\n        while (i < m) {\n            p(k) = arr(i)\n\
    \            i += 1\n            k += 1\n        }\n        while (j < m) {\n\
    \            p(k) = arr(j)\n            j += 1\n            k += 1\n        }\n\
    \        while (i < m && j < m) {\n            if (arr(i) < arr(j)) {\n      \
    \          p(k) = arr(i)\n                i += 1\n                k += 1\n   \
    \         } else {\n                p(k) = arr(j)\n                j += 1\n  \
    \              k += 1\n            }\n        }\n        while (i < m) {\n   \
    \         p(k) = arr(i)\n            i += 1\n            k += 1\n        }\n \
    \       while (j < \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3t72tx24.scala:123:18 --------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m        \e[33mwhile\e[0m (j < \n\e[31m\e[31m    |\e\
    [0m                  ^\e[0m\n\e[31m    |\e[0m                  expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val min = len / 2\n        val max = len\
    \ - min\n        val mid = len / 2\n        var count = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var temp = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        while (i < len) {\n            while (j\
    \ < len) {\n                if (arr(i) == arr(j)) {\n                    count\
    \ += 1\n                    j++\n                }\n                else {\n \
    \                   count = 0\n                    j++\n                }\n  \
    \          }\n            if (count == min) {\n                temp2 = arr(i)\n\
    \                temp3 = arr(mid)\n                while (k < len) {\n       \
    \             if (arr(k) == temp2) {\n                        arr(k) = temp3\n\
    \                        k++\n                    }\n                    else\
    \ {\n                        arr(k) = temp2\n                        k++\n   \
    \                 }\n                }\n                count += 1\n         \
    \       i = 0\n                j = 0\n                k = 0\n                temp\
    \ = 0\n                temp2 = 0\n                temp3 = 0\n            }\n \
    \           else if (count == max) {\n                temp2 = arr(i)\n       \
    \         temp3 = arr(mid)\n                while (k < len) {\n              \
    \      if (arr(k) == temp2) {\n                        arr(k) = temp3\n      \
    \                  k++\n                    }\n                    else {\n  \
    \                      arr(k) = temp2\n                        k++\n         \
    \           }\n                }\n                count -= 1\n               \
    \ i = 0\n                j = 0\n                k = 0\n                temp =\
    \ 0\n                temp2 = 0\n                temp3 = 0\n            }\n   \
    \         else if (count < min) {\n                temp2 = arr(i)\n          \
    \      temp3 = arr(mid)\n                while (k < len) {\n                 \
    \   if (arr(k) == temp2) {\n                        arr(k) = temp3\n         \
    \               k++\n                    }\n                    else {\n     \
    \                   arr(k) = temp2\n                        k++\n            \
    \        }\n                }\n                count += 1\n                i =\
    \ 0\n                j = 0\n                k = 0\n                temp = 0\n\
    \                temp2 = 0\n                temp3 = 0\n            }\n       \
    \     else if (count > max) {\n                temp2 = arr(i)\n              \
    \  temp3 = arr(mid)\n                while (k < len) {\n                    if\
    \ (arr(k) == temp2) {\n                        arr(k) = temp3\n              \
    \          k++\n                    }\n                    else {\n          \
    \              arr(k) = temp2\n                        k++\n                 \
    \   }\n                }\n                count -= 1\n                i = 0\n\
    \                j = 0\n                k = 0\n                temp = 0\n    \
    \            temp2 = 0\n                temp3 = 0\n            }\n           \
    \ i += 1\n        }\n        arr.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkecauxo9.scala:28:23 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpkecauxo9.scala:32:23 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkecauxo9.scala:41:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                     \
    \   k++\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkecauxo9.scala:45:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                     \
    \   k++\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkecauxo9.scala:62:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m62 |\e[0m                     \
    \   k++\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkecauxo9.scala:66:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m66 |\e[0m                     \
    \   k++\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e\
    [0m                           expression expected but \e[31m'}"
  stdout: ''
  timestamp: 1659805398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val p = new Array[Long](n)\n        var i =\
    \ 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n \
    \       while(i < n && j < n) {\n            if(arr(i) < arr(j)) {\n         \
    \       p(k) = arr(i)\n                i += 1\n                k += 1\n      \
    \      } else {\n                p(k) = arr(j)\n                j += 1\n     \
    \           k += 1\n            }\n            min = Math.min(min, k - i)\n  \
    \      }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvlzmb0av.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        var i = 0\n        var j = 0\n        while (i < len) {\n    \
    \        while (j < len) {\n                if (arr(i) != arr(j)) {\n        \
    \            minChangeIndex = j\n                    break\n                }\n\
    \                j += 1\n            }\n            i += 1\n            minChange\
    \ = math.min(minChange, j - i)\n        }\n        minChangeIndex\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpanzreony.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpanzreony.scala:21:35 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    minChangeIndex = j\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Reassignment to val minChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpanzreony.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpanzreony.scala:27:22 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            minChange = math.min(minChange, j - i)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val min = len / 2\n        val\
    \ max = len - min\n        val mid = len / 2\n        val mid2 = len / 2\n   \
    \     val mid3 = len / 2\n        val mid4 = len / 2\n        val mid5 = len /\
    \ 2\n        val mid6 = len / 2\n        val mid7 = len / 2\n        val mid8\
    \ = len / 2\n        val mid9 = len / 2\n        val mid10 = len / 2\n       \
    \ val mid11 = len / 2\n        val mid12 = len / 2\n        val mid13 = len /\
    \ 2\n        val mid14 = len / 2\n        val mid15 = len / 2\n        val mid16\
    \ = len / 2\n        val mid17 = len / 2\n        val mid18 = len / 2\n      \
    \  val mid19 = len / 2\n        val mid20 = len / 2\n        val mid21 = len /\
    \ 2\n        val mid22 = len / 2\n        val mid23 = len / 2\n        val mid24\
    \ = len / 2\n        val mid25 = len / 2\n        val mid26 = len / 2\n      \
    \  val mid27 = len / 2\n        val mid28 = len / 2\n        val mid29 = len /\
    \ 2\n        val mid30 = len / 2\n        val mid31 = len / 2\n        val mid32\
    \ = len / 2\n        val mid33 = len / 2\n        val mid34 = len / 2\n      \
    \  val mid35 = len / 2\n        val mid36 = len / 2\n        val mid37 = len /\
    \ 2\n        val mid38 = len / 2\n        val mid39 = len / 2\n        val mid40\
    \ = len / 2\n        val mid41 = len / 2\n        val mid42 = len / 2\n      \
    \  val mid43 = len / 2\n        val mid44 = len / 2\n        val mid45 = len /\
    \ 2\n        val mid46 = len / 2\n        val mid47 = len / 2\n        val mid48\
    \ = len / 2\n        val mid49 = len / 2\n        val mid50 = len / 2\n      \
    \  val mid51 = len / 2\n        val mid52 = len / 2\n        val mid53 = len /\
    \ 2\n        val mid54 = len / 2\n        val mid55 = len / 2\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd56b4po8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd56b4po8.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805408
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val d = (m - n) / 2\n        val result = 0\n\
    \        val arr = arr.sortWith(_ < _)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while (i < m) {\n          \
    \  temp = arr(i)\n            while (j < n && arr(j) == temp) {\n            \
    \    j += 1\n            }\n            k += j - i\n            result += k\n\
    \            i = j\n            j = 0\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpobjii6n6.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpobjii6n6.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            result += k\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean result.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659805409
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.head\n        val p = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var minChange = 0\n        var\
    \ minChangeIndex = 0\n        var changeCount = 0\n        var changeIndex = 0\n\
    \        var changeCountIndex = 0\n        var changeIndex2 = 0\n        var changeCountIndex2\
    \ = 0\n        var changeIndex3 = 0\n        var changeCountIndex3 = 0\n     \
    \   var changeIndex4 = 0\n        var changeCountIndex4 = 0\n        var changeIndex5\
    \ = 0\n        var changeCountIndex5 = 0\n        var changeIndex6 = 0\n     \
    \   var changeCountIndex6 = 0\n        var changeIndex7 = 0\n        var changeCountIndex7\
    \ = 0\n        var changeIndex8 = 0\n        var changeCountIndex8 = 0\n     \
    \   var changeIndex9 = 0\n        var changeCountIndex9 = 0\n        var changeIndex10\
    \ = 0\n        var changeCountIndex10 = 0\n        var changeIndex11 = 0\n   \
    \     var changeCountIndex11 = 0\n        var changeIndex12 = 0\n        var changeCountIndex12\
    \ = 0\n        var changeIndex13 = 0\n        var changeCountIndex13 = 0\n   \
    \     var changeIndex14 = 0\n        var changeCountIndex14 = 0\n        var changeIndex15\
    \ = 0\n        var changeCountIndex15 = 0\n        var changeIndex16 = 0\n   \
    \     var changeCountIndex16 = 0\n        var changeIndex17 = 0\n        var changeCountIndex17\
    \ = 0\n        var changeIndex18 = 0\n        var changeCountIndex18 = 0\n   \
    \     var changeIndex19 = 0\n        var changeCountIndex19 = 0\n        var changeIndex20\
    \ = 0\n        var changeCountIndex20 = 0\n        var changeIndex21 = 0\n   \
    \     var changeCountIndex21 = 0\n        var changeIndex22 = 0\n        var changeCountIndex22\
    \ = 0\n        var changeIndex23 = 0\n        var changeCountIndex23 = 0\n   \
    \     var changeIndex24 = 0\n        var changeCountIndex24 = 0\n        var changeIndex25\
    \ = 0\n        var changeCountIndex25 = 0\n        var changeIndex26 = 0\n   \
    \     var changeCountIndex26 = 0\n        var changeIndex27 = 0\n        var changeCountIndex27\
    \ = 0\n        var changeIndex28 = 0\n        var changeCountIndex28 = 0\n   \
    \     var changeIndex29 = 0\n        var changeCountIndex29 = 0\n        var changeIndex30\
    \ = 0\n        var changeCountIndex30 = 0\n        var changeIndex31 = 0\n   \
    \     var changeCountIndex31 = 0\n        var changeIndex32 = 0\n        var changeCountIndex32\
    \ = 0\n        var changeIndex33 = 0\n        var changeCountIndex33 = 0\n   \
    \     var changeIndex34 = 0\n        var changeCountIndex34 = 0\n        var changeIndex35\
    \ = 0\n        var changeCountIndex35 = 0\n        var changeIndex36 = 0\n   \
    \     var changeCountIndex\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5telmr_e.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5telmr_e.scala:93:5 ---------------------\e[0m\e[0m\n\e[31m93 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ while (j < len) {\n                if (arr(i) == arr(j)) {\n               \
    \     j++\n                }\n                else {\n                    minChange\
    \ = minChange - 1\n                    k = j\n                    while (k < len)\
    \ {\n                        arr(k) = arr(k + 1)\n                        k++\n\
    \                    }\n                    j = 0\n                }\n       \
    \     }\n            i++\n            j = 0\n        }\n        minChange\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmzwj7ut7.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpmzwj7ut7.scala:28:27 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                        k++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpmzwj7ut7.scala:34:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m34 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpmzwj7ut7.scala:12:18 ---------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpmzwj7ut7.scala:24:30 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    minChange = minChange - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Reassignment to val minChange\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmzwj7ut7.scala:33:13 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            i++\n\e[31m\e[31m   |\e[0m            ^^^\e\
    [0m\n\e[31m   |\e[0m            value ++ is not a member of Int\n6 errors found\n"
  stdout: ''
  timestamp: 1659805410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val maxLen2\
    \ = maxLen / 2\n        val maxLen3 = maxLen / 3\n        val maxLen4 = maxLen\
    \ / 4\n        val maxLen5 = maxLen / 5\n        val maxLen6 = maxLen / 6\n  \
    \      val maxLen7 = maxLen / 7\n        val maxLen8 = maxLen / 8\n        val\
    \ maxLen9 = maxLen / 9\n        val maxLen10 = maxLen / 10\n        val maxLen11\
    \ = maxLen / 11\n        val maxLen12 = maxLen / 12\n        val maxLen13 = maxLen\
    \ / 13\n        val maxLen14 = maxLen / 14\n        val maxLen15 = maxLen / 15\n\
    \        val maxLen16 = maxLen / 16\n        val maxLen17 = maxLen / 17\n    \
    \    val maxLen18 = maxLen / 18\n        val maxLen19 = maxLen / 19\n        val\
    \ maxLen20 = maxLen / 20\n        val maxLen21 = maxLen / 21\n        val maxLen22\
    \ = maxLen / 22\n        val maxLen23 = maxLen / 23\n        val maxLen24 = maxLen\
    \ / 24\n        val maxLen25 = maxLen / 25\n        val maxLen26 = maxLen / 26\n\
    \        val maxLen27 = maxLen / 27\n        val maxLen28 = maxLen / 28\n    \
    \    val maxLen29 = maxLen / 29\n        val maxLen30 = maxLen / 30\n        val\
    \ maxLen31 = maxLen / 31\n        val maxLen32 = maxLen / 32\n        val maxLen33\
    \ = maxLen / 33\n        val maxLen34 = maxLen / 34\n        val maxLen35 = maxLen\
    \ / 35\n        val maxLen36 = maxLen / 36\n        val maxLen37 = maxLen / 37\n\
    \        val maxLen38 = maxLen / 38\n        val maxLen39 = maxLen / 39\n    \
    \    val maxLen40 = maxLen / 40\n        val maxLen41 = maxLen / 41\n        val\
    \ maxLen42 = maxLen / 42\n        val maxLen43 = maxLen / 43\n        val maxLen44\
    \ = maxLen / 44\n        val maxLen45 = maxLen / 45\n        val maxLen46 = maxLen\
    \ / 46\n        val maxLen47 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp75bnhsm8.scala:60:22 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmaxLen47\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp75bnhsm8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp75bnhsm8.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var min = Long.MaxValue\n        while (i < len) {\n\
    \            while (j < len && arr(i) == arr(j)) {\n                j += 1\n \
    \           }\n            while (k < len && arr(i) != arr(k)) {\n           \
    \     k += 1\n            }\n            if (j < len && k < len) {\n         \
    \       if (arr(i) < arr(k)) {\n                    min = Math.min(min, j - i\
    \ + 1)\n                } else {\n                    min = Math.min(min, k -\
    \ j + 1)\n                }\n            }\n            i += 1\n            j\
    \ += 1\n            k += 1\n        }\n        min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkarf6bbh.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val minChange = arr.foldLeft(0)((acc, x)\
    \ => {\n            val y = x - 1\n            val z = x + 1\n            if (arr(x)\
    \ == arr(y) && arr(y) == arr(z)) {\n                acc + 1\n            } else\
    \ {\n                acc\n            }\n        })\n        minChange\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1icvx9me.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val arr = arr.toArray\n        val m = arr.max\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n\
    \        var m1 = arr.length\n        var m2 = arr.length\n        var m3 = arr.length\n\
    \        var m4 = arr.length\n        var m5 = arr.length\n        var m6 = arr.length\n\
    \        var m7 = arr.length\n        var m8 = arr.length\n        var m9 = arr.length\n\
    \        var m10 = arr.length\n        var m11 = arr.length\n        var m12 =\
    \ arr.length\n        var m13 = arr.length\n        var m14 = arr.length\n   \
    \     var m15 = arr.length\n        var m16 = arr.length\n        var m17 = arr.length\n\
    \        var m18 = arr.length\n        var m19 = arr.length\n        var m20 =\
    \ arr.length\n        var m21 = arr.length\n        var m22 = arr.length\n   \
    \     var m23 = arr.length\n        var m24 = arr.length\n        var m25 = arr.length\n\
    \        var m26 = arr.length\n        var m27 = arr.length\n        var m28 =\
    \ arr.length\n        var m29 = arr.length\n        var m30 = arr.length\n   \
    \     var m31 = arr.length\n        var m32 = arr.length\n        var m33 = arr.length\n\
    \        var m34 = arr.length\n        var m35 = arr.length\n        var m36 =\
    \ arr.length\n        var m37 = arr.length\n        var m38 = arr.length\n   \
    \     var m39 = arr.length\n        var m40 = arr.length\n        var m41 = arr.length\n\
    \        var m42 = arr.length\n        var m43 = arr.length\n        var m44 =\
    \ arr.length\n        var m45 = arr.length\n        var m46 = arr.length\n   \
    \     var m47 = arr.length\n        var m48 = arr.length\n        var m49 = arr.length\n\
    \        var m50 = arr.length\n        var m51 = arr.length\n        var m52 =\
    \ arr.length\n        var m53 = arr.length\n        var m54 = arr.length\n   \
    \     var m55 = arr.length\n        var m56 = arr.length\n        var m57 = arr.length\n\
    \        var m58 = arr.length\n        var m59 = arr.length\n        var m60 =\
    \ arr.length\n        var m61 = arr.length\n        var m62 = arr.length\n   \
    \     var m63 = arr.length\n        var m64 = arr.length\n        var m65 = arr.length\n\
    \        var m66 = arr.length\n        var m67 = arr.length\n        var m68 =\
    \ arr.length\n        var m69 = arr.length\n        var m70\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjkwuk2f5.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjkwuk2f5.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjkwuk2f5.scala:14:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjkwuk2f5.scala:90:5\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = arr.take(len/2).foldLeft(0)\
    \ { (sum, item) =>\n            val newSum = sum + item\n            val newItem\
    \ = item - arr[len/2-1]\n            if (newSum == newItem) {\n              \
    \  sum\n            } else {\n                newSum\n            }\n        }\n\
    \        val maxChange = arr.take(len/2).foldLeft(0) { (sum, item) =>\n      \
    \      val newSum = sum + item\n            val newItem = item + arr[len/2-1]\n\
    \            if (newSum == newItem) {\n                sum\n            } else\
    \ {\n                newSum\n            }\n        }\n        if (minChange <\
    \ maxChange) {\n            minChange\n        } else {\n            maxChange\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbv86pmrz.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val arr = arr.toList\n        val minChange = arr.take(n).foldLeft(0)(_ +\
    \ arr.take(n).reverse.foldLeft(0)(_ + _))\n        val maxChange = arr.take(n).foldLeft(0)(_\
    \ + arr.take(n).reverse.foldRight(0)(_ - _))\n        minChange < maxChange ?\
    \ minChange : maxChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps5ziu__0.scala:13:18 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps5ziu__0.scala:16:44 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        minChange < maxChange ? minChange : \e[35mmaxChange\e\
    [0m\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Not found: type\
    \ maxChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val changes = mutable.ArrayBuffer(m)\n      \
    \  val palindromic = mutable.ArrayBuffer(m)\n        val changed = mutable.ArrayBuffer(m)\n\
    \        val palindromicChanged = mutable.ArrayBuffer(m)\n        val change =\
    \ mutable.ArrayBuffer(m)\n        val palindromicChange = mutable.ArrayBuffer(m)\n\
    \        val changed = mutable.ArrayBuffer(m)\n        val palindromicChanged\
    \ = mutable.ArrayBuffer(m)\n        val change = mutable.ArrayBuffer(m)\n    \
    \    val palindromicChange = mutable.ArrayBuffer(m)\n        val changed = mutable.ArrayBuffer(m)\n\
    \        val palindromicChanged = mutable.ArrayBuffer(m)\n        val change =\
    \ mutable.ArrayBuffer(m)\n        val palindromicChange = mutable.ArrayBuffer(m)\n\
    \        val changed = mutable.ArrayBuffer(m)\n        val palindromicChanged\
    \ = mutable.ArrayBuffer(m)\n        val change = mutable.ArrayBuffer(m)\n    \
    \    val palindromicChange = mutable.ArrayBuffer(m)\n        val changed = mutable.ArrayBuffer(m)\n\
    \        val palindromicChanged = mutable.ArrayBuffer(m)\n        val change =\
    \ mutable.ArrayBuffer(m)\n        val palindromicChange = mutable.ArrayBuffer(m)\n\
    \        val changed = mutable.ArrayBuffer(m)\n        val palindromicChanged\
    \ = mutable.ArrayBuffer(m)\n        val change = mutable.ArrayBuffer(m)\n    \
    \    val palindromicChange = mutable.ArrayBuffer(m)\n        val changed = mutable.ArrayBuffer(m)\n\
    \        val palindromicChanged = mutable.ArrayBuffer(m)\n        val change =\
    \ mutable.ArrayBuffer(m)\n        val palindromicChange = mutable.ArrayBuffer(m)\n\
    \        val changed = mutable.ArrayBuffer(m)\n        val palindromicChanged\
    \ = mutable.ArrayBuffer(m)\n        val change = mutable.ArrayBuffer(m)\n    \
    \    val palindromicChange = mutable.ArrayBuffer(m)\n        val changed = mutable.ArrayBuffer(m)\n\
    \        val palindromicChanged = mutable.ArrayBuffer(m)\n        val change =\
    \ mutable.ArrayBuffer(m)\n        val palindromicChange = mutable.ArrayBuffer(m)\n\
    \        val changed = mutable.ArrayBuffer(m)\n        val palindromicChanged\
    \ = mutable.ArrayBuffer(m)\n        val change = mutable.ArrayBuffer(m)\n    \
    \    val palindromicChange = mutable.Array\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpduqdhiqe.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpduqdhiqe.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mpalindromicChanged\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChanged is already defined as \e[33mvalue\e[0m\
    \ \e[35mpalindromicChanged\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpduqdhiqe.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpduqdhiqe.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mpalindromicChange\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpalindromicChange is already defined as \e[33mvalue\e[0m \e\
    [35mpalindromicChange\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpduqdhiqe.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer(m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val minChange = arr.head\n        val minChangeIndex\
    \ = arr.indexOf(minChange)\n        val minChangeIndex = minChangeIndex + 1\n\
    \        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex =\
    \ minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n      \
    \  val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex - 1\n    \
    \    val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex = minChangeIndex\
    \ - 1\n        val minChangeIndex = minChangeIndex - 1\n        val minChangeIndex\
    \ = minChangeIndex - 1\n\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8uhrd42t.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8uhrd42t.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8uhrd42t.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8uhrd42t.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndex is already defined as \e[33mvalue\e[0m \e[35mminChangeIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8uhrd42t.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndex\e[0m = minChangeIndex\
    \ - \e[31m1\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659805414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n + 1)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m1\
    \ = m\n        var m2 = m\n        var m3 = m\n        var m4 = m\n        var\
    \ m5 = m\n        var m6 = m\n        var m7 = m\n        var m8 = m\n       \
    \ var m9 = m\n        var m10 = m\n        var m11 = m\n        var m12 = m\n\
    \        var m13 = m\n        var m14 = m\n        var m15 = m\n        var m16\
    \ = m\n        var m17 = m\n        var m18 = m\n        var m19 = m\n       \
    \ var m20 = m\n        var m21 = m\n        var m22 = m\n        var m23 = m\n\
    \        var m24 = m\n        var m25 = m\n        var m26 = m\n        var m27\
    \ = m\n        var m28 = m\n        var m29 = m\n        var m30 = m\n       \
    \ var m31 = m\n        var m32 = m\n        var m33 = m\n        var m34 = m\n\
    \        var m35 = m\n        var m36 = m\n        var m37 = m\n        var m38\
    \ = m\n        var m39 = m\n        var m40 = m\n        var m41 = m\n       \
    \ var m42 = m\n        var m43 = m\n        var m44 = m\n        var m45 = m\n\
    \        var m46 = m\n        var m47 = m\n        var m48 = m\n        var m49\
    \ = m\n        var m50 = m\n        var m51 = m\n        var m52 = m\n       \
    \ var m53 = m\n        var m54 = m\n        var m55 = m\n        var m56 = m\n\
    \        var m57 = m\n        var m58 = m\n        var m59 = m\n        var m60\
    \ = m\n        var m61 = m\n        var m62 = m\n        var m63 = m\n       \
    \ var m64 = m\n        var m65 = m\n        var m66 = m\n        var m67 = m\n\
    \        var m68 = m\n        var m69 = m\n        var m70 = m\n        var m71\
    \ = m\n        var m72 = m\n        var m73 = m\n        var m74 = m\n       \
    \ var m75 = m\n        var m76 = m\n        var m77 = m\n        var m78 = m\n\
    \        var m79 = m\n        var m80 = m\n        var m81 = m\n        var m82\
    \ = m\n        var m83 = m\n        var m84 = m\n        var m85 = m\n       \
    \ var m86 = m\n        var m87 = m\n        var m88 = m\n        var m89 = m\n\
    \        var m90 = m\n        var m91 = m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyxpjhsd0.scala:110:5\
    \ --------------------\e[0m\e[0m\n\e[31m110 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex = mutable.ArrayBuffer.empty[Long]\n        val changeIndex2\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex3 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex4 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex5\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex6 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex7 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex8\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex9 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex10 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex11\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex12 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex13 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex14\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex15 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex16 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex17\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex18 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex19 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex20\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex21 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex22 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex23\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex24 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex25 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex26\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex27 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex28 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex29\
    \ = mutable.ArrayBuffer.empty[Long]\n        val changeIndex30 = mutable.ArrayBuffer.empty[Long]\n\
    \        val changeIndex31 = mutable.ArrayBuffer.empty[Long]\n        val changeIndex32\
    \ = mutable.Array\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphbdry2n2.scala:14:22 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphbdry2n2.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphbdry2n2.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphbdry2n2.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmphbdry2n2.scala:18:27 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmphbdry2n2.scala:19:27 -----------------------"
  stdout: ''
  timestamp: 1659805416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.takeRight(n).reverse.take(n).length\n        val max = (arr.takeRight(n).reverse.take(n).length\
    \ + arr.takeRight(n).length) / 2\n        val min = n - max\n        val changes\
    \ = arr.takeRight(n).reverse.take(n).length\n        val change = (changes + arr.takeRight(n).length)\
    \ / 2\n        val change2 = change + change\n        val change3 = change2 +\
    \ change\n        val change4 = change3 + change\n        val change5 = change4\
    \ + change\n        val change6 = change5 + change\n        val change7 = change6\
    \ + change\n        val change8 = change7 + change\n        val change9 = change8\
    \ + change\n        val change10 = change9 + change\n        val change11 = change10\
    \ + change\n        val change12 = change11 + change\n        val change13 = change12\
    \ + change\n        val change14 = change13 + change\n        val change15 = change14\
    \ + change\n        val change16 = change15 + change\n        val change17 = change16\
    \ + change\n        val change18 = change17 + change\n        val change19 = change18\
    \ + change\n        val change20 = change19 + change\n        val change21 = change20\
    \ + change\n        val change22 = change21 + change\n        val change23 = change22\
    \ + change\n        val change24 = change23 + change\n        val change25 = change24\
    \ + change\n        val change26 = change25 + change\n        val change27 = change26\
    \ + change\n        val change28 = change27 + change\n        val change29 = change28\
    \ + change\n        val change30 = change29 + change\n        val change31 = change30\
    \ + change\n        val change32 = change31 + change\n        val change33 = change32\
    \ + change\n        val change34 = change33 + change\n        val change35 = change34\
    \ + change\n        val change36 = change35 + change\n        val change37 = change36\
    \ + change\n        val change38 = change37 + change\n        val change39 = change38\
    \ + change\n        val change40 = change39 + change\n        val change41 = change40\
    \ + change\n        val change42 = change41 + change\n        val change43 = change42\
    \ + change\n        val change44 = change43 + change\n        val change45 = change44\
    \ + change\n        val change46 = change\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2n1b16u3.scala:63:5\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n)\n        val r = new\
    \ Array[Long](n)\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m1 = new Array[Long](n)\n        var m2 = new Array[Long](n)\n\
    \        var m3 = new Array[Long](n)\n        var m4 = new Array[Long](n)\n  \
    \      var m5 = new Array[Long](n)\n        var m6 = new Array[Long](n)\n    \
    \    var m7 = new Array[Long](n)\n        var m8 = new Array[Long](n)\n      \
    \  var m9 = new Array[Long](n)\n        var m10 = new Array[Long](n)\n       \
    \ var m11 = new Array[Long](n)\n        var m12 = new Array[Long](n)\n       \
    \ var m13 = new Array[Long](n)\n        var m14 = new Array[Long](n)\n       \
    \ var m15 = new Array[Long](n)\n        var m16 = new Array[Long](n)\n       \
    \ var m17 = new Array[Long](n)\n        var m18 = new Array[Long](n)\n       \
    \ var m19 = new Array[Long](n)\n        var m20 = new Array[Long](n)\n       \
    \ var m21 = new Array[Long](n)\n        var m22 = new Array[Long](n)\n       \
    \ var m23 = new Array[Long](n)\n        var m24 = new Array[Long](n)\n       \
    \ var m25 = new Array[Long](n)\n        var m26 = new Array[Long](n)\n       \
    \ var m27 = new Array[Long](n)\n        var m28 = new Array[Long](n)\n       \
    \ var m29 = new Array[Long](n)\n        var m30 = new Array[Long](n)\n       \
    \ var m31 = new Array[Long](n)\n        var m32 = new Array[Long](n)\n       \
    \ var m33 = new Array[Long](n)\n        var m34 = new Array[Long](n)\n       \
    \ var m35 = new Array[Long](n)\n        var m36 = new Array[Long](n)\n       \
    \ var m37 = new Array[Long](n)\n        var m38 = new Array[Long](n)\n       \
    \ var m39 = new Array[Long](n)\n        var m40 = new Array[Long](n)\n       \
    \ var m41 = new Array[Long](n)\n        var m42 = new Array[Long](n)\n       \
    \ var m43 = new Array[Long](n)\n        var m44 = new Array[Long](n)\n       \
    \ var m45 = new Array[Long](n)\n        var m46 = new Array[Long](n)\n       \
    \ var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmptx0dt0gz.scala:66:11 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptx0dt0gz.scala:67:5 ---------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val count = new Array[Int](n)\n        val change\
    \ = new Array[Int](n)\n        val max = new Array[Int](n)\n        val min =\
    \ new Array[Int](n)\n        val p = new Array[Int](n)\n        val dp = new Array[Int](n+1)\n\
    \        val dp2 = new Array[Int](n+1)\n        val dp3 = new Array[Int](n+1)\n\
    \        val dp4 = new Array[Int](n+1)\n        val dp5 = new Array[Int](n+1)\n\
    \        val dp6 = new Array[Int](n+1)\n        val dp7 = new Array[Int](n+1)\n\
    \        val dp8 = new Array[Int](n+1)\n        val dp9 = new Array[Int](n+1)\n\
    \        val dp10 = new Array[Int](n+1)\n        val dp11 = new Array[Int](n+1)\n\
    \        val dp12 = new Array[Int](n+1)\n        val dp13 = new Array[Int](n+1)\n\
    \        val dp14 = new Array[Int](n+1)\n        val dp15 = new Array[Int](n+1)\n\
    \        val dp16 = new Array[Int](n+1)\n        val dp17 = new Array[Int](n+1)\n\
    \        val dp18 = new Array[Int](n+1)\n        val dp19 = new Array[Int](n+1)\n\
    \        val dp20 = new Array[Int](n+1)\n        val dp21 = new Array[Int](n+1)\n\
    \        val dp22 = new Array[Int](n+1)\n        val dp23 = new Array[Int](n+1)\n\
    \        val dp24 = new Array[Int](n+1)\n        val dp25 = new Array[Int](n+1)\n\
    \        val dp26 = new Array[Int](n+1)\n        val dp27 = new Array[Int](n+1)\n\
    \        val dp28 = new Array[Int](n+1)\n        val dp29 = new Array[Int](n+1)\n\
    \        val dp30 = new Array[Int](n+1)\n        val dp31 = new Array[Int](n+1)\n\
    \        val dp32 = new Array[Int](n+1)\n        val dp33 = new Array[Int](n+1)\n\
    \        val dp34 = new Array[Int](n+1)\n        val dp35 = new Array[Int](n+1)\n\
    \        val dp36 = new Array[Int](n+1)\n        val dp37 = new Array[Int](n+1)\n\
    \        val dp38 = new \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphw0an3jt.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphw0an3jt.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_.toInt)\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var min = 0\n        var minIndex = 0\n        var minValue =\
    \ 0\n        var temp = 0\n        while (i < len) {\n            temp = arr(i)\n\
    \            j = i\n            while (j < len) {\n                if (arr(j)\
    \ < temp) {\n                    temp = arr(j)\n                    k = j\n  \
    \              }\n                j++\n            }\n            if (temp ==\
    \ arr(k)) {\n                min = k - i\n                minIndex = i\n     \
    \           minValue = temp\n            }\n            i++\n        }\n     \
    \   minValue\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptc73atf9.scala:29:19 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptc73atf9.scala:36:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmptc73atf9.scala:12:18 ---------------------------\e[0m\e[0m\n\e[31m12\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_.toInt)\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.last\n        val max = (n-1)/2 // max is half the length of\
    \ the array\n        val max2 = max*2 // max is double the length of the array\n\
    \        val min = (n-1)/2 // min is half the length of the array\n        val\
    \ min2 = min*2 // min is double the length of the array\n        val max3 = max*3\
    \ // max is triple the length of the array\n        val min3 = min*3 // min is\
    \ triple the length of the array\n        val max4 = max*4 // max is quadruple\
    \ the length of the array\n        val min4 = min*4 // min is quadruple the length\
    \ of the array\n        val max5 = max*5 // max is quintuple the length of the\
    \ array\n        val min5 = min*5 // min is quintuple the length of the array\n\
    \        val max6 = max*6 // max is sextuple the length of the array\n       \
    \ val min6 = min*6 // min is sextuple the length of the array\n        val max7\
    \ = max*7 // max is octuple the length of the array\n        val min7 = min*7\
    \ // min is octuple the length of the array\n        val max8 = max*8 // max is\
    \ nonuple the length of the array\n        val min8 = min*8 // min is nonuple\
    \ the length of the array\n        val max9 = max*9 // max is dectuple the length\
    \ of the array\n        val min9 = min*9 // min is dectuple the length of the\
    \ array\n        val max10 = max*10 // max is undectuple the length of the array\n\
    \        val min10 = min*10 // min is undectuple the length of the array\n   \
    \     val max11 = max*11 // max is ductuple the length of the array\n        val\
    \ min11 = min*11 // min is ductuple the length of the array\n        val max12\
    \ = max*12 // max is unductuple the length of the array\n        val min12 = min*12\
    \ // min is unductuple the length of the array\n        val max13 = max*13 //\
    \ max is ductuple the length of the array\n        val min13 = min*13 // min is\
    \ ductuple the length of the array\n        val max14 = max*14 // max is unductuple\
    \ the length of the array\n        val min14 = min*14 // min is unductuple the\
    \ length of the array\n        val max15 = max*15 // max is ductuple the length\
    \ of the array\n        val min15 = min*15 // min \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3mlgjpij.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        val maxChange = arr.foldLeft(0) { (max, change)\
    \ => if (change > max) max else change }\n        val maxChange2 = maxChange /\
    \ 2\n        val maxChange3 = maxChange / 3\n        val maxChange4 = maxChange\
    \ / 4\n        val maxChange5 = maxChange / 5\n        val maxChange6 = maxChange\
    \ / 6\n        val maxChange7 = maxChange / 7\n        val maxChange8 = maxChange\
    \ / 8\n        val maxChange9 = maxChange / 9\n        val maxChange10 = maxChange\
    \ / 10\n        val maxChange11 = maxChange / 11\n        val maxChange12 = maxChange\
    \ / 12\n        val maxChange13 = maxChange / 13\n        val maxChange14 = maxChange\
    \ / 14\n        val maxChange15 = maxChange / 15\n        val maxChange16 = maxChange\
    \ / 16\n        val maxChange17 = maxChange / 17\n        val maxChange18 = maxChange\
    \ / 18\n        val maxChange19 = maxChange / 19\n        val maxChange20 = maxChange\
    \ / 20\n        val maxChange21 = maxChange / 21\n        val maxChange22 = maxChange\
    \ / 22\n        val maxChange23 = maxChange / 23\n        val maxChange24 = maxChange\
    \ / 24\n        val maxChange25 = maxChange / 25\n        val maxChange26 = maxChange\
    \ / 26\n        val maxChange27 = maxChange / 27\n        val maxChange28 = maxChange\
    \ / 28\n        val maxChange29 = maxChange / 29\n        val maxChange30 = maxChange\
    \ / 30\n        val maxChange31 = maxChange / 31\n        val maxChange32 = maxChange\
    \ / 32\n        val maxChange33 = maxChange / 33\n        val maxChange34 = maxChange\
    \ / 34\n        val maxChange35 = maxChange / 35\n        val maxChange36 = maxChange\
    \ / 36\n        val maxChange37 = maxChange / 37\n        val maxChange38 = maxChange\
    \ / 38\n        val maxChange39 = maxChange / 39\n        val maxChange40 = maxChange\
    \ / 40\n        val maxChange41 = maxChange / 41\n        val maxChange42 = maxChange\
    \ / 42\n        val maxChange43 = maxChange / 43\n        val maxChange44 = maxChange\
    \ / 44\n        val maxChange45 = maxChange / 45\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpi0y0q2i2.scala:59:11 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y0q2i2.scala:14:86 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxChange\e[0m = arr.foldLeft(\e\
    [31m0\e[0m) { (\e[36mmax\e[0m, \e[36mchange\e[0m) => \e[33mif\e[0m (change > max)\
    \ max \e[33melse\e[0m change }\n\e[31m\e[31m   |\e[0m                        \
    \                                                              ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                               Found:    (change\
    \ : Long)\n\e[31m   |\e[0m                                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi0y0q2i2.scala:60:5\
    \ ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var change = 0\n        var temp =\
    \ 0\n        while (i < len) {\n            while (j < len) {\n              \
    \  if (arr(i) == arr(j)) {\n                    temp = arr(i)\n              \
    \      arr(i) = arr(j)\n                    arr(j) = temp\n                  \
    \  change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr(i) = arr(j)\n                    arr(j) = temp\n                 \
    \   change += 1\n                    j++\n                }\n                else\
    \ {\n                    j++\n                }\n            }\n            i\
    \ += 1\n            j = len - k\n            while (j < len) {\n             \
    \   if (arr(i) == arr(j)) {\n                    temp = arr(i)\n             \
    \       arr\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj329lyxt.scala:27:23 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpj329lyxt.scala:30:23 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj329lyxt.scala:41:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpj329lyxt.scala:44:23 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpj329lyxt.scala:55:23 ---------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj329lyxt.scala:58:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1659805416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val result = new Array[Long](n + 1)\n       \
    \ var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n    \
    \    var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var\
    \ temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 =\
    \ 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n \
    \       var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n     \
    \   var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95 = 0\n        var\
    \ temp96 = 0\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpadcdal4u.scala:114:5\
    \ --------------------\e[0m\e[0m\n\e[31m114 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = min + (max - min) / 2\n        val mid2 = mid + 1\n       \
    \ val mid3 = mid + 1\n        val mid4 = mid + 1\n        val mid5 = mid + 1\n\
    \        val mid6 = mid + 1\n        val mid7 = mid + 1\n        val mid8 = mid\
    \ + 1\n        val mid9 = mid + 1\n        val mid10 = mid + 1\n        val mid11\
    \ = mid + 1\n        val mid12 = mid + 1\n        val mid13 = mid + 1\n      \
    \  val mid14 = mid + 1\n        val mid15 = mid + 1\n        val mid16 = mid +\
    \ 1\n        val mid17 = mid + 1\n        val mid18 = mid + 1\n        val mid19\
    \ = mid + 1\n        val mid20 = mid + 1\n        val mid21 = mid + 1\n      \
    \  val mid22 = mid + 1\n        val mid23 = mid + 1\n        val mid24 = mid +\
    \ 1\n        val mid25 = mid + 1\n        val mid26 = mid + 1\n        val mid27\
    \ = mid + 1\n        val mid28 = mid + 1\n        val mid29 = mid + 1\n      \
    \  val mid30 = mid + 1\n        val mid31 = mid + 1\n        val mid32 = mid +\
    \ 1\n        val mid33 = mid + 1\n        val mid34 = mid + 1\n        val mid35\
    \ = mid + 1\n        val mid36 = mid + 1\n        val mid37 = mid + 1\n      \
    \  val mid38 = mid + 1\n        val mid39 = mid + 1\n        val mid40 = mid +\
    \ 1\n        val mid41 = mid + 1\n        val mid42 = mid + 1\n        val mid43\
    \ = mid + 1\n        val mid44 = mid + 1\n        val mid45 = mid + 1\n      \
    \  val mid46 = mid + 1\n        val mid47 = mid + 1\n        val mid48 = mid +\
    \ 1\n        val mid49 = mid + 1\n        val mid50 = mid + 1\n        val mid51\
    \ = mid + 1\n        val mid52 = mid + 1\n        val mid53 = mid + 1\n      \
    \  val mid54 = mid + 1\n        val mid55 = mid + 1\n        val mid56 = mid +\
    \ 1\n        val mid57 = mid + 1\n        val mid58 = mid + 1\n        val mid59\
    \ = mid + 1\n        val mid\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpimfh_7oc.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpimfh_7oc.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpimfh_7oc.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val len = arr.length\n        var i = 0\n        var j = 0\n \
    \       var count = 0\n        while (i < len) {\n            if (arr(i) == arr(len-j))\
    \ {\n                count += 1\n                j++\n            } else {\n \
    \               j = 0\n            }\n            i += 1\n        }\n        count\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppt6wx10h.scala:20:19 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppt6wx10h.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val minChange = len\n        val minChangeIndex = 0\n        val minChangeIndexList\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexListSize = minChangeIndexList.length\n\
    \        val minChangeIndexListSet = minChangeIndexList.asInstanceOf[mutable.Set[Int]]\n\
    \        val minChangeIndexListSetSize = minChangeIndexListSet.size\n        val\
    \ minChangeIndexListSetIterator = minChangeIndexListSet.iterator\n        val\
    \ minChangeIndexListSetIteratorSize = minChangeIndexListSetIterator.size\n   \
    \     val minChangeIndexListSetIteratorIterator = minChangeIndexListSetIterator.iterator\n\
    \        val minChangeIndexListSetIteratorIteratorSize = minChangeIndexListSetIteratorIterator.size\n\
    \        val minChangeIndexListSetIteratorIteratorIterator = minChangeIndexListSetIteratorIterator.iterator\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorSize = minChangeIndexListSetIteratorIteratorIterator.size\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIterator = minChangeIndexListSetIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorSize = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorIterator = minChangeIndexListSetIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorSize = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorIterator = minChangeIndexListSetIteratorIteratorIterator.iterator\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorSize = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n\
    \        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorIterator\
    \ = minChangeIndexListSetIteratorIteratorIterator.iterator\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorSize\
    \ = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorIterator\
    \ = minChangeIndexListSetIteratorIteratorIterator.iterator\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorSize\
    \ = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorIterator\
    \ = minChangeIndexListSetIteratorIteratorIterator.iterator\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorSize\
    \ = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n        val minChangeIndexListSetIteratorIteratorIteratorIteratorIteratorIteratorIterator\
    \ = minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx9kp35rd.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\e\
    [0m = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx9kp35rd.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexListSetIteratorIteratorIteratorIteratorIterator\e\
    [0m = minChangeIndexListSetIteratorIteratorIterator.iterator\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexListSetIteratorIteratorIteratorIteratorIterator\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeIndexListSetIteratorIteratorIteratorIteratorIterator\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx9kp35rd.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\e\
    [0m = minChangeIndexListSetIteratorIteratorIteratorIterator.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeIndexListSetIteratorIteratorIteratorIteratorSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that "
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val maxLen = len / 2\n        val maxLen2 = maxLen / 2\n        val maxLen3\
    \ = maxLen / 3\n        val maxLen4 = maxLen / 4\n        val maxLen5 = maxLen\
    \ / 5\n        val maxLen6 = maxLen / 6\n        val maxLen7 = maxLen / 7\n  \
    \      val maxLen8 = maxLen / 8\n        val maxLen9 = maxLen / 9\n        val\
    \ maxLen10 = maxLen / 10\n        val maxLen11 = maxLen / 11\n        val maxLen12\
    \ = maxLen / 12\n        val maxLen13 = maxLen / 13\n        val maxLen14 = maxLen\
    \ / 14\n        val maxLen15 = maxLen / 15\n        val maxLen16 = maxLen / 16\n\
    \        val maxLen17 = maxLen / 17\n        val maxLen18 = maxLen / 18\n    \
    \    val maxLen19 = maxLen / 19\n        val maxLen20 = maxLen / 20\n        val\
    \ maxLen21 = maxLen / 21\n        val maxLen22 = maxLen / 22\n        val maxLen23\
    \ = maxLen / 23\n        val maxLen24 = maxLen / 24\n        val maxLen25 = maxLen\
    \ / 25\n        val maxLen26 = maxLen / 26\n        val maxLen27 = maxLen / 27\n\
    \        val maxLen28 = maxLen / 28\n        val maxLen29 = maxLen / 29\n    \
    \    val maxLen30 = maxLen / 30\n        val maxLen31 = maxLen / 31\n        val\
    \ maxLen32 = maxLen / 32\n        val maxLen33 = maxLen / 33\n        val maxLen34\
    \ = maxLen / 34\n        val maxLen35 = maxLen / 35\n        val maxLen36 = maxLen\
    \ / 36\n        val maxLen37 = maxLen / 37\n        val maxLen38 = maxLen / 38\n\
    \        val maxLen39 = maxLen / 39\n        val maxLen40 = maxLen / 40\n    \
    \    val maxLen41 = maxLen / 41\n        val maxLen42 = maxLen / 42\n        val\
    \ maxLen43 = maxLen / 43\n        val maxLen44 = maxLen / 44\n        val maxLen45\
    \ = maxLen / 45\n        val maxLen46 = maxLen / 46\n        val maxLen47 = maxLen\
    \ / 47\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp05auirte.scala:60:11 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp05auirte.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        val max = (len /\
    \ 2) - 1\n        val mid = max / 2\n        val mid2 = max / 2\n        val mid3\
    \ = max / 2\n        val mid4 = max / 2\n        val mid5 = max / 2\n        val\
    \ mid6 = max / 2\n        val mid7 = max / 2\n        val mid8 = max / 2\n   \
    \     val mid9 = max / 2\n        val mid10 = max / 2\n        val mid11 = max\
    \ / 2\n        val mid12 = max / 2\n        val mid13 = max / 2\n        val mid14\
    \ = max / 2\n        val mid15 = max / 2\n        val mid16 = max / 2\n      \
    \  val mid17 = max / 2\n        val mid18 = max / 2\n        val mid19 = max /\
    \ 2\n        val mid20 = max / 2\n        val mid21 = max / 2\n        val mid22\
    \ = max / 2\n        val mid23 = max / 2\n        val mid24 = max / 2\n      \
    \  val mid25 = max / 2\n        val mid26 = max / 2\n        val mid27 = max /\
    \ 2\n        val mid28 = max / 2\n        val mid29 = max / 2\n        val mid30\
    \ = max / 2\n        val mid31 = max / 2\n        val mid32 = max / 2\n      \
    \  val mid33 = max / 2\n        val mid34 = max / 2\n        val mid35 = max /\
    \ 2\n        val mid36 = max / 2\n        val mid37 = max / 2\n        val mid38\
    \ = max / 2\n        val mid39 = max / 2\n        val mid40 = max / 2\n      \
    \  val mid41 = max / 2\n        val mid42 = max / 2\n        val mid43 = max /\
    \ 2\n        val mid44 = max / 2\n        val mid45 = max / 2\n        val mid46\
    \ = max / 2\n        val mid47 = max / 2\n        val mid48 = max / 2\n      \
    \  val mid49 = max / 2\n        val mid50 = max / 2\n        val mid51 = max /\
    \ 2\n        val mid52 = max / 2\n        val mid53 = max / 2\n        val mid54\
    \ = max / 2\n        val mid55 = max / 2\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpe4zp01ga.scala:71:11 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpe4zp01ga.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpe4zp01ga.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805426
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.sortWith(_ < _)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var count = 0\n        var\
    \ min = 0\n        while(i < m && j < n) {\n            val x = arr(i)\n     \
    \       val y = arr(j)\n            if(x == y) {\n                count += 1\n\
    \                i += 1\n                j += 1\n            } else if(x < y)\
    \ {\n                count += 1\n                i += 1\n            } else {\n\
    \                count += 1\n                j += 1\n            }\n         \
    \   if(count > min) {\n                min = count\n                k = i\n  \
    \          }\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_xwwf68e.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m       \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659805421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.size\n\
    \        val minChangeSet = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.HashSet[Long]()\n        val minChangeSetSize\
    \ = mutable.HashSet[Long]()\n        val minChangeSetSize = mutable.HashSet[Long]()\n\
    \        val minChangeSetSize = mutable.Hash\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl7ytg72d.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mminChangeSetSize\e[0m =\
    \ mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeSetSize is already defined as \e[33mvalue\e[0m \e\
    [35mminChangeSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl7ytg72d.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminChangeSetSize\e[0m =\
    \ mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeSetSize is already defined as \e[33mvalue\e[0m \e\
    [35mminChangeSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl7ytg72d.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeSetSize\e[0m =\
    \ mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeSetSize is already defined as \e[33mvalue\e[0m \e\
    [35mminChangeSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl7ytg72d.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminChangeSetSize\e[0m =\
    \ mutable.HashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeSetSize is already defined as \e[33mvalue\e[0m \e\
    [35mminChangeSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl7ytg72d.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        "
  stdout: ''
  timestamp: 1659805429
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ListBuffer[Int]()\n\
    \        var i = 0\n        while (i < n) {\n            val j = n - i - 1\n \
    \           if (arr(i) == arr(j)) {\n                changes += i\n          \
    \      i += 1\n            } else {\n                val change = arr(i) - arr(j)\n\
    \                if (change < 0)\n                    changes += change\n    \
    \            else\n                    changes += change + 1\n            }\n\
    \        }\n        changes.min\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5a9hj8ay.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5a9hj8ay.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        var i = 0\n        var j = 0\n        while (i < len) {\n    \
    \        while (j < len) {\n                if (arr(i) == arr(j)) {\n        \
    \            j++\n                }\n                else {\n                \
    \    j++\n                }\n            }\n            minChangeIndex = j\n \
    \           minChange = minChangeIndex\n            i += 1\n            j = 0\n\
    \        }\n        minChange\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcb5fl9yi.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpcb5fl9yi.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcb5fl9yi.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpcb5fl9yi.scala:27:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            minChangeIndex\
    \ = j\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            Reassignment to val minChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpcb5fl9yi.scala:28:22 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            minChange = minChangeIndex\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \     Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(-_)\n\
    \        val len = arr.length\n        var i = 0\n        var j = 0\n        var\
    \ changes = 0\n        var minChanges = len\n        while (i < len) {\n     \
    \       while (j < len && arr(i) == arr(j)) {\n                j += 1\n      \
    \      }\n            if (j == len) {\n                changes += 1\n        \
    \        minChanges = math.min(minChanges, changes)\n            }\n         \
    \   i += 1\n            j = 0\n        }\n        minChanges\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf1t3qyqs.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805425
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val minChange = arr.size\n\
    \        val reversed = arr.reverse\n        val reversedSize = reversed.size\n\
    \        val changes = reversedSize - minChange\n        val change = reversed.size\
    \ - minChange\n        if (change > 0)\n            smallestChange(reversed.dropRight(change))\n\
    \        else\n            minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmd7sc5e6.scala:23)\n\tat Problem.main(tmpmd7sc5e6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        val minChange = math.min(math.ceil(n/2), math.floor(n/2))\n\
    \        val changes = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val changeIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val changeIndexMap = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap2 = mutable.HashMap.empty[Int, Int]\n      \
    \  val changeIndexMap3 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap4\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap5 = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap6 = mutable.HashMap.empty[Int, Int]\n      \
    \  val changeIndexMap7 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap8\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap9 = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap10 = mutable.HashMap.empty[Int, Int]\n     \
    \   val changeIndexMap11 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap12\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap13 = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap14 = mutable.HashMap.empty[Int, Int]\n     \
    \   val changeIndexMap15 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap16\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap17 = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap18 = mutable.HashMap.empty[Int, Int]\n     \
    \   val changeIndexMap19 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap20\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap21 = mutable.HashMap.empty[Int,\
    \ Int]\n        val changeIndexMap22 = mutable.HashMap.empty[Int, Int]\n     \
    \   val changeIndexMap23 = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap24\
    \ = mutable.HashMap.empty[Int, Int]\n        val changeIndexMap25 = mutable.HashMap.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwwy2dj8e.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpwwy2dj8e.scala:15:22 ------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwwy2dj8e.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwwy2dj8e.scala:17:22 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwwy2dj8e.scala:18:26 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchangeIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpwwy2dj8e.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mchangeIndexMap\e[0m = mutable.HashMap.empty[\e\
    [35mInt\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                         \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m          "
  stdout: ''
  timestamp: 1659805434
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.last\n        val max = (n-1)/2 // max is half the length of\
    \ the array\n        val min = n/2\n        val maxChange = arr.take(max).diff(arr.drop(max))\n\
    \        val minChange = arr.take(min).diff(arr.drop(min))\n        val maxChangeCount\
    \ = maxChange.count(x => x == m)\n        val minChangeCount = minChange.count(x\
    \ => x == m)\n        val changeCount = maxChangeCount + minChangeCount\n    \
    \    if (changeCount > max) {\n            smallestChange(arr)\n        } else\
    \ {\n            changeCount\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4ylrxu80.scala:28)\n\tat Problem.main(tmp4ylrxu80.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659805436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val arr = arr.sortWith(_ < _)\n        val changes\
    \ = arr.zip(arr.dropRight(1)).filter(_._1 != _._2).length\n        val change\
    \ = changes / 2\n        val changes = changes - change\n        val change =\
    \ change / 2\n        val changes = changes - change\n        val change = change\
    \ / 2\n        val changes = changes - change\n        val change = change / 2\n\
    \        val changes = changes - change\n        val change = change / 2\n   \
    \     val changes = changes - change\n        val change = change / 2\n      \
    \  val changes = changes - change\n        val change = change / 2\n        val\
    \ changes = changes - change\n        val change = change / 2\n        val changes\
    \ = changes - change\n        val change = change / 2\n        val changes = changes\
    \ - change\n        val change = change / 2\n        val changes = changes - change\n\
    \        val change = change / 2\n        val changes = changes - change\n   \
    \     val change = change / 2\n        val changes = changes - change\n      \
    \  val change = change / 2\n        val changes = changes - change\n        val\
    \ change = change / 2\n        val changes = changes - change\n        val change\
    \ = change / 2\n        val changes = changes - change\n        val change = change\
    \ / 2\n        val changes = changes - change\n        val change = change / 2\n\
    \        val changes = changes - change\n        val change = change / 2\n   \
    \     val changes = changes - change\n        val change = change / 2\n      \
    \  val changes = changes - change\n        val change = change / 2\n        val\
    \ changes = changes - change\n        val change = change / 2\n        val changes\
    \ = changes - change\n        val change = change / 2\n        val changes = changes\
    \ - change\n        val change = change / 2\n        val changes = changes - change\n\
    \        val change = change / 2\n        val changes = changes - change\n   \
    \     val change = change / 2\n        val changes = changes - change\n      \
    \  val change = change / 2\n        val changes = changes - change\n        val\
    \ change = change / 2\n        val changes = changes - change\n        val change\
    \ = change / 2\n        val changes = changes - change\n        val change = change\
    \ / 2\n        val changes = changes - change\n        val change = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmunrnvs4.scala:74:20 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = \n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmunrnvs4.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes - change\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmunrnvs4.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = change / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmunrnvs4.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = changes - change\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mchanges\
    \ is already defined as \e[33mvalue\e[0m \e[35mchanges\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmunrnvs4.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mchange\e[0m = change / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659805434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        var minChange = len\n        var minChangeIndex\
    \ = 0\n        val reversed = arr.reverse\n        val reversedLen = reversed.length\n\
    \        val palindromic = arr.zip(reversed).forall { case (x, y) => x == y }\n\
    \        if (palindromic) {\n            minChange = len - reversedLen\n     \
    \       minChangeIndex = reversedLen\n        }\n        minChange\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpspbsnavk.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805429
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var minChange = 0\n        while (i\
    \ < len) {\n            while (j < len) {\n                if (arr(i) != arr(j))\
    \ {\n                    minChange = min\n                    k = j\n        \
    \            while (k < len) {\n                        arr(k) = arr(k)\n    \
    \                    k += 1\n                    }\n                    arr(k)\
    \ = arr(i)\n                    i += 1\n                    j -= 1\n         \
    \       }\n                j += 1\n            }\n            i += 1\n       \
    \ }\n        minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzhg3ecwx.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805430
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexArr : List[Int] = new Array[Int](len)\n     \
    \   val minChangeIndexArrIndex = 0\n        val minChangeIndexArrIndex2 = 0\n\
    \        val minChangeIndexArrIndex3 = 0\n        val minChangeIndexArrIndex4\
    \ = 0\n        val minChangeIndexArrIndex5 = 0\n        val minChangeIndexArrIndex6\
    \ = 0\n        val minChangeIndexArrIndex7 = 0\n        val minChangeIndexArrIndex8\
    \ = 0\n        val minChangeIndexArrIndex9 = 0\n        val minChangeIndexArrIndex10\
    \ = 0\n        val minChangeIndexArrIndex11 = 0\n        val minChangeIndexArrIndex12\
    \ = 0\n        val minChangeIndexArrIndex13 = 0\n        val minChangeIndexArrIndex14\
    \ = 0\n        val minChangeIndexArrIndex15 = 0\n        val minChangeIndexArrIndex16\
    \ = 0\n        val minChangeIndexArrIndex17 = 0\n        val minChangeIndexArrIndex18\
    \ = 0\n        val minChangeIndexArrIndex19 = 0\n        val minChangeIndexArrIndex20\
    \ = 0\n        val minChangeIndexArrIndex21 = 0\n        val minChangeIndexArrIndex22\
    \ = 0\n        val minChangeIndexArrIndex23 = 0\n        val minChangeIndexArrIndex24\
    \ = 0\n        val minChangeIndexArrIndex25 = 0\n        val minChangeIndexArrIndex26\
    \ = 0\n        val minChangeIndexArrIndex27 = 0\n        val minChangeIndexArrIndex28\
    \ = 0\n        val minChangeIndexArrIndex29 = 0\n        val minChangeIndexArrIndex30\
    \ = 0\n        val minChangeIndexArrIndex31 = 0\n        val minChangeIndexArrIndex32\
    \ = 0\n        val minChangeIndexArrIndex33 = 0\n        val minChangeIndexArrIndex34\
    \ = 0\n        val minChangeIndexArrIndex35 = 0\n        val minChangeIndexArrIndex36\
    \ = 0\n        val minChangeIndexArrIndex37 = 0\n        val minChangeIndexArrIndex38\
    \ = 0\n        val minChangeIndexArrIndex39 = 0\n        val minChangeIndexArrIndex40\
    \ = 0\n        val minChangeIndexArrIndex41 = 0\n        val minChangeIndexArrIndex42\
    \ = 0\n        val minChangeIndexArrIndex43 = 0\n        val minChangeIndexArrIndex44\
    \ = 0\n        val minChangeIndexArrIndex45 = 0\n        val minChangeIndexArrIndex46\
    \ = 0\n        val minChangeIndexArrIndex47 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjqmnbjav.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjqmnbjav.scala:16:44 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexArr\e[0m :\
    \ \e[35mList\e[0m[\e[35mInt\e[0m] = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e\
    [0m](len)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    \e[1m\e\
    [31mArray\e[0m[Int]\n\e[31m   |\e[0m                                         \
    \   Required: \e[1m\e[32mList\e[0m[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpjqmnbjav.scala:64:5 ---------------------\e[0m\e\
    [0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val maxLen = len / 2\n        val minLen\
    \ = len - maxLen\n        val maxChange = arr.take(maxLen).zip(arr.drop(maxLen)).map\
    \ { case (prev, curr) => curr - prev }\n        val minChange = arr.take(minLen).zip(arr.drop(minLen)).map\
    \ { case (prev, curr) => curr - prev }\n        val minChangeMin = minChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin = minChange.min\n\
    \        val minChangeMax = minChange.max\n        val maxChangeMin = maxChange.min\n\
    \        val maxChangeMax = maxChange.max\n        val minChangeMin\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp49192b6b.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp49192b6b.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChangeMin\e[0m = minChange.min\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeMin is already defined as \e[33mvalue\e[0m \e[35mminChangeMin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp49192b6b.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxChangeMax\e[0m = maxChange.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxChangeMax is already defined as \e[33mvalue\e[0m \e[35mmaxChangeMax\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp49192b6b.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mminChangeMin\e[0m = minChange.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminChangeMin\
    \ is already defined as \e[33mvalue\e[0m \e[35mminChangeMin\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp49192b6b.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminChangeMax\e[0m = minChange.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminChangeMax is already defined as \e[33mvalue\e[0m \e[35mminChangeMax\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp49192b6b.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e"
  stdout: ''
  timestamp: 1659805436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val mid1 = mid - 1\n        val mid2 = mid\
    \ + 1\n        val mid3 = mid + 1\n        val mid4 = mid + 1\n        val mid5\
    \ = mid + 1\n        val mid6 = mid + 1\n        val mid7 = mid + 1\n        val\
    \ mid8 = mid + 1\n        val mid9 = mid + 1\n        val mid10 = mid + 1\n  \
    \      val mid11 = mid + 1\n        val mid12 = mid + 1\n        val mid13 = mid\
    \ + 1\n        val mid14 = mid + 1\n        val mid15 = mid + 1\n        val mid16\
    \ = mid + 1\n        val mid17 = mid + 1\n        val mid18 = mid + 1\n      \
    \  val mid19 = mid + 1\n        val mid20 = mid + 1\n        val mid21 = mid +\
    \ 1\n        val mid22 = mid + 1\n        val mid23 = mid + 1\n        val mid24\
    \ = mid + 1\n        val mid25 = mid + 1\n        val mid26 = mid + 1\n      \
    \  val mid27 = mid + 1\n        val mid28 = mid + 1\n        val mid29 = mid +\
    \ 1\n        val mid30 = mid + 1\n        val mid31 = mid + 1\n        val mid32\
    \ = mid + 1\n        val mid33 = mid + 1\n        val mid34 = mid + 1\n      \
    \  val mid35 = mid + 1\n        val mid36 = mid + 1\n        val mid37 = mid +\
    \ 1\n        val mid38 = mid + 1\n        val mid39 = mid + 1\n        val mid40\
    \ = mid + 1\n        val mid41 = mid + 1\n        val mid42 = mid + 1\n      \
    \  val mid43 = mid + 1\n        val mid44 = mid + 1\n        val mid45 = mid +\
    \ 1\n        val mid46 = mid + 1\n        val mid47 = mid + 1\n        val mid48\
    \ = mid + 1\n        val mid49 = mid + 1\n        val mid50 = mid + 1\n      \
    \  val mid51 = mid + 1\n        val mid52 = mid + 1\n        val mid53 = mid +\
    \ 1\n        val mid54 = mid + 1\n        val mid55 = mid + 1\n        val mid56\
    \ = mid + 1\n        val mid57 = mid + 1\n        val mid58 = mid + 1\n      \
    \  val mid59 = m\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppoxua1z8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppoxua1z8.scala:75:20 ------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        \e[33mval\e[0m \e[36mmid59\e[0m = m\n\e[31m\e\
    [31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    Not\
    \ found: m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppoxua1z8.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805437
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.head\n        val p = new Array[Long](n)\n        val d = new\
    \ Array[Long](n)\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var min = 0\n        var minIndex = 0\n        var maxIndex = 0\n     \
    \   var max = 0\n        var maxIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var minIndex = 0\n        var minIndex = 0\n        var\
    \ minIndex = 0\n        var \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpotjaw8t0.scala:113:11 --------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpotjaw8t0.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mmaxIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mmaxIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpotjaw8t0.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndex is already defined as \e[33mvariable\e[0m \e[35mminIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpotjaw8t0.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mvar\e[0m \e[36mminIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminIndex is already\
    \ defined as \e[33mvariable\e[0m \e[35mminIndex\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpotjaw8t0.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mminIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminIndex is already defined as \e[33mvariable\e[0m \e[35mminIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpotjaw8t0.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e"
  stdout: ''
  timestamp: 1659805438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var min = 0\n        var max =\
    \ 0\n        var flag = 0\n        var flag2 = 0\n        var flag3 = 0\n    \
    \    var flag4 = 0\n        var flag5 = 0\n        var flag6 = 0\n        var\
    \ flag7 = 0\n        var flag8 = 0\n        var flag9 = 0\n        var flag10\
    \ = 0\n        var flag11 = 0\n        var flag12 = 0\n        var flag13 = 0\n\
    \        var flag14 = 0\n        var flag15 = 0\n        var flag16 = 0\n    \
    \    var flag17 = 0\n        var flag18 = 0\n        var flag19 = 0\n        var\
    \ flag20 = 0\n        var flag21 = 0\n        var flag22 = 0\n        var flag23\
    \ = 0\n        var flag24 = 0\n        var flag25 = 0\n        var flag26 = 0\n\
    \        var flag27 = 0\n        var flag28 = 0\n        var flag29 = 0\n    \
    \    var flag30 = 0\n        var flag31 = 0\n        var flag32 = 0\n        var\
    \ flag33 = 0\n        var flag34 = 0\n        var flag35 = 0\n        var flag36\
    \ = 0\n        var flag37 = 0\n        var flag38 = 0\n        var flag39 = 0\n\
    \        var flag40 = 0\n        var flag41 = 0\n        var flag42 = 0\n    \
    \    var flag43 = 0\n        var flag44 = 0\n        var flag45 = 0\n        var\
    \ flag46 = 0\n        var flag47 = 0\n        var flag48 = 0\n        var flag49\
    \ = 0\n        var flag50 = 0\n        var flag51 = 0\n        var flag52 = 0\n\
    \        var flag53 = 0\n        var flag54 = 0\n        var flag55 = 0\n    \
    \    var flag56 = 0\n        var flag57 = 0\n        var flag58 = 0\n        var\
    \ flag59 = 0\n        var flag60 = 0\n        var flag61 = 0\n        var flag62\
    \ = 0\n        var flag63 = 0\n        var flag64 = 0\n        var flag65 = 0\n\
    \        var flag66 = 0\n        var flag67 = 0\n        var flag68 = 0\n    \
    \    var flag69 = 0\n        var flag70 = 0\n        var flag71 = 0\n        var\
    \ flag72 = 0\n        var flag73 = 0\n        var flag74 = 0\n        var flag75\
    \ = 0\n        var flag76 = 0\n        var flag77 = 0\n        var flag78 = 0\n\
    \        var flag79 = 0\n        var flag80 = 0\n        var flag81 = 0\n    \
    \    var flag82 = 0\n        var flag83 = 0\n        var flag84 = 0\n        var\
    \ flag85 = 0\n        var flag86 = 0\n        var flag87 = 0\n        var flag88\
    \ = 0\n        var flag89 = 0\n        var flag90 = 0\n        var flag91 = 0\n\
    \        var flag92 = 0\n        var flag93 = 0\n        var flag94 = 0\n    \
    \    var flag\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp24n0u4k1.scala:115:4 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp24n0u4k1.scala:115:5 --------------------\e[0m\e[0m\n\e[31m115 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805439
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.head\n        val result = new Array[Long](n)\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe1fry2wq.scala:115:4 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpe1fry2wq.scala:115:5 --------------------\e[0m\e[0m\n\e[31m115 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val len = arr.length\n\
    \        val arr = arr.sortBy(-_)\n        val len = arr.length\n        var i\
    \ = 0\n        var j = 0\n        var k = 0\n        var min = 0\n        var\
    \ max = 0\n        while (i < len) {\n            max = arr(i)\n            while\
    \ (j < len) {\n                if (arr(i) == arr(j)) {\n                    j++\n\
    \                }\n                else {\n                    min = arr(i)\n\
    \                    while (k < len) {\n                        if (arr(i) ==\
    \ arr(k)) {\n                            k++\n                        }\n    \
    \                    else {\n                            min = arr(i)\n      \
    \                  }\n                    }\n                    max = Math.max(max,\
    \ min)\n                }\n            }\n            min = Math.max(min, max)\n\
    \            i++\n        }\n        min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5imde77t.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp5imde77t.scala:30:31 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                            k++\n\e[31m\e[31m   |\e[0m               \
    \                ^\e[0m\n\e[31m   |\e[0m                               expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp5imde77t.scala:40:15 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m            i++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5imde77t.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5imde77t.scala:13:18 ---------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805434
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      val len = arr.length\n        var count = 0\n        var i = 0\n      \
    \  var j = len - 1\n        while (i < j) {\n            if (arr(i) != arr(j))\
    \ {\n                count += 1\n            }\n            i += 1\n         \
    \   j -= 1\n        }\n        count * 2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpukbompkv.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val result = new Array[Long](n)\n        val changes\
    \ = new Array[Long](n)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var change = 0\n        var minChange = Long.MaxValue\n        while(i\
    \ < n && j < n) {\n            val x = arr(i)\n            val y = arr(j)\n  \
    \          val xy = x * y\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = xy / m\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = xy / m\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = xy / m\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = xy / m\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = xy / m\n            val xy = xy % m\n            val xy = xy\
    \ / m\n            val xy = xy % m\n            val xy = xy / m\n            val\
    \ xy = xy % m\n            val xy = xy / m\n            val xy = xy % m\n    \
    \        val xy = x\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdm4omfeb.scala:86:0 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdm4omfeb.scala:25:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36mxy\e[0m = xy % m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxy is already defined as \e[33mvalue\e[0m \e[35mxy\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdm4omfeb.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36mxy\e[0m = xy / m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mxy is already defined as \e\
    [33mvalue\e[0m \e[35mxy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdm4omfeb.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mxy\e[0m = xy % m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mxy is already\
    \ defined as \e[33mvalue\e[0m \e[35mxy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdm4omfeb.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mxy\e[0m = xy / m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mxy is already\
    \ defined as \e[33mvalue\e[0m \e[35mxy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdm4omfeb.scala:29:16 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mxy\e[0m = xy % m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mxy is already\
    \ defined as \e[33mvalue\e[0m \e[35mxy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ t"
  stdout: ''
  timestamp: 1659805444
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        val minChangeIndex2 = -1\n        val minChangeIndex3 = -1\n \
    \       val minChangeIndex4 = -1\n        val minChangeIndex5 = -1\n        val\
    \ minChangeIndex6 = -1\n        val minChangeIndex7 = -1\n        val minChangeIndex8\
    \ = -1\n        val minChangeIndex9 = -1\n        val minChangeIndex10 = -1\n\
    \        val minChangeIndex11 = -1\n        val minChangeIndex12 = -1\n      \
    \  val minChangeIndex13 = -1\n        val minChangeIndex14 = -1\n        val minChangeIndex15\
    \ = -1\n        val minChangeIndex16 = -1\n        val minChangeIndex17 = -1\n\
    \        val minChangeIndex18 = -1\n        val minChangeIndex19 = -1\n      \
    \  val minChangeIndex20 = -1\n        val minChangeIndex21 = -1\n        val minChangeIndex22\
    \ = -1\n        val minChangeIndex23 = -1\n        val minChangeIndex24 = -1\n\
    \        val minChangeIndex25 = -1\n        val minChangeIndex26 = -1\n      \
    \  val minChangeIndex27 = -1\n        val minChangeIndex28 = -1\n        val minChangeIndex29\
    \ = -1\n        val minChangeIndex30 = -1\n        val minChangeIndex31 = -1\n\
    \        val minChangeIndex32 = -1\n        val minChangeIndex33 = -1\n      \
    \  val minChangeIndex34 = -1\n        val minChangeIndex35 = -1\n        val minChangeIndex36\
    \ = -1\n        val minChangeIndex37 = -1\n        val minChangeIndex38 = -1\n\
    \        val minChangeIndex39 = -1\n        val minChangeIndex40 = -1\n      \
    \  val minChangeIndex41 = -1\n        val minChangeIndex42 = -1\n        val minChangeIndex43\
    \ = -1\n        val minChangeIndex44 = -1\n        val minChangeIndex45 = -1\n\
    \        val minChangeIndex46 = -1\n        val minChangeIndex47 = -1\n      \
    \  val minChangeIndex48 = -1\n        val minChangeIndex49 = -1\n        val minChangeIndex50\
    \ = -1\n        val minChangeIndex51 = -1\n        val minChangeIndex52 = -1\n\
    \        val minChangeIndex53 = -1\n        val minChangeIndex54 = -1\n      \
    \  val minChangeIndex55 = -1\n        val minChangeIndex56 = -1\n        val minChangeIndex57\
    \ = -1\n        val minChangeIndex58 = -1\n        val minChangeIndex59 = -1\n\
    \        val minChangeIndex60 = -1\n        val min\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8e71qgsj.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8e71qgsj.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8e71qgsj.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        val n = arr.length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take(n/2).length\n        val m = arr.take(n/2).length\n   \
    \     val m = arr.take\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw4zca2wo.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw4zca2wo.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e\
    [33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw4zca2wo.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw4zca2wo.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mm\e[0m = arr.take(n/\e[31m2\e[0m).length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined as \e\
    [33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw4zca2wo.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.take(n/\e[31m2\e\
    [0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the sam"
  stdout: ''
  timestamp: 1659805445
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_).reverse\n\
    \        var count = 0\n        var i = 0\n        var j = 0\n        while (i\
    \ < arr.length && j < arr.length) {\n            if (arr(i) == arr(j)) {\n   \
    \             count += 1\n                i += 1\n                j += 1\n   \
    \         } else if (arr(i) < arr(j)) {\n                i += 1\n            }\
    \ else {\n                j += 1\n            }\n        }\n        count * arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpyqbq7wql.scala:12:29 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyqbq7wql.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.toSet.size // number of unique elements\n        val dp = new\
    \ Array[Long](m+1)\n        dp(0) = 1\n        for(i <- 1 to m){\n           \
    \ val dp1 = new Array[Long](n+1)\n            dp1(0) = 1\n            for(j <-\
    \ 1 to n){\n                val dp2 = new Array[Long](n+1)\n                dp2(0)\
    \ = 1\n                for(k <- 1 to n){\n                    val dp3 = new Array[Long](n+1)\n\
    \                    dp3(0) = 1\n                    for(l <- 1 to n){\n     \
    \                   val dp4 = new Array[Long](n+1)\n                        dp4(0)\
    \ = 1\n                        for(m <- 1 to n){\n                           \
    \ val dp5 = new Array[Long](n+1)\n                            dp5(0) = 1\n   \
    \                         for(p <- 1 to n){\n                                val\
    \ dp6 = new Array[Long](n+1)\n                                dp6(0) = 1\n   \
    \                             for(q <- 1 to n){\n                            \
    \        val dp7 = new Array[Long](n+1)\n                                    dp7(0)\
    \ = 1\n                                    val dp8 = new Array[Long](n+1)\n  \
    \                                  dp8(0) = 1\n                              \
    \      val dp9 = new Array[Long](n+1)\n                                    dp9(0)\
    \ = 1\n                                    val dp10 = new Array[Long](n+1)\n \
    \                                   dp10(0) = 1\n                            \
    \        val dp11 = new Array[Long](n+1)\n                                   \
    \ dp11(0) = 1\n                                    val dp12 = new Array[Long](n+1)\n\
    \                                    dp12(0) = 1\n                           \
    \         val dp13 = new Array[Long](n+1)\n                                  \
    \  dp13(0) = 1\n                                    val dp14 = new Array[Long](n+1)\n\
    \                                    dp14(0) = 1\n                           \
    \         val dp15 = new Array[Long](n+1)\n                                  \
    \  dp15(0) = 1\n                                    val dp16 = new Array[Long](n+1)\n\
    \                                    dp16(0) = 1\n                           \
    \         val dp17 = new Array[Long](n+1)\n                                  \
    \  dp17(0) = 1\n                                    val dp18 = new Array[Long](n+1)\n\
    \                                    dp18(0) = 1\n                           \
    \         val dp19 = new Array[Long](n+1)\n                                  \
    \  dp19(0) = 1\n                                    val dp20 = new Array[Long](n+1)\n\
    \                                    dp20(0) = 1\n                           \
    \         val dp21 = new Array[Long](n+1)\n                                  \
    \  dp21(0) = 1\n                                    val dp22 = new Array[Long](n+1)\n\
    \                                    dp22(0) = 1\n                           \
    \         val dp23 = new Array[Long](n+1)\n                                  \
    \  dp23(0) = 1\n                                    val dp24 = new Array\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfm1n0cek.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- Error: /tmp/tmpfm1n0cek.scala:69:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m                                    \e[33mval\e[0m \e\
    [36mdp24\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter _length of \e[33mconstructor\e[0m \e[35mArray\e[0m in\
    \ \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpfm1n0cek.scala:71:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m71 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659805442
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = -1\n        var i = 0\n        var j = 0\n        while (i < len) {\n    \
    \        val temp = arr(i)\n            val temp2 = arr(j)\n            if (temp\
    \ != temp2) {\n                minChangeIndex = i\n                minChange =\
    \ j\n            }\n            i += 1\n            j += 1\n        }\n      \
    \  minChange\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9hts4t7i.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp9hts4t7i.scala:22:31 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                minChangeIndex = i\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val minChangeIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp9hts4t7i.scala:23:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                minChange\
    \ = j\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val p = new Array[Long](n)\n        val r = new\
    \ Array[Long](n)\n        var i = 0\n        var j = 0\n        var k = 0\n  \
    \      var l = 0\n        var m1 = new Array[Long](n)\n        var m2 = new Array[Long](n)\n\
    \        var m3 = new Array[Long](n)\n        var m4 = new Array[Long](n)\n  \
    \      var m5 = new Array[Long](n)\n        var m6 = new Array[Long](n)\n    \
    \    var m7 = new Array[Long](n)\n        var m8 = new Array[Long](n)\n      \
    \  var m9 = new Array[Long](n)\n        var m10 = new Array[Long](n)\n       \
    \ var m11 = new Array[Long](n)\n        var m12 = new Array[Long](n)\n       \
    \ var m13 = new Array[Long](n)\n        var m14 = new Array[Long](n)\n       \
    \ var m15 = new Array[Long](n)\n        var m16 = new Array[Long](n)\n       \
    \ var m17 = new Array[Long](n)\n        var m18 = new Array[Long](n)\n       \
    \ var m19 = new Array[Long](n)\n        var m20 = new Array[Long](n)\n       \
    \ var m21 = new Array[Long](n)\n        var m22 = new Array[Long](n)\n       \
    \ var m23 = new Array[Long](n)\n        var m24 = new Array[Long](n)\n       \
    \ var m25 = new Array[Long](n)\n        var m26 = new Array[Long](n)\n       \
    \ var m27 = new Array[Long](n)\n        var m28 = new Array[Long](n)\n       \
    \ var m29 = new Array[Long](n)\n        var m30 = new Array[Long](n)\n       \
    \ var m31 = new Array[Long](n)\n        var m32 = new Array[Long](n)\n       \
    \ var m33 = new Array[Long](n)\n        var m34 = new Array[Long](n)\n       \
    \ var m35 = new Array[Long](n)\n        var m36 = new Array[Long](n)\n       \
    \ var m37 = new Array[Long](n)\n        var m38 = new Array[Long](n)\n       \
    \ var m39 = new Array[Long](n)\n        var m40 = new Array[Long](n)\n       \
    \ var m41 = new Array[Long](n)\n        var m42 = new Array[Long](n)\n       \
    \ var m43 = new Array[Long](n)\n        var m44 = new Array[Long](n)\n       \
    \ var m45 = new Array[Long](n)\n        var m46 = new Array[Long](n)\n       \
    \ var \n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4vo12f68.scala:66:11 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4vo12f68.scala:67:5 ---------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortWith(_\
    \ < _)\n        var i = 0\n        var j = 0\n        var k = 0\n        var min\
    \ = Long.MaxValue\n        while (i < arr.length) {\n            while (j < arr.length)\
    \ {\n                if (arr(i) == arr(j)) {\n                    j++\n      \
    \          }\n                else {\n                    k++\n              \
    \      min = Math.min(min, k - j)\n                    j = 0\n               \
    \ }\n            }\n            i += 1\n            j = 0\n            k = 0\n\
    \        }\n        min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5qlkvkpr.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp5qlkvkpr.scala:24:24\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \             min = Math.min(min, k - j)\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        end of statement expected\
    \ but '=' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5qlkvkpr.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                \
    \  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5qlkvkpr.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    k++\n\
    \e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m           \
    \         value ++ is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1659805447
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val result = new Array[Long](n)\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var min = Long.MaxValue\n\
    \        var max = 0\n        while (i < n && j < n) {\n            val a = arr(i)\n\
    \            val b = arr(j)\n            if (a > b) {\n                max +=\
    \ 1\n                val temp = arr(i)\n                arr(i) = arr(j)\n    \
    \            arr(j) = temp\n                i += 1\n                j += 1\n \
    \           } else if (a == b) {\n                k += 1\n                i +=\
    \ 1\n                j += 1\n            } else {\n                min += 1\n\
    \                val temp = arr(i)\n                arr(i) = arr(j)\n        \
    \        arr(j) = temp\n                i += 1\n                j += 1\n     \
    \       }\n        }\n        if (min == n) {\n            0\n        } else {\n\
    \            min - k\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge_iqtuq.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge_iqtuq.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpge_iqtuq.scala:37:16 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                arr(i) = arr(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge_iqtuq.scala:38:16\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                arr(j) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n4 errors found\n"
  stdout: ''
  timestamp: 1659805452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val arr = arr.toList\n        val maxCount = arr.foldLeft(0)(_ + arr.size)\n\
    \        val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n  \
    \      val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n    \
    \    val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n      \
    \  val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n        val\
    \ maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount\
    \ = maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount =\
    \ maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount = maxCount\
    \ / 2\n        val maxCount = maxCount % 2\n        val maxCount = maxCount /\
    \ 2\n        val maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n\
    \        val maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n  \
    \      val maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n    \
    \    val maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n      \
    \  val maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n        val\
    \ maxCount = maxCount % 2\n        val maxCount = maxCount / 2\n        val maxCount\
    \ = maxCount % 2\n        val maxCount = maxCount / 2\n        val maxCount =\
    \ maxCount % 2\n        val maxCount = maxCount / 2\n        val maxCount = maxCount\
    \ % 2\n        val maxCount = maxCount / 2\n        val maxCount = maxCount %\
    \ 2\n        val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n\
    \        val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n  \
    \      val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n    \
    \    val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n      \
    \  val maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n        val\
    \ maxCount = maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount\
    \ = maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount =\
    \ maxCount / 2\n        val maxCount = maxCount % 2\n        val maxCount = maxCount\
    \ / 2\n        val maxCount = maxCount % \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa6217l9a.scala:68:33 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = maxCount\
    \ % \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa6217l9a.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxCount\e[0m = maxCount / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa6217l9a.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = maxCount\
    \ % \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa6217l9a.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = maxCount / \e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxCount is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa6217l9a.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxCount\e[0m = maxCount % \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods"
  stdout: ''
  timestamp: 1659805449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val arr = arr.tail\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        val changed = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var l = 0\n        var m1 = m\n  \
    \      var m2 = m\n        var m3 = m\n        var m4 = m\n        var m5 = m\n\
    \        var m6 = m\n        var m7 = m\n        var m8 = m\n        var m9 =\
    \ m\n        var m10 = m\n        var m11 = m\n        var m12 = m\n        var\
    \ m13 = m\n        var m14 = m\n        var m15 = m\n        var m16 = m\n   \
    \     var m17 = m\n        var m18 = m\n        var m19 = m\n        var m20 =\
    \ m\n        var m21 = m\n        var m22 = m\n        var m23 = m\n        var\
    \ m24 = m\n        var m25 = m\n        var m26 = m\n        var m27 = m\n   \
    \     var m28 = m\n        var m29 = m\n        var m30 = m\n        var m31 =\
    \ m\n        var m32 = m\n        var m33 = m\n        var m34 = m\n        var\
    \ m35 = m\n        var m36 = m\n        var m37 = m\n        var m38 = m\n   \
    \     var m39 = m\n        var m40 = m\n        var m41 = m\n        var m42 =\
    \ m\n        var m43 = m\n        var m44 = m\n        var m45 = m\n        var\
    \ m46 = m\n        var m47 = m\n        var m48 = m\n        var m49 = m\n   \
    \     var m50 = m\n        var m51 = m\n        var m52 = m\n        var m53 =\
    \ m\n        var m54 = m\n        var m55 = m\n        var m56 = m\n        var\
    \ m57 = m\n        var m58 = m\n        var m59 = m\n        var m60 = m\n   \
    \     var m61 = m\n        var m62 = m\n        var m63 = m\n        var m64 =\
    \ m\n        var m65 = m\n        var m66 = m\n        var m67 = m\n        var\
    \ m68 = m\n        var m69 = m\n        var m70 = m\n        var m71 = m\n   \
    \     var m72 = m\n        var m73 = m\n        var m74 = m\n        var m75 =\
    \ m\n        var m76 = m\n        var m77 = m\n        var m78 = m\n        var\
    \ m79 = m\n        var m80 = m\n        var m81 = m\n        var m82 = m\n   \
    \     var m83 = m\n        var m84 = m\n        var m85 = m\n        var m86 =\
    \ m\n        var m87 = m\n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd9kgqmgi.scala:14:18 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd9kgqmgi.scala:15:22 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd9kgqmgi.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpd9kgqmgi.scala:109:5 --------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659805449
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n)\n        val p1 =\
    \ new Array[Long](n)\n        val p2 = new Array[Long](n)\n        val p3 = new\
    \ Array[Long](n)\n        val p4 = new Array[Long](n)\n        val p5 = new Array[Long](n)\n\
    \        val p6 = new Array[Long](n)\n        val p7 = new Array[Long](n)\n  \
    \      val p8 = new Array[Long](n)\n        val p9 = new Array[Long](n)\n    \
    \    val p10 = new Array[Long](n)\n        val p11 = new Array[Long](n)\n    \
    \    val p12 = new Array[Long](n)\n        val p13 = new Array[Long](n)\n    \
    \    val p14 = new Array[Long](n)\n        val p15 = new Array[Long](n)\n    \
    \    val p16 = new Array[Long](n)\n        val p17 = new Array[Long](n)\n    \
    \    val p18 = new Array[Long](n)\n        val p19 = new Array[Long](n)\n    \
    \    val p20 = new Array[Long](n)\n        val p21 = new Array[Long](n)\n    \
    \    val p22 = new Array[Long](n)\n        val p23 = new Array[Long](n)\n    \
    \    val p24 = new Array[Long](n)\n        val p25 = new Array[Long](n)\n    \
    \    val p26 = new Array[Long](n)\n        val p27 = new Array[Long](n)\n    \
    \    val p28 = new Array[Long](n)\n        val p29 = new Array[Long](n)\n    \
    \    val p30 = new Array[Long](n)\n        val p31 = new Array[Long](n)\n    \
    \    val p32 = new Array[Long](n)\n        val p33 = new Array[Long](n)\n    \
    \    val p34 = new Array[Long](n)\n        val p35 = new Array[Long](n)\n    \
    \    val p36 = new Array[Long](n)\n        val p37 = new Array[Long](n)\n    \
    \    val p38 = new Array[Long](n)\n        val p39 = new Array[Long](n)\n    \
    \    val p40 = new Array[Long](n)\n        val p41 = new Array[Long](n)\n    \
    \    val p42 = new Array[Long](n)\n        val p43 = new Array[Long](n)\n    \
    \    val p44 = new Array[Long](n)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpyls3mk9r.scala:59:11 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyls3mk9r.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val d = arr.min\n        val r = arr.filter(_\
    \ % 2 == 0).length\n        val s = arr.filter(_ % 2 == 1).length\n        val\
    \ t = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).length\n        val u = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).length\n        val v = arr.filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).length\n        val w = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).length\n        val x = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val y = arr.filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 0).length\n        val z = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).length\n        val a = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).length\n\
    \        val b = arr.filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).length\n        val c = arr.filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).length\n        val d = arr.filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).length\n\
    \        val e = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).length\n        val f = arr.filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 0).length\n        val g = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).filter(_\
    \ % 2 == 1).filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ % 2 == 0).\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppkfdnfj3.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppkfdnfj3.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36md\e[0m = arr.filter(_ % \e[31m2\e[0m == \e\
    [31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m ==\
    \ \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e\
    [0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).filter(_ % \e[31m2\e\
    [0m == \e[31m1\e[0m).filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppkfdnfj3.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexMap = new mutable.HashMap[Long, Int]\n      \
    \  val minChangeIndexMap2 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap3\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap4 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap5 = new mutable.HashMap[Long, Int]\n    \
    \    val minChangeIndexMap6 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap7\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap8 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap9 = new mutable.HashMap[Long, Int]\n    \
    \    val minChangeIndexMap10 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap11\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap12 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap13 = new mutable.HashMap[Long, Int]\n   \
    \     val minChangeIndexMap14 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap15\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap16 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap17 = new mutable.HashMap[Long, Int]\n   \
    \     val minChangeIndexMap18 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap19\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap20 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap21 = new mutable.HashMap[Long, Int]\n   \
    \     val minChangeIndexMap22 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap23\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap24 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap25 = new mutable.HashMap[Long, Int]\n   \
    \     val minChangeIndexMap26 = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap27\
    \ = new mutable.HashMap[Long, Int]\n        val minChangeIndexMap28 = new mutable.HashMap[Long,\
    \ Int]\n        val minChangeIndexMap29 = new mut\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptqze8cx_.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptqze8cx_.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexMap\e[0m =\
    \ \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptqze8cx_.scala:17:37 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexMap2\e[0m\
    \ = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmptqze8cx_.scala:18:37 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexMap3\e[0m\
    \ = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmptqze8cx_.scala:19:37 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexMap4\e[0m\
    \ = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                     Not found"
  stdout: ''
  timestamp: 1659805455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.size\n    \
    \    val m = arr.max\n        val d = arr.min\n        val maxChange = arr.size\
    \ - 1\n        val minChange = arr.size - 1\n        val changes = mutable.ArrayBuffer.empty[Int]\n\
    \        val changed = mutable.ArrayBuffer.empty[Int]\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var change = 0\n        var max =\
    \ 0\n        var min = 0\n        while(i < n && j < n) {\n            val a =\
    \ arr(i)\n            val b = arr(j)\n            val c = math.abs(a - b)\n  \
    \          val d = math.abs(a - d)\n            val e = math.abs(b - d)\n    \
    \        val f = math.abs(a - e)\n            val g = math.abs(b - e)\n      \
    \      val h = math.abs(a - f)\n            val i = math.abs(b - f)\n        \
    \    val j = math.abs(a - g)\n            val k = math.abs(b - g)\n          \
    \  val l = math.abs(a - h)\n            val m = math.abs(b - h)\n            val\
    \ n = math.abs(a - i)\n            val o = math.abs(b - i)\n            val p\
    \ = math.abs(a - j)\n            val q = math.abs(b - j)\n            val r =\
    \ math.abs(a - k)\n            val s = math.abs(b - k)\n            val t = math.abs(a\
    \ - l)\n            val u = math.abs(b - l)\n            val v = math.abs(a -\
    \ m)\n            val w = math.abs(b - m)\n            val x = math.abs(a - n)\n\
    \            val y = math.abs(b - n)\n            val z = math.abs(a - o)\n  \
    \          val A = math.abs(b - o)\n            val B = math.abs(a - p)\n    \
    \        val C = math.abs(b - p)\n            val D = math.abs(a - q)\n      \
    \      val E = math.abs(b - q)\n            val F = math.abs(a - r)\n        \
    \    val G = math.abs(b - r)\n            val H = math.abs(a - s)\n          \
    \  val I = math.abs(b - s)\n            val J = math.abs(a - t)\n            val\
    \ K = math.abs(b - t)\n            val L = math.abs(a - u)\n            val M\
    \ = math.abs(b - u)\n            val N = math.abs(a - v)\n            val O =\
    \ math.abs(b - v)\n            val P = math.abs(a - w)\n            val Q = math.abs(b\
    \ - w)\n            val R = math.abs(a - x)\n            val S = math.abs(b -\
    \ x)\n            val T = math.abs(a - y)\n            val U = math.abs(b - y)\n\
    \            val V = math.abs(a - z)\n            val W = math.abs(b - \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwh6fu2sg.scala:74:32 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m            \e[33mval\e[0m \e[36mW\e[0m = math.abs(b\
    \ - \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwh6fu2sg.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpwh6fu2sg.scala:17:22 ------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mval\e[0m \e[36mchanges\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwh6fu2sg.scala:18:22 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpwh6fu2sg.scala:35:29 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mj\e[0m = math.abs(a\
    \ - g)\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e\
    [0m                             Recursive \e[33mvalue\e[0m \e[35ma\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwh6fu2sg.scala:31:29\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mf\e[0m = math.abs(a - e)\n\e[31m\e[31m   |\e[0m                    \
    \         ^\e[0m\n\e[31m   |\e[0m                             Recursive \e[33mvalue\e\
    [0m \e[35ma\e[0m needs typ"
  stdout: ''
  timestamp: 1659805455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val m = arr.min\n        val changes = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < n) {\n            while\
    \ (j < n) {\n                if (arr(i) != arr(j)) {\n                    changes\
    \ += arr(i)\n                    j++\n                } else {\n             \
    \       j++\n                }\n            }\n            i += 1\n          \
    \  j = 0\n        }\n        changes.min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp750_4s_o.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp750_4s_o.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp750_4s_o.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp750_4s_o.scala:15:22\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mchanges\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805451
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      val len = arr.length\n        var count = 0\n        var i = 0\n      \
    \  var j = 0\n        var k = 0\n        while (i < len) {\n            while\
    \ (j < len) {\n                if (arr(i) == arr(j)) {\n                    count\
    \ += 1\n                    j++\n                } else {\n                  \
    \  j++\n                }\n            }\n            i += 1\n            j =\
    \ 0\n        }\n        if (count > len / 2) {\n            count\n        } else\
    \ {\n            0\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong,\
    \ 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnqd18tfh.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpnqd18tfh.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnqd18tfh.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sort\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805451
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.max\n        val p = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m1 = m\n\
    \        var m2 = m\n        var m3 = m\n        var m4 = m\n        var m5 =\
    \ m\n        var m6 = m\n        var m7 = m\n        var m8 = m\n        var m9\
    \ = m\n        var m10 = m\n        var m11 = m\n        var m12 = m\n       \
    \ var m13 = m\n        var m14 = m\n        var m15 = m\n        var m16 = m\n\
    \        var m17 = m\n        var m18 = m\n        var m19 = m\n        var m20\
    \ = m\n        var m21 = m\n        var m22 = m\n        var m23 = m\n       \
    \ var m24 = m\n        var m25 = m\n        var m26 = m\n        var m27 = m\n\
    \        var m28 = m\n        var m29 = m\n        var m30 = m\n        var m31\
    \ = m\n        var m32 = m\n        var m33 = m\n        var m34 = m\n       \
    \ var m35 = m\n        var m36 = m\n        var m37 = m\n        var m38 = m\n\
    \        var m39 = m\n        var m40 = m\n        var m41 = m\n        var m42\
    \ = m\n        var m43 = m\n        var m44 = m\n        var m45 = m\n       \
    \ var m46 = m\n        var m47 = m\n        var m48 = m\n        var m49 = m\n\
    \        var m50 = m\n        var m51 = m\n        var m52 = m\n        var m53\
    \ = m\n        var m54 = m\n        var m55 = m\n        var m56 = m\n       \
    \ var m57 = m\n        var m58 = m\n        var m59 = m\n        var m60 = m\n\
    \        var m61 = m\n        var m62 = m\n        var m63 = m\n        var m64\
    \ = m\n        var m65 = m\n        var m66 = m\n        var m67 = m\n       \
    \ var m68 = m\n        var m69 = m\n        var m70 = m\n        var m71 = m\n\
    \        var m72 = m\n        var m73 = m\n        var m74 = m\n        var m75\
    \ = m\n        var m76 = m\n        var m77 = m\n        var m78 = m\n       \
    \ var m79 = m\n        var m80 = m\n        var m81 = m\n        var m82 = m\n\
    \        var m83 = m\n        var m84 = m\n        var m85 = m\n        var m86\
    \ = m\n        var m87 = m\n        var m88 = m\n        var m89 = m\n       \
    \ var m90 = m\n        var m91 = m\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp80ycsvlu.scala:111:5\
    \ --------------------\e[0m\e[0m\n\e[31m111 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659805456
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = len\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var count = 0\n        while (i < len)\
    \ {\n            while (j < len) {\n                if (arr(i) == arr(j)) {\n\
    \                    j++\n                } else {\n                    val temp\
    \ = arr(i)\n                    arr(i) = arr(j)\n                    arr(j) =\
    \ temp\n                    j++\n                }\n            }\n          \
    \  i += 1\n            j += 1\n            k += 1\n            count += 1\n  \
    \      }\n        if (count < min) {\n            min = count\n        }\n   \
    \     min\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzz_mqywe.scala:22:23 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpzz_mqywe.scala:27:23 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzz_mqywe.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpzz_mqywe.scala:36:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            min = count\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Reassignment to val min\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805452
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val min = arr.min\n        val max = arr.max\n\
    \        val mid = len / 2\n        val mid2 = len / 2\n        val mid3 = len\
    \ / 2\n        val mid4 = len / 2\n        val mid5 = len / 2\n        val mid6\
    \ = len / 2\n        val mid7 = len / 2\n        val mid8 = len / 2\n        val\
    \ mid9 = len / 2\n        val mid10 = len / 2\n        val mid11 = len / 2\n \
    \       val mid12 = len / 2\n        val mid13 = len / 2\n        val mid14 =\
    \ len / 2\n        val mid15 = len / 2\n        val mid16 = len / 2\n        val\
    \ mid17 = len / 2\n        val mid18 = len / 2\n        val mid19 = len / 2\n\
    \        val mid20 = len / 2\n        val mid21 = len / 2\n        val mid22 =\
    \ len / 2\n        val mid23 = len / 2\n        val mid24 = len / 2\n        val\
    \ mid25 = len / 2\n        val mid26 = len / 2\n        val mid27 = len / 2\n\
    \        val mid28 = len / 2\n        val mid29 = len / 2\n        val mid30 =\
    \ len / 2\n        val mid31 = len / 2\n        val mid32 = len / 2\n        val\
    \ mid33 = len / 2\n        val mid34 = len / 2\n        val mid35 = len / 2\n\
    \        val mid36 = len / 2\n        val mid37 = len / 2\n        val mid38 =\
    \ len / 2\n        val mid39 = len / 2\n        val mid40 = len / 2\n        val\
    \ mid41 = len / 2\n        val mid42 = len / 2\n        val mid43 = len / 2\n\
    \        val mid44 = len / 2\n        val mid45 = len / 2\n        val mid46 =\
    \ len / 2\n        val mid47 = len / 2\n        val mid48 = len / 2\n        val\
    \ mid49 = len / 2\n        val mid50 = len / 2\n        val mid51 = len / 2\n\
    \        val mid52 = len / 2\n        val mid53 = len / 2\n        val mid54 =\
    \ len / 2\n        val mid55 = len / 2\n        val mid5\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoe_r_whf.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoe_r_whf.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoe_r_whf.scala:72:5\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805322
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sort\n  \
    \      val len = arr.length\n        val palindromic = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        var j = 0\n        while (i < len) {\n           \
    \ val temp = arr(i)\n            while (j < len) {\n                if (arr(j)\
    \ != temp) {\n                    break\n                }\n                j\
    \ += 1\n            }\n            if (j == len) {\n                palindromic.append(temp)\n\
    \                i += 1\n            }\n        }\n        palindromic.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmdcsag2t.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmdcsag2t.scala:14:30 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmdcsag2t.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659805454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var minChangeIndex = 0\n      \
    \  var minChangeIndex2 = 0\n        var minChangeIndex3 = 0\n        var minChangeIndex4\
    \ = 0\n        var minChangeIndex5 = 0\n        var minChangeIndex6 = 0\n    \
    \    var minChangeIndex7 = 0\n        var minChangeIndex8 = 0\n        var minChangeIndex9\
    \ = 0\n        var minChangeIndex10 = 0\n        var minChangeIndex11 = 0\n  \
    \      var minChangeIndex12 = 0\n        var minChangeIndex13 = 0\n        var\
    \ minChangeIndex14 = 0\n        var minChangeIndex15 = 0\n        var minChangeIndex16\
    \ = 0\n        var minChangeIndex17 = 0\n        var minChangeIndex18 = 0\n  \
    \      var minChangeIndex19 = 0\n        var minChangeIndex20 = 0\n        var\
    \ minChangeIndex21 = 0\n        var minChangeIndex22 = 0\n        var minChangeIndex23\
    \ = 0\n        var minChangeIndex24 = 0\n        var minChangeIndex25 = 0\n  \
    \      var minChangeIndex26 = 0\n        var minChangeIndex27 = 0\n        var\
    \ minChangeIndex28 = 0\n        var minChangeIndex29 = 0\n        var minChangeIndex30\
    \ = 0\n        var minChangeIndex31 = 0\n        var minChangeIndex32 = 0\n  \
    \      var minChangeIndex33 = 0\n        var minChangeIndex34 = 0\n        var\
    \ minChangeIndex35 = 0\n        var minChangeIndex36 = 0\n        var minChangeIndex37\
    \ = 0\n        var minChangeIndex38 = 0\n        var minChangeIndex39 = 0\n  \
    \      var minChangeIndex40 = 0\n        var minChangeIndex41 = 0\n        var\
    \ minChangeIndex42 = 0\n        var minChangeIndex43 = 0\n        var minChangeIndex44\
    \ = 0\n        var minChangeIndex45 = 0\n        var minChangeIndex46 = 0\n  \
    \      var minChangeIndex47 = 0\n        var minChangeIndex48 = 0\n        var\
    \ minChangeIndex49 = 0\n        var minChangeIndex50 = 0\n        var minChangeIndex51\
    \ = 0\n        var minChangeIndex52 = 0\n        var minChangeIndex53 = 0\n  \
    \      var minChangeIndex54 = 0\n        var minChangeIndex55 = 0\n        var\
    \ minChangeIndex56 = 0\n        var minChangeIndex57 = 0\n        var minChangeIndex58\
    \ = 0\n        var minChangeIndex59 = 0\n        var minChangeIndex60 = 0\n  \
    \      var minChangeIndex61 = 0\n        var minChangeIndex62 = 0\n        var\
    \ minChangeIndex63 = 0\n        var minChangeIndex64 = 0\n        var minChangeIndex65\
    \ = 0\n        var minChangeIndex66 = 0\n        var minChangeIndex67 = 0\n  \
    \      var minChangeIndex68 = 0\n        var minChangeIndex69 = 0\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg9ld5jht.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpg9ld5jht.scala:87:5 ---------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val m = arr.max\n        val result = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var change = 0\n        var temp2 = 0\n        var temp3 = 0\n      \
    \  var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7\
    \ = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n\
    \        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n    \
    \    var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n        var\
    \ temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var temp20\
    \ = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n\
    \        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n    \
    \    var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n        var\
    \ temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var temp33\
    \ = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n\
    \        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n    \
    \    var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n        var\
    \ temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var temp46\
    \ = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n\
    \        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n    \
    \    var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n        var\
    \ temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var temp59\
    \ = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n\
    \        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n    \
    \    var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n        var\
    \ temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var temp72\
    \ = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n\
    \        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n    \
    \    var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n        var\
    \ temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var temp85\
    \ = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n\
    \        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n    \
    \    var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6kr_p5q8.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6kr_p5q8.scala:114:5 --------------------\e\
    [0m\e[0m\n\e[31m114 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Long\n\e[31m    |\e\
    [0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659805456
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        while (i < len) {\n           \
    \ while (j < len) {\n                if (arr(i) == arr(j)) {\n               \
    \     j++\n                }\n                else {\n                    k++\n\
    \                }\n            }\n            if (k > minChange) {\n        \
    \        minChange = k\n            }\n            i += 1\n            j = 0\n\
    \            k = 0\n        }\n        minChange\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplmord_ay.scala:21:23 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmplmord_ay.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    k++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplmord_ay.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmplmord_ay.scala:28:26\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                minChange\
    \ = k\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659805453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.sortBy(_).reverse\n\
    \        var min = 0\n        var max = 0\n        var count = 0\n        var\
    \ i = 0\n        var j = 0\n        while (i < arr.length) {\n            max\
    \ = arr(i)\n            while (j < arr.length) {\n                if (arr(i) ==\
    \ arr(j)) {\n                    count += 1\n                    j++\n       \
    \         }\n                else {\n                    if (arr(i) > arr(j))\
    \ {\n                        count += 1\n                        j++\n       \
    \             }\n                    else {\n                        count +=\
    \ 1\n                        i++\n                    }\n                }\n \
    \           }\n            if (count > min) {\n                min = count\n \
    \           }\n            count = 0\n            i++\n        }\n        min\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplurrxosi.scala:23:23 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmplurrxosi.scala:28:27 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                        j++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmplurrxosi.scala:32:27 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m                        i++\n\e[31m\e[31m   |\e[0m                   \
    \        ^\e[0m\n\e[31m   |\e[0m                           expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmplurrxosi.scala:40:15 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m            i++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m  \
    \ |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmplurrxosi.scala:12:29 -----------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.sortBy(_$1).reverse.\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplurrxosi.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659805455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        val minChangeIndex\
    \ = 0\n        val minChangeIndexList = mutable.ListBuffer[Int]()\n        val\
    \ minChangeIndexList2 = mutable.ListBuffer[Int]()\n        val minChangeIndexList3\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList4 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList5 = mutable.ListBuffer[Int]()\n        val minChangeIndexList6\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList7 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList8 = mutable.ListBuffer[Int]()\n        val minChangeIndexList9\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList10 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList11 = mutable.ListBuffer[Int]()\n        val minChangeIndexList12\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList13 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList14 = mutable.ListBuffer[Int]()\n        val minChangeIndexList15\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList16 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList17 = mutable.ListBuffer[Int]()\n        val minChangeIndexList18\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList19 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList20 = mutable.ListBuffer[Int]()\n        val minChangeIndexList21\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList22 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList23 = mutable.ListBuffer[Int]()\n        val minChangeIndexList24\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList25 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList26 = mutable.ListBuffer[Int]()\n        val minChangeIndexList27\
    \ = mutable.ListBuffer[Int]()\n        val minChangeIndexList28 = mutable.ListBuffer[Int]()\n\
    \        val minChangeIndexList29 = mutable.ListBuffer[Int]()\n        val minChangeIndex\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppeo1zigj.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppeo1zigj.scala:12:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppeo1zigj.scala:16:33\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mminChangeIndexList\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppeo1zigj.scala:17:34 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexList2\e[0m\
    \ = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppeo1zigj.scala:18:34 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mminChangeIndexList3\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppeo1zigj.scala:19:34 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mminChangeIndexList4\e[0m\
    \ = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \         "
  stdout: ''
  timestamp: 1659805458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val minChange = len\n        var i = 0\n\
    \        var j = 0\n        while (i < len) {\n            val left = arr(i)\n\
    \            val right = arr(len - 1 - i)\n            if (left < right) {\n \
    \               minChange = minChange - 1\n                i = i + 1\n       \
    \     } else {\n                minChange = minChange + 1\n                j =\
    \ j + 1\n            }\n        }\n        minChange\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb33fe7yv.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpb33fe7yv.scala:21:26 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                minChange = minChange - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpb33fe7yv.scala:24:26 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                minChange = minChange + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Reassignment to val minChange\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805453
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val m = arr.length\n  \
    \      val n = arr.last\n        val dp = new Array[Long](m+1)\n        dp(0)\
    \ = 1\n        for(i<-1 to m){\n            val dp1 = new Array[Long](n+1)\n \
    \           dp1(0) = 1\n            for(j<-1 to n){\n                val dp2 =\
    \ new Array[Long](m+1)\n                dp2(0) = 1\n                for(k<-1 to\
    \ m){\n                    val dp3 = new Array[Long](n+1)\n                  \
    \  dp3(0) = 1\n                    for(l<-1 to n){\n                        val\
    \ dp4 = new Array[Long](m+1)\n                        dp4(0) = 1\n           \
    \             for(m<-1 to m){\n                            val dp5 = new Array[Long](n+1)\n\
    \                            dp5(0) = 1\n                            for(n<-1\
    \ to n){\n                                val dp6 = new Array[Long](m+1)\n   \
    \                             dp6(0) = 1\n                                for(p<-1\
    \ to m){\n                                    val dp7 = new Array[Long](n+1)\n\
    \                                    dp7(0) = 1\n                            \
    \        for(q<-1 to n){\n                                        val dp8 = new\
    \ Array[Long](m+1)\n                                        dp8(0) = 1\n     \
    \                                   for(r<-1 to n){\n                        \
    \                    val dp9 = new Array[Long](n+1)\n                        \
    \                    dp9(0) = 1\n                                            for(s<-1\
    \ to n){\n                                                val dp10 = new Array[Long](m+1)\n\
    \                                                dp10(0) = 1\n               \
    \                                 for(t<-1 to n){\n                          \
    \                          val dp11 = new Array[Long](n+1)\n                 \
    \                                   dp11(0) = 1\n                            \
    \                        for(u<-1 to n){\n                                   \
    \                     val dp12 = new Array[Long](n+1)\n                      \
    \                                  dp12(0) = 1\n                             \
    \                           for(v<-1 to n){\n                                \
    \                            val dp13 = new Array[Long](n+1)\n               \
    \                                             dp13(0) = 1\n                  \
    \                                          for(w<-1 to n){\n                 \
    \                                               val dp14 = new Array[Long](n+1)\n\
    \                                                                dp14(0) = 1\n\
    \                                                                for(x<-1 to n){\n\
    \                                                                    val dp15\
    \ = new Array[Long](n+1)\n                                                   \
    \                 dp15(0) = 1\n                                              \
    \                      for(y<-1 to n){\n                                     \
    \                                   val dp16 = new Array[Long](n+1)\n        \
    \                                                                dp16(0) = 1\n\
    \                                                                        for(z<-1\
    \ to n){\n                                                                   \
    \         val dp17 = new Array[Long](n+1)\n                                  \
    \                                          dp17(0) = 1\n                     \
    \                                                       for(a<-1 to n){\n    \
    \                                                                            val\
    \ dp18 = new Array[\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1vcsqggv.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp1vcsqggv.scala:82:0 ----------------------------\e[0m\e[0m\n\e[31m82\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vcsqggv.scala:17:38 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mdp1\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mLong\e[0m](n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                     ^^^\e[0m\n\e[31m   |\e[0m              \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1vcsqggv.scala:19:24 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m            \e[33mfor\e[0m(j<-\e[31m1\e[0m to n){\n\e[31m\e[31m   |\e\
    [0m                        ^\e[0m\n\e[31m   |\e[0m                        Found:\
    \    (n : Long)\n\e[31m   |\e[0m                        Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vcsqggv.scala:23:46 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    \e[33mval\e[0m \e[36mdp3\e[0m = \e\
    [33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n+\e[31m1\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                                              ^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    Long\n\e[31m   |\e\
    [0m                                              Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1vcsqggv.scala:25:32 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mfor\e[0m(l<-\e[31m1\e[0m to\
    \ n){\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m               "
  stdout: ''
  timestamp: 1659805459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val min = arr.head\n        val max = arr.last\n\
    \        val mid = arr.size / 2\n        val mid2 = mid / 2\n        val mid3\
    \ = mid / 3\n        val mid4 = mid / 4\n        val mid5 = mid / 5\n        val\
    \ mid6 = mid / 6\n        val mid7 = mid / 7\n        val mid8 = mid / 8\n   \
    \     val mid9 = mid / 9\n        val mid10 = mid / 10\n        val mid11 = mid\
    \ / 11\n        val mid12 = mid / 12\n        val mid13 = mid / 13\n        val\
    \ mid14 = mid / 14\n        val mid15 = mid / 15\n        val mid16 = mid / 16\n\
    \        val mid17 = mid / 17\n        val mid18 = mid / 18\n        val mid19\
    \ = mid / 19\n        val mid20 = mid / 20\n        val mid21 = mid / 21\n   \
    \     val mid22 = mid / 22\n        val mid23 = mid / 23\n        val mid24 =\
    \ mid / 24\n        val mid25 = mid / 25\n        val mid26 = mid / 26\n     \
    \   val mid27 = mid / 27\n        val mid28 = mid / 28\n        val mid29 = mid\
    \ / 29\n        val mid30 = mid / 30\n        val mid31 = mid / 31\n        val\
    \ mid32 = mid / 32\n        val mid33 = mid / 33\n        val mid34 = mid / 34\n\
    \        val mid35 = mid / 35\n        val mid36 = mid / 36\n        val mid37\
    \ = mid / 37\n        val mid38 = mid / 38\n        val mid39 = mid / 39\n   \
    \     val mid40 = mid / 40\n        val mid41 = mid / 41\n        val mid42 =\
    \ mid / 42\n        val mid43 = mid / 43\n        val mid44 = mid / 44\n     \
    \   val mid45 = mid / 45\n        val mid46 = mid / 46\n        val mid47 = mid\
    \ / 47\n        val mid48 = mid / 48\n        val mid49 = mid / 49\n        val\
    \ mid50 = mid / 50\n        val mid51 = mid / 51\n        val mid52 = mid / 52\n\
    \        val mid53 = mid / 53\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpc024mu64.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc024mu64.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpc024mu64.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659805458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n + 1)\n        val r\
    \ = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n        val\
    \ minChange = Long.MaxValue\n        val minChangeIndex = 0\n        val minChangeIndex2\
    \ = 0\n        val minChangeIndex3 = 0\n        val minChangeIndex4 = 0\n    \
    \    val minChangeIndex5 = 0\n        val minChangeIndex6 = 0\n        val minChangeIndex7\
    \ = 0\n        val minChangeIndex8 = 0\n        val minChangeIndex9 = 0\n    \
    \    val minChangeIndex10 = 0\n        val minChangeIndex11 = 0\n        val minChangeIndex12\
    \ = 0\n        val minChangeIndex13 = 0\n        val minChangeIndex14 = 0\n  \
    \      val minChangeIndex15 = 0\n        val minChangeIndex16 = 0\n        val\
    \ minChangeIndex17 = 0\n        val minChangeIndex18 = 0\n        val minChangeIndex19\
    \ = 0\n        val minChangeIndex20 = 0\n        val minChangeIndex21 = 0\n  \
    \      val minChangeIndex22 = 0\n        val minChangeIndex23 = 0\n        val\
    \ minChangeIndex24 = 0\n        val minChangeIndex25 = 0\n        val minChangeIndex26\
    \ = 0\n        val minChangeIndex27 = 0\n        val minChangeIndex28 = 0\n  \
    \      val minChangeIndex29 = 0\n        val minChangeIndex30 = 0\n        val\
    \ minChangeIndex31 = 0\n        val minChangeIndex32 = 0\n        val minChangeIndex33\
    \ = 0\n        val minChangeIndex34 = 0\n        val minChangeIndex35 = 0\n  \
    \      val minChangeIndex36 = 0\n        val minChangeIndex37 = 0\n        val\
    \ minChangeIndex38 = 0\n        val minChangeIndex39 = 0\n        val minChangeIndex40\
    \ = 0\n        val minChangeIndex41 = 0\n        val minChangeIndex42 = 0\n  \
    \      val minChangeIndex43 = 0\n        val minChangeIndex44 = 0\n        val\
    \ minChangeIndex45 = 0\n        val minChangeIndex46 = 0\n        val minChangeIndex47\
    \ = 0\n        val minChangeIndex48 = 0\n        val minChangeIndex49 = 0\n  \
    \      val minChangeIndex50 = 0\n        val minChangeIndex51 = 0\n        val\
    \ minChangeIndex52 = 0\n        val minChangeIndex53 = 0\n        val minChangeIndex54\
    \ = 0\n        val minChangeIndex55 = 0\n        val minChangeIndex56 = 0\n  \
    \      val minChangeIndex57 = 0\n        val min\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong))) == (4l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n\
    \    assert(smallestChange((List[Long](1l.toLong, 4l.toLong, 4l.toLong, 2l.toLong)))\
    \ == (1l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2ly9693c.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2ly9693c.scala:76:5 ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val p = new Array[Long](n)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var min = 0\n        var max =\
    \ 0\n        var flag = false\n        var temp = 0\n        var temp2 = 0\n \
    \       var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzheelutm.scala:115:4 ---------------------------\e\
    [0m\e[0m\n\e[31m115 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpzheelutm.scala:115:5 --------------------\e[0m\e[0m\n\e[31m115 |\e[0m\
    \    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\
    \e[31m    |\e[0m     Required: Long\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659805459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val n = arr.length\n  \
    \      val m = arr.head\n        val changes = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.ArrayBuffer.empty[Long]\n\
    \        val changed = mutable.ArrayBuffer.empty[Long]\n        val change = mutable.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_xtiljgp.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_xtiljgp.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xtiljgp.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xtiljgp.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mchanged\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchanged is already defined as \e[33mvalue\e[0m \e[35mchanged\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xtiljgp.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mchange\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mchange is already defined as \e[33mvalue\e[0m \e[35mchange\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e["
  stdout: ''
  timestamp: 1659805459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given an array arr of integers, find the minimum number of elements\
    \ that\n    // need to be changed to make the array palindromic. A palindromic\
    \ array is an array that\n    // is read the same backwards and forwards. In one\
    \ change, you can change one element to any other element.\n    // For example:\n\
    \    // smallest_change([1,2,3,5,4,7,9,6]) == 4\n    // smallest_change([1, 2,\
    \ 3, 4, 3, 2, 2]) == 1\n    // smallest_change([1, 2, 3, 2, 1]) == 0\n    def\
    \ smallestChange(arr : List[Long]) : Long = {\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val m = arr.max\n        val minChange = arr.foldLeft(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val maxChange = arr.foldRight(0)((acc,\
    \ x) => if (x == m) acc else acc + 1)\n        val change = minChange - maxChange\n\
    \        change\n    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
    \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
    \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
    \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) ==\
    \ (1l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmkbabh84.scala:12:18 ---------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659805458
