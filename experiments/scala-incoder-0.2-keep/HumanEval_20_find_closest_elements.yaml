name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> find_closest_elements([1.0, 2.0, 3.0, 4.0,\
  \ 5.0, 2.2])\n    // (2.0, 2.2)\n    // >>> find_closest_elements([1.0, 2.0, 3.0,\
  \ 4.0, 5.0, 2.0])\n    // (2.0, 2.0)\n    def findClosestElements(numbers : List[Float])\
  \ : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["        val sortedNumbers = numbers.sortWith(_ < _)\n        val smallestNumber\
    \ = sortedNumbers.head\n        val largestNumber = sortedNumbers.last\n     \
    \   (smallestNumber, largestNumber)", "        val sortedNumbers = numbers.sortWith(_\
    \ < _)\n        val closestToLeft = sortedNumbers.head\n        val closestToRight\
    \ = sortedNumbers.last\n        (closestToLeft, closestToRight)", "        val\
    \ sortedNumbers = numbers.sortWith(_ < _)\n        val smallest = sortedNumbers.head\n\
    \        val largest = sortedNumbers.last\n        (smallest, largest)", "   \
    \     val sortedNumbers = numbers.sortWith(_ < _)\n        val closestPair = sortedNumbers.zip(sortedNumbers.tail).minBy(_._1).map(_._2)\n\
    \        (closestPair._1, closestPair._2)", "        val sortedNumbers = numbers.sortBy(math.abs)\n\
    \        val firstClosestIndex = sortedNumbers.indexWhere(x => x < sortedNumbers(0))\n\
    \        val secondClosestIndex = sortedNumbers.indexWhere(x => x > sortedNumbers(0))\n\
    \        (sortedNumbers(firstClosestIndex), sortedNumbers(secondClosestIndex))",
  "        val mins = numbers.minBy(_)\n        val maxs = numbers.maxBy(_)\n    \
    \    (mins, maxs)", "        val sortedNumbers = numbers.sortWith(_ < _)\n   \
    \     val closestPair = sortedNumbers.zip(sortedNumbers.tail).find(_._1 < _._1)\n\
    \        closestPair._1.toFloat -> closestPair._2.toFloat", "        val sortedNumbers\
    \ = numbers.sortWith(_ < _)\n        val firstClosest = sortedNumbers.head\n \
    \       val secondClosest = sortedNumbers.last\n        (firstClosest, secondClosest)",
  "        val minDistance = math.abs(numbers(0) - numbers(1))\n        val minIndex\
    \ = -1\n        numbers.zipWithIndex.foreach { case (number, index) =>\n     \
    \       if (math.abs(number - numbers(index)) < minDistance) {\n             \
    \   minDistance = math.abs(number - numbers(index))\n                minIndex\
    \ = index\n            }\n        }\n        (numbers(minIndex), numbers(minIndex\
    \ + 1))", "        val sortedNumbers = numbers.sortWith(_ < _)\n        val closestTo\
    \ = sortedNumbers.zipWithIndex.filter(_._2 < sortedNumbers.size - 1).map(_._1)\n\
    \        val closestTo2 = sortedNumbers.zipWithIndex.filter(_._2 < sortedNumbers.size\
    \ - 2).map(_._1)\n        closestTo.toList match {\n            case Nil => (sortedNumbers.last,\
    \ sortedNumbers.last)\n            case x :: xs => (x._1, x._2)\n        }", " \
    \       val mins = numbers.minBy(_.abs)\n        val maxs = numbers.maxBy(_.abs)\n\
    \        (mins, maxs)", "        val sortedNumbers = numbers.sortWith(_ < _)\n\
    \        val closestPairs = sortedNumbers.sliding(2).map {\n            n => (n,\
    \ sortedNumbers.find(_ == n))\n        }.toList\n        closestPairs.sortBy(_._1).take(2)",
  "        val min1 = numbers.min\n        val min2 = numbers.min\n        val min3\
    \ = numbers.min\n        val min4 = numbers.min\n        val min5 = numbers.min\n\
    \        val min6 = numbers.min\n        val min7 = numbers.min\n        val min8\
    \ = numbers.min\n        val min9 = numbers.min\n        val min10 = numbers.min\n\
    \        val min11 = numbers.min\n        val min12 = numbers.min\n        val\
    \ min13 = numbers.min\n        val min14 = numbers.min\n        val min15 = numbers.min\n\
    \        val min16 = numbers.min\n        val min17 = numbers.min\n        val\
    \ min18 = numbers.min\n        val min19 = numbers.min\n        val min20 = numbers.min\n\
    \        val min21 = numbers.min\n        val min22 = numbers.min\n        val\
    \ min23 = numbers.min\n        val min24 = numbers.min\n        val min25 = numbers.min\n\
    \        val min26 = numbers.min\n        val min27 = numbers.min\n        val\
    \ min28 = numbers.min\n        val min29 = numbers.min\n        val min30 = numbers.min\n\
    \        val min31 = numbers.min\n        val min32 = numbers.min\n        val\
    \ min33 = numbers.min\n        val min34 = numbers.min\n        val min35 = numbers.min\n\
    \        val min36 = numbers.min\n        val min37 = numbers.min\n        val\
    \ min38 = numbers.min\n        val min39 = numbers.min\n        val min40 = numbers.min\n\
    \        val min41 = numbers.min\n        val min42 = numbers.min\n        val\
    \ min43 = numbers.min\n        val min44 = numbers.min\n        val min45 = numbers.min\n\
    \        val min46 = numbers.min\n        val min47 = numbers.min\n        val\
    \ min48 = numbers.min\n        val min49 = numbers.min\n        val min50 = numbers.min\n\
    \        val min51 = numbers.min\n        val min52 = numbers.min\n        val\
    \ min53 = numbers.min\n        val min54 = numbers.min\n        val min55 = numbers.min\n\
    \        val min56 = numbers.min\n        val min57 = numbers.min\n        val\
    \ min58 = numbers.min\n        val min59 = numbers.min\n        val min60 = numbers.min\n\
    \        val min61 = numbers.min\n        val min62 = numbers.min\n        val\
    \ min63 = numbers.min\n        val min64 = numbers.min\n        val min65 = numbers.min\n\
    \        val min66", "        val smallest = math.min(numbers)\n        val largest\
    \ = math.max(numbers)\n        (smallest, largest)", "        val smallest = math.min(numbers)\n\
    \        val largest = math.max(numbers)\n        (smallest, largest)", "    \
    \    val smallest = math.min(numbers)\n        val largest = math.max(numbers)\n\
    \        (smallest, largest)", "        val smallest = numbers.min\n        val\
    \ largest = numbers.max\n        val smallestIndex = numbers.indexOf(smallest)\n\
    \        val largestIndex = numbers.indexOf(largest)\n        (smallest, largest)",
  "        val sortedNumbers = numbers.sortWith(_ < _)\n        val smallest = sortedNumbers.head\n\
    \        val largest = sortedNumbers.last\n        (smallest, largest)", "   \
    \     val smallest = math.min(numbers)\n        val largest = math.max(numbers)\n\
    \        (smallest, largest)", "        val sortedNumbers = numbers.sortWith(_\
    \ < _)\n        val closestTo = sortedNumbers.zipWithIndex.filter(_._2 < sortedNumbers.length\
    \ / 2)\n        closestTo.sortBy(_._1).reverse"]
stop_tokens:
- "\n    }\n"
