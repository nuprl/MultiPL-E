name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    // digits(1)  == 1\n\
  \    // digits(4)  == 0\n    // digits(235) == 15\n    def digits(n : Long) : Long\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n \
    \       val odd = digits.find(_ % 2 == 1)\n        if (odd.isEmpty) 0\n      \
    \  else odd.get.product", "        val digits = mutable.ListBuffer[Long]()\n \
    \       var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer.empty[Long]\n        while(n > 0){\n            digits\
    \ += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = mutable.ArrayBuffer.empty[Long]\n        val digit =\
    \ mutable.ArrayBuffer.empty[Long]\n        val remainderDigit = mutable.ArrayBuffer.empty[Long]\n\
    \        val digitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigit\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long", "        val\
    \ digits = mutable.ListBuffer.empty[Long]\n        while(n > 0){\n           \
    \ digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(0)((acc,\
    \ x) => acc * x)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ListBuffer[Long]()\n        val\
    \ digit = n % 10\n        n /= 10\n        while (n > 0) {\n            digits\
    \ += digit\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n  \
    \      else digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        val product = mutable.Long.MaxValue\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foreach(product *= _)\n        product", "  \
    \      val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            product = product\
    \ * n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n  \
    \      else digits.reverse.foldLeft(product) { (product, digit) => product * digit\
    \ }", "        var product = 1\n        for(i <- 0 until n.toInt) {\n        \
    \    product *= n % 10\n            n /= 10\n        }\n        if(n.toInt ==\
    \ 0) product else 0", "        val digits = mutable.ListBuffer.empty[Long]\n \
    \       val digit = n.toString.reverse.dropWhile(_ == '0').drop(1)\n        val\
    \ digits = digit.reverse.dropWhile(_ == '0').drop(1)\n        digits.reverse.foldLeft(1L)\
    \ { (acc, digit) => acc * digit.toLong }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.sum", "        var result : Long = 0\n        var digits = n.toString.toList\n\
    \        while(digits.size > 0) {\n            val digit = digits(0)\n       \
    \     digits.remove(digit)\n            result *= digit\n        }\n        result",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            n /= 10\n    \
    \    }\n        digits.reverse.foldLeft(product) { (product, digit) => product\
    \ * digit }", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) 0 else product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit }",
  "        var product = 1\n        var digits = n.toString.reverse\n        for(i\
    \ <- 0 until digits.length)\n            product *= digits(i)\n        if(product\
    \ % 2 == 0)\n            0\n        else\n            product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product *= x)\n        digits.reverse.foreach(x => product /= x)\n      \
    \  product", "        val product = n.toString.toLong * n.toString.toLong\n  \
    \      val digits = n.toString.toLong / 10\n        if (digits == 0) product else\
    \ product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)(_ * _)", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        val digit = n % 10\n        n /= 10\n\
    \        while (n > 0) {\n            digits += digit\n            n /= 10\n \
    \       }\n        if (remainder == 0) {\n            digits.reverse.foldLeft(1L)(_\
    \ * _)\n        } else {\n            digits.reverse.foldLeft(0L)(_ * _)\n   \
    \     }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n \
    \       digits.foldLeft(0)((acc, x) => acc * x)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L){\
    \ (product, digit) => product * digit }\n        product % 2 == 0 ? product :\
    \ product.toLong", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.reduceLeft(_ * _)", "        val product = n.toString.toList.map(_.toInt).product\n\
    \        if (product == 0)\n            return 0\n        else\n            return\
    \ product", "        val digits = mutable.ArrayBuffer.empty[Long]\n        val\
    \ remainder = n % 10\n        val digit = n % 10\n        n /= 10\n        while\
    \ (n > 0) {\n            digits += digit\n            n /= 10\n        }\n   \
    \     if (remainder == 0) {\n            digits.toLong\n        } else {\n   \
    \         digits += remainder\n            digits.toLong\n        }", "      \
    \  val digits = mutable.ListBuffer[Long]()\n        var product = 1\n        while\
    \ (n > 0) {\n            digits += n % 10\n            product *= n % 10\n   \
    \         n /= 10\n        }\n        if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product)\
    \ { (product, digit) =>\n            product * digit\n        }", "        var\
    \ result = 1\n        var remainder = n\n        while (remainder > 0) {\n   \
    \         result *= (remainder % 10)\n            remainder /= 10\n        }\n\
    \        if (remainder == 0) {\n            result\n        } else {\n       \
    \     0\n        }", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if(digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product){_ * _}", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            product *= n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foldLeft(product){ (product, digit) =>\
    \ product * digit }", "        val digits = mutable.ListBuffer[Long]()\n     \
    \   val n = n.toInt\n        for(i <- 0 until n){\n            digits += i.toLong\n\
    \        }\n        digits.reverse.foldLeft(1L){ (product, digit) => product *\
    \ digit }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n \
    \       else digits.reverse.foldLeft(product)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        val odd = digits.filter(x => x % 2 != 0)\n        val\
    \ product = even.foldLeft(1L)(_ * _) + odd.foldLeft(0L)(_ * _)\n        product",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n\
    \        for(i <- 0 until n.toInt) {\n            val digit = n.toString.charAt(i).toLong\n\
    \            digits += digit\n            product *= digit\n        }\n      \
    \  if(digits.isEmpty) 0\n        else product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        var product = 1\n        for(i <- 0 until n.toInt) {\n            val\
    \ digit = n.toString.charAt(i).toLong\n            if(digit % 2 == 1) {\n    \
    \            digits += digit\n            }\n            else {\n            \
    \    product *= digit\n            }\n        }\n        product", "        val\
    \ digits = mutable.ListBuffer.empty[Long]\n        val remainder = n % 10\n  \
    \      n /= 10\n        while(n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        if (remainder == 0) digits.reverse.foldLeft(1L)(_\
    \ * _)\n        else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val evens = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x\
    \ => x % 2 != 0)\n        evens.foldLeft(0)(_ * _) + odds.foldLeft(0)(_ * _)",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        val remainder = n\
    \ % 10\n        n /= 10\n        digits += remainder\n        n /= 10\n      \
    \  digits += remainder\n        n /= 10\n        digits += remainder\n       \
    \ n /= 10\n        digits += remainder\n        n /= 10\n        digits += remainder\n\
    \        n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += ", "        val\
    \ digits = mutable.ListBuffer[Long]()\n        var product = 1\n        while\
    \ (n > 0){\n            digits += n % 10\n            n /= 10\n        }\n   \
    \     digits.reverse.foreach(product *= _)\n        digits.reverse.sum", "   \
    \     val digits = n.toString.reverse.grouped(2).map(_.toInt).filter(_ % 2 ==\
    \ 1).map(_ / 2)\n        digits.reduceLeft(_ * _)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product.toLong", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        var digit = n\n        while (digit > 0) {\n\
    \            digits += digit\n            product *= digit\n            digit\
    \ /= 10\n        }\n        if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product)((a,\
    \ b) => a * b)", "        val product = n.toString.toList.map(_.toInt).product\n\
    \        product % 2 == 0 ? product : product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit }",
  "        val digits = mutable.ListBuffer[Long]()\n        val remainder = n % 10\n\
    \        n /= 10\n        while(n > 0) {\n            digits.append(n % 10)\n\
    \            n /= 10\n        }\n        if (remainder == 0) {\n            digits.reverse.foldLeft(1L)(_\
    \ * _)\n        } else {\n            digits.reverse.foldLeft(0L)(_ * _)\n   \
    \     }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while(n > 0){\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product){\n\
    \            case (acc, digit) => acc * digit\n        }", "        val digits\
    \ = n.toString.toInt\n        val product = digits * digits * digits\n       \
    \ if (product % 2 == 0) product else 0", "        val product = n.toString.dropRight(n.toString.length).map(_.toInt).reduce(_\
    \ * _)\n        if (product % 2 == 0) 0 else product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit}",
  "        var product = 1\n        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        for (i <- 0 until digits.length) product *= digits(i)\n        product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            n /= 10\n    \
    \    }\n        digits.reverse.foreach(product *= _)\n        digits.sum", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)((acc,\
    \ digit) => acc * digit)", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while (n > 0){\n            digits += n % 10\n\
    \            product = product * n % 10\n            n /= 10\n        }\n    \
    \    if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ListBuffer.empty[Long]\n    \
    \    var product = 1\n        while(n > 0){\n            digits += n % 10\n  \
    \          n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val even = digits.filter(x => x % 2 == 0).length\n        val odd = digits.filter(x\
    \ => x % 2 != 0).length\n        if (even > odd) 0\n        else digits.map(x\
    \ => x * 2).reduceLeft(_ * _)", "        val product = n.toString.reverse.foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit.toLong\n        }\n        if\
    \ (product % 2 == 0) product else 0", "        var product = 1\n        var digits\
    \ = n.toString.toCharArray\n        for(i <- 0 until digits.length)\n        \
    \    product *= digits(i)\n        if(product % 2 == 0)\n            0\n     \
    \   else\n            product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product.reduceLeft(_ * _)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        val product =\
    \ n.toString.map(_.toInt).foldLeft(1L) {\n            (product, digit) => product\
    \ * digit\n        }\n        if (product % 2 == 0) 0 else product", "       \
    \ val digits = mutable.ListBuffer.empty[Long]\n        var product = 1\n     \
    \   while (n > 0) {\n            digits += n % 10\n            n /= 10\n     \
    \   }\n        digits.reverse.foreach(product *= _)\n        digits.sum", "  \
    \      val digits = mutable.ListBuffer[Long]()\n        val product = mutable.Long.MaxValue\n\
    \        val remainder = n\n        while(n > 0) {\n            val digit = n\
    \ % 10\n            digits.append(digit)\n            n /= 10\n        }\n   \
    \     digits.reverse.foreach(digit => product *= digit)\n        digits.reverse.foreach(digit\
    \ => product /= digit)\n        product * remainder", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        while(n > 0) {\n            digits += n % 10\n            n /= 10\n \
    \       }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val product =\
    \ n.toString.toList.map(_.toInt).foldLeft(1L) { (product, digit) => product *\
    \ digit }\n        if (product % 2 == 0) product else 0", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits.append(n % 10)\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product *= x)\n        digits.reverse.foreach(x => product /= x)\n      \
    \  product", "        var product = 1\n        for(i <- 1 to n.toInt){\n     \
    \       product *= i%2\n        }\n        if(product == 0){\n            return\
    \ 0\n        }\n        product", "        val digits = n.toString.toList.map(_.toInt)\n\
    \        val evens = digits.filter(x => x % 2 == 0)\n        val odds = digits.filter(x\
    \ => x % 2 != 0)\n        val product = evens.reduceLeft(_ * _)\n        if (evens.size\
    \ == 0 && odds.length == 0)\n            0\n        else if (evens.size == 0 &&\
    \ odds.length > 0)\n            0\n        else if (evens.length == 0 && odds.length\
    \ == 0)\n            product\n        else\n            product", "        val\
    \ digits = mutable.ListBuffer[Long]()\n        var product = 1\n        var digit\
    \ = 0\n        while (n > 0) {\n            digit = n % 10\n            digits.append(digit)\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while (n > 0)\
    \ {\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        digits.sum", "        val product = n.toString.reverse.foldLeft(1L)(_\
    \ * _)\n        product % 2 == 0 ? product : product", "        var result = 1\n\
    \        var remainder = n\n        while (remainder > 0) {\n            result\
    \ *= (remainder % 10)\n            remainder = remainder / 10\n        }\n   \
    \     if (remainder == 0) {\n            result\n        } else {\n          \
    \  result\n        }", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        n /= 10\n        while(n > 0) {\n   \
    \         digits += n % 10\n            n /= 10\n        }\n        if (remainder\
    \ == 0) digits.sum\n        else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product){\
    \ (product, digit) => product * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        for(i <- 0 until n.toInt) {\n            val\
    \ d = n % 10\n            digits += d\n            n /= 10\n            product\
    \ *= d\n        }\n        digits.toList.foldLeft(product)((acc, x) => acc * x)",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        val remainder = n\
    \ % 10\n        n /= 10\n        while(n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        if (remainder == 0) {\n            digits.sum\n\
    \        } else {\n            0\n        }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            product = product * n % 10\n            n /= 10\n        }\n    \
    \    if (digits.isEmpty) 0\n        else digits.head * product", "        var\
    \ product = 1\n        var digits = n.toString.reverse.grouped(2).toList\n   \
    \     digits.foreach(x => product = product * x)\n        product", "        val\
    \ digits = mutable.ListBuffer.empty[Long]\n        val product = mutable.Long.empty\n\
    \        val remainder = n % 10\n        n /= 10\n        while (n > 0) {\n  \
    \          digits += n\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product += x)\n        if (remainder == 0) {\n            product.foreach(x\
    \ => product *= x)\n        }\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val product\
    \ = n.toString.reverse.foldLeft(1L) { (product, digit) =>\n            if (digit\
    \ % 2 == 1) product * 10 + digit.toLong\n            else product\n        }\n\
    \        if (product % 2 == 0) 0\n        else product", "        val digits =\
    \ n.toString.toList.map(_.toInt)\n        digits.foldLeft(1L) { (product, digit)\
    \ => product * digit }", "        val digits = mutable.ListBuffer[Long]()\n  \
    \      var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.sum", "        val digits = n.toString.toList.map(_.toInt)\n \
    \       val odd = digits.filter(x => x % 2 != 0)\n        odd.foldLeft(0)(_ *\
    \ _)", "        var result = 1\n        var remainder = n\n        while (remainder\
    \ > 0) {\n            result *= (remainder % 10)\n            remainder /= 10\n\
    \        }\n        if (remainder == 0) {\n            result\n        } else\
    \ {\n            0\n        }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.reverse.sum", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val digit = n.toString.reverse.dropWhile(_ == '0').drop(1)\n        val\
    \ digits = digit.reverse.dropWhile(_ == '0').drop(1)\n        digits.foreach(x\
    \ => digits += x.toLong)\n        digits.sum", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.reverse.foldLeft(product)((a, b) => a * b)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     product = product * n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product) { (product, digit) => product\
    \ * digit }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0){\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n \
    \       else digits.head * product", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val product = n.toString.dropRight(1).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit.toLong\n        }\n        if\
    \ (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        var digit = n\n        while (digit > 0) {\n\
    \            digits.append(digit)\n            digit /= 10\n        }\n      \
    \  digits.reverse.foreach(x => product *= x)\n        if (digits.isEmpty) 0\n\
    \        else product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.ArrayBuffer.empty[Long]\n        while(n > 0){\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product.reduceLeft(_ * _)", "        var product = 1\n      \
    \  val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foreach(x\
    \ => product *= x)\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0){\n\
    \            digits += n % 10\n            product = product * n % 10\n      \
    \      n = n / 10\n        }\n        if(digits.isEmpty) 0\n        else digits.reduceLeft(_\
    \ * _)", "        val digits = mutable.ListBuffer.empty[Long]\n        while(n\
    \ > 0) {\n            digits += n % 10\n            n /= 10\n        }\n     \
    \   digits.reverse.foldLeft(1L)(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        var product = 1\n\
    \        var digits = n.toString.reverse\n        while(digits.length > 0) {\n\
    \            val digit = digits.head.toInt\n            digits -= digit\n    \
    \        product *= digit\n        }\n        product", "        var product =\
    \ 1\n        for(i <- 0 until n.toString.length){\n            product *= n.toString.charAt(i).toLong\n\
    \        }\n        if(product % 2 == 0){\n            return 0\n        }\n \
    \       return product", "        val digits = mutable.ListBuffer[Long]()\n  \
    \      var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        if (digits.isEmpty) 0\n        else product", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        for(i <- 0 until n.toInt) {\n            val\
    \ digit = n.toString.charAt(i).toLong\n            digits += digit\n         \
    \   product *= digit\n        }\n        if(digits.isEmpty) 0\n        else product",
  "        val product = n.toString.reverse.foldLeft(1L) { (product, digit) => product\
    \ * 10 + digit.toLong }\n        if (product % 2 == 0) product else 0", "    \
    \    val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n      \
    \  if (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val remainder = n % 10\n        n /= 10\n        digits += remainder\n\
    \        digits(0)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val n = n.toInt\n        var i = 0\n        while (i < n) {\n       \
    \     digits += n % 10\n            n /= 10\n            i += 1\n        }\n \
    \       if (digits.isEmpty) 0\n        else digits.reduceLeft(_ * _)", "     \
    \   val digits = mutable.ListBuffer[Long]()\n        val remainder = n % 10\n\
    \        n /= 10\n        while(n > 0) {\n            digits += n % 10\n     \
    \       n /= 10\n        }\n        if (remainder == 0) {\n            digits.reverse.foldLeft(1L)\
    \ { (acc, x) => acc * x }\n        } else {\n            digits.reverse.foldLeft(0L)\
    \ { (acc, x) => acc * x }\n        }", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n     \
    \   digits.sum", "        val digits = mutable.ListBuffer[Long]()\n        val\
    \ remainder = n % 10\n        n /= 10\n        while(n > 0) {\n            digits.append(n\
    \ % 10)\n            n /= 10\n        }\n        if (remainder == 0) {\n     \
    \       digits.reverse.foldLeft(1L)(_ * _)\n        } else {\n            digits.reverse.foldLeft(0L)(_\
    \ * _)\n        }", "        val digits = mutable.ArrayBuffer.empty[Long]\n  \
    \      val n = n.toInt\n        for(i <- 0 until n) {\n            digits += i.toLong\n\
    \        }\n        digits.reduceLeft(_ * _)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val i = n.toInt\n        while(i > 0) {\n            digits += i % 10\n\
    \            i /= 10\n        }\n        digits.sum", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        n /= 10\n        while(n > 0) {\n   \
    \         digits += n % 10\n            n /= 10\n        }\n        if (remainder\
    \ == 0) digits.head\n        else digits.head * 10 + remainder", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toInt)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        val odd = digits.filter(x => x % 2 != 0)\n        val\
    \ product = even.foldLeft(1L)(_ * _) + odd.foldLeft(0L)(_ * _)\n        product",
  "        val digits = mutable.ListBuffer[Long]()\n        val temp = n % 10\n  \
    \      digits.append(temp)\n        n /= 10\n        while (n > 0) {\n       \
    \     val temp = n % 10\n            digits.append(temp)\n            n /= 10\n\
    \        }\n        digits.reverse.foldLeft(1L) { (acc, digit) => acc * digit}",
  "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n    \
    \    if (product % 2 == 0) product else 0", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L){\
    \ (product, digit) =>\n            product * digit\n        }\n        if (product\
    \ % 2 == 0) 0 else product", "        var product = 1\n        var digits = n.toString.reverse.grouped(2).map(_.toInt).toList\n\
    \        digits.foreach(x => product *= x)\n        if (digits.forall(x => x %\
    \ 2 == 0)) 0 else product", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        product % 2 == 0 ? product : product.toLong", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.reduceLeft(_ *\
    \ _)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L) {\n\
    \            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) 0 else product", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while(n > 0){\n            digits += n%10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val digits = mutable.ListBuffer[Long]()\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n     \
    \   digits.reverse.foldLeft(product)((product, digit) => product * digit)", " \
    \       val product = n.toString.toList.map(_.toInt).filter(_ % 2 == 1).foldLeft(1L)(_\
    \ * _)\n        product % 10", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val product = mutable.Long(0)\n        while(n > 0){\n            digits.append(n\
    \ % 10)\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        val remainder = n % 10\n  \
    \      n /= 10\n        while(n > 0) {\n            digits += n\n            n\
    \ /= 10\n        }\n        digits.reverse.foreach(product += _)\n        product\
    \ * remainder", "        val product = n.toString.toInt\n        val digits =\
    \ n.toString.toInt\n        var productOfOddDigits = 0\n        for(i <- 0 until\
    \ digits) {\n            val digit = digits - i\n            if(digit % 2 == 1)\
    \ {\n                productOfOddDigits *= digit\n            }\n        }\n \
    \       if(productOfOddDigits == 0) {\n            return 0\n        }\n     \
    \   return product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        digits.reverse.foreach(x => product /= x)\n        product", " \
    \       val product = n.toString.toLong.dropWhile(_ == '0').drop(1).foldLeft(1L)\
    \ {\n            (product, digit) => product * digit.toLong\n        }\n     \
    \   if (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        digits.reverse.foreach(x => product /= x)\n        product", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)(_\
    \ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n  \
    \      digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits =\
    \ mutable.ListBuffer[Long]()\n        val i = math.ceil(math.log10(n))\n     \
    \   while(i >= 0) {\n            digits += math.pow(10, i)\n            i -= 1\n\
    \        }\n        digits.reduceLeft(_ * _)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) 0 else product", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        while(n > 0){\n            digits += n\
    \ % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){ (product,\
    \ digit) => product * digit}", "        val product = n.toString.toList.map(_.toInt).filter(_\
    \ % 2 == 1).reduceLeft(_ * _)\n        if (product == 0) 0 else product", "  \
    \      val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)(_\
    \ * _)", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0)\n        {\n            digits += n % 10\n      \
    \      product = product * n % 10\n            n /= 10\n        }\n        if\
    \ (digits.isEmpty)\n            return 0\n        digits.reverse.foldLeft(product)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ArrayBuffer.empty[Long]\n   \
    \     var product = 1\n        while(n > 0){\n            digits += n % 10\n \
    \           product *= n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product){\n\
    \            case (acc, digit) => acc * digit\n        }", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.ArrayBuffer.empty[Long]\n\
    \        val digit = n.toString.reverse.dropWhile(_ == '0').drop(1)\n        digits.clear()\n\
    \        digits.append(digit)\n        digits.reverse.foreach { digit =>\n   \
    \         if (digit % 2 == 1) {\n                digits.append(digit)\n      \
    \      }\n        }\n        digits.reverse.foreach { digit =>\n            if\
    \ (digit % 2 != 0) {\n                digits.append(digit)\n            }\n  \
    \      }\n        digits.reverse.foreach { digit =>\n            product += digit.toLong\n\
    \        }\n        if (digits.isEmpty) {\n            return 0\n        }\n \
    \       product.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        var result\
    \ = 1\n        for (i <- 0 until n) {\n            result *= n % 10\n        \
    \    n /= 10\n        }\n        if (n == 0) {\n            result\n        }\
    \ else {\n            0\n        }", "        var result = 1\n        for(i <-\
    \ 1 to n.toInt) {\n            result *= i\n            result %= 10\n       \
    \ }\n        result", "        val digits = mutable.ListBuffer[Long]()\n     \
    \   var product = 1\n        while (n > 0) {\n            digits.append(n % 10)\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.reverse.foldLeft(product)((a, b) => a * b)", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while (n > 0){\n\
    \            digits += n%10\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product *= x)\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)(_ * _)", "        var result : Long = 1\n        var\
    \ remainder : Long = n % 10\n        n /= 10\n        while (remainder != 0) {\n\
    \            result *= 10\n            result += (n % 10)\n            n /= 10\n\
    \            remainder /= 10\n        }\n        result", "        val digits\
    \ = n.toString.toList.map(_.toInt)\n        digits.foldLeft(1L){ (product, digit)\
    \ =>\n            if (digit%2 == 1) product * digit\n            else product\n\
    \        }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while(n > 0){\n            digits.append(n % 10)\n            n\
    \ /= 10\n        }\n        digits.reverse.foreach(x => product *= x)\n      \
    \  digits.reverse.foreach(x => product /= x)\n        product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while (n > 0){\n\
    \            digits += n % 10\n            product *= n % 10\n            n /=\
    \ 10\n        }\n        if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product){\
    \ (product, digit) => product * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        n /= 10\n        while(n > 0) {\n   \
    \         digits += n % 10\n            n /= 10\n        }\n        if (remainder\
    \ == 0) {\n            digits.sum\n        } else {\n            0\n        }",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        n /= 10\n        while(n > 0) {\n   \
    \         digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += digits)\n        product.reduceLeft(_ * _)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        var product = 1\n        var digits = n.toString.toInt\n \
    \       while(digits > 0) {\n            product *= digits\n            digits\
    \ /= 10\n        }\n        if (digits == 0) {\n            product = 0\n    \
    \    }\n        return product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.sum * product", "        var result : Long = 1\n    \
    \    var remainder : Long = n % 10\n        n /= 10\n        while (remainder\
    \ > 0) {\n            result *= 10\n            result += (n % 10)\n         \
    \   n /= 10\n            remainder -= 1\n        }\n        if (n == 0) result\n\
    \        else result", "        val digits = mutable.ListBuffer[Long]()\n    \
    \    var product = 1\n        while(n > 0) {\n            digits.append(n % 10)\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val product\
    \ = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n        product % 2 ==\
    \ 0 ? product : product.toLong", "        var product = 1\n        var digits\
    \ = n.toString.reverse.grouped(2).reverse\n        digits.foreach(x => product\
    \ *= x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while (n > 0)\
    \ {\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product *= x)\n        if (digits.isEmpty) 0\n        else product", "  \
    \      val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0){\n            digits += n % 10\n            product *= n %\
    \ 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n        else\
    \ digits.sum * product", "        val digits = mutable.ListBuffer[Long]()\n  \
    \      var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.sum", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, x) => acc * x)", "        val digits = n.toString.toList.map(_.toInt)\n\
    \        val odd = digits.filter(x => x % 2 != 0)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        odd.foldLeft(0)(_ * _) + even.foldLeft(0)(_ * _)", " \
    \       val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)(_\
    \ * _)", "        var product = 1\n        var digits = n.toString.reverse.grouped(2).map(_\
    \ + \"\").reverse\n        digits.foreach(x => product *= x.toInt)\n        product",
  "        val product = n.toString.map(_.toInt).foldLeft(1L) {\n            case\
    \ (acc, digit) => acc * digit\n        }\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foreach(x => product *= x)\n        digits.reverse.foreach(x\
    \ => product /= x)\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.sum", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        val product = digits.foldLeft(1L) { (product, digit) => product * digit\
    \ }\n        if (product % 2 == 0) product else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product)((acc, digit) => acc * digit)",
  "        var sum = 0\n        var product = 1\n        while (n > 0){\n        \
    \    sum += n % 10\n            product *= n % 10\n            n /= 10\n     \
    \   }\n        if (sum % 2 == 0)\n            0\n        else\n            product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            n /= 10\n    \
    \    }\n        digits.reverse.foreach(product *= _)\n        digits.sum", " \
    \       val digits = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n\
    \        while(n > 0){\n            digits += n % 10\n            product *= n\
    \ % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product){\
    \ (product, digit) => product * digit }", "        var product = 1\n        var\
    \ remainder = n\n        while (remainder > 0) {\n            product *= (remainder\
    \ % 10)\n            remainder = remainder / 10\n        }\n        if (remainder\
    \ == 0) {\n            product = 1\n        }\n        product", "        var\
    \ product = 1\n        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foreach(x => product *= x)\n        if (digits.forall(x => x %\
    \ 2 == 0)) 0 else product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(0)((acc, x) => acc * x)"]
stop_tokens:
- "\n    }\n"
