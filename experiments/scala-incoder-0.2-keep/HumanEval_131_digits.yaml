name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    // digits(1)  == 1\n\
  \    // digits(4)  == 0\n    // digits(235) == 15\n    def digits(n : Long) : Long\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n \
    \       val odd = digits.find(_ % 2 == 1)\n        if (odd.isEmpty) 0\n      \
    \  else odd.get.product", "        val digits = mutable.ListBuffer[Long]()\n \
    \       var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer.empty[Long]\n        while(n > 0){\n            digits\
    \ += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt).map(_.toLong)\n\
    \        digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reduceLeft(_ * _)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = mutable.ArrayBuffer.empty[Long]\n        val digit =\
    \ mutable.ArrayBuffer.empty[Long]\n        val remainderDigit = mutable.ArrayBuffer.empty[Long]\n\
    \        val digitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigit\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ productDigitCount = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val productDigitCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val productDigitCount = mutable.ArrayBuffer.empty[Long", "        val\
    \ digits = mutable.ListBuffer.empty[Long]\n        while(n > 0){\n           \
    \ digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(0)((acc,\
    \ x) => acc * x)", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)((acc, digit) => acc * digit)", "        val digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)((acc,\
    \ x) => acc * x)", "        val digits = mutable.ListBuffer[Long]()\n        val\
    \ digit = n % 10\n        n /= 10\n        while (n > 0) {\n            digits\
    \ += digit\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n  \
    \      else digits.reduceLeft(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        val product = mutable.Long.MaxValue\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foreach(product *= _)\n        product", "  \
    \      val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            product = product\
    \ * n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n  \
    \      else digits.reverse.foldLeft(product) { (product, digit) => product * digit\
    \ }", "        var product = 1\n        for(i <- 0 until n.toInt) {\n        \
    \    product *= n % 10\n            n /= 10\n        }\n        if(n.toInt ==\
    \ 0) product else 0", "        val digits = mutable.ListBuffer.empty[Long]\n \
    \       val digit = n.toString.reverse.dropWhile(_ == '0').drop(1)\n        val\
    \ digits = digit.reverse.dropWhile(_ == '0').drop(1)\n        digits.reverse.foldLeft(1L)\
    \ { (acc, digit) => acc * digit.toLong }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        digits.sum", "        var result : Long = 0\n        var digits = n.toString.toList\n\
    \        while(digits.size > 0) {\n            val digit = digits(0)\n       \
    \     digits.remove(digit)\n            result *= digit\n        }\n        result",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            n /= 10\n    \
    \    }\n        digits.reverse.foldLeft(product) { (product, digit) => product\
    \ * digit }", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) 0 else product"]
stop_tokens:
- "\n    }\n"
