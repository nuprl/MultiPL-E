name: HumanEval_108_count_nums
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function count_nums which takes an array of integers and returns\n\
  \    // the number of elements which has a sum of digits > 0.\n    // If a number\
  \ is negative, then its first signed digit will be negative:\n    // e.g. -123 has\
  \ signed digits -1, 2, and 3.\n    // >>> count_nums([]) == 0\n    // >>> count_nums([-1,\
  \ 11, -11]) == 1\n    // >>> count_nums([1, 1, 2]) == 3\n    def countNums(arr :\
  \ List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countNums((List[Long]()))\
  \ == (0l));\n    assert(countNums((List[Long](-1l.toLong, -2l.toLong, 0l.toLong)))\
  \ == (0l));\n    assert(countNums((List[Long](1l.toLong, 1l.toLong, 2l.toLong, -2l.toLong,\
  \ 3l.toLong, 4l.toLong, 5l.toLong))) == (6l));\n    assert(countNums((List[Long](1l.toLong,\
  \ 6l.toLong, 9l.toLong, -6l.toLong, 0l.toLong, 1l.toLong, 5l.toLong))) == (5l));\n\
  \    assert(countNums((List[Long](1l.toLong, 100l.toLong, 98l.toLong, -7l.toLong,\
  \ 1l.toLong, -1l.toLong))) == (4l));\n    assert(countNums((List[Long](12l.toLong,\
  \ 23l.toLong, 34l.toLong, -45l.toLong, -56l.toLong, 0l.toLong))) == (5l));\n   \
  \ assert(countNums((List[Long](0l.toLong, 1l.toLong))) == (1l));\n    assert(countNums((List[Long](1l.toLong)))\
  \ == (1l));\n    }\n\n}\n"
completions: ["        var count = 0\n        for (i <- 0 until arr.length) {\n  \
    \          val num = arr(i)\n            if (num < 0) num *= -1\n            val\
    \ digits = num.toString.toInt\n            if (digits > 0) count += digits\n \
    \       }\n        count", "        val n = arr.length\n        val sums = mutable.ArrayBuffer.empty[Long]\n\
    \        for(i <- 0 until n) {\n            val digits = arr(i).abs\n        \
    \    sums += digits\n        }\n        sums.sum", "        val nums = arr.toSet\n\
    \        val digits = arr.map(_.toString.toInt)\n        val digitSums = digits.map(_.sum)\n\
    \        val numsWithSum = nums.filter(x => digitSums.contains(x))\n        numsWithSum.size",
  "        val sums = arr.map(x => math.abs(x))\n        val nums = arr.filter(x =>\
    \ math.abs(x) > 0).size\n        sums.filter(_ > 0).sum - nums", "        val\
    \ nums = arr.map(_.toInt)\n        val sums = nums.map(x => math.abs(x))\n   \
    \     val counts = sums.groupBy(x => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n\
    \        count", "        val nums = arr.toSet\n        val sums = nums.map(x\
    \ => math.abs(x))\n        val count = sums.count(x => x > 0)\n        count",
  "        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x))\n  \
    \      val numsSums = nums.map(x => sums.filter(_ > x).length)\n        numsSums.sum",
  "        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n\
    \        val numsSums = nums.filter(_ > 0).map(_ % 10).filter(x => sums.contains(x)).length\n\
    \        numsSums", "        val nums = arr.toSet\n        val sums = arr.map(x\
    \ => math.abs(x))\n        val positiveSums = sums.filter(x => x >= 0)\n     \
    \   val negativeSums = sums.filter(x => x < 0)\n        val positiveSumsCount\
    \ = positiveSums.count(x => x > 0)\n        val negativeSumsCount = negativeSums.count(x\
    \ => x < 0)\n        val positiveSumsSum = positiveSums.sum\n        val negativeSumsSum\
    \ = negativeSums.sum\n        val positiveSumsSumAbs = math.abs(positiveSumsSum)\n\
    \        val negativeSumsSumAbs = math.abs(negativeSumsSum)\n        val positiveSumsSumAbsCount\
    \ = positiveSums.count(x => math.abs(x) > 0)\n        val negativeSumsSumAbsCount\
    \ = negativeSums.count(x => math.abs(x) < 0)\n        val positiveSumsSumAbsSum\
    \ = positiveSums.sum\n        val negativeSumsSumAbsSum = negativeSums.sum\n \
    \       val positiveSumsSumAbsSumAbs = math.abs(positiveSumsSumAbs)\n        val\
    \ negativeSumsSumAbsSumAbs = math.abs(negativeSumsSumAbs)\n        val positiveSumsSumAbsSumAbsCount\
    \ = positiveSums.count(x => math.abs(x) > 0)\n        val negativeSumsSumAbsSumAbsCount\
    \ = negativeSums.count(x => math.abs(x) < 0)\n        val positiveSumsSumAbsSumAbsSum\
    \ = positiveSums.sum\n        val negativeSumsSumAbsSumAbsSum = negativeSums.sum\n\
    \        val positiveSumsSumAbsSumAbsSumAbs = math.abs(positiveSumsSumAbsSumAbs)\n\
    \        val negativeSumsSumAbsSumAbsSumAbs = math.abs(negativeSumsSumAbsSumAbs)\n\
    \        val positiveSumsSumAbsSumAbsSumAbsCount = positiveSums.count(x => math.abs(x)\
    \ > 0)\n        val negativeSumsSumAbsSumAbsSumAbsCount = negativeSums.count(x\
    \ => math.abs(x) < 0)\n        val positiveSumsSumAbsSumAbsSumAbsSum = positiveSums.sum\n\
    \        val negativeSumsSumAbsSumAbsSumAbsSum = negativeSums.sum\n        val\
    \ positiveSumsSumAbsSumAbsSumAbsSumAbs = math.abs(positiveSumsSumAbsSumAbsSumAbs)\n\
    \        val negativeSum", "        val nums = arr.toSet\n        val sums = arr.map(x\
    \ => math.abs(x))\n        val positiveSums = sums.filter(x => x > 0)\n      \
    \  val negativeSums = sums.filter(x => x < 0)\n        val positiveSumsCount =\
    \ positiveSums.size\n        val negativeSumsCount = negativeSums.size\n     \
    \   val numsCount = nums.size\n        val positiveSumsSum = positiveSums.sum\n\
    \        val negativeSumsSum = negativeSums.sum\n        val numsSum = nums.sum\n\
    \        val positiveSumsSumOfDigits = positiveSumsSum.toString.toInt\n      \
    \  val negativeSumsSumOfDigits = negativeSumsSum.toString.toInt\n        val numsSumOfDigits\
    \ = numsSum.toString.toInt\n        val positiveSumsSumOfDigitsCount = positiveSumsSumOfDigits.toInt\n\
    \        val negativeSumsSumOfDigitsCount = negativeSumsSumOfDigits.toInt\n  \
    \      val numsSumOfDigitsCount = numsSumOfDigits.toInt\n        val positiveSumsSumOfDigitsSum\
    \ = positiveSumsSumOfDigits / numsSumOfDigits\n        val negativeSumsSumOfDigitsSum\
    \ = negativeSumsSumOfDigits / numsSumOfDigits\n        val numsSumOfDigitsSum\
    \ = numsSum / numsSumOfDigits\n        val positiveSumsSumOfDigitsSumOfDigits\
    \ = positiveSumsSumOfDigitsSum.toString.toInt\n        val negativeSumsSumOfDigitsSumOfDigits\
    \ = negativeSumsSumOfDigitsSum.toString.toInt\n        val numsSumOfDigitsSumOfDigits\
    \ = numsSumOfDigitsSum.toString.toInt\n        val positiveSumsSumOfDigitsSumOfDigitsCount\
    \ = positiveSumsSumOfDigitsSumOfDigits.toInt\n        val negativeSumsSumOfDigitsSumOfDigitsCount\
    \ = negativeSumsSumOfDigitsSumOfDigits.toInt\n        val numsSumOfDigitsSumOfDigitsCount\
    \ = numsSumOfDigitsSumOfDigits.toInt\n        val positiveSumsSumOfDigitsSumOfDigitsSum\
    \ = positiveSumsSumOfDigitsSumOfDigits / numsSumOfDigitsSumOfDigits\n        val\
    \ negativeSumsSumOfDigitsSumOfDigitsSum = negativeSumsSumOfDigitsSumOfDig", " \
    \       val nums = arr.toSet\n        val numsSum = nums.map(x => math.abs(x)).sum\n\
    \        nums.filter(x => math.abs(x) > 0).count(x => math.abs(x) == numsSum)",
  "        val nums = arr.toSet\n        val sums = arr.map(x => math.abs(x)).toSet\n\
    \        val numsSums = nums.map(x => sums.count(y => y > x))\n        numsSums.sum",
  "        val nums = arr.toSet\n        val numsCount = arr.count(x => nums.contains(x))\n\
    \        numsCount", "        val nums = arr.toSet\n        val sums = arr.map(x\
    \ => math.abs(x))\n        val counts = sums.groupBy(x => math.abs(x))\n     \
    \   val count = counts.foldLeft(0)(_ + _._2)\n        nums.filter(x => math.abs(x)\
    \ > 0).length", "        val nums = arr.map(x => math.abs(x))\n        val sums\
    \ = nums.map(x => math.abs(x)).reduceLeft(_ + _)\n        sums.toLong", "    \
    \    val sums = arr.map(x => math.abs(x))\n        val counts = sums.groupBy(x\
    \ => math.abs(x))\n        val count = counts.mapValues(_.size).sum\n        count",
  "        val nums = arr.filter(_ > 0)\n        val sums = nums.map(x => math.abs(x))\n\
    \        val counts = sums.groupBy(x => math.abs(x))\n        val maxCount = counts.maxBy(_._2)._2\n\
    \        val numsOverMaxCount = nums.filter(x => math.abs(x) > maxCount)\n   \
    \     val numsOverMaxCountSum = numsOverMaxCount.map(x => math.abs(x)).reduce(_\
    \ + _)\n        numsOverMaxCountSum", "        val nums = arr.map(x => if (x <\
    \ 0) -x else x).distinct\n        val sums = nums.map(x => math.abs(x)).sum\n\
    \        nums.count(x => sums - math.abs(x) > 0)", "        var sum = 0L\n   \
    \     var count = 0L\n        for (i <- 0 until arr.length) {\n            sum\
    \ += arr(i)\n            if (sum > 0) {\n                count += 1\n        \
    \    }\n        }\n        count", "        val nums = arr.map(_.toInt)\n    \
    \    val sum = nums.sum\n        if (sum < 0) nums.map(_.toInt).sum\n        else\
    \ nums.count(_ > 0)"]
stop_tokens:
- "\n    }\n"
