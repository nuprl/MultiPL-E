language: scala
name: HumanEval_116_sort_array
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 100000000000000000000000000000000)\n        val decillions = arr.count(_\
    \ == 10000000000000000000000000000)\n        val undecillions = arr.count(_ ==\
    \ 1000000000000000000000000000)\n        val decillions = arr.count(_ == 100000000000000000000)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000)\n        val decillions\
    \ = arr.count(_ == 1000000000000)\n        val undecillions = arr.count(_ == 100000000000)\n\
    \        val decillions = arr.count(_ == 100000000)\n        val undecillions\
    \ = arr.count(_ == 1000000000)\n        val decillions = arr.count(_ == 1000000)\n\
    \        val undecillions = arr.count(_ == 10000000)\n        val decillions =\
    \ arr.count(_ == 100000)\n        val undecillions = arr.count(_ == 100000)\n\
    \        val decillions = arr.count(_ == 10000)\n        val undecillions = arr.count(_\
    \ == 10000)\n        val decillions = arr.count(_ == 1000)\n        val undecillions\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7e91z7xo.scala:50:26 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp7e91z7xo.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecillions is already defined as \e[33mvalue\e[0m \e[35mdecillions\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7e91z7xo.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.count(_ == \e\
    [31m1000000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mundecillions is already defined as \e[33mvalue\e[0m \e[35mundecillions\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7e91z7xo.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.count(_ == \e\
    [31m100000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecillions is already defined as \e[33mvalue\e[0m \e[35mdecillions\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7e91z7xo.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.count(_ == \e\
    ["
  stdout: ''
  timestamp: 1659795186
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 1)\n        val onesArr = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val decimalsArr = arr.map(x => if (x > 1) x / 2 else\
    \ 0)\n        val sortedArr = onesArr.zip(decimalsArr).sortBy(_._1).map(x => x._2)\n\
    \        sortedArr.map(x => if (x == 0) x else x + ones)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2lqjoaiq.scala:20)\n\tat Problem.main(tmp2lqjoaiq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val hundreds = arr.filter(x\
    \ => x % 100 == 0).length\n        val thousands = arr.filter(x => x % 1000 ==\
    \ 0).length\n        val millions = arr.filter(x => x % 1000000 == 0).length\n\
    \        val billions = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ trillions = arr.filter(x => x % 1000000000000 == 0).length\n        val quadrillions\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val quintillions\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val onesAndZeros\
    \ = arr.filter(x => x % 1 == 0 && x != 0).length\n        val onesAndOnes = arr.filter(x\
    \ => x % 1 == 1 && x != 0).length\n        val twosAndZeros = arr.filter(x =>\
    \ x % 2 == 0 && x != 0).length\n        val twosAndOnes = arr.filter(x => x %\
    \ 2 == 1 && x != 0).length\n        val threesAndZeros = arr.filter(x => x % 3\
    \ == 0 && x != 0).length\n        val threesAndOnes = arr.filter(x => x % 3 ==\
    \ 1 && x != 0).length\n        val foursAndZeros = arr.filter(x => x % 4 == 0\
    \ && x != 0).length\n        val foursAndOnes = arr.filter(x => x % 4 == 1 &&\
    \ x != 0).length\n        val fivesAndZeros = arr.filter(x => x % 5 == 0 && x\
    \ != 0).length\n        val fivesAndOnes = arr.filter(x => x % 5 == 1 && x !=\
    \ 0).length\n        val sixesAndZeros = arr.filter(x => x % 6 == 0 && x != 0).length\n\
    \        val sixesAndOnes = arr.filter(x => x % 6 == 1 && x != 0).\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5xwzxq3e.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:27:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:28:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5xwzxq3e.scala:41:5 ---------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val twos = arr.filter(_ % 2 == 1).length\n        val decimals = arr.filter(_\
    \ % 10 == 0).length\n        val decimalsDecimal = arr.filter(_ % 10 == 1).length\n\
    \        val decimalsDecimalDecimal = arr.filter(_ % 10 == 2).length\n       \
    \ val decimalsDecimalDecimalDecimal = arr.filter(_ % 10 == 3).length\n       \
    \ val decimalsDecimalDecimalDecimalDecimal = arr.filter(_ % 10 == 4).length\n\
    \        val decimalsDecimalDecimalDecimalDecimalDecimal = arr.filter(_ % 10 ==\
    \ 5).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ arr.filter(_ % 10 == 6).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxw9z7o8s.scala:36:107 --------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.filter(_ % \n\e[31m\e[31m   |\e[0m                                 \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxw9z7o8s.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m8\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxw9z7o8s.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m1\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxw9z7o8s.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => (x % 2 ==\
    \ 0 ? 1 : 0))\n        val zerosArr = arr.map(x => (x % 2 == 0 ? 0 : 1))\n   \
    \     val onesCount = onesArr.count(_ == 1)\n        val zerosCount = zerosArr.count(_\
    \ == 0)\n        val onesZeros = onesArr.zip(zerosArr).count(_ == 1)\n       \
    \ val zerosOnes = zerosArr.zip(onesArr).count(_ == 0)\n        val onesZeroOnes\
    \ = onesArr.zip(zerosArr).zip(onesArr).count(_ == 1)\n        val zerosOneOnes\
    \ = zerosArr.zip(onesArr).zip(zerosArr).count(_ == 1)\n        val onesZeroZeroOnes\
    \ = onesArr.zip(zerosArr).zip(zerosArr).zip(onesArr).count(_ == 1)\n        val\
    \ zerosOneZeroOnes = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).count(_\
    \ == 1)\n        val onesZeroZeroZeroOnes = onesArr.zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(onesArr).count(_\
    \ == 1)\n        val zerosOneZeroZeroOnes = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).zip(onesArr).count(_\
    \ == 1)\n        val onesZeroZeroZeroZeroOnes = onesArr.zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(onesArr).count(_\
    \ == 1)\n        val zerosOneZeroZeroOnes = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).zip(onesArr).zip(onesArr).count(_\
    \ == 1)\n        val onesZeroZeroZeroZeroOnes = onesArr.zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(onesArr).zip(onesArr).count(_\
    \ == 1)\n        val zerosOneZeroZeroOnes = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).zip(onesArr).zip(onesArr).zip(onesArr).count(_\
    \ == 1)\n        val onesZeroZeroZeroZeroOnes = onesArr.zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(onesArr).zip(onesArr).count(_\
    \ == 1)\n\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7usfx5ge.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosOneZeroZeroOnes\e[0m\
    \ = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).zip(onesArr).zip(onesArr).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosOneZeroZeroOnes is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosOneZeroZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7usfx5ge.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroOnes\e\
    [0m = onesArr.zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(zerosArr).zip(onesArr).zip(onesArr).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroOnes is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7usfx5ge.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mzerosOneZeroZeroOnes\e[0m\
    \ = zerosArr.zip(onesArr).zip(onesArr).zip(zerosArr).zip(onesArr).zip(onesArr).zip(onesArr).count(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosOneZeroZeroOnes is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosOneZeroZeroOnes\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7usfx5ge.scala:30:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659795188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).size\n\
    \        val zeros = arr.filter(_ % 2 == 1).size\n        val decimals = arr.filter(_\
    \ % 10 == 0).size\n        val decimalsDecimal = arr.filter(_ % 10 == 1).size\n\
    \        val decimalsDecimalDecimal = arr.filter(_ % 10 == 2).size\n        val\
    \ decimalsDecimalDecimalDecimal = arr.filter(_ % 10 == 3).size\n        val decimalsDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 4).size\n        val decimalsDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 5).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 6).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 7).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 8).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 9).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 10).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 11).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 12).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 13).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 14).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 15).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 16).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 17).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 18).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 19).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 20).size\n        val decimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = arr.filter(_ % 10 == 21).size\n        val decimalsDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoqkur7lu.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoqkur7lu.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = arr.filter(_\
    \ % \e[31m10\e[0m == \e[31m8\e[0m).size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoqkur7lu.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m9\e[0m).size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoqkur7lu.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m12\e[0m).size\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[3"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(x => x ==\
    \ 1).sorted\n        val zerosArr = arr.filter(x => x == 0).sorted\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val\
    \ onesDec = onesArr.map(_.toString.toInt).sortWith(_ < _)\n        val zerosDec\
    \ = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n        val onesDec = onesArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n        val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n\
    \        val onesDec = onesArr.map(_.toString.toInt).sortWith(_ < _)\n       \
    \ val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n        val onesDec\
    \ = onesArr.map(_.toString.toInt).sortWith(_ < _)\n        val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n        val onesDec = onesArr.map(_.toString.toInt).sortWith(_ < _)\n\
    \        val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n     \
    \   val onesDec = onesArr.map(_.toString.toInt).sortWith(_ < _)\n        val zerosDec\
    \ = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n        val onesDec = onesArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n        val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n\
    \        val onesDec = onesArr.map(_.toString.toInt).sortWith(_ < _)\n       \
    \ val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_ < _)\n        val onesDec\
    \ = onesArr.map(_.toString.toInt).sortWith(_ < _)\n        val zerosDec = zerosArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n        val onesDec = onesAr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0dhopjnn.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0dhopjnn.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0dhopjnn.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0dhopjnn.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosArr.map(_.toString.toInt).sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0dhopjnn.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val onesDec = arr.map(x\
    \ => math.log10(x)).filter(x => x == 0).map(x => math.pow(10, x)).sum\n      \
    \  val zerosDec = arr.map(x => math.log10(x)).filter(x => x == 1).map(x => math.pow(10,\
    \ x)).sum\n        val onesBin = arr.map(x => math.log10(x)).filter(x => x ==\
    \ 1).map(x => math.pow(10, x)).sum\n        val zerosBin = arr.map(x => math.log10(x)).filter(x\
    \ => x == 0).map(x => math.pow(10, x)).sum\n        val onesBinDec = onesBin -\
    \ onesDec\n        val zerosBinDec = zerosBin - zerosDec\n        val onesBinBin\
    \ = onesBin + zerosBin\n        val zerosBinBin = zerosBin + onesBin\n       \
    \ val onesBinBinDec = onesBinBin - onesBinDec\n        val zerosBinBinDec = zerosBinBin\
    \ - zerosBinDec\n        val onesBinBinBin = onesBinBin + zerosBinBin\n      \
    \  val zerosBinBinBin = zerosBinBin + onesBinBin\n        val onesBinBinBinDec\
    \ = onesBinBinBin - onesBinBinDec\n        val zerosBinBinBinDec = zerosBinBinBin\
    \ - zerosBinBinDec\n        val onesBinBinBinBin = onesBinBinBin + zerosBinBinBin\n\
    \        val zerosBinBinBinBin = zerosBinBinBin + onesBinBinBin\n        val onesBinBinBinBinDec\
    \ = onesBinBinBinBin - onesBinBinBinDec\n        val zerosBinBinBinBinDec = zerosBinBinBinBin\
    \ - zerosBinBinBinDec\n        val onesBinBinBinBinBin = onesBinBinBinBin + zerosBinBinBinBin\n\
    \        val zerosBinBinBinBin = zerosBinBinBin + onesBinBinBinBin\n        val\
    \ onesBinBinBinBinDec = onesBinBinBinBinBin - onesBinBinBinBinDec\n        val\
    \ zerosBinBinBinBinDec = zerosBinBinBinBin - zerosBinBinBinBinDec\n        val\
    \ onesBinBinBinBinBin = onesBinBinBinBin + zerosBinBinBin\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv303ydn0.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosBinBinBinBin\e[0m =\
    \ zerosBinBinBin + onesBinBinBinBin\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBinBin is already defined as \e[33mvalue\e[0m \e\
    [35mzerosBinBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpv303ydn0.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesBinBinBinBinDec\e[0m\
    \ = onesBinBinBinBinBin - onesBinBinBinBinDec\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35monesBinBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpv303ydn0.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosBinBinBinBinDec\e[0m\
    \ = zerosBinBinBinBin - zerosBinBinBinBinDec\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosBinBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpv303ydn0.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesBinBinBinBinBin\e[0m\
    \ = onesBinBinBinBin + zerosBinBinBin\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinBinBinBinBin is already defined as \e[33mvalue\e[0m\
    \ \e[35monesBinBinBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e["
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val decs = arr.map(x => math.abs(x - math.floor(x)))\n        val sorted\
    \ = decs.sortBy(x => math.abs(x))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.sortBy(x => math.floor(x))\n        val sorted = sorted.sortBy(x\
    \ => math.abs(x - math.floor(x)))\n        val sorted = sorted.sortBy(x => math.floor(x))\n\
    \        val sorted = sorted.sortBy(x => math.abs(x - math.floor(x)))\n      \
    \  val sorted = sorted.\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu7edv3oz.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu7edv3oz.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(\e[36mx\e[0m\
    \ => math.floor(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu7edv3oz.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(\e[36mx\e\
    [0m => math.abs(x - math.floor(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu7edv3oz.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(\e[36mx\e\
    [0m => math.floor(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu7edv3oz.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = sorted.sortBy(\e[36mx\e\
    [0m => math.abs(x - math.floor(x)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msorted is already defined as \e[33mvalue\e[0m \e[35msorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must "
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / onesCount\n        val zerosDecimalDecimal\
    \ = zerosDecimal / zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpigr7vwpl.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpigr7vwpl.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpigr7vwpl.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpigr7vwpl.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795184
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val decimalsArr = arr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimalsArr.sortBy(x\
    \ => x)\n        val decimalsArr = decimalsArr.map(x => math.pow(2,x)).toArray\n\
    \        val decimalsArr = decimalsArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.map(x => math.pow(2,x)).toArray\n        val decimalsArr = decimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy6kwafko.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy6kwafko.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.map(\e\
    [36mx\e[0m => math.pow(\e[31m2\e[0m,x)).toArray\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy6kwafko.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy6kwafko.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.map(\e\
    [36mx\e[0m => math.pow(\e[31m2\e[0m,x)).toArray\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy6kwafko.scala:19:12 ---------------------------"
  stdout: ''
  timestamp: 1659795188
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val thousand_thousands = arr.map(x => if\
    \ (x == 10000000000000000000) 10000000000000000000 else 0)\n        val million_millions\
    \ = arr.map(x => if (x == 1000000000000000000000) 100000000000000000000000 else\
    \ 0)\n        val billion_billions = arr.map(x => if (x == 1000000000000000000000000)\
    \ 10000000000000000000000000 else 0)\n        val trillion_trillions = arr.map(x\
    \ => if (x == 1000000000000000000000000000) 1000000000000000000000000000 else\
    \ 0)\n        val quadrillion_quadrillions = arr.map(x => if (x == 1000000000000000000000000000000)\
    \ 10000000000000000000000000000000 else 0)\n        val quintillion_quintillions\
    \ = arr.map(x => if (x == 1000000000000000000000000000000000) 1000000000000000000000000000000000\
    \ else 0)\n        val thousand_millions = arr.map(x => if (x == 1000000000000000000000000000000000)\
    \ 1000000000000000000000000000000000 else \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpcss9yxco.scala:37:129 --------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mthousand_millions\e[0m =\
    \ arr.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000000000000000000000000\e\
    [0m) \e[31m1000000000000000000000000000000000\e[0m \e[33melse\e[0m \n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpcss9yxco.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpcss9yxco.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpcss9yxco.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpcss9yxco.scala:29:67\
    \ ---------------------------------------"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(x => x ==\
    \ 1).sorted\n        val zerosArr = arr.filter(x => x == 0).sorted\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val\
    \ onesSumDecimal = onesSum / onesCount\n        val zerosSumDecimal = zerosSum\
    \ / zerosCount\n        val onesSumDecimalDecimal = onesSumDecimal / onesCount\n\
    \        val zerosSumDecimalDecimal = zerosSumDecimal / zerosCount\n        val\
    \ onesSumDecimalDecimalDecimal = onesSumDecimalDecimal / onesCount\n        val\
    \ zerosSumDecimalDecimalDecimal = zerosSumDecimalDecimal / zerosCount\n      \
    \  val onesSumDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimal / onesCount\n\
    \        val zerosSumDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimal = onesSumDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosSumDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n   \
    \     val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosSumDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuhd35v9l.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuhd35v9l.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal /\
    \ onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesSumDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuhd35v9l.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosSumDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosSumDecimalDecimalDecimalDecimalDecimalDecimalDecim"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.size\n        val\
    \ twos_count = twos.size\n        val threes_count = threes.size\n        val\
    \ fours_count = fours.size\n        val fives_count = fives.size\n        val\
    \ sixes_count = sixes.size\n        val sevens_count = sevens.size\n        val\
    \ eights_count = eights.size\n        val nines_count = nines.size\n        val\
    \ tens_count = tens.size\n        val hundreds_count = hundreds.size\n       \
    \ val thousands_count = thousands.size\n        val ten_thousands_count = ten_thousands.size\n\
    \        val hundred_thousands_count = hundred_thousands.size\n        val millions_count\
    \ = millions.size\n        val billions_count = billions.size\n        val trillions_count\
    \ = trillions.size\n        val quadrilli\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9q9irzo.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpn9q9irzo.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = ones / arr.length\n \
    \       val zerosDec = zeros / arr.length\n        val onesBin = ones.toBinaryString\n\
    \        val zerosBin = zeros.toBinaryString\n        val onesBinLen = onesBin.length\n\
    \        val zerosBinLen = zerosBin.length\n        val onesBinArray = onesBin.toArray\n\
    \        val zerosBinArray = zerosBin.toArray\n        val onesBinArrayLen = onesBinArray.length\n\
    \        val zerosBinArrayLen = zerosBinArray.length\n        val onesBinArrayCopy\
    \ = onesBinArray.clone()\n        val zerosBinArrayCopy = zerosBinArray.clone()\n\
    \        val onesBinArrayCopyLen = onesBinArrayCopy.length\n        val zerosBinArrayCopyLen\
    \ = zerosBinArrayCopy.length\n        val onesBinArrayCopyCopy = onesBinArrayCopy.clone()\n\
    \        val zerosBinArrayCopyCopy = zerosBinArrayCopy.clone()\n        val onesBinArrayCopyCopyLen\
    \ = onesBinArrayCopyCopy.length\n        val zerosBinArrayCopyCopyLen = zerosBinArrayCopyCopy.length\n\
    \        val onesBinArrayCopyCopyCopy = onesBinArrayCopyCopy.clone()\n       \
    \ val zerosBinArrayCopyCopy = zerosBinArrayCopyCopy.clone()\n        val onesBinArrayCopyCopyLen\
    \ = onesBinArrayCopyCopy.length\n        val zerosBinArrayCopyCopyLen = zerosBinArrayCopyCopy.length\n\
    \        val onesBinArrayCopyCopyCopy = onesBinArrayCopyCopy.clone()\n       \
    \ val zerosBinArrayCopyCopy = zerosBinArrayCopyCopy.clone()\n        val onesBinArrayCopyCopyLen\
    \ = onesBinArrayCopyCopy.length\n        val zerosBinArrayCopyCopyLen = zerosBinArrayCopyCopy.length\n\
    \        val onesBinArrayCopyCopyCopy = onesBinArrayCopyCopy.clone()\n       \
    \ val zerosBinArrayCopyCopy = zerosBinArrayCopyCopy.clone()\n        val onesBinArrayCopyCopyLen\
    \ = onesBinArrayCopyCopy.length\n        val zerosBinArrayCopyCopyLen = zerosBinArrayCopyCopy.length\n\
    \        val onesBinArrayCopyCopyCopy = onesBinArrayCopyCopy.clone()\n       \
    \ val zerosBinArrayCopyCopy = zerosBinArrayCopyCopy.clone()\n        val onesBinArrayCopyCopyLen\
    \ = onesBin\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpka4w3pit.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosBinArrayCopyCopy\e\
    [0m = zerosBinArrayCopyCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mzerosBinArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpka4w3pit.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesBinArrayCopyCopyLen\e\
    [0m = onesBinArrayCopyCopy.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinArrayCopyCopyLen is already defined as \e[33mvalue\e\
    [0m \e[35monesBinArrayCopyCopyLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpka4w3pit.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosBinArrayCopyCopyLen\e\
    [0m = zerosBinArrayCopyCopy.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinArrayCopyCopyLen is already defined as \e[33mvalue\e\
    [0m \e[35mzerosBinArrayCopyCopyLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpka4w3pit.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36monesBinArrayCopyCopyCopy\e\
    [0m = onesBinArrayCopyCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinArrayCopyCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35monesBinArrayCopyCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 100000000000000000000)\n        val\
    \ septillions = arr.count(_ == 10000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 100000000000000000000000000)\n        val decillions = arr.count(_ == 10000000000000000000000000000)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000000L)\n\
    \        val decillions = arr.count(_ == 100000000000000000000000000000000L)\n\
    \        val undecillions = arr.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5825a_cd.scala:36:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000000000000L\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                             number too large\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5825a_cd.scala:37:0 ----------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.count(_ == \e[31m100000000000000000000000000000000L\e\
    [0m)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m')' expected, but 'end of\
    \ statement' found\n\e[31m\e[31m-- Error: /tmp/tmp5825a_cd.scala:37:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.count(_\
    \ == \e[31m100000000000000000000000000000000L\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                        number too large\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5825a_cd.scala:38:0 ----------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.count(_ == \e[31m1000000000000000000000000000000000L\e\
    [0m)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m')' expected, but 'end of\
    \ statement' found\n\e[31m\e[31m-- Error: /tmp/tmp5825a_cd.scala:38:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000000000000L\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                             number too large\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5825a_cd.scala:39:0 ----------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.count(_ == \e[31m100000000000000000000000000000000L\e\
    [0m)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m')' expected, but 'end of\
    \ statement' found\n\e[31m\e[31m-- Error: /tmp/tmp5825a_cd.scala:39:40 -----------------------------------------\e\
    [0"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val hundreds = arr.filter(x\
    \ => x % 100 == 0).length\n        val thousands = arr.filter(x => x % 1000 ==\
    \ 0).length\n        val ten_thousands = arr.filter(x => x % 10000 == 0).length\n\
    \        val hundred_thousands = arr.filter(x => x % 100000 == 0).length\n   \
    \     val millions = arr.filter(x => x % 1000000 == 0).length\n        val billions\
    \ = arr.filter(x => x % 10000000 == 0).length\n        val trillions = arr.filter(x\
    \ => x % 100000000 == 0).length\n        val quadrillions = arr.filter(x => x\
    \ % 1000000000 == 0).length\n        val quintillions = arr.filter(x => x % 10000000000\
    \ == 0).length\n        val sextillions = arr.filter(x => x % 1000000000000 ==\
    \ 0).length\n        val septillions = arr.filter(x => x % 10000000000000 == 0).length\n\
    \        val octillions = arr.filter(x => x % 100000000000000 == 0).length\n \
    \       val nonillions = arr.filter(x => x % 1000000000000000 == 0).length\n \
    \       val decillions = arr.filter(x => x % 10000000000000000 == 0).length\n\
    \        val undecillions = arr.filter(x => x % 100000000000000000 == 0).length\n\
    \        val decillion_and_more = arr.filter(x => x % 1000000000000000000 == 0).length\n\
    \        val undecillion_and_more = arr.filter(x => x % 10000000000000000000 ==\
    \ 0).length\n        val decillion_and_more_and_more = arr.filter(x => x % 100000000000000000000\
    \ == 0).length\n        val undecillion_and_more_and_more = arr.filter(x => x\
    \ % 1000000000000000000000\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5kokmzbl.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp5kokmzbl.scala:30:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                        number too large\n\e[31m\e[31m-- Error: /tmp/tmp5kokmzbl.scala:31:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m31 |\e[0m       \
    \ \e[33mval\e[0m \e[36msextillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                        number too large\n\e[31m\e[31m-- Error: /tmp/tmp5kokmzbl.scala:32:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m32 |\e[0m       \
    \ \e[33mval\e[0m \e[36mseptillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m10000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                   ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmp5kokmzbl.scala:33:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \ \e[33mval\e[0m \e[36moctillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m100000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        number too large\n\e[31m\e[31m-- Error: /tmp/tmp5kokmzbl.scala:34:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m34 |\e[0m       \
    \ \e[33mval\e[0m \e[36mnonillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                  ^^^^^^^^"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val decs = arr.filter(x => x == 0).map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val result = decs.zip(ones).sortBy(_._1).reverse.map(x => x._2)\n   \
    \     result.map(x => x + ones)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp93fm8zca.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortBy(_._1).reverse.map(\e[36mx\e[0m => x._2)\n\e[31m\e\
    [31m   |\e[0m                              ^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Found:    (ones : Int)\n\e[31m   |\e[0m               \
    \               Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp93fm8zca.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        result.map(\e[36mx\e[0m => x + ones)\n\e[31m\e\
    [31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of Nothing, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.properties AsScalaMap\n\e[31m\
    \   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n\
    \        val onesArraySorted = onesArray.sortBy(x => x)\n        val zerosArraySorted\
    \ = zerosArray.sortBy(x => x)\n        val onesArraySortedWithZeros = onesArraySorted.zip(zerosArraySorted)\n\
    \        val zerosArraySortedWithOnes = zerosArraySorted.zip(onesArraySorted)\n\
    \        val onesArraySortedWithOnes = onesArraySortedWithZeros.zip(zerosArraySortedWithOnes)\n\
    \        val zerosArraySortedWithZeros = zerosArraySortedWithOnes.zip(onesArraySortedWithZeros)\n\
    \        val sortedArray = onesArraySortedWithZeros.toList ++ zerosArraySortedWithOnes.toList\
    \ ++ onesArraySortedWithOnes.toList ++ zerosArraySortedWithZeros.toList\n    \
    \    sortedArray\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiqjg1r25.scala:23:8\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m        sortedArray\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Found:    (sortedArray\
    \ : List[(Int | (Int, Int), Int | (Int, Int))])\n\e[31m   |\e[0m    Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toSet.size\n        val zerosCount = zeros.toSet.size\n   \
    \     val onesZeros = ones.toSet.intersect(zeros.toSet)\n        val onesZeroCount\
    \ = onesZeros.size\n        val onesZeroSum = onesZeros.foldLeft(0)(_ + _)\n \
    \       val onesZeroAvg = (onesZeroSum / onesZeroCount)\n        val onesZeroMax\
    \ = onesZeros.max\n        val onesZeroMin = onesZeros.min\n        val zerosCount\
    \ = zeros.toSet.size\n        val zerosSum = zeros.foldLeft(0)(_ + _)\n      \
    \  val zerosAvg = (zerosSum / zerosCount)\n        val zerosMax = zeros.max\n\
    \        val zerosMin = zeros.min\n        val onesCount = ones.toSet.size\n \
    \       val onesSum = ones.foldLeft(0)(_ + _)\n        val onesAvg = (onesSum\
    \ / onesCount)\n        val onesMax = ones.max\n        val onesMin = ones.min\n\
    \        val onesZeroCount = onesZeros.size\n        val onesZeroSum = onesZeros.foldLeft(0)(_\
    \ + _)\n        val onesZeroAvg = (onesZeroSum / onesZeroCount)\n        val onesZeroMax\
    \ = onesZeros.max\n        val onesZeroMin = onesZeros.min\n        val zerosCount\
    \ = zeros.toSet.size\n        val zerosSum = zeros.foldLeft(0)(_ + _)\n      \
    \  val zerosAvg = (zerosSum / zerosCount)\n        val zerosMax = zeros.max\n\
    \        val zerosMin = zeros.min\n        val onesCount = ones.toSet.size\n \
    \       val onesSum = ones.foldLeft(0)(_ + _)\n        val onesAvg = (onesSum\
    \ / onesCount)\n        val onesMax = ones.max\n        val onesMin = ones.min\n\
    \        val onesZeroCount = onesZeros.size\n        val onesZeroSum = onesZeros.foldLeft(0)(_\
    \ + _)\n        val onesZeroAvg = (onesZeroSum / onesZero\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp06za1e4.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp06za1e4.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosCount\e[0m = zeros.toSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCount is already defined as \e[33mvalue\e[0m \e[35mzerosCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp06za1e4.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36monesCount\e[0m = ones.toSet.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesCount is already defined as \e[33mvalue\e[0m \e[35monesCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp06za1e4.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZeroCount\e[0m = onesZeros.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesZeroCount\
    \ is already defined as \e[33mvalue\e[0m \e[35monesZeroCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp06za1e4.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroSum\e[0m = onesZeros.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeroSum is already defined as \e[33mvalue\e[0m \e[35monesZeroSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp06za1e4.scala:34:12 ---------------"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesBin = arr.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val zerosBin = arr.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val onesBinDec = onesBin.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinDec = zerosBin.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesBinBin = onesBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val zerosBinBin = zerosBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val onesBinBinDec = onesBinBin.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinDec = zerosBinBin.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesBinBinBin = onesBinBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val zerosBinBinBin = zerosBinBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val onesBinBinBinDec = onesBinBinBin.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinBinDec = zerosBinBinBin.map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val onesBinBinBinBin = onesBinBinBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val zerosBinBinBin = zerosBinBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\"\
    \")\n        val onesBinBinBinDec = onesBinBinBin.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinBinDec = zerosBinBinBin.map(_.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5hbdh1km.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5hbdh1km.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosBinBinBin\e[0m = zerosBinBin.map(_.toString.toInt).map(Integer.toBinaryString(_)).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBin is already defined as \e[33mvalue\e[0m \e[35mzerosBinBinBin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5hbdh1km.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36monesBinBinBinDec\e[0m = onesBinBinBin.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinBinBinDec is already defined as \e[33mvalue\e[0m \e\
    [35monesBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5hbdh1km.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mzerosBinBinBinDec\e[0m =\
    \ zerosBinBinBin.map(_.to\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBinDec is already defined as \e[33mvalue\e[0m \e\
    [35mzerosBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5hbdh1km.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val hundreds = arr.filter(x\
    \ => x % 100 == 0).length\n        val thousands = arr.filter(x => x % 1000 ==\
    \ 0).length\n        val millions = arr.filter(x => x % 1000000 == 0).length\n\
    \        val billions = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ trillions = arr.filter(x => x % 1000000000000 == 0).length\n        val quadrillions\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val quintillions\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val onesAndZeros\
    \ = arr.filter(x => x % 1 == 0).length\n        val onesAndOnes = arr.filter(x\
    \ => x % 1 == 1).length\n        val twosAndZeros = arr.filter(x => x % 2 == 0).length\n\
    \        val twosAndOnes = arr.filter(x => x % 2 == 1).length\n        val threesAndZeros\
    \ = arr.filter(x => x % 3 == 0).length\n        val threesAndOnes = arr.filter(x\
    \ => x % 3 == 1).length\n        val foursAndZeros = arr.filter(x => x % 4 ==\
    \ 0).length\n        val foursAndOnes = arr.filter(x => x % 4 == 1).length\n \
    \       val fivesAndZeros = arr.filter(x => x % 5 == 0).length\n        val fivesAndOnes\
    \ = arr.filter(x => x % 5 == 1).length\n        val sixesAndZeros = arr.filter(x\
    \ => x % 6 == 0).length\n        val sixesAndOnes = arr.filter(x => x % 6 == 1).length\n\
    \        val sevensAndZeros = arr.filter(x => x % 7 == 0).length\n        val\
    \ sevensAndOnes = arr.filter(x => x % 7 == 1).\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_h3gknqw.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp_h3gknqw.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmp_h3gknqw.scala:27:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmp_h3gknqw.scala:28:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp_h3gknqw.scala:43:5 ---------------------\e[0m\e[0m\n\
    \e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val twos = arr.count(x => x == 2)\n        val threes = arr.count(x =>\
    \ x == 3)\n        val fours = arr.count(x => x == 4)\n        val fives = arr.count(x\
    \ => x == 5)\n        val sixes = arr.count(x => x == 6)\n        val sevens =\
    \ arr.count(x => x == 7)\n        val eights = arr.count(x => x == 8)\n      \
    \  val nines = arr.count(x => x == 9)\n        val tens = arr.count(x => x ==\
    \ 10)\n        val hundreds = arr.count(x => x == 100)\n        val thousands\
    \ = arr.count(x => x == 1000)\n        val millions = arr.count(x => x == 1000000)\n\
    \        val billions = arr.count(x => x == 1000000000)\n        val trillions\
    \ = arr.count(x => x == 1000000000000)\n        val quadrillions = arr.count(x\
    \ => x == 1000000000000000)\n        val quintillions = arr.count(x => x == 1000000000000000000)\n\
    \        val onesAndZeroes = arr.count(x => x == 1)\n        val onesAndOnes =\
    \ arr.count(x => x == 1 && x != 0)\n        val onesAndTwos = arr.count(x => x\
    \ == 1 && x != 0 && x != 1)\n        val onesAndThrees = arr.count(x => x == 1\
    \ && x != 0 && x != 1 && x != 2)\n        val onesAndFours = arr.count(x => x\
    \ == 1 && x != 0 && x != 1 && x != 2 && x != 3)\n        val onesAndFives = arr.count(x\
    \ => x == 1 && x != 0 && x != 1 && x != 2 && x != 3 && x != 4)\n        val onesAndSixes\
    \ = arr.count(x => x == 1 && x != 0 && x != 1 && x != 2 && x != 3 && x != 4 &&\
    \ x != 5)\n        val onesAndSevens = arr.count(x => x == 1 && x != 0 && x !=\
    \ 1 && x != 2 && x != 3 && x != 4 && x != 5 && x != 6)\n        val onesAndEights\
    \ = arr.count(x => x == 1 && x != 0 && x != 1 && x != 2 && x != 3 && x != 4 &&\
    \ x != 5 && x != 6 && x != 7)\n        val onesAndNines = arr.count(x => x ==\
    \ 1 && x != 0 && x != 1 && x != 2 && x != 3 && x != 4 && x != 5 && x != 6 && x\
    \ != 7 && x != 8)\n        val onesAndTens = arr.count(x => x == 1 && \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpviarsdd8.scala:39:50 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36monesAndTens\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1\e[0m && \n\e[31m\e[31m   |\e[0m                   \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpviarsdd8.scala:26:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpviarsdd8.scala:27:47 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpviarsdd8.scala:28:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpviarsdd8.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => (x % 2)\
    \ == 0).sorted\n        val zerosArr = arr.map(x => (x % 2) == 1).sorted\n   \
    \     val onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n\
    \        val onesSum = onesArr.foldLeft(0L)(_ + _)\n        val zerosSum = zerosArr.foldLeft(0L)(_\
    \ + _)\n        val onesSumArr = onesArr.map(x => (x - onesSum) / 2)\n       \
    \ val zerosSumArr = zerosArr.map(x => (x - zerosSum) / 2)\n        val onesSumCount\
    \ = onesArr.length\n        val zerosSumCount = zerosArr.length\n        val onesSumArr\
    \ = onesArr.map(x => (x - onesSum) / 2)\n        val zerosSumArr = zerosArr.map(x\
    \ => (x - zerosSum) / 2)\n        val onesSumCount = onesArr.length\n        val\
    \ zerosSumCount = zerosArr.length\n        val onesSumArr = onesArr.map(x => (x\
    \ - onesSum) / 2)\n        val zerosSumArr = zerosArr.map(x => (x - zerosSum)\
    \ / 2)\n        val onesSumCount = onesArr.length\n        val zerosSumCount =\
    \ zerosArr.length\n        val onesSumArr = onesArr.map(x => (x - onesSum) / 2)\n\
    \        val zerosSumArr = zerosArr.map(x => (x - zerosSum) / 2)\n        val\
    \ onesSumCount = onesArr.length\n        val zerosSumCount = zerosArr.length\n\
    \        val onesSumArr = onesArr.map(x => (x - onesSum) / 2)\n        val zerosSumArr\
    \ = zerosArr.map(x => (x - zerosSum) / 2)\n        val onesSumCount = onesArr.length\n\
    \        val zerosSumCount = zerosArr.length\n        val onesSumArr = onesArr.map(x\
    \ => (x - onesSum) / 2)\n        val zerosSumArr = zerosArr.map(x => (x - zerosSum)\
    \ / 2)\n        val onesSumCount = onesArr.length\n        val zerosSumCount =\
    \ zerosArr.length\n        val onesSumArr = onesArr.map(x => (x - onesSum) / 2)\n\
    \        val zerosSumArr = zerosArr.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl9b3ela7.scala:45:39 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mzerosSumArr\e[0m = zerosArr.map(\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl9b3ela7.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSumArr\e[0m = onesArr.map(\e[36mx\e[0m => (x - onesSum) / \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumArr is already defined as \e[33mvalue\e[0m \e[35monesSumArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl9b3ela7.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosSumArr\e[0m = zerosArr.map(\e[36mx\e\
    [0m => (x - zerosSum) / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumArr is already defined as \e[33mvalue\e[0m \e[35mzerosSumArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl9b3ela7.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesSumCount\e[0m = onesArr.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0monesSumCount is already defined as \e[33mvalue\e[0m \e[35monesSumCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl9b3ela7.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosSumCount\e[0m = zerosArr.length\n\
    \e[31m\e[31m   |\e[0m        ^^^"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = ones / arr.length\n \
    \       val zerosDec = zeros / arr.length\n        val onesBin = ones % arr.length\n\
    \        val zerosBin = zeros % arr.length\n        val onesBins = onesBin.toString.reverse\n\
    \        val zerosBins = zerosBin.toString.reverse\n        val onesBinsArr =\
    \ onesBins.toList\n        val zerosBinsArr = zerosBins.toList\n        val onesBinsArr2\
    \ = onesBinsArr.zip(zerosBinsArr).map { case (a, b) => a -> b }.toMap\n      \
    \  val zerosBinsArr2 = zerosBinsArr.zip(onesBinsArr).map { case (a, b) => a ->\
    \ b }.toMap\n        val onesBinsArr3 = onesBinsArr2.toSeq.sortBy(_._1).map(x\
    \ => x._2)\n        val zerosBinsArr3 = zerosBinsArr2.toSeq.sortBy(_._1).map(x\
    \ => x._2)\n        val onesBinsArr4 = onesBinsArr3.zip(zerosBinsArr3).map { case\
    \ (a, b) => a -> b }.toMap\n        val zerosBinsArr4 = zerosBinsArr3.zip(onesBinsArr3).map\
    \ { case (a, b) => a -> b }.toMap\n        val onesBinsArr5 = onesBinsArr4.zip(zerosBinsArr4).map\
    \ { case (a, b) => a -> b }.toMap\n        val zerosBinsArr5 = zerosBinsArr4.zip(onesBinsArr4).map\
    \ { case (a, b) => a -> b }.toMap\n        val onesBinsArr6 = onesBinsArr5.zip(zerosBinsArr5).map\
    \ { case (a, b) => a -> b }.toMap\n        val zerosBinsArr6 = zerosBinsArr5.zip(onesBinsArr5).map\
    \ { case (a, b) => a -> b }.toMap\n        val onesBinsArr7 = onesBinsArr6.zip(zerosBinsArr6).map\
    \ { case (a, b) => a -> b }.toMap\n        val zerosBinsArr7 = zerosBinsArr6.zip(onesBinsArr6).map\
    \ { case (a, b) => a -> b }.toMap\n        val onesBinsArr8 = onesBinsArr7.zip(zerosBinsArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8_x78qj.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpa8_x78qj.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = ones /\
    \ onesCount\n        val zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n      \
    \  val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpou3i_2b5.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal / zerosCount\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpou3i_2b5.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpou3i_2b5.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the sa"
  stdout: ''
  timestamp: 1659795197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decs = arr.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toInt)\n\
    \        val result = decs.zip(ones).sortBy(_._1).map(x => x._2)\n        result.map(x\
    \ => x + arr(0))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5sj6sprb.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            Found:    (ones : Int)\n\e[31m   |\e[0m                         \
    \     Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp5sj6sprb.scala:15:26 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        result.map(\e[36mx\e[0m => x + arr(\e[31m0\e[0m))\n\e[31m\e[31m   |\e\
    [0m                        ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => math.pow(2,\
    \ x))\n        val zerosDec = arr.map(x => math.pow(2, -x))\n        val onesDec.zip(zerosDec).sortBy(x\
    \ => x._1 - x._2).map(x => x._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpixhufz7l.scala:16:33 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m onesDec.zip(zerosDec).sortBy(x\
    \ => x._1 - x._2).map(x => x._1)\n\e[31m\e[31m   |\e[0m                      \
    \           ^\e[0m\n\e[31m   |\e[0m                                 '=' expected,\
    \ but '.' found\n\e[31m\e[31m-- [E127] Syntax Error: /tmp/tmpixhufz7l.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ onesDec.zip(zerosDec).sortBy(x => x._1 - x._2).map(x => x._1)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesDec.zip cannot be used\
    \ as an extractor in a pattern because it lacks an unapply or unapplySeq method\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpixhufz7l.scala:17:5\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprc0o5pv6.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprc0o5pv6.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmprc0o5pv6.scala:28:68 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprc0o5pv6.scala:29:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m                                    "
  stdout: ''
  timestamp: 1659795198
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val decs = arr.filter(x => x % 2 == 1).length\n        val\
    \ sorted = arr.sortBy(x => if (x % 2 == 0) ones else decs)\n        sorted.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9rd_gctp.scala:18)\n\tat Problem.main(tmp9rd_gctp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val onesArr = arr.filter(x\
    \ => x == 1).map(x => x.toBinaryString).sorted\n        val zerosArr = arr.filter(x\
    \ => x == 0).map(x => x.toBinaryString).sorted\n        val onesArr = onesArr.map(x\
    \ => x.toInt)\n        val zerosArr = zerosArr.map(x => x.toInt)\n        val\
    \ onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.map(x => x.toLong)\n        val zerosArr\
    \ = zerosArr.map(x => x.toLong)\n        val onesArr = onesArr.sortWith(_ < _)\n\
    \        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.map(x\
    \ => x.toInt)\n        val zerosArr = zerosArr.map(x => x.toInt)\n        val\
    \ onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.map(x => x.toLong)\n        val zerosArr\
    \ = zerosArr.map(x => x.toLong)\n        val onesArr = onesArr.sortWith(_ < _)\n\
    \        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.map(x\
    \ => x.toInt)\n        val zerosArr = zerosArr.map(x => x.toInt)\n        val\
    \ onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.map(x => x.toLong)\n        val zerosArr\
    \ = zerosArr.map(x => x.toLong)\n        val onesArr = onesArr.sortWith(_ < _)\n\
    \        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.map(x\
    \ => x.toInt)\n        val zerosArr = zerosArr.map(x => x.toInt)\n        val\
    \ onesArr = onesArr.sortWith(_ < _\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi7j1xypa.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi7j1xypa.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArr\e[0m = onesArr.map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesArr\
    \ is already defined as \e[33mvalue\e[0m \e[35monesArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi7j1xypa.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArr\e[0m = zerosArr.map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mzerosArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi7j1xypa.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArr\e[0m = onesArr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi7j1xypa.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi7j1xypa.scala:20:12 --------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.count(_ == 1)\n        val zerosCount = zeros.count(_ == 0)\n\
    \        val onesZeros = ones.zip(zeros).filter(_._1 == _._2)\n        val onesZeroCount\
    \ = onesZeros.count(_._1 == 1)\n        val onesZeroZeros = onesZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroCount = onesZeroZeros.count(_._1 == 1)\n    \
    \    val onesZeroZeroZeros = onesZeroZeros.filter(_._1 == 0)\n        val onesZeroZeroZeroCount\
    \ = onesZeroZeroZeros.count(_._1 == 1)\n        val onesZeroZeroZeroZeros = onesZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroCount = onesZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeros = onesZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == 1)\n        val onesZeroZeroZeroZeroZeroZeroZeros = onesZeroZeroZeroZeroZeroZeros.filter(_._1\
    \ == 0)\n        val onesZeroZeroZeroZeroZeroCount = onesZeroZeroZeroZeroZeros.count(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxmm2vvr1.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmm2vvr1.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroZeroZeroZeroZeroCount\e[0m = onesZeroZeroZeroZeroZeros.count(_._1\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmm2vvr1.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroZeros\e\
    [0m = onesZeroZeroZeroZeroZeros.filter(_._1 == \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroZeros is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmm2vvr1.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesZeroZeroZeroZeroZeroCount\e\
    [0m = onesZeroZeroZeroZeroZeros.count(_._1 == \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroZeroZeroZeroZeroCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroZeroZeroZeroZeroCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxmm2vvr1.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mo"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).size\n        val twos = arr.filter(x => x % 2 == 1).size\n        val threes\
    \ = arr.filter(x => x % 3 == 0).size\n        val fours = arr.filter(x => x %\
    \ 4 == 0).size\n        val fives = arr.filter(x => x % 5 == 0).size\n       \
    \ val sixes = arr.filter(x => x % 6 == 0).size\n        val sevens = arr.filter(x\
    \ => x % 7 == 0).size\n        val eights = arr.filter(x => x % 8 == 0).size\n\
    \        val nines = arr.filter(x => x % 9 == 0).size\n        val tens = arr.filter(x\
    \ => x % 10 == 0).size\n        val hundreds = arr.filter(x => x % 100 == 0).size\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).size\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).size\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).size\n        val trillions = arr.filter(x => x % 1000000000000\
    \ == 0).size\n        val quadrillions = arr.filter(x => x % 1000000000000000\
    \ == 0).size\n        val quintillions = arr.filter(x => x % 1000000000000000000\
    \ == 0).size\n        val ones = arr.filter(x => x % 1 == 0).size\n        val\
    \ twos = arr.filter(x => x % 2 == 1).size\n        val threes = arr.filter(x =>\
    \ x % 3 == 1).size\n        val fours = arr.filter(x => x % 4 == 1).size\n   \
    \     val fives = arr.filter(x => x % 5 == 1).size\n        val sixes = arr.filter(x\
    \ => x % 6 == 1).size\n        val sevens = arr.filter(x => x % 7 == 1).size\n\
    \        val eights = arr.filter(x => x % 8 == 1).size\n        val nines = arr.filter(x\
    \ => x % 9 == 1).size\n        val tens = arr.filter(x => x % 10 == 1).size\n\
    \        val hundreds = arr.filter(x => x % 100 == 1).size\n        val thousands\
    \ = arr.filter(x => x % 1000 == 1).size\n        val millions = arr.filter(x =>\
    \ x % 1000000 == 1).size\n        val billions = arr.filter(x => x % 1000000000\
    \ == 1).size\n        val trillions = arr.filter(x => x % 1000000000000 == 1).size\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjy953roo.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mones\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1\e[0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mones is\
    \ already defined as \e[33mvalue\e[0m \e[35mones\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjy953roo.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mtwos\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m1\e[0m).size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mtwos is already defined as \e[33mvalue\e[0m \e[35mtwos\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpjy953roo.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mthrees\e[0m = arr.filter(\e[36mx\e[0m =>\
    \ x % \e[31m3\e[0m == \e[31m1\e[0m).size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mthrees is already defined as \e[33mvalue\e[0m \e[35mthrees\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjy953roo.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mfours\e[0m = arr.filter(\e[36mx\e[0m\
    \ => x % \e[31m4\e[0m == \e[31m1\e[0m).size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mfours is already defined as \e[33mvalue\e[0m \e[35mfours\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjy953roo.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mfives\e[0m = arr.fi"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val twos = arr.filter(_ % 2 == 1).length\n        val threes = arr.filter(_\
    \ % 3 == 0).length\n        val fours = arr.filter(_ % 4 == 0).length\n      \
    \  val fives = arr.filter(_ % 5 == 0).length\n        val sixes = arr.filter(_\
    \ % 6 == 0).length\n        val sevens = arr.filter(_ % 7 == 0).length\n     \
    \   val eights = arr.filter(_ % 8 == 0).length\n        val nines = arr.filter(_\
    \ % 9 == 0).length\n        val tens = arr.filter(_ % 10 == 0).length\n      \
    \  val hundreds = arr.filter(_ % 100 == 0).length\n        val thousands = arr.filter(_\
    \ % 1000 == 0).length\n        val millions = arr.filter(_ % 1000000 == 0).length\n\
    \        val billions = arr.filter(_ % 1000000000 == 0).length\n        val trillions\
    \ = arr.filter(_ % 1000000000000 == 0).length\n        val quadrillions = arr.filter(_\
    \ % 1000000000000000 == 0).length\n        val quintillions = arr.filter(_ % 1000000000000000000\
    \ == 0).length\n        val onesAndZeros = arr.filter(_ % 1 == 0).length\n   \
    \     val onesAndOnes = arr.filter(_ % 1 == 1).length\n        val onesAndTwos\
    \ = arr.filter(_ % 1 == 2).length\n        val onesAndThrees = arr.filter(_ %\
    \ 1 == 3).length\n        val onesAndFours = arr.filter(_ % 1 == 4).length\n \
    \       val onesAndFives = arr.filter(_ % 1 == 5).length\n        val onesAndSixes\
    \ = arr.filter(_ % 1 == 6).length\n        val onesAndSevens = arr.filter(_ %\
    \ 1 == 7).length\n        val onesAndEights = arr.filter(_ % 1 == 8).length\n\
    \        val onesAndNines = arr.filter(_ % 1 == 9).length\n        val onesAndTens\
    \ = arr.filter(_ % 1 == 10).length\n        val onesAndHundreds = arr.filter(_\
    \ % 1 == 100).length\n        val onesAndThousands = arr.filter(_ % 1 == 1000).length\n\
    \        val onesAndMillions = arr.filter(_ % 1 == 1000000).length\n        val\
    \ onesAndBillions = arr.filter(_ % 1 == 1000000000).length\n        val onesAndTrillions\
    \ = arr.filter(_ % 1 == 1000000000000).length\n        val onesAndQuadrillions\
    \ = arr.filter(_ % 1 == 1000000000000000\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpreoz8r3r.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpreoz8r3r.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(_ % \e[31m1000000000000\e[0m\
    \ == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                             \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpreoz8r3r.scala:27:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(_ % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                   number too large\n\e[31m\e[31m-- Error: /tmp/tmpreoz8r3r.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(_ % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \               ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                      number too large\n\e[31m\e[31m-- Error: /tmp/tmpreoz8r3r.scala:44:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m44 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesAndTrillions\e[0m = arr.filter(_ % \e[31m1\e[0m ==\
    \ \e[31m1000000000000\e[0m).length\n\e[31m\e[31m   |\e[0m                    \
    \                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                         number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpreoz8r3r.scala:45:54 -----------------------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36monesAndQuadrillions\e[0m = arr.filter(_\
    \ % \e[31m1\e[0m == \e[31m1000000000000000\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                 "
  stdout: ''
  timestamp: 1659795198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesZeros = arr.count(_\
    \ == 1 && _ == 0)\n        val maxOnesOnes = arr.count(_ == 1 && _ == 1)\n   \
    \     val maxOnesTwos = arr.count(_ == 1 && _ == 2)\n        val maxOnesThrees\
    \ = arr.count(_ == 1 && _ == 3)\n        val maxOnesFours = arr.count(_ == 1 &&\
    \ _ == 4)\n        val maxOnesFives = arr.count(_ == 1 && _ == 5)\n        val\
    \ maxOnesSixes = arr.count(_ == 1 && _ == 6)\n        val maxOnesSevens = arr.count(_\
    \ == 1 && _ == 7)\n        val maxOnesEights = arr.count(_ == 1 && _ == 8)\n \
    \       val maxOnesNines = arr.count(_ == 1 && _ == 9)\n        val maxOnesTens\
    \ = arr.count(_ == 1 && _ == 10)\n        val maxOnesElevens = arr.count(_ ==\
    \ 1 && _ == 11)\n        val maxOnesTwelves = arr.count(_ == 1 && _ == 12)\n \
    \       val maxOnesThirteens = arr.count(_ == 1 && _ == 13)\n        val maxOnesFourteens\
    \ = arr.count(_ == 1 && _ == 14)\n        val maxOnesFifteens = arr.count(_ ==\
    \ 1 && _ == 15)\n        val maxOnesSixteens = arr.count(_ == 1 && _ == 16)\n\
    \        val maxOnesSeventeens = arr.count(_ == 1 && _ == 17)\n        val maxOnesEighteens\
    \ = arr.count(_ == 1 && _ == 18)\n        val maxOnesNineteens = arr.count(_ ==\
    \ 1 && _ == 19)\n        val maxOnesTwentys = arr.count(_ == 1 && _ == 20)\n \
    \       val maxOnesTwentyFours = arr.count(_ == 1 && _ == 24)\n        val maxOnesTwentyFives\
    \ = arr.count(_ == 1 && _ == 25)\n        val maxOnesTwentySixes = arr.count(_\
    \ == 1 && _ == 26)\n        val maxOnesTwentySevens = arr.count(_ == 1 && _ ==\
    \ 27)\n        val maxOnesTwentyEights = arr.count(_ == 1 && _ == 28)\n      \
    \  val maxOnesTwentyN\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvxuz97kz.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvxuz97kz.scala:16:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesZeros\e[0m = arr.count(_ == \e[31m1\e[0m && _ == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpvxuz97kz.scala:17:36 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOnes\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpvxuz97kz.scala:18:36 ---------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesTwos\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpvxuz97kz.scala:19:38 ---------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesThrees\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                  Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpvxuz97kz.scala:20:37 ---------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesFours\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ == \e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: "
  stdout: ''
  timestamp: 1659795197
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val onesAndZeros = arr.count(_ == 1)\n        val onesAndOnes = arr.count(_\
    \ == 2)\n        val onesAndTwos = arr.count(_ == 3)\n        val onesAndThrees\
    \ = arr.count(_ == 4)\n        val onesAndFours = arr.count(_ == 5)\n        val\
    \ onesAndFives = arr.count(_ == 6)\n        val onesAndSixes = arr.count(_ ==\
    \ 7)\n        val onesAndSevens = arr.count(_ == 8)\n        val onesAndEights\
    \ = arr.count(_ == 9)\n        val onesAndNines = arr.count(_ == 10)\n       \
    \ val onesAndTens = arr.count(_ == 11)\n        val onesAndHundreds = arr.count(_\
    \ == 100)\n        val onesAndThousands = arr.count(_ == 1000)\n        val onesAndMillions\
    \ = arr.count(_ == 1000000)\n        val onesAndBillions = arr.count(_ == 1000000000)\n\
    \        val onesAndTrillions = arr.count(_ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1000000000000000)\n        val onesAndQuintillions = arr.count(_\
    \ == 1000000000000000000)\n        val onesAndOnesAndZeros = arr.count(_ == 1)\n\
    \        val onesAndOnesAndOnes = arr.count(_ == 2)\n        val onesAndOnesAndTwos\
    \ = arr.count(_ == 3)\n        val onesAndOnesAndThrees = arr.count(_ == 4)\n\
    \        val onesAndOnesAndFours = arr.count(_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk9gj6q58.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpk9gj6q58.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:44:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndTrillions\e[0m =\
    \ arr.count(_ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpk9gj6q58.scala:45:49 -----------------------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36monesAndQuadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpk9gj6q58.scala:46:49 ------------------------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val hundreds = arr.filter(x\
    \ => x % 100 == 0).length\n        val thousands = arr.filter(x => x % 1000 ==\
    \ 0).length\n        val millions = arr.filter(x => x % 1000000 == 0).length\n\
    \        val billions = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ trillions = arr.filter(x => x % 1000000000000 == 0).length\n        val quadrillions\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val quintillions\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val onesAndZeros\
    \ = arr.filter(x => x % 1 == 0 && x != 0).length\n        val onesAndOnes = arr.filter(x\
    \ => x % 1 == 1 && x != 0).length\n        val twosAndZeros = arr.filter(x =>\
    \ x % 2 == 0 && x != 0).length\n        val twosAndOnes = arr.filter(x => x %\
    \ 2 == 1 && x != 0).length\n        val threesAndZeros = arr.filter(x => x % 3\
    \ == 0 && x != 0).length\n        val threesAndOnes = arr.filter(x => x % 3 ==\
    \ 1 && x != 0).length\n        val foursAndZeros = arr.filter(x => x % 4 == 0\
    \ && x != 0).length\n        val foursAndOnes = arr.filter(x => x % 4 == 1 &&\
    \ x != 0).length\n        val fivesAndZeros = arr.filter(x => x % 5 == 0 && x\
    \ != 0).length\n        val fivesAndOnes = arr.filter(x => x % 5 == 1 && x !=\
    \ 0).length\n        val sixesAndZeros = arr.filter(x => x % 6 == 0 && x != 0).length\n\
    \        val sixesAndOnes = arr.filter(x => x % 6 == 1 && x != 0).\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5xwzxq3e.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:27:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmp5xwzxq3e.scala:28:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5xwzxq3e.scala:41:5 ---------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795186
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesDecimal = ones * decimals\n\
    \        val onesDecimals = onesDecimal.map(x => x / decimals)\n        val onesDecimalsSorted\
    \ = onesDecimals.sortWith(_ < _)\n        val decimalsSorted = decimals.map(x\
    \ => x / onesDecimal)\n        val decimalsSortedSorted = decimalsSorted.sortWith(_\
    \ < _)\n        val sortedArray = onesDecimalsSorted.zip(decimalsSortedSorted).map(_._1).zipWithIndex.sortWith(_._2\
    \ < _._2).map(_._2).map(_._1)\n        sortedArray.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2yfa89s9.scala:15:39 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesDecimals\e[0m = onesDecimal.map(\e\
    [36mx\e[0m => x / decimals)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value map is not a member of Int\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2yfa89s9.scala:17:38 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsSorted\e[0m = decimals.map(\e\
    [36mx\e[0m => x / onesDecimal)\n\e[31m\e[31m   |\e[0m                        \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             value map\
    \ is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val onesCount = ones.toList\n        val onesCount = onesCount.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCount.reverse\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse.sortBy(x\
    \ => x)\n        val onesCountReverse = onesCountReverse.sortBy(x => x)\n    \
    \    val onesCountReverse = onesCountReverse.sortBy(x => x)\n        val onesCountReverse\
    \ = onesCountReverse.sortBy(x => x)\n        val onesCountReverse = onesCountReverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk9p76chi.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36monesCount\e[0m = onesCount.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesCount is already defined as \e[33mvalue\e[0m \e[35monesCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk9p76chi.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36monesCountReverse\e[0m = onesCountReverse.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesCountReverse is already defined as \e[33mvalue\e[0m \e\
    [35monesCountReverse\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk9p76chi.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesCountReverse\e[0m =\
    \ onesCountReverse.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesCountReverse is already defined as \e[33mvalue\e[0m \e\
    [35monesCountReverse\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk9p76chi.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesCountReverse\e[0m =\
    \ onesCountReverse.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesCountReverse is already defined as \e[33mvalue\e[0m \e\
    [35monesCountReverse\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk9p76chi.scala:19:12 ---------------------------\e\
    [0m\e[0m"
  stdout: ''
  timestamp: 1659795198
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.size\n        val\
    \ twos_count = twos.size\n        val threes_count = threes.size\n        val\
    \ fours_count = fours.size\n        val fives_count = fives.size\n        val\
    \ sixes_count = sixes.size\n        val sevens_count = sevens.size\n        val\
    \ eights_count = eights.size\n        val nines_count = nines.size\n        val\
    \ tens_count = tens.size\n        val hundreds_count = hundreds.size\n       \
    \ val thousands_count = thousands.size\n        val ten_thousands_count = ten_thousands.size\n\
    \        val hundred_thousands_count = hundred_thousands.size\n        val millions_count\
    \ = millions.size\n        val billions_count = billions.size\n        val trillions_count\
    \ = trillions.size\n        val quadrilli\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9q9irzo.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpn9q9irzo.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpn9q9irzo.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795187
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val onesAndZeros = arr.count(_ == 1)\n        val onesAndOnes = arr.count(_\
    \ == 1)\n        val onesAndTwos = arr.count(_ == 1)\n        val onesAndThrees\
    \ = arr.count(_ == 1)\n        val onesAndFours = arr.count(_ == 1)\n        val\
    \ onesAndFives = arr.count(_ == 1)\n        val onesAndSixes = arr.count(_ ==\
    \ 1)\n        val onesAndSevens = arr.count(_ == 1)\n        val onesAndEights\
    \ = arr.count(_ == 1)\n        val onesAndNines = arr.count(_ == 1)\n        val\
    \ onesAndTens = arr.count(_ == 1)\n        val onesAndHundreds = arr.count(_ ==\
    \ 1)\n        val onesAndThousands = arr.count(_ == 1)\n        val onesAndMillions\
    \ = arr.count(_ == 1)\n        val onesAndBillions = arr.count(_ == 1)\n     \
    \   val onesAndTrillions = arr.count(_ == 1)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1)\n        val onesAndQuintillions = arr.count(_ == 1)\n \
    \       val onesAndOnesAndZeros = arr.count(_ == 1)\n        val onesAndOnesAndOnes\
    \ = arr.count(_ == 1)\n        val onesAndOnesAndTwos = arr.count(_ == 1)\n  \
    \      val onesAndOnesAndThrees = arr.count(_ == 1)\n        val onesAndOnesAndFours\
    \ = arr.count(_ == 1)\n        val onesAndOnesAndFi\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3p7yu1sj.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp3p7yu1sj.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmp3p7yu1sj.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmp3p7yu1sj.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3p7yu1sj.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = arr.count(x => x == 1)\n\
    \        val twos_count = arr.count(x => x == 2)\n        val threes_count = arr.count(x\
    \ => x == 3)\n        val fours_count = arr.count(x => x == 4)\n        val fives_count\
    \ = arr.count(x => x == 5)\n        val sixes_count = arr.count(x => x == 6)\n\
    \        val sevens_count = arr.count(x => x == 7)\n        val eights_count =\
    \ arr.count(x => x == 8)\n        val nines_count = arr.count(x => x == 9)\n \
    \       val tens_count = arr.count(x => x == 10) \n        val hundreds_count\
    \ = arr.count(x => x == 11)\n        val thousands_count = arr.count(x => x ==\
    \ 100)\n        val ten_thousands_count = arr.count(x => x == 1000)\n        val\
    \ hundred_thousands_count = arr.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjpuibh3t.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpjpuibh3t.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpjpuibh3t.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpjpuibh3t.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpjpuibh3t.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpjpuibh3t.scala:30:49 ------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 10000000000000000000000000000000001)\n        val decillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000010)\n        val undecillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000011)\n        val decillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000100)\n        val undecillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000101)\n        val decillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001000)\n        val undecillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001001)\n        val decillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010000)\n        val undecillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010001)\n        val decillionsFive = arr.count(_\
    \ == 100000000000000000000000000000000100000)\n        val undecillionsFive =\
    \ arr.count(_ == 100000000000000000000000000000000100001)\n        val decillionsSix\
    \ = arr.count(_ == 1000000000000000000000000000000001000000)\n        val undecillion\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8xxvypl.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmph8xxvypl.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:30:41 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:31:40 -------------------------------"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(x => math.abs(math.log2(x)))\n        val sorted = decs.sortWith((x,\
    \ y) => math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.sig\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3jugzd8v.scala:15:4 ----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3jugzd8v.scala:13:46\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mdecs\e[0m = arr.map(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m\
    \   |\e[0m                                         ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      value log2 is not a member of math\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp3jugzd8v.scala:14:58 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) *"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.size\n        val\
    \ twos_count = twos.size\n        val threes_count = threes.size\n        val\
    \ fours_count = fours.size\n        val fives_count = fives.size\n        val\
    \ sixes_count = sixes.size\n        val sevens_count = sevens.size\n        val\
    \ eights_count = eights.size\n        val nines_count = nines.size\n        val\
    \ tens_count = tens.size\n        val hundreds_count = hundreds.size\n       \
    \ val thousands_count = thousands.size\n        val ten_thousands_count = ten_thousands.size\n\
    \        val hundred_thousands_count = hundred_thousands.size\n        val millions_count\
    \ = millions.size\n        val billions_count = billions.size\n        val trillions_count\
    \ = trillions.size\n        val quadrillion\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpui58upli.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpui58upli.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decimals = arr.count(x => x == 0)\n        val onesDecimals = ones\
    \ * decimals\n        val onesDecimalsArray = onesDecimals.toArray\n        val\
    \ onesDecimalsArrayLength = onesDecimalsArray.length\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ - 1\n        val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n   \
    \     val onesDecimalsArrayLength = onesDecimalsArrayLength - 1\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6peiksnt.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArrayLength\e\
    [0m = onesDecimalsArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6peiksnt.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArrayLength\e\
    [0m = onesDecimalsArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6peiksnt.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArrayLength\e\
    [0m = onesDecimalsArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6peiksnt.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArrayLength\e\
    [0m = onesDecimalsArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group "
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val onesDec = arr.filter(x\
    \ => x == 1).map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n        val\
    \ zerosDec = arr.filter(x => x == 0).map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take(ones)\n        val zerosDec = zerosDec.take(zeros)\n\
    \        val onesDec = onesDec.take\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2oy0685.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.take(ones)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi2oy0685.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.take(zeros)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpi2oy0685.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.take(ones)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesDec\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi2oy0685.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDec\e[0m = zerosDec.take(zeros)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi2oy0685.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.take(ones)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e[0m\n\e[31m \
    \  |\e[0m\n\e"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val elevens =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val twelves = arr.map(x => if\
    \ (x == 12) 12 else 0)\n        val thirteens = arr.map(x => if (x == 13) 13 else\
    \ 0)\n        val fourteens = arr.map(x => if (x == 14) 14 else 0)\n        val\
    \ fifteens = arr.map(x => if (x == 15) 15 else 0)\n        val sixteens = arr.map(x\
    \ => if (x == 16) 16 else 0)\n        val seventeens = arr.map(x => if (x == 17)\
    \ 17 else 0)\n        val eighteens = arr.map(x => if (x == 18) 18 else 0)\n \
    \       val nineteens = arr.map(x => if (x == 19) 19 else 0)\n        val twenties\
    \ = arr.map(x => if (x == 20) 20 else 0)\n        val twentys = arr.map(x => if\
    \ (x == 21) 21 else 0)\n        val twentyfours = arr.map(x => if (x == 22) 22\
    \ else 0)\n        val twentyfives = arr.map(x => if (x == 23) 23 else 0)\n  \
    \      val twentysixes = arr.map(x => if (x == 24) 24 else 0)\n        val twentysevens\
    \ = arr.map(x => if (x == 25) 25 else 0)\n        val twentyeights = arr.map(x\
    \ => if (x == 26) 26 else 0)\n        val twentynines = arr.map(x => if (x ==\
    \ 27) 27 else 0)\n        val thirties = arr.map(x => if (x == 28) 28 else 0)\n\
    \        val thirtys = arr.map(x => if (x == 29) 29 else 0)\n        val thirtyfours\
    \ = arr.map(x => \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp63x98pbz.scala:41:38 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mthirtyfours\e[0m = arr.map(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                      ^\e\
    [0m\n\e[31m   |\e[0m                                      expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp63x98pbz.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795201
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val twos = arr.filter(x => x == 2).size\n        val threes = arr.filter(x\
    \ => x == 3).size\n        val fours = arr.filter(x => x == 4).size\n        val\
    \ fives = arr.filter(x => x == 5).size\n        val sixes = arr.filter(x => x\
    \ == 6).size\n        val sevens = arr.filter(x => x == 7).size\n        val eights\
    \ = arr.filter(x => x == 8).size\n        val nines = arr.filter(x => x == 9).size\n\
    \        val tens = arr.filter(x => x == 10).size\n        val hundreds = arr.filter(x\
    \ => x == 11).size\n        val thousands = arr.filter(x => x == 12).size\n  \
    \      val millions = arr.filter(x => x == 13).size\n        val billions = arr.filter(x\
    \ => x == 14).size\n        val trillions = arr.filter(x => x == 15).size\n  \
    \      val quadrillions = arr.filter(x => x == 16).size\n        val quintillions\
    \ = arr.filter(x => x == 17).size\n        val sextillions = arr.filter(x => x\
    \ == 18).size\n        val septillions = arr.filter(x => x == 19).size\n     \
    \   val octillions = arr.filter(x => x == 20).size\n        val nonillions = arr.filter(x\
    \ => x == 21).size\n        val decillions = arr.filter(x => x == 22).size\n \
    \       val undecillions = arr.filter(x => x == 23).size\n        val duodecillions\
    \ = arr.filter(x => x == 24).size\n        val tredecillions = arr.filter(x =>\
    \ x == 25).size\n        val quattuordecillions = arr.filter(x => x == 26).size\n\
    \        val quindecillions = arr.filter(x => x == 27).size\n        val sexdecillions\
    \ = arr.filter(x => x == 28).size\n        val septendecillions = arr.filter(x\
    \ => x == 29).size\n        val octodecillions = arr.filter(x => x == 30).size\n\
    \        val novemdecillions = arr.filter(x => x == 31).size\n        val vigintillions\
    \ = arr.filter(x => x == 32).size\n        val unvigintillions = arr.filter(x\
    \ => x == 33).size\n        val duovigintillions = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwdo0aym1.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwdo0aym1.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val twos = arr.count(x => x == 2)\n        val threes = arr.count(x =>\
    \ x == 3)\n        val fours = arr.count(x => x == 4)\n        val fives = arr.count(x\
    \ => x == 5)\n        val sixes = arr.count(x => x == 6)\n        val sevens =\
    \ arr.count(x => x == 7)\n        val eights = arr.count(x => x == 8)\n      \
    \  val nines = arr.count(x => x == 9)\n        val tens = arr.count(x => x ==\
    \ 10)\n        val hundreds = arr.count(x => x == 100)\n        val thousands\
    \ = arr.count(x => x == 1000)\n        val millions = arr.count(x => x == 1000000)\n\
    \        val billions = arr.count(x => x == 1000000000)\n        val trillions\
    \ = arr.count(x => x == 1000000000000)\n        val quadrillions = arr.count(x\
    \ => x == 1000000000000000)\n        val quintillions = arr.count(x => x == 1000000000000000000)\n\
    \        val onesAndZeroes = arr.count(x => x == 1)\n        val onesAndZeroesAndOnes\
    \ = arr.count(x => x == 1 && x == 0)\n        val onesAndOnes = arr.count(x =>\
    \ x == 1 && x == 1)\n        val onesAndOnesAndZeroes = arr.count(x => x == 1\
    \ && x == 0 && x == 1)\n        val onesAndOnesAndOnes = arr.count(x => x == 1\
    \ && x == 1 && x == 1)\n        val onesAndOnesAndOnesAndZeroes = arr.count(x\
    \ => x == 1 && x == 1 && x == 0 && x == 1)\n        val onesAndOnesAndOnesAndOnes\
    \ = arr.count(x => x == 1 && x == 1 && x == 1 && x == 1)\n        val onesAndOnesAndOnesAndOnesAndZeroes\
    \ = arr.count(x => x == 1 && x == 1 && x == 1 && x == 0 && x == 1)\n        val\
    \ onesAndOnesAndOnesAndOnesAndOnes = arr.count(x => x == 1 && x == 1 && x == 1\
    \ && x == 1 && x == 1)\n        val onesAndOnesAndOnesAndOnesAndOnesAndZeroes\
    \ = arr.count(x => x == 1 && x == 1 && x == 1 && x == 0 && x == 1)\n        val\
    \ onesAndOnesAndOnesAndOnesAndOnesAndOnes = arr.count(x => x == 1 && x == 1 &&\
    \ x == 1 && x == 1 && x == 1 && x == 1)\n        val onesAndOnesAndOnesAndOnesAndOnesAndOnesAndZeroes\
    \ = arr.count(x => x == 1 && x == 1 && x == 1 && x == 1 && x == 0 && x == 1)\n\
    \        val onesAndOnesAndOnesAndOnesAndOnesAndOnesAndOnes = arr.count(x => \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1d3zk87d.scala:41:75 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36monesAndOnesAndOnesAndOnesAndOnesAndOnesAndOnes\e\
    [0m = arr.count(\e[36mx\e[0m => \n\e[31m\e[31m   |\e[0m                      \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp1d3zk87d.scala:26:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp1d3zk87d.scala:27:47 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp1d3zk87d.scala:28:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1d3zk87d.scala:42:5 ---------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val onesCount = ones.map(x => x).sum\n        val sortedOnes\
    \ = ones.sortBy(x => x.toInt)\n        val sortedOnesCount = sortedOnes.map(x\
    \ => x).sum\n        val sortedArr = arr.sortBy(x => if (x == 1) 1 else 0)\n \
    \       val sortedArrCount = sortedArr.map(x => x).sum\n        val sortedArrCount\
    \ = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x => if (x\
    \ == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n  \
    \      val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n        val sortedArrCount = sortedArr.map(x => x).sum\n\
    \        val sortedArrCount = sortedArrCount.toLong\n        val sortedArr = sortedArr.sortBy(x\
    \ => if (x == 1) 1 else 0)\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp243oh8o0.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msortedArrCount\e[0m = sortedArrCount.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArrCount is already defined as \e[33mvalue\e[0m \e[35msortedArrCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp243oh8o0.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.sortBy(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp243oh8o0.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36msortedArrCount\e[0m = sortedArr.map(\e\
    [36mx\e[0m => x).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArrCount is already defined as \e[33mvalue\e[0m \e[35msortedArrCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp243oh8o0.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36msortedArrCount\e[0m = sortedArrCount.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArrCount is already defined as \e[33mvalue\e[0m \e[35msortedArrCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp243oh8o0.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e"
  stdout: ''
  timestamp: 1659795210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val millions = arr.map(x => if (x == 1000) 1000\
    \ else 0)\n        val billions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val sextillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val onesSorted = ones.sortWith(_ < _)\n\
    \        val twosSorted = twos.sortWith(_ < _)\n        val threesSorted = threes.sortWith(_\
    \ < _)\n        val foursSorted = fours.sortWith(_ < _)\n        val fivesSorted\
    \ = fives.sortWith(_ < _)\n        val sixesSorted = sixes.sortWith(_ < _)\n \
    \       val sevensSorted = sevens.sortWith(_ < _)\n        val eightsSorted =\
    \ eights.sortWith(_ < _)\n        val ninesSorted = nines.sortWith(_ < _)\n  \
    \      val tensSorted = tens.sortWith(_ < _)\n        val hundredsSorted = hundreds.sortWith(_\
    \ < _)\n        val thousandsSorted = thousands.sortWith(_ < _)\n        val millions\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp32frvzv9.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp32frvzv9.scala:27:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \              number too large\n\e[31m\e[31m-- Error: /tmp/tmp32frvzv9.scala:27:64\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                                    number too large\n\e[31m\e[31m-- Error: /tmp/tmp32frvzv9.scala:28:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp32frvzv9.scala:28:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp32frvzv9.scala:29:48 -------"
  stdout: ''
  timestamp: 1659795209
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(x => x ==\
    \ 1).sortBy(x => x.toString.toInt)\n        val zerosArr = arr.filter(x => x ==\
    \ 0).sortBy(x => x.toString.toInt)\n        val onesCount = onesArr.length\n \
    \       val zerosCount = zerosArr.length\n        if (onesCount < zerosCount)\
    \ {\n            onesArr.toList\n        } else if (zerosCount < onesCount) {\n\
    \            zerosArr.toList\n        } else {\n            onesArr.zip(zerosArr).sortBy(x\
    \ => x._1 - x._2).map(x => x._1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_x7t4r09.scala:27)\n\tat Problem.main(tmp_x7t4r09.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decs = arr.map(x => math.abs(math.log2(x)))\n        val decs = decs.sortBy(x\
    \ => x)\n        val decs = decs.takeWhile(x => x < ones)\n        val decs =\
    \ decs.sortBy(x => math.abs(x - ones))\n        val decs = decs.takeWhile(x =>\
    \ x < ones)\n        val decs = decs.sortBy(x => math.abs(x - ones))\n       \
    \ val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.sortBy(x =>\
    \ math.abs(x - ones))\n        val decs = decs.takeWhile(x => x < ones)\n    \
    \    val decs = decs.sortBy(x => math.abs(x - ones))\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.sortBy(x => math.abs(x - ones))\n    \
    \    val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.sortBy(x\
    \ => math.abs(x - ones))\n        val decs = decs.takeWhile(x => x < ones)\n \
    \       val decs = decs.sortBy(x => math.abs(x - ones))\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.sortBy(x => math.abs(x - ones))\n    \
    \    val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.sortBy(x\
    \ => math.abs(x - ones))\n        val decs = decs.takeWhile(x => x < ones)\n \
    \       val decs = decs.sortBy(x => math.abs(x - ones))\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.sortBy(x => math.abs(x - ones))\n    \
    \    val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.sortBy(x\
    \ => math.abs(x - ones))\n        val decs = decs.takeWhile(x => x < ones)\n \
    \       val decs = decs.sortBy(x => math.abs(x - ones))\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.sortBy(x => math.abs(x - ones))\n    \
    \    val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.sortBy(x\
    \ => math.abs(x - ones))\n        val decs = decs.takeWhile(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyvkd5p4s.scala:45:34 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyvkd5p4s.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdecs is already defined\
    \ as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyvkd5p4s.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e\
    [36mx\e[0m => x < ones)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyvkd5p4s.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x\
    \ - ones))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpyvkd5p4s.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m =>\
    \ x < ones)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val decimal = arr.map(x\
    \ => math.pow(2,x)).sum\n        val decimalOnes = math.pow(2,ones)\n        val\
    \ decimalZeros = math.pow(2,zeros)\n        val decimalOnesZeros = math.pow(2,ones\
    \ + zeros)\n        val decimalZeroOnes = math.pow(2,zeros + ones)\n        val\
    \ decimalOnesOnes = math.pow(2,ones + ones)\n        val decimalZeroOnesOnes =\
    \ math.pow(2,zeros + ones + ones)\n        val decimalOnesOnesOnes = math.pow(2,ones\
    \ + ones + ones)\n        val decimalZeroOnesOnesOnes = math.pow(2,zeros + ones\
    \ + ones + ones)\n        val decimalOnesOnesOnesOnes = math.pow(2,ones + ones\
    \ + ones + ones)\n        val decimalZeroOnesOnesOnesOnes = math.pow(2,zeros +\
    \ ones + ones + ones + ones)\n        val decimalOnesOnesOnesOnesOnes = math.pow(2,ones\
    \ + ones + ones + ones + ones)\n        val decimalZeroOnesOnesOnesOnesOnes =\
    \ math.pow(2,zeros + ones + ones + ones + ones + ones)\n        val decimalOnesOnesOnesOnesOnesOnes\
    \ = math.pow(2,ones + ones + ones + ones + ones + ones)\n        val decimalZeroOnesOnesOnesOnesOnesOnes\
    \ = math.pow(2,zeros + ones + ones + ones + ones + ones + ones)\n        val decimalOnesOnesOnesOnesOnesOnesOnes\
    \ = math.pow(2,ones + ones + ones + ones + ones + ones + ones + ones)\n      \
    \  val decimalZeroOnesOnesOnesOnesOnesOnesOnes = math.pow(2,zeros + ones + ones\
    \ + ones + ones + ones + ones + ones + ones)\n        val decimalOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = math.pow(2,ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones)\n        val decimalZeroOnesOnesOnesOnesOnesOnesOnesOnesOnes = math.pow(2,zeros\
    \ + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones)\n\
    \        val decimalOnes\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkbmyd1cr.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpkbmyd1cr.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 10000000000000000000000000000000001)\n        val decillionsOrMore = arr.count(_\
    \ == 10000000000000000000000000000000010)\n        val undecillionsOrMore = arr.count(_\
    \ == 10000000000000000000000000000000011)\n        val decillionsOrLessOrMore\
    \ = arr.count(_ == 100000000000000000000000000000000100)\n        val undecillionsOrLessOrMore\
    \ = arr.count(_ == 100000000000000000000000000000000101)\n        val decillionsOrLessOrLess\
    \ = arr.count(_ == 1000000000000000000000000000000001000)\n        val undecillionsOrLessOrLess\
    \ = arr.count(_ == 1000000000000000000000000000000001001)\n        val decillionsOrLessOrLessOrMore\
    \ = arr.count(_ == 10000000000000000000000000000000010000)\n        val undecillionsOrLessOrLessOrMore\
    \ = arr.count(_ == 10000000000000000000000000000000010001)\n        val decillionsOrLessOrLessOrLessOrMore\
    \ = arr.count(_ == 100000000000000000000000000000000100000)\n        val undecillionsOrLessOrLessOrLessOrMore\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf31hflpa.scala:44:50 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mundecillionsOrLessOrLessOrLessOrMore\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \  ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpf31hflpa.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpf31hflpa.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpf31hflpa.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpf31hflpa.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpf31hflpa.scala:30:41 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000"
  stdout: ''
  timestamp: 1659795210
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val twos = arr.filter(_ % 2 == 1).length\n        val threes = arr.filter(_\
    \ % 3 == 0).length\n        val fours = arr.filter(_ % 4 == 0).length\n      \
    \  val fives = arr.filter(_ % 5 == 0).length\n        val sixes = arr.filter(_\
    \ % 6 == 0).length\n        val sevens = arr.filter(_ % 7 == 0).length\n     \
    \   val eights = arr.filter(_ % 8 == 0).length\n        val nines = arr.filter(_\
    \ % 9 == 0).length\n        val tens = arr.filter(_ % 10 == 0).length\n      \
    \  val hundreds = arr.filter(_ % 100 == 0).length\n        val thousands = arr.filter(_\
    \ % 1000 == 0).length\n        val tenThousands = arr.filter(_ % 10000 == 0).length\n\
    \        val oneThousands = arr.filter(_ % 100000 == 0).length\n        val oneMillion\
    \ = arr.filter(_ % 1000000 == 0).length\n        val oneBillion = arr.filter(_\
    \ % 10000000 == 0).length\n        val oneTrillion = arr.filter(_ % 100000000\
    \ == 0).length\n        val oneQuadrillion = arr.filter(_ % 1000000000 == 0).length\n\
    \        val oneQuintillion = arr.filter(_ % 10000000000 == 0).length\n      \
    \  val oneGiganticillion = arr.filter(_ % 1000000000000 == 0).length\n       \
    \ val oneTrillion = arr.filter(_ % 10000000000000 == 0).length\n        val oneQuintillion\
    \ = arr.filter(_ % 100000000000000 == 0).length\n        val oneGiganticillion\
    \ = arr.filter(_ % 1000000000000000 == 0).length\n        val oneTrillion = arr.filter(_\
    \ % 10000000000000000 == 0).length\n        val oneQuintillion = arr.filter(_\
    \ % 100000000000000000 == 0).length\n        val oneGiganticillion = arr.filter(_\
    \ % 1000000000000000000 == 0).length\n        val oneTrillion = arr.filter(_ %\
    \ 10000000000000000000 == 0).length\n        val oneQuintillion = arr.filter(_\
    \ % 100000000000000000000 == 0).length\n        val oneGiganticillion = arr.filter(_\
    \ % 1000000000000000000000 == 0).length\n        val oneTrillion = arr.filter(_\
    \ % 10000000000000000000000 == 0).length\n        val oneQuintillion = arr.filter(_\
    \ % 100000000000000000000000 == 0).length\n        val oneGiganticillion = arr.filter(_\
    \ % 1000000000000000000000000 == 0).\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc1jaxd9p.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc1jaxd9p.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36moneTrillion\e[0m = arr.filter(_ % \e[31m10000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneTrillion is already defined as \e[33mvalue\e[0m \e[35moneTrillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc1jaxd9p.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36moneQuintillion\e[0m = arr.filter(_ %\
    \ \e[31m100000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moneQuintillion is already defined as \e[33mvalue\e[0m \e[35moneQuintillion\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc1jaxd9p.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moneGiganticillion\e[0m = arr.filter(_\
    \ % \e[31m1000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moneGiganticillion is already defined as \e[33mvalue\e[0m \e\
    [35moneGiganticillion\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc1jaxd9p.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moneTrillion\e[0m = arr.filter(_\
    \ % \e[31m10000000000000000\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toSet.size\n        val zerosCount = zeros.toSet.size\n   \
    \     val onesZeros = ones.toSet.intersect(zeros.toSet)\n        val onesZeroCount\
    \ = onesZeros.size\n        val onesZeroSum = onesZeros.toSet.sum\n        val\
    \ onesZeroAvg = (onesZeroSum / onesZeroCount).toDouble\n        val onesZeroMax\
    \ = onesZeros.toSet.max\n        val onesZeroMin = onesZeros.toSet.min\n     \
    \   val zerosCount = zeros.toSet.size\n        val zerosSum = zeros.toSet.sum\n\
    \        val zerosAvg = (zerosSum / zerosCount).toDouble\n        val zerosMax\
    \ = zeros.toSet.max\n        val zerosMin = zeros.toSet.min\n        val onesCount\
    \ = ones.toSet.size\n        val onesSum = ones.toSet.sum\n        val onesAvg\
    \ = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n   \
    \     val onesMin = ones.toSet.min\n        val onesSum = ones.toSet.sum\n   \
    \     val onesAvg = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n\
    \        val onesMin = ones.toSet.min\n        val onesSum = ones.toSet.sum\n\
    \        val onesAvg = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n\
    \        val onesMin = ones.toSet.min\n        val onesSum = ones.toSet.sum\n\
    \        val onesAvg = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n\
    \        val onesMin = ones.toSet.min\n        val onesSum = ones.toSet.sum\n\
    \        val onesAvg = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n\
    \        val onesMin = ones.toSet.min\n        val onesSum = ones.toSet.sum\n\
    \        val onesAvg = (onesSum / onesCount).toDouble\n        val onesMax = ones.toSet.max\n\
    \        val onesMin = ones.toSet.min\n        val onesSum = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7306tdha.scala:52:21 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36monesSum\e[0m = \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp7306tdha.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mzerosCount\e[0m = zeros.toSet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mzerosCount is already defined as \e[33mvalue\e[0m \e[35mzerosCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7306tdha.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36monesCount\e[0m = ones.toSet.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesCount\
    \ is already defined as \e[33mvalue\e[0m \e[35monesCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7306tdha.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSum\e[0m = ones.toSet.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSum is already defined as \e[33mvalue\e[0m \e[35monesSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7306tdha.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36monesAvg\e[0m = (onesSum / onesCount).toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesAvg is already defined as \e[33mvalue\e[0m \e[35monesAvg\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ d"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(x => x ==\
    \ 1).sortBy(x => x.toString.toInt)\n        val zerosArr = arr.filter(x => x ==\
    \ 0).sortBy(x => x.toString.toInt)\n        val onesCount = onesArr.length\n \
    \       val zerosCount = zerosArr.length\n        val onesSum = onesArr.sum\n\
    \        val zerosSum = zerosArr.sum\n        val onesDecimal = onesSum / onesCount\n\
    \        val zerosDecimal = zerosSum / zerosCount\n        val onesDecimalString\
    \ = onesDecimal.toString\n        val zerosDecimalString = zerosDecimal.toString\n\
    \        val onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n        val onesDecimalStringLength = onesDecimalString.length\n\
    \        val zerosDecimalStringLength = zerosDecimalString.length\n        val\
    \ onesDecimalStringLength = onesDecimalString.length\n        val zerosDecimalStringLength\
    \ = zerosDecimalString.length\n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4nc07mkt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesDecimalStringLength\e\
    [0m = onesDecimalString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalStringLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4nc07mkt.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalStringLength\e\
    [0m = zerosDecimalString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4nc07mkt.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalStringLength\e\
    [0m = onesDecimalString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalStringLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4nc07mkt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalStringLength\e\
    [0m = zerosDecimalString.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalStringLength is already defined as \e[33mvalue\e\
    [0m \e[35mzerosDecimalStringLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Nami"
  stdout: ''
  timestamp: 1659795211
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesDecimal = maxOnes.toDouble\
    \ / ones\n        val maxZerosDecimal = maxZeros.toDouble / zeros\n        val\
    \ maxDecimal = math.max(maxOnesDecimal, maxZerosDecimal)\n        val onesDecimal\
    \ = ones / maxDecimal\n        val zerosDecimal = zeros / maxDecimal\n       \
    \ val decimal = math.max(onesDecimal, zerosDecimal)\n        val onesDecimalString\
    \ = onesDecimal.toString\n        val zerosDecimalString = zerosDecimal.toString\n\
    \        val decimalString = decimal.toString\n        val decimalStringWithZeros\
    \ = decimalString\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimalStringWithZeros.padTo(maxDecimal.toString,\
    \ \"0\")\n        val decimalStringWithZeros = decimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwx91kcqd.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalStringWithZeros\e\
    [0m = decimalStringWithZeros.padTo(maxDecimal.toString, \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mdecimalStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwx91kcqd.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mdecimalStringWithZeros\e\
    [0m = decimalStringWithZeros.padTo(maxDecimal.toString, \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mdecimalStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwx91kcqd.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mdecimalStringWithZeros\e\
    [0m = decimalStringWithZeros.padTo(maxDecimal.toString, \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mdecimalStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwx91kcqd.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mdecimalStringWithZeros\e\
    [0m = decimalStringWithZeros.padTo(maxDecimal.toString, \e[31m\"0\"\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decs = arr.map(x => math.abs(math.log2(x)))\n        val sortedArr\
    \ = arr.sortBy(x => math.abs(math.log2(x)))\n        val sortedDecs = decs.sortBy(x\
    \ => x)\n        val sortedOnes = ones.sortBy(x => x)\n        sortedArr ++ sortedDecs\
    \ ++ sortedOnes\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplx6mcvtd.scala:13:46 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = arr.map(\e[36mx\e\
    [0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \          value log2 is not a member of math\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmplx6mcvtd.scala:14:54 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m\
    \ => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                          \
    \                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                value log2 is not a member of math\n\e[31m\e[31m-- Error: /tmp/tmplx6mcvtd.scala:14:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m => math.abs(math.log2(x)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmplx6mcvtd.scala:15:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msortedDecs\e[0m = decs.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                                      \
    \      ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m\
    \ \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplx6mcvtd.scala:16:30\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36msortedOnes\e[0m = ones.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e["
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(x => math.abs(x))\n        val zerosArr = arr.filter(_ % 2\
    \ == 1).sortBy(x => math.abs(x))\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesArr\
    \ = onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x\
    \ => math.abs(x))\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n  \
    \      val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesArr =\
    \ onesArr.sortBy(x => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x =>\
    \ math.abs(x))\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n     \
    \   val zerosArr = zerosArr.sortBy(x => math.abs(x))\n        val onesArr = onesArr.sortBy(x\
    \ => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n\
    \        val onesArr = onesArr.sortBy(x => math.abs(x))\n        val zerosArr\
    \ = zerosArr.sortBy(x => math.abs(x))\n        val onesArr = onesArr.sortBy(x\
    \ => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n\
    \        val onesArr = onesArr.sortBy(x => math.abs(x))\n        val zerosArr\
    \ = zerosArr.sortBy(x => math.abs(x))\n        val onesArr = onesArr.sortBy(x\
    \ => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n\
    \        val onesArr = onesArr.sortBy(x => math.abs(x))\n        val zerosArr\
    \ = zerosArr.sortBy(x => math.abs(x))\n        val onesArr = onesArr.sortBy(x\
    \ => math.abs(x))\n        val zerosArr = zerosArr.sortBy(x => math.abs(x))\n\
    \        val onesArr = onesArr.sortBy(x => math.abs(x))\n        val zerosArr\
    \ = zerosArr.sortBy(x => math.abs(x))\n        val onesArr = one\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0jk99t4r.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jk99t4r.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jk99t4r.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jk99t4r.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0jk99t4r.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m =>"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 1)\n        val onesDecimals = arr.count(_ ==\
    \ 1 && _ > 1)\n        val decimalsDecimals = arr.count(_ > 1 && _ > 1)\n    \
    \    val onesDecimalsDecimals = arr.count(_ == 1 && _ > 1 && _ > 1)\n        val\
    \ decimalsDecimalsDecimals = arr.count(_ > 1 && _ > 1 && _ > 1)\n        val onesDecimalsDecimalsDecimals\
    \ = arr.count(_ == 1 && _ > 1 && _ > 1 && _ > 1)\n        val decimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ > 1 && _ > 1 && _ > 1 && _ > 1)\n        val onesDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ == 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n        val decimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n        val onesDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ == 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n        val\
    \ decimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.count(_ > 1 && _ > 1\
    \ && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ == 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.count(_\
    \ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n      \
    \  val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.count(_\
    \ == 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _\
    \ > 1 && _ > 1 && _ > 1)\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.count(_ == 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1 &&\
    \ _ > 1 && _ > 1 && _ > 1 && _ > 1 && _ > 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp782k551f.scala:14:37 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36monesDecimals\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ > \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \               Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp782k551f.scala:15:41 ---------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimals\e[0m = arr.count(_\
    \ > \e[31m1\e[0m && _ > \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Wrong number of parameters, expected: 1\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp782k551f.scala:16:45 ---------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsDecimals\e[0m = arr.count(_\
    \ == \e[31m1\e[0m && _ > \e[31m1\e[0m && _ > \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 Wrong number of parameters, expected:\
    \ 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp782k551f.scala:17:49 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalsDecimals\e\
    [0m = arr.count(_ > \e[31m1\e[0m && _ > \e[31m1\e[0m && _ > \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp782k551f.scala:18:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalsDecimalsDecimals\e[0m = arr.count(_ == \e[31m1\e[0m && _ >\
    \ \e[31m1\e[0m && _ > \e[31m1\e[0m && _ > \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp782k551"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength / 2\n   \
    \     val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 3\n        val zerosArrayLength\
    \ = zerosArrayLength * 3\n        val onesArrayLength = onesArrayLength * 4\n\
    \        val zerosArrayLength = zerosArrayLength * 4\n        val onesArrayLength\
    \ = onesArrayLength * 5\n        val zerosArrayLength = zerosArrayLength * 5\n\
    \        val onesArrayLength = onesArrayLength * 6\n        val zerosArrayLength\
    \ = zerosArrayLength * 6\n        val onesArrayLength = onesArrayLength * 7\n\
    \        val zerosArrayLength = zerosArrayLength * 7\n        val onesArrayLength\
    \ = onesArrayLength * 8\n        val zerosArrayLength = zerosArrayLength * 8\n\
    \        val onesArrayLength = onesArrayLength * 9\n        val zerosArrayLength\
    \ = zerosArrayLength * 9\n        val onesArrayLength = onesArrayLength * 10\n\
    \        val zerosArrayLength = zerosArrayLength * 10\n        val onesArrayLength\
    \ = onesArrayLength * 11\n        val zerosArrayLength = zerosArrayLength * 11\n\
    \        val onesArrayLength = onesArrayLength * 12\n        val zerosArrayLength\
    \ = zerosArrayLength * 12\n        val onesArrayLength = onesArrayLength * 13\n\
    \        val zerosArrayLength = zerosArrayLength * 13\n        val onesArrayLength\
    \ = onesArrayLength * 14\n        val zerosArrayLength = zerosArrayLength * 14\n\
    \        val onesArrayLength = onesArrayLength * 15\n        val zerosArrayLength\
    \ = zerosArrayLength * 15\n        val onesArrayLength = onesArrayLength * 16\n\
    \        val zerosArrayLength = zerosArrayLength * 16\n        val onesArrayLength\
    \ = onesArrayLength * 17\n        val zerosArrayLength = zerosArrayLength * 17\n\
    \        val onesArrayLength = onesArrayLength * 18\n        val zerosArrayLength\
    \ = zerosArrayLength * 18\n        val onesArrayLength = onesArrayLength * \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2kj4p_g1.scala:54:47 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ * \n\e[31m\e[31m   |\e[0m                                               ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2kj4p_g1.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2kj4p_g1.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2kj4p_g1.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2kj4p_g1.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength * \e[31m2\e[0m\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decimals = arr.count(x => x == 0)\n        val maxOnes = arr.count(x\
    \ => x == 1)\n        val maxDecimals = arr.count(x => x == 0)\n        val maxOnesDecimals\
    \ = maxOnes * decimals\n        val maxDecimalsOnes = maxDecimals * ones\n   \
    \     val maxDecimalsOnesDecimals = maxDecimalsOnes * decimals\n        val maxDecimalsOnesDecimalsOnes\
    \ = maxDecimalsOnesDecimals * ones\n        val maxDecimalsOnesDecimalsOnesOnes\
    \ = maxDecimalsOnesDecimalsOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnesOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnes * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnes * ones\n        val\
    \ maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ * ones\n        val maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\
    \ = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes * ones\n \
    \       val maxDecimalsOnesDecimalsOnesOnes\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppgvbc4yi.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppgvbc4yi.scala:28:90\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\e\
    [0m = maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes * ones\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxDecimalsOnesDecimalsOnesOnesOnesOnesOnesOnesOnesOnesOnesOnes\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppgvbc4yi.scala:30:5\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decs = arr.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val res = decs.zip(ones).sortBy(_._1).map(_._2)\n        arr.filter(_\
    \ % 2 == 0).sortBy(_.toString.toInt).reverse.map(_.toString.toInt).sortBy(_._1).map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0e4a5bkg.scala:14:27\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = decs.zip(ones).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                           Found: \
    \   (ones : Int)\n\e[31m   |\e[0m                           Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0e4a5bkg.scala:15:95\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        arr.filter(_ % \e\
    [31m2\e[0m == \e[31m0\e[0m).sortBy(_.toString.toInt).reverse.map(_.toString.toInt).sortBy(_._1).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                     ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                            value _1 is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp0e4a5bkg.scala:15:98 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_.toString.toInt).reverse.map(_.toString.toInt).sortBy(_._1).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                          ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659795213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ decimals = arr.map(x => math.log10(x)).reduceLeft(_ + _)\n        val decimalsDiff\
    \ = decimals - ones - twos\n        val decimalsDiffInt = decimalsDiff % 1\n \
    \       val decimalsDiffIntInt = math.round(decimalsDiffInt)\n        val decimalsDiffIntIntInt\
    \ = math.round(decimalsDiffIntInt)\n        val decimalsDiffIntIntIntInt = math.round(decimalsDiffIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8f_78pdy.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8f_78pdy.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e[0m = math.round(decimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt is\
    \ already defined as \e[33mvalue\e[0m \e[35mdecimalsDiffIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp8f_78pdy.scala:20:53 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDiffIntIntIntIntInt\e[0m = math.round(decimalsDiffIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                     ^\e\
    [0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35mdecimalsDiffIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8f_78pdy.scala:21:56\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDiffIntIntIntIntIntInt\e[0m = math.round(decimalsDiffIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m               Recursive \e[33mvalue\e[0m \e[35mdecimalsDiffIntIntIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8f_78pdy.scala:22:59\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDiffIntIntI"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val maxOnes = arr.filter(x\
    \ => x == 1).max\n        val maxZeros = arr.filter(x => x == 0).max\n       \
    \ val maxOnesDecimal = maxOnes.toString.toInt\n        val maxZerosDecimal = maxZeros.toString.toInt\n\
    \        val maxOnesDecimalDecimal = maxOnesDecimal.toString.toInt\n        val\
    \ maxZerosDecimalDecimal = maxZerosDecimal.toString.toInt\n        val maxOnesDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimal.toString.toInt\n        val maxZerosDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimal.toString.toInt\n        val maxOnesDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimal.toString.toInt\n        val maxZerosDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimal.toString.toInt\n        val maxOnesDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimal.toString.toInt\n        val maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimal.toString.toInt\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toInt\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toInt\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n       \
    \ val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n  \
    \      val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfwij1xg6.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfwij1xg6.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpfwij1xg6.scala:33:79 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toString.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659795212
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArray = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val zerosArray = arr.map(x => if (x == 0) 0 else 1)\n\
    \        val onesArraySorted = onesArray.sortWith(_ < _)\n        val zerosArraySorted\
    \ = zerosArray.sortWith(_ < _)\n        val result = onesArraySorted.zip(zerosArraySorted).sortWith(_._1\
    \ < _._1)\n        result.map(x => x._1 + x._2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp26bh1yoh.scala:22)\n\tat Problem.main(tmp26bh1yoh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795214
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesDecimals = ones * decimals\n\
    \        val decimalsDecimals = decimals * ones\n        val onesDecimalsDecimals\
    \ = onesDecimals * decimals\n        val onesDecimalsDecimalsDecimals = onesDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimals * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * decimals\n        val\
    \ onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * decimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals * decimals\n\
    \        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ * decimals\n        val onesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpffjcdmqr.scala:28:138 --------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                            \
    \              ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpffjcdmqr.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795212
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val decimal = arr.map(x\
    \ => math.pow(2,x)).sum\n        val onesDecimal = math.pow(2,ones)\n        val\
    \ zerosDecimal = math.pow(2,zeros)\n        val decimalDecimal = math.pow(2,decimal)\n\
    \        val onesDecimalDecimal = math.pow(2,onesDecimal)\n        val zerosDecimalDecimal\
    \ = math.pow(2,zerosDecimal)\n        val decimalDecimalDecimal = math.pow(2,decimalDecimal)\n\
    \        val onesDecimalDecimalDecimal = math.pow(2,onesDecimalDecimal)\n    \
    \    val zerosDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimal)\n      \
    \  val decimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimal)\n    \
    \    val onesDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = math.pow(2,zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ math.pow(2,decimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal)\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpebrbu5s2.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpebrbu5s2.scala:28:66\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m2\e[0m,zerosDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \          ^\e[0m\n\e[31m   |\e[0m     Recursive \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpebrbu5s2.scala:29:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m2\e[0m,decimalDecimalDecimalDecimalDecimalDecimal)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35mdecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpebrbu5s2.scala:30:72\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e[31m2\e\
    [0m,onesDecimalDecimalDecimalDecimalDecimalDecimal)\n\e[31m\e[31m   |\e[0m   \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebrbu5s2.scala:37:87\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = math.pow(\e\
    [31m2\e[0m,zerosDecimalDecimal"
  stdout: ''
  timestamp: 1659795213
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => (x >>> 0).toInt)\n\
    \        val zerosDec = arr.map(x => (x >>> 0).toInt)\n        val onesDecSorted\
    \ = onesDec.sortWith(_ > _)\n        val zerosDecSorted = zerosDec.sortWith(_\
    \ > _)\n        val onesDecSortedSortedWithZeros = onesDecSorted.zip(zerosDecSorted).sortWith(_._1\
    \ > _._1)\n        val zerosDecSortedSortedWithOnes = zerosDecSorted.zip(onesDecSortedSortedWithZeros).sortWith(_._1\
    \ < _._1)\n        val sortedArray = onesDecSortedSortedWithOnes.zip(zerosDecSortedSortedWithOnes).sortWith(_._1\
    \ < _._1)\n        sortedArray.map(x => x._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsngzajr6.scala:20:26 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = onesDecSortedSortedWithOnes.zip(zerosDecSortedSortedWithOnes).sortWith(_._1\
    \ < _._1)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Not found: onesDecSortedSortedWithOnes\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795217
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toSet.size\n        val zerosCount = zeros.toSet.size\n   \
    \     val onesZeros = ones.toSet intersect zeros.toSet\n        val onesZerosCount\
    \ = onesZeros.size\n        val onesZerosZeros = onesZeros.toSet intersect zeros.toSet\n\
    \        val onesZerosZerosCount = onesZerosZeros.size\n        val onesZerosZerosZerosCount\
    \ = onesZerosZeros.toSet intersect zeros.toSet\n        val onesZerosZerosZerosZerosCount\
    \ = onesZerosZerosZeros.toSet intersect zeros.toSet\n        val onesZerosZerosZerosZerosZerosCount\
    \ = onesZerosZerosZerosZeros.toSet intersect zeros.toSet\n        val onesZerosZerosZerosZerosZerosZerosCount\
    \ = onesZerosZerosZerosZerosZeros.toSet intersect zeros.toSet\n        val onesZerosZerosZerosZerosZerosZerosCount\
    \ = onesZerosZerosZerosZerosZerosZeros.toSet intersect zeros.toSet\n        val\
    \ onesZerosZerosZerosZerosZerosZerosZerosCount = onesZerosZerosZerosZerosZerosZerosZeros.toSet\
    \ intersect zeros.toSet\n        val onesZerosZerosZerosZerosZerosZerosZerosCount\
    \ = onesZerosZerosZerosZerosZerosZerosZeros.toSet intersect zeros.toSet\n    \
    \    val onesZerosZerosZerosZerosZerosZerosZerosZerosCount = onesZerosZerosZerosZerosZerosZerosZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdfpm5h7k.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZerosZerosZerosZerosZerosZerosCount\e\
    [0m = onesZerosZerosZerosZerosZerosZeros.toSet intersect zeros.toSet\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosZerosZerosZerosZerosZerosCount is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZerosZerosZerosZerosZerosZerosCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdfpm5h7k.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZerosZerosZerosZerosZerosZerosZerosCount\e\
    [0m = onesZerosZerosZerosZerosZerosZerosZeros.toSet intersect zeros.toSet\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosZerosZerosZerosZerosZerosZerosCount is already defined\
    \ as \e[33mvalue\e[0m \e[35monesZerosZerosZerosZerosZerosZerosZerosCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpdfpm5h7k.scala:21:44 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36monesZerosZerosZerosZerosCount\e[0m = onesZerosZerosZeros.toSet\
    \ intersect zeros.toSet\n\e[31m\e[31m   |\e[0m                               \
    \             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                    Not found: onesZerosZerosZeros\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdfpm5h7k.scala:22:49 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesZerosZerosZerosZerosZerosCount\e\
    [0m = onesZerosZerosZerosZeros.toSet intersect zeros.toSet\n\e[31m\e[31m   |\e\
    [0m"
  stdout: ''
  timestamp: 1659795221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.filter(_\
    \ % 2 == 0).max\n        val maxZeros = arr.filter(_ % 2 == 1).max\n        val\
    \ maxOnesDec = maxOnes.toString.toInt\n        val maxZerosDec = maxZeros.toString.toInt\n\
    \        val maxOnesBin = maxOnes.toString.toBinaryString\n        val maxZerosBin\
    \ = maxZeros.toString.toBinaryString\n        val maxOnesBinDec = maxOnesBin.toString.toInt\n\
    \        val maxZerosBinDec = maxZerosBin.toString.toInt\n        val maxOnesBinBin\
    \ = maxOnesBin.toString.toBinaryString\n        val maxZerosBinBin = maxZerosBin.toString.toBinaryString\n\
    \        val maxOnesBinBinDec = maxOnesBinBin.toString.toInt\n        val maxZerosBinBinDec\
    \ = maxZerosBinBin.toString.toInt\n        val maxOnesBinBinBinBin = maxOnesBinBin.toString.toBinaryString\n\
    \        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n    \
    \    val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val maxZerosBinBinDec\
    \ = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBinBin = maxOnesBinBinBin.toString.toBinaryString\n\
    \        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n    \
    \    val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val maxZerosBinBinDec\
    \ = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBinBin = maxOnesBinBinBin.toString.toBinaryString\n\
    \        val maxZerosBinBinBin = maxZerosBinBin.toString.toBinaryString\n    \
    \    val maxOnesBinBinBinDec = maxOnesBinBinDec.toString.toInt\n        val maxZerosBinBinDec\
    \ = maxZerosBinBinDec.toString.toInt\n        val maxOnesBinBinBinBin = maxOnesBinBinBin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgwnjnmfr.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosBinBinDec\e[0m =\
    \ maxZerosBinBinDec.toString.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosBinBinDec is already defined as \e[33mvalue\e[0m \e\
    [35mmaxZerosBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgwnjnmfr.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesBinBinBinBin\e[0m\
    \ = maxOnesBinBinBin.toString.toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesBinBinBinBin is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxOnesBinBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgwnjnmfr.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosBinBinBin\e[0m =\
    \ maxZerosBinBin.toString.toBinaryString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosBinBinBin is already defined as \e[33mvalue\e[0m \e\
    [35mmaxZerosBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgwnjnmfr.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesBinBinBinDec\e[0m\
    \ = maxOnesBinBinDec.toString.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxOnesBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming"
  stdout: ''
  timestamp: 1659795221
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val onesCount = ones.toSet\n        val sortedArray = arr.sortWith((x,\
    \ y) => onesCount.contains(y) - onesCount.contains(x))\n        sortedArray\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8l5g4jzo.scala:14:68\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e\
    [0m = arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => onesCount.contains(y) - onesCount.contains(x))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \           Found:    (y : Long)\n\e[31m   |\e[0m                            \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp8l5g4jzo.scala:14:92 --------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msortedArray\e[0m = arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => onesCount.contains(y) - onesCount.contains(x))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                                 Found:    (x : Long)\n\e[31m   |\e[0m      \
    \                                              Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = arr.count(x => x == 1)\n\
    \        val twos_count = arr.count(x => x == 2)\n        val threes_count = arr.count(x\
    \ => x == 3)\n        val fours_count = arr.count(x => x == 4)\n        val fives_count\
    \ = arr.count(x => x == 5)\n        val sixes_count = arr.count(x => x == 6)\n\
    \        val sevens_count = arr.count(x => x == 7)\n        val eights_count =\
    \ arr.count(x => x == 8)\n        val nines_count = arr.count(x => x == 9)\n \
    \       val tens_count = arr.count(x => x == 10)\n        val hundreds_count =\
    \ arr.count(x => x == 11)\n        val thousands_count = arr.count(x => x == 100)\n\
    \        val ten_thousands_count = arr.count(x => x == 1000)\n        val hundred_thousands_count\
    \ = arr.count(x => \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpehztlskm.scala:44:52 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mhundred_thousands_count\e\
    [0m = arr.count(\e[36mx\e[0m => \n\e[31m\e[31m   |\e[0m                      \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpehztlskm.scala:28:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e\
    [0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                              number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e["
  stdout: ''
  timestamp: 1659795222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 10000000000000000000000000000000001)\n        val decillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000010)\n        val undecillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000011)\n        val decillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000100)\n        val undecillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000101)\n        val decillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001000)\n        val undecillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001001)\n        val decillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010000)\n        val undecillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010001)\n        val decillionsFive = arr.count(_\
    \ == 100000000000000000000000000000000100000)\n        val undecillionsFive =\
    \ arr.count(_ == 100000000000000000000000000000000100001)\n        val decillionsSix\
    \ = arr.count(_ == 1000000000000000000000000000000001000000)\n        val undecillion\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8xxvypl.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmph8xxvypl.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:30:41 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:31:40 -------------------------------"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val elevens = arr.filter(x\
    \ => x % 11 == 0).length\n        val twelves = arr.filter(x => x % 12 == 0).length\n\
    \        val thirteens = arr.filter(x => x % 13 == 0).length\n        val fourteens\
    \ = arr.filter(x => x % 14 == 0).length\n        val fifteens = arr.filter(x =>\
    \ x % 15 == 0).length\n        val sixteens = arr.filter(x => x % 16 == 0).length\n\
    \        val seventeens = arr.filter(x => x % 17 == 0).length\n        val eighteens\
    \ = arr.filter(x => x % 18 == 0).length\n        val nineteens = arr.filter(x\
    \ => x % 19 == 0).length\n        val twenties = arr.filter(x => x % 20 == 0).length\n\
    \        val thirties = arr.filter(x => x % 30 == 0).length\n        val forties\
    \ = arr.filter(x => x % 40 == 0).length\n        val fifties = arr.filter(x =>\
    \ x % 50 == 0).length\n        val sixties = arr.filter(x => x % 60 == 0).length\n\
    \        val seventies = arr.filter(x => x % 70 == 0).length\n        val eighties\
    \ = arr.filter(x => x % 80 == 0).length\n        val nineties = arr.filter(x =>\
    \ x % 90 == 0).length\n        val hundreds = arr.filter(x => x % 100 == 0).length\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).length\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).length\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).length\n        val trillions = arr.filter(x => x %\
    \ 1000000000000 == \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplwv17q12.scala:43:60 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                      expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmplwv17q12.scala:43:44 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \e[31m1000000000000\e[0m == \n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                       number too large\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplwv17q12.scala:44:5 ---------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val decimal = arr.filter(_\
    \ % 2 == 0).sum / 2\n        val decimal2 = arr.filter(_ % 2 == 1).sum / 2\n \
    \       val decimal3 = arr.filter(_ % 2 == 0).sum / 3\n        val decimal4 =\
    \ arr.filter(_ % 2 == 1).sum / 3\n        val decimal5 = arr.filter(_ % 2 == 0).sum\
    \ / 5\n        val decimal6 = arr.filter(_ % 2 == 1).sum / 5\n        val decimal7\
    \ = arr.filter(_ % 2 == 0).sum / 7\n        val decimal8 = arr.filter(_ % 2 ==\
    \ 1).sum / 7\n        val decimal9 = arr.filter(_ % 2 == 0).sum / 9\n        val\
    \ decimal10 = arr.filter(_ % 2 == 1).sum / 9\n        val decimal11 = arr.filter(_\
    \ % 2 == 0).sum / 11\n        val decimal12 = arr.filter(_ % 2 == 1).sum / 11\n\
    \        val decimal13 = arr.filter(_ % 2 == 0).sum / 13\n        val decimal14\
    \ = arr.filter(_ % 2 == 1).sum / 13\n        val decimal15 = arr.filter(_ % 2\
    \ == 0).sum / 15\n        val decimal16 = arr.filter(_ % 2 == 1).sum / 15\n  \
    \      val decimal17 = arr.filter(_ % 2 == 0).sum / 17\n        val decimal18\
    \ = arr.filter(_ % 2 == 1).sum / 17\n        val decimal19 = arr.filter(_ % 2\
    \ == 0).sum / 19\n        val decimal20 = arr.filter(_ % 2 == 1).sum / 19\n  \
    \      val decimal21 = arr.filter(_ % 2 == 0).sum / 21\n        val decimal22\
    \ = arr.filter(_ % 2 == 1).sum / 21\n        val decimal23 = arr.filter(_ % 2\
    \ == 0).sum / 23\n        val decimal24 = arr.filter(_ % 2 == 1).sum / 23\n  \
    \      val decimal25 = arr.filter(_ % 2 == 0).sum / 25\n        val decimal26\
    \ = arr.filter(_ % 2 == 1).sum / 25\n        val decimal27 = arr.filter(_ % 2\
    \ == 0).sum / 27\n        val decimal28 = arr.filter(_ % 2 == 1).sum / 27\n  \
    \      val decimal29 = arr.filter(_ % 2 == 0).sum / 29\n        val decimal30\
    \ = arr.filter(_ % 2 == 1).sum / 29\n        val decimal31 = arr.filter(_ % 2\
    \ == 0).sum / 31\n        val decimal32 = arr.filter(_ % 2 == 1).sum / 31\n  \
    \      val decimal33 = arr.filter(_ % 2 == 0).sum / 33\n        val decimal34\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbt8368vc.scala:47:23 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mdecimal34\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpbt8368vc.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.count(_ > 0)\n  \
    \      val twos_count = twos.count(_ > 0)\n        val threes_count = threes.count(_\
    \ > 0)\n        val fours_count = fours.count(_ > 0)\n        val fives_count\
    \ = fives.count(_ > 0)\n        val sixes_count = sixes.count(_ > 0)\n       \
    \ val sevens_count = sevens.count(_ > 0)\n        val eights_count = eights.count(_\
    \ > 0)\n        val nines_count = nines.count(_ > 0)\n        val tens_count =\
    \ tens.count(_ > 0)\n        val hundreds_count = hundreds.count(_ > 0)\n    \
    \    val thousands_count = thousands.count(_ > 0)\n        val ten_thousands_count\
    \ = ten_thousands.count(_ > 0)\n        val hundred_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6vqvv276.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp6vqvv276.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 1 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 1 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 1 else 0)\n        val fives = arr.map(x => if (x == 5) 1 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 1 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 1 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 1 else 0)\n        val nines = arr.map(x => if (x == 9) 1 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 1 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 1 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 1 else 0)\n        val millions = arr.map(x => if (x == 1000) 1 else\
    \ 0)\n        val billions = arr.map(x => if (x == 10000) 1 else 0)\n        val\
    \ trillions = arr.map(x => if (x == 100000) 1 else 0)\n        val quadrillions\
    \ = arr.map(x => if (x == 1000000) 1 else 0)\n        val quintillions = arr.map(x\
    \ => if (x == 100000000) 1 else 0)\n        val onesAndZeroes = arr.map(x => if\
    \ (x == 1) 0 else 1)\n        val onesAndOnes = arr.map(x => if (x == 1) 1 else\
    \ 0)\n        val onesAndTwos = arr.map(x => if (x == 1) 2 else 0)\n        val\
    \ onesAndThrees = arr.map(x => if (x == 1) 3 else 0)\n        val onesAndFours\
    \ = arr.map(x => if (x == 1) 4 else 0)\n        val onesAndFives = arr.map(x =>\
    \ if (x == 1) 5 else 0)\n        val onesAndSixes = arr.map(x => if (x == 1) 6\
    \ else 0)\n        val onesAndSevens = arr.map(x => if (x == 1) 7 else 0)\n  \
    \      val onesAndEights = arr.map(x => if (x == 1) 8 else 0)\n        val onesAndNines\
    \ = arr.map(x => if (x == 1) 9 else 0)\n        val onesAndTens = arr.map(x =>\
    \ if (x == 1) 10 else 0)\n        val onesAndHundreds = arr.map(x => if (x ==\
    \ 1) 11 else 0)\n        val onesAndThousands = arr.map(x => if (x == 1) 100 else\
    \ 0)\n        val onesAndMillions = arr.map(x => if (x == 1) 1000 else 0)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfq1wt4u.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 1 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 1 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 1 else 0)\n        val fives = arr.map(x => if (x == 5) 1 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 1 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 1 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 1 else 0)\n        val nines = arr.map(x => if (x == 9) 1 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 1 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 1 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 1 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 1 else\
    \ 0)\n        val millions = arr.map(x => if (x == 1000000) 1 else 0)\n      \
    \  val billions = arr.map(x => if (x == 1000000000) 1 else 0)\n        val trillions\
    \ = arr.map(x => if (x == 1000000000000) 1 else 0)\n        val quadrillions =\
    \ arr.map(x => if (x == 1000000000000000) 1 else 0)\n        val quintillions\
    \ = arr.map(x => if (x == 1000000000000000000) 1 else 0)\n        val ones_count\
    \ = ones.count(_ > 0)\n        val twos_count = twos.count(_ > 0)\n        val\
    \ threes_count = threes.count(_ > 0)\n        val fours_count = fours.count(_\
    \ > 0)\n        val fives_count = fives.count(_ > 0)\n        val sixes_count\
    \ = sixes.count(_ > 0)\n        val sevens_count = sevens.count(_ > 0)\n     \
    \   val eights_count = eights.count(_ > 0)\n        val nines_count = nines.count(_\
    \ > 0)\n        val tens_count = tens.count(_ > 0)\n        val hundreds_count\
    \ = hundreds.count(_ > 0)\n        val thousands_count = thousands.count(_ > 0)\n\
    \        val ten_thousands_count = ten_thousands.count(_ > 0)\n        val hundred_thousands_count\
    \ = hundred_thousands.count(_ > 0)\n        val millions_count = millions.\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps7l4063f.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmps7l4063f.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmps7l4063f.scala:29:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000000\e[0m) \e[31m1\e[0m \e\
    [33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                           \
    \                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmps7l4063f.scala:30:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000000\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 number too\
    \ large\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps7l4063f.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n\
    \        val zerosArr = arr.filter(_ == 0)\n        val onesCount = onesArr.size\n\
    \        val zerosCount = zerosArr.size\n        val onesDecimal = onesArr.map(_.toString.toInt)\n\
    \        val zerosDecimal = zerosArr.map(_.toString.toInt)\n        val onesDecimalCount\
    \ = onesDecimal.size\n        val zerosDecimalCount = zerosDecimal.size\n    \
    \    val onesDecimalCount = onesDecimalCount.toInt\n        val zerosDecimalCount\
    \ = zerosDecimalCount.toInt\n        val onesDecimalCount = onesDecimalCount.toInt\n\
    \        val zerosDecimalCount = zerosDecimalCount.toInt\n        val onesDecimalCount\
    \ = onesDecimalCount.toInt\n        val zerosDecimalCount = zerosDecimalCount.toInt\n\
    \        val onesDecimalCount = onesDecimalCount.toInt\n        val zerosDecimalCount\
    \ = zerosDecimalCount.toInt\n        val onesDecimalCount = onesDecimalCount.toInt\n\
    \        val zerosDecimalCount = zerosDecimalCount.toInt\n        val onesDecimalCount\
    \ = onesDecimalCount.toInt\n        val zerosDecimalCount = zerosDecimalCount.toInt\n\
    \        val onesDecimalCount = onesDecimalCount.toInt\n        val zerosDecimalCount\
    \ = zerosDecimalCount.toInt\n        val onesDecimalCount = onesDecimalCount.toInt\n\
    \        val zerosDecimalCount = zerosDecimalCount.toInt\n        val onesDecimalCount\
    \ = onesDecimalCount.toInt\n        val zerosDecimalCount = zerosDecimalCount.toInt\n\
    \        val onesDecimalCount = onesDecimalCount.toInt\n        val zerosDecimalCount\
    \ = zerosDecimalCount.toInt\n        val onesDecimalCount = onesDecimalCount.toInt\n\
    \        val zerosDecimalCount = zerosDecimalCount.toInt\n        val onesDecimalCount\
    \ = onesDecimalCount.toInt\n        val zerosDecimalCount = zerosDecimalCount.toInt\n\
    \        val onesDecimalCount = onesDecimalCount.toInt\n        val zerosDecimalCount\
    \ = zerosDecimalCount.toInt\n        val onesDecimalCount = onesDecimalCount.toInt\n\
    \        val zerosDecimalCount = zerosDecimalCount.toInt\n        val onesDecimalCount\
    \ = onesDecimalCount.toInt\n        val zerosDecimalCount = zerosDecimalCount.toInt\n\
    \        val onesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplrjzcpxq.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplrjzcpxq.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimalCount\e[0m = onesDecimalCount.toInt\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesDecimalCount\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalCount\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplrjzcpxq.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m = zerosDecimalCount.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplrjzcpxq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ onesDecimalCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplrjzcpxq.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosDecimalCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in "
  stdout: ''
  timestamp: 1659795224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val onesArr = arr.filter(x\
    \ => x == 1).map(x => x.toBinaryString).sorted\n        val zerosArr = arr.filter(x\
    \ => x == 0).map(x => x.toBinaryString).sorted\n        val onesCount = onesArr.length\n\
    \        val zerosCount = zerosArr.length\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / zerosDecimal\n        val zerosDecimalDecimal\
    \ = zerosDecimal / onesDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal\
    \ / zerosDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / onesDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal /\
    \ zerosDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp55n6a26m.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp55n6a26m.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp55n6a26m.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp55n6a26m.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDec"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val twos = arr.count(x => x == 2)\n        val threes = arr.count(x =>\
    \ x == 3)\n        val fours = arr.count(x => x == 4)\n        val fives = arr.count(x\
    \ => x == 5)\n        val sixes = arr.count(x => x == 6)\n        val sevens =\
    \ arr.count(x => x == 7)\n        val eights = arr.count(x => x == 8)\n      \
    \  val nines = arr.count(x => x == 9)\n        val tens = arr.count(x => x ==\
    \ 10)\n        val hundreds = arr.count(x => x == 100)\n        val thousands\
    \ = arr.count(x => x == 1000)\n        val millions = arr.count(x => x == 1000000)\n\
    \        val billions = arr.count(x => x == 1000000000)\n        val trillions\
    \ = arr.count(x => x == 1000000000000)\n        val quadrillions = arr.count(x\
    \ => x == 1000000000000000)\n        val quintillions = arr.count(x => x == 1000000000000000000)\n\
    \        val onesAndZeroes = arr.count(x => x == 1)\n        val onesAndOnes =\
    \ arr.count(x => x == 1 && x > 0)\n        val onesAndTwos = arr.count(x => x\
    \ == 1 && x > 1)\n        val onesAndThrees = arr.count(x => x == 1 && x > 2)\n\
    \        val onesAndFours = arr.count(x => x == 1 && x > 3)\n        val onesAndFives\
    \ = arr.count(x => x == 1 && x > 4)\n        val onesAndSixes = arr.count(x =>\
    \ x == 1 && x > 5)\n        val onesAndSevens = arr.count(x => x == 1 && x > 6)\n\
    \        val onesAndEights = arr.count(x => x == 1 && x > 7)\n        val onesAndNines\
    \ = arr.count(x => x == 1 && x > 8)\n        val onesAndTens = arr.count(x =>\
    \ x == 1 && x > 9)\n        val onesAndHundreds = arr.count(x => x == 1 && x >\
    \ 100)\n        val onesAndThousands = arr.count(x => x == 1 && x > 1000)\n  \
    \      val onesAndMillions = arr.count(x => x == 1 && x > 1000000)\n        val\
    \ onesAndBillions = arr.count(x => x == 1 && x > 1000000000)\n        val onesAndTrillions\
    \ = arr.count(x => x == 1 && x > 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(x => x == 1 && x > 1000000000000000)\n        val onesAndQuintillions\
    \ = arr.count(x => x == 1 && x > 1000000000000000000\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcw7cbx0z.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpcw7cbx0z.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e[36mx\e[0m => x == \e[31m1000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpcw7cbx0z.scala:27:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpcw7cbx0z.scala:28:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpcw7cbx0z.scala:44:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndTrillions\e[0m =\
    \ arr.count(\e[36mx\e[0m => x == \e[31m1\e[0m && x > \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \                   number too large\n\e[31m\e[31m-- Error: /tmp/tmpcw7cbx0z.scala:45:63\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m45 |\e[0m       \
    \ \e[33mval\e[0m \e[36monesAndQuadrillions\e[0m = arr.count(\e[36mx\e[0m => x\
    \ == \e[31m1\e[0m && x > \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                                              ^^^^^"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val decimals = arr.filter(_\
    \ % 10 == 0).length\n        val decimalsDecimals = arr.filter(_ % 10 == 1).length\n\
    \        val decimalsDecimalsDecimals = arr.filter(_ % 10 == 2).length\n     \
    \   val decimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 3).length\n  \
    \      val decimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 4).length\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ %\
    \ 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 0).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 1).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 2).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 3).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 4).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 5).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).length\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsb6efq8n.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsb6efq8n.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpsb6efq8n.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m2\e[0m).length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpsb6efq8n.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659795224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).size\n        val twos = arr.filter(x => x % 2 == 1).size\n        val threes\
    \ = arr.filter(x => x % 3 == 0).size\n        val fours = arr.filter(x => x %\
    \ 4 == 0).size\n        val fives = arr.filter(x => x % 5 == 0).size\n       \
    \ val sixes = arr.filter(x => x % 6 == 0).size\n        val sevens = arr.filter(x\
    \ => x % 7 == 0).size\n        val eights = arr.filter(x => x % 8 == 0).size\n\
    \        val nines = arr.filter(x => x % 9 == 0).size\n        val tens = arr.filter(x\
    \ => x % 10 == 0).size\n        val hundreds = arr.filter(x => x % 100 == 0).size\n\
    \        val thousands = arr.filter(x => x % 1000 == 0).size\n        val millions\
    \ = arr.filter(x => x % 1000000 == 0).size\n        val billions = arr.filter(x\
    \ => x % 1000000000 == 0).size\n        val trillions = arr.filter(x => x % 1000000000000\
    \ == 0).size\n        val quadrillions = arr.filter(x => x % 1000000000000000\
    \ == 0).size\n        val quintillions = arr.filter(x => x % 1000000000000000000\
    \ == 0).size\n        val onesAndZeros = arr.filter(x => x == 1).size\n      \
    \  val onesAndOnes = arr.filter(x => x == 1).size - onesAndZeros\n        val\
    \ twosAndZeros = arr.filter(x => x == 2).size\n        val twosAndOnes = arr.filter(x\
    \ => x == 2).size - twosAndZeros\n        val threesAndZeros = arr.filter(x =>\
    \ x == 3).size\n        val threesAndOnes = arr.filter(x => x == 3).size - threesAndZeros\n\
    \        val foursAndZeros = arr.filter(x => x == 4).size\n        val foursAndOnes\
    \ = arr.filter(x => x == 4).size - foursAndZeros\n        val fivesAndZeros =\
    \ arr.filter(x => x == 5).size\n        val fivesAndOnes = arr.filter(x => x ==\
    \ 5).size - fivesAndZeros\n        val sixesAndZeros = arr.filter(x => x == 6).size\n\
    \        val sixesAndOnes = arr.filter(x => x == 6).size - sixesAndZeros\n   \
    \     val sevensAndZeros = arr.filter(x => x == 7).size\n        val sevensAndOnes\
    \ = arr.filter(x \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzfy18d7k.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpzfy18d7k.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                  number too large\n\e[31m\e[31m-- Error: /tmp/tmpzfy18d7k.scala:27:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                           number too large\n\e[31m\e[31m-- Error: /tmp/tmpzfy18d7k.scala:28:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).size\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                              number too large\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpzfy18d7k.scala:42:39 ------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m        \e[33mval\e[0m \e[36msevensAndOnes\e[0m = arr.filter(x \n\e[31m\e\
    [31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m  \
    \                                     Not found: x\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzfy18d7k.scala:43:5 ---------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling wi"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesDecimal = maxOnes.toDouble\
    \ / maxOnes.toDouble.toInt\n        val maxZerosDecimal = maxZeros.toDouble /\
    \ maxZeros.toDouble.toInt\n        val maxDecimal = math.max(maxOnesDecimal, maxZerosDecimal)\n\
    \        val onesDecimal = ones.toDouble / ones.toDouble.toInt\n        val zerosDecimal\
    \ = zeros.toDouble / zeros.toDouble.toInt\n        val decimal = math.max(onesDecimal,\
    \ zerosDecimal)\n        val onesDecimal = ones.toDouble / ones.toDouble.toInt\n\
    \        val zerosDecimal = zeros.toDouble / zeros.toDouble.toInt\n        val\
    \ decimal = math.max(onesDecimal, zerosDecimal)\n        val onesDecimal = ones.toDouble\
    \ / ones.toDouble.toInt\n        val zerosDecimal = zeros.toDouble / zeros.toDouble.toInt\n\
    \        val decimal = math.max(onesDecimal, zerosDecimal)\n        val onesDecimal\
    \ = ones.toDouble / ones.toDouble.toInt\n        val zerosDecimal = zeros.toDouble\
    \ / zeros.toDouble.toInt\n        val decimal = math.max(onesDecimal, zerosDecimal)\n\
    \        val onesDecimal = ones.toDouble / ones.toDouble.toInt\n        val zerosDecimal\
    \ = zeros.toDouble / zeros.toDouble.toInt\n        val decimal = math.max(onesDecimal,\
    \ zerosDecimal)\n        val onesDecimal = ones.toDouble / ones.toDouble.toInt\n\
    \        val zerosDecimal = zeros.toDouble / zeros.toDouble.toInt\n        val\
    \ decimal = math.max(onesDecimal, zerosDecimal)\n        val onesDecimal = ones.toDouble\
    \ / ones.toDouble.toInt\n        val zerosDecimal = zeros.toDouble / zeros.toDouble.toInt\n\
    \        val decimal = math.max(onesDecimal, zerosDecimal)\n        val onesDecimal\
    \ = ones.toDouble / ones.toDouble.toInt\n        val zerosDecimal = zeros.toDouble\
    \ / zeros.toDouble.toInt\n        val decimal = math.max(onesDecimal, zerosDecimal)\n\
    \        val onesDecimal = ones.toDouble / ones.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6kpld1hb.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6kpld1hb.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = ones.toDouble / ones.toDouble.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6kpld1hb.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = zeros.toDouble /\
    \ zeros.toDouble.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimal is already defined as \e[33mvalue\e[0m \e[35mzerosDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6kpld1hb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mdecimal\e[0m = math.max(onesDecimal,\
    \ zerosDecimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimal is already defined as \e[33mvalue\e[0m \e[35mdecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6kpld1hb.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = ones.toDouble / ones.toDouble.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all "
  stdout: ''
  timestamp: 1659795223
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(x => math.abs(x))\n        val decimalsArr = arr.filter(_ %\
    \ 2 == 1).sortBy(x => math.abs(x))\n        onesArr.zip(decimalsArr).sortBy(x\
    \ => x._1 - x._2).map(x => x._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph344x98z.scala:19)\n\tat Problem.main(tmph344x98z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795226
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toSet.size\n        val zerosCount = zeros.toSet.size\n   \
    \     val onesZeros = ones.toSet & zeros.toSet\n        val onesZeroCount = onesZeros.size\n\
    \        val onesZeroSum = onesZeros.toSet.sum\n        val onesZeroSumCount =\
    \ onesZeroSum.toSet.size\n        val onesZeroSumSum = onesZeroSum.toSet.sum\n\
    \        val onesZeroSumSumCount = onesZeroSumSum.toSet.size\n        val onesZeroSumSumSum\
    \ = onesZeroSumSum.toSet.sum\n        val onesZeroSumSumSumCount = onesZeroSumSumSum.toSet.size\n\
    \        val onesZeroSumSumSumSum = onesZeroSumSumSum.toSet.sum\n        val onesZeroSumSumSumSumCount\
    \ = onesZeroSumSumSumSum.toSet.size\n        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSum.toSet.sum\n\
    \        val onesZeroSumSumSumSumCount = onesZeroSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSumSum.toSet.sum\n   \
    \     val onesZeroSumSumSumSumSumCount = onesZeroSumSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSumSum.toSet.sum\n   \
    \     val onesZeroSumSumSumSumSumCount = onesZeroSumSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSumSum.toSet.sum\n   \
    \     val onesZeroSumSumSumSumSumCount = onesZeroSumSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSumSum.toSet.sum\n   \
    \     val onesZeroSumSumSumSumSumCount = onesZeroSumSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSumSum = onesZeroSumSumSumSumSum.toSet.sum\n   \
    \     val onesZeroSumSumSumSumSumCount = onesZeroSumSumSumSumSumCount.toSet.size\n\
    \        val onesZeroSumSumSumSum\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp01b3ryal.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp01b3ryal.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZeroSumSumSumSumCount\e[0m = onesZeroSumSumSumSumCount.toSet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroSumSumSumSumCount is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroSumSumSumSumCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp01b3ryal.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36monesZeroSumSumSumSumSum\e\
    [0m = onesZeroSumSumSumSumSum.toSet.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroSumSumSumSumSum is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroSumSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp01b3ryal.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesZeroSumSumSumSumSum\e\
    [0m = onesZeroSumSumSumSumSum.toSet.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroSumSumSumSumSum is already defined as \e[33mvalue\e\
    [0m \e[35monesZeroSumSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp01b3ryal.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36monesZeroSumSumSumSumSumCount\e\
    [0m = onesZeroSumSumSumSumSumCount.toSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_and_zeros = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val ones_and_ones = arr.map(x => if (x == 1) 1 else\
    \ 1)\n        val ones_and_twos = arr.map(x => if (x == 1) 1 else 2)\n       \
    \ val ones_and_threes = arr.map(x => if (x == 1) 1 else 3)\n        val ones_and_fours\
    \ = arr.map(x => if (x == 1) 1 else 4)\n        val ones_and_fives = arr.map(x\
    \ => if (x == 1) 1 else 5)\n        val ones_and_sixes = arr.map(x => if (x ==\
    \ 1) 1 else 6)\n        val ones_and_sevens = arr.map(x => if (x == 1) 1 else\
    \ 7)\n        val ones_and_eights = arr.map(x => if (x == 1) 1 else 8)\n     \
    \   val ones_and_nines = arr.map(x => if (x == 1) 1 else 9)\n        val ones_and_tens\
    \ = arr.map(x => if (x == 1) \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_uxlo65z.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp_uxlo65z.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmp_uxlo65z.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmp_uxlo65z.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp_uxlo65z.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp_uxlo65z.scala:30:49 -------------------"
  stdout: ''
  timestamp: 1659795224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 100000000000000000000)\n        val\
    \ septillions = arr.count(_ == 10000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 100000000000000000000000000)\n        val decillions = arr.count(_ == 10000000000000000000000000000)\n\
    \        val undecillions = arr.count(_ == 1000000000000000000000000000000)\n\
    \        val duodecillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val tredecillions = arr.count(_ == 1000000000000000000000000000000000)\
    \ \n        val quattuordecillions = arr.count(_ == 1000000000000000000000000000000000)\n\
    \        val sexdecillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val septendecillions = arr.count(_ == 1000000000000000000000000000000000)\n\
    \        val octodecillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val novemdecillions = arr.count(_ == 1000000000000000000000000000000000)\
    \ \n        val vigintillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val unvigintillions = arr.count(_ == 1000000000000000000000000000000000)\n\
    \        val duovigintillions = arr.count(_ == 100000000000000000000000000000000)\n\
    \        val trevigintillions = arr.count(_ == 1000000000000000000000000000000000)\
    \ \n        val quattuorvigintillions = arr.count(_ == 100000000000000000000000000000000\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl43ht6u4.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpl43ht6u4.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpl43ht6u4.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpl43ht6u4.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpl43ht6u4.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m100000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \                         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpl43ht6u4.scala:30:41\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_ == \e[31m10000000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpl43ht6u4.scala:31:40 ---------------------------------------"
  stdout: ''
  timestamp: 1659795224
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toSet.size\n        val zerosCount = zeros.toSet.size\n   \
    \     val onesZeros = ones.toSet.intersect(zeros.toSet)\n        val onesZeroCount\
    \ = onesZeros.size\n        val onesZeroSum = onesZeros.sum\n        val onesZeroSumCount\
    \ = onesZeroSum.toSet.size\n        val onesZeroSumCount = onesZeroSumCount.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZeroSum.toInt\n\
    \        val onesZeroSum = onesZeroSum.toInt\n        val onesZeroSum = onesZero\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwl1udvml.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesZeroSumCount\e[0m =\
    \ onesZeroSumCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZeroSumCount is already defined as \e[33mvalue\e[0m \e\
    [35monesZeroSumCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwl1udvml.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum\e[0m = onesZeroSum.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeroSum is already defined as \e[33mvalue\e[0m \e[35monesZeroSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwl1udvml.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum\e[0m = onesZeroSum.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeroSum is already defined as \e[33mvalue\e[0m \e[35monesZeroSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwl1udvml.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum\e[0m = onesZeroSum.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesZeroSum is already defined as \e[33mvalue\e[0m \e[35monesZeroSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwl1udvml.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36monesZeroSum\e[0m = onesZeroSum.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mo"
  stdout: ''
  timestamp: 1659795225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val twos = arr.filter(x => x == 2).length\n        val threes = arr.filter(x\
    \ => x == 3).length\n        val fours = arr.filter(x => x == 4).length\n    \
    \    val fives = arr.filter(x => x == 5).length\n        val sixes = arr.filter(x\
    \ => x == 6).length\n        val sevens = arr.filter(x => x == 7).length\n   \
    \     val eights = arr.filter(x => x == 8).length\n        val nines = arr.filter(x\
    \ => x == 9).length\n        val tens = arr.filter(x => x == 10).length\n    \
    \    val hundreds = arr.filter(x => x == 11).length\n        val thousands = arr.filter(x\
    \ => x == 12).length\n        val millions = arr.filter(x => x == 13).length\n\
    \        val billions = arr.filter(x => x == 14).length\n        val trillions\
    \ = arr.filter(x => x == 15).length\n        val quadrillions = arr.filter(x =>\
    \ x == 16).length\n        val quintillions = arr.filter(x => x == 17).length\n\
    \        val sextillions = arr.filter(x => x == 18).length\n        val septillions\
    \ = arr.filter(x => x == 19).length\n        val octillions = arr.filter(x =>\
    \ x == 20).length\n        val nonillions = arr.filter(x => x == 21).length\n\
    \        val decillions = arr.filter(x => x == 22).length\n        val undecillions\
    \ = arr.filter(x => x == 23).length\n        val duodecillions = arr.filter(x\
    \ => x == 24).length\n        val tredecillions = arr.filter(x => x == 25).length\n\
    \        val quattuordecillions = arr.filter(x => x == 26).length\n        val\
    \ quindecillions = arr.filter(x => x == 27).length\n        val sexdecillions\
    \ = arr.filter(x => x == 28).length\n        val septendecillions = arr.filter(x\
    \ => x == 29).length\n        val octodecillions = arr.filter(x => x == 30).length\n\
    \        val novemdecillions = arr.filter(x => x == 31).length\n        val vigintillions\
    \ = arr.filter(x => x == 32).length\n        val unvigintillions = arr.filter(x\
    \ => x == 33).length\n        val duovigintillions = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpucz0ktsr.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpucz0ktsr.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 1 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 1 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 1 else 0)\n        val fives = arr.map(x => if (x == 5) 1 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 1 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 1 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 1 else 0)\n        val nines = arr.map(x => if (x == 9) 1 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 1 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 1 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 1 else 0)\n        val millions = arr.map(x => if (x == 1000) 1 else\
    \ 0)\n        val billions = arr.map(x => if (x == 10000) 1 else 0)\n        val\
    \ trillions = arr.map(x => if (x == 100000) 1 else 0)\n        val quadrillions\
    \ = arr.map(x => if (x == 1000000) 1 else 0)\n        val quintillions = arr.map(x\
    \ => if (x == 100000000) 1 else 0)\n        val onesAndZeros = ones + twos + threes\
    \ + fours + fives + sixes + sevens + eights + nines + tens + hundreds + thousands\
    \ + millions + billions + trillions + quadrillions + quintillions\n        val\
    \ onesAndOnes = ones + ones\n        val onesAndTwos = ones + twos\n        val\
    \ onesAndThrees = ones + threes\n        val onesAndFours = ones + fours\n   \
    \     val onesAndFives = ones + fives\n        val onesAndSixes = ones + sixes\n\
    \        val onesAndSevens = ones + sevens\n        val onesAndEights = ones +\
    \ eights\n        val onesAndNines = ones + nines\n        val onesAndTens = ones\
    \ + tens\n        val onesAndHundreds = ones + hundreds\n        val onesAndThousands\
    \ = ones + thousands\n        val onesAndMillions = ones + millions\n        val\
    \ onesAndBillions = ones + billions\n        val onesAndTrilli\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyh6eeaz5.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyh6eeaz5.scala:29:32\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36monesAndZeros\e[0m = ones + twos + threes + fours + fives + sixes + sevens\
    \ + eights + nines + tens + hundreds + thousands + millions + billions + trillions\
    \ + quadrillions + quintillions\n\e[31m\e[31m   |\e[0m                       \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Int], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpyh6eeaz5.scala:30:31 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesAndOnes\e[0m = ones\
    \ + ones\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue + is not a member of List[Int], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyh6eeaz5.scala:31:31\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36monesAndTwos\e[0m = ones + twos\n\e[31m\e[31m   |\e[0m                    \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Int], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress to"
  stdout: ''
  timestamp: 1659795232
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesArr2 = onesArr.map(x => math.pow(2,\
    \ x))\n        val zerosArr2 = zerosArr.map(x => math.pow(2, x))\n        val\
    \ onesArr3 = onesArr2.zip(zerosArr2).sortBy(_._1).reverse\n        val zerosArr3\
    \ = zerosArr2.zip(onesArr2).sortBy(_._1).reverse\n        val onesArr4 = onesArr3.zip(zerosArr3).sortBy(_._1).reverse\n\
    \        val zerosArr4 = zerosArr3.zip(onesArr3).sortBy(_._1).reverse\n      \
    \  val onesArr5 = onesArr4.zip(zerosArr4).sortBy(_._1).reverse\n        val zerosArr5\
    \ = zerosArr4.zip(onesArr4).sortBy(_._1).reverse\n        val onesArr6 = onesArr5.zip(zerosArr5).sortBy(_._1).reverse\n\
    \        val zerosArr6 = zerosArr5.zip(onesArr5).sortBy(_._1).reverse\n      \
    \  val onesArr7 = onesArr6.zip(zerosArr6).sortBy(_._1).reverse\n        val zerosArr7\
    \ = zerosArr6.zip(onesArr6).sortBy(_._1).reverse\n        val onesArr8 = onesArr7.zip(zerosArr7).sortBy(_._1).reverse\n\
    \        val zerosArr8 = zerosArr7.zip(onesArr7).sortBy(_._1).reverse\n      \
    \  val onesArr9 = onesArr8.zip(zerosArr8).sortBy(_._1).reverse\n        val zerosArr9\
    \ = zerosArr8.zip(onesArr8).sortBy(_._1).reverse\n        val onesArr10 = onesArr9.zip(zerosArr9).sortBy(_._1).reverse\n\
    \        val zerosArr10 = zerosArr9.zip(onesArr9).sortBy(_._1).reverse\n     \
    \   val onesArr11 = onesArr10.zip(zerosArr10).sortBy(_._1).reverse\n        val\
    \ zerosArr11 = zerosArr10.zip(onesArr10).sortBy(_._1).reverse\n        val onesArr12\
    \ = onesArr11.zip(zerosArr11).sortBy(_._1).reverse\n        val zerosArr12 = zerosArr11.zip(onesArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx_ahm85w.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpx_ahm85w.scala:38:5 ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 1)\n        val onesArr = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val decimalsArr = arr.map(x => if (x > 1) x / 2 else\
    \ 0)\n        val decimalsArr = decimalsArr.sortBy(x => x)\n        val onesArr\
    \ = onesArr.sortBy(x => x)\n        val result = onesArr ++ decimalsArr\n    \
    \    val result = result.sortBy(x => x)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyi9hxn0l.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyi9hxn0l.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyi9hxn0l.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.sortBy(\e[36mx\e\
    [0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyi9hxn0l.scala:20:8 ---------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (result : List[AnyVal])\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795233
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesArr = arr.map(x => (x % 2).toLong)\n\
    \        val decimalsArr = arr.map(x => (x % 2).toLong)\n        val onesArr =\
    \ onesArr.sortWith(_ < _)\n        val decimalsArr = decimalsArr.sortWith(_ <\
    \ _)\n        onesArr.zip(decimalsArr).map(x => x._1 + x._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0l88oxti.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0l88oxti.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659795230
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val maxOnes = arr.max\n\
    \        val maxZeros = arr.min\n        val maxOnesDecimal = maxOnes.toString.toDouble\n\
    \        val maxZerosDecimal = maxZeros.toString.toDouble\n        val maxOnesDecimalDecimal\
    \ = maxOnesDecimal.toString.toDouble\n        val maxZerosDecimalDecimal = maxZerosDecimal.toString.toDouble\n\
    \        val onesDecimal = ones / arr.size\n        val zerosDecimal = zeros /\
    \ arr.size\n        val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal.toString.toDouble\n\
    \        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimal = onesDecimal.toString.toDouble\n        val zerosDecimalDecimal\
    \ = zerosDecimal.toString.toDouble\n        val maxOnesDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimal.toString.toDouble\n        val maxZerosDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimal.toString.toDouble\n        val onesDecimalDecimalDecimal\
    \ = onesDecimalDecimal.toString.toDouble\n        val zerosDecimalDecimalDecimal\
    \ = zerosDecimalDecimal.toString.toDouble\n        val maxOnesDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimal.toString.toDouble\n        val maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimal.toString.toDouble\n        val onesDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimal.toString.toDouble\n        val zerosDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimal.toString.toDouble\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n        val\
    \ maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimal = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplyjcouub.scala:40:60 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \            ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmplyjcouub.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplyjcouub.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimal.toString.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmplyjcouub.scala:41:5 ---------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m "
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val decimalsSorted = decimals.toList.sortBy(x\
    \ => math.abs(x))\n        val onesSorted = ones.toList.sortBy(x => math.abs(x))\n\
    \        onesSorted.zip(decimalsSorted).map(x => x._1 + x._2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmuf4u113.scala:14:38 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecimalsSorted\e[0m = decimals.toList.sortBy(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m                            \
    \ ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value toList is not a member of Int\
    \ - did you mean decimals.toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmuf4u113.scala:15:30\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36monesSorted\e[0m = ones.toList.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \    value toList is not a member of Int - did you mean ones.toInt?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ threes = arr.filter(x => x % 3 == 0).length\n        val fours = arr.filter(x\
    \ => x % 4 == 0).length\n        val fives = arr.filter(x => x % 5 == 0).length\n\
    \        val sixes = arr.filter(x => x % 6 == 0).length\n        val sevens =\
    \ arr.filter(x => x % 7 == 0).length\n        val eights = arr.filter(x => x %\
    \ 8 == 0).length\n        val nines = arr.filter(x => x % 9 == 0).length\n   \
    \     val tens = arr.filter(x => x % 10 == 0).length\n        val hundreds = arr.filter(x\
    \ => x % 100 == 0).length\n        val thousands = arr.filter(x => x % 1000 ==\
    \ 0).length\n        val millions = arr.filter(x => x % 1000000 == 0).length\n\
    \        val billions = arr.filter(x => x % 1000000000 == 0).length\n        val\
    \ trillions = arr.filter(x => x % 1000000000000 == 0).length\n        val quadrillions\
    \ = arr.filter(x => x % 1000000000000000 == 0).length\n        val quintillions\
    \ = arr.filter(x => x % 1000000000000000000 == 0).length\n        val onesAndZeros\
    \ = arr.filter(x => x % 1 == 0 && x != 0).length\n        val onesAndOnes = arr.filter(x\
    \ => x % 1 == 1 && x != 0).length\n        val onesAndTwos = arr.filter(x => x\
    \ % 1 == 2 && x != 0).length\n        val onesAndThrees = arr.filter(x => x %\
    \ 1 == 3 && x != 0).length\n        val onesAndFours = arr.filter(x => x % 1 ==\
    \ 4 && x != 0).length\n        val onesAndFives = arr.filter(x => x % 1 == 5 &&\
    \ x != 0).length\n        val onesAndSixes = arr.filter(x => x % 1 == 6 && x !=\
    \ 0).length\n        val onesAndSevens = arr.filter(x => x % 1 == 7 && x != 0).length\n\
    \        val onesAndEights = arr.filter(x => x % 1 == 8 && x != 0).length\n  \
    \      val onesAndNines = arr.filter(x => x % 1 == 9 && x != 0).length\n     \
    \   val onesAndTens = arr.filter(x => x % 1 == 10 && x != 0).length\n        val\
    \ onesAndHundreds = arr.filter(x => x % \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp76ghgk5q.scala:40:49 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36monesAndHundreds\e[0m = arr.filter(\e\
    [36mx\e[0m => x % \n\e[31m\e[31m   |\e[0m                                    \
    \             ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp76ghgk5q.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    number too large\n\e[31m\e[31m-- Error: /tmp/tmp76ghgk5q.scala:27:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             number too large\n\e[31m\e[31m-- Error: /tmp/tmp76ghgk5q.scala:28:47\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.filter(\e[36mx\e[0m => x % \e[31m1000000000000000000\e\
    [0m == \e[31m0\e[0m).length\n\e[31m\e[31m   |\e[0m                           \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                number too large\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp76ghgk5q.scala:41:5 ---------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n        val\
    \ decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = decs.map(_.toString.toInt)\n        val decs = decs.map(_.toString.toInt)\n\
    \        val decs = de\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe5chqpmx.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe5chqpmx.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe5chqpmx.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe5chqpmx.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe5chqpmx.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(_.toString.toInt)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e["
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / ones\n \
    \       val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv7bouyx0.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv7bouyx0.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpv7bouyx0.scala:28:68 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv7bouyx0.scala:34:89\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m                                              \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(x\
    \ => math.abs(x))\n        val zerosArr = arr.filter(_ == 0).sortBy(x => math.abs(x))\n\
    \        val onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n\
    \        val onesDec = onesArr.map(x => math.pow(2,x)).sum\n        val zerosDec\
    \ = zerosArr.map(x => math.pow(2,x)).sum\n        val onesDec2 = 0\n        val\
    \ zerosDec2 = 0\n        val onesDec3 = 0\n        val zerosDec3 = 0\n       \
    \ val onesDec4 = 0\n        val zerosDec4 = 0\n        val onesDec5 = 0\n    \
    \    val zerosDec5 = 0\n        val onesDec6 = 0\n        val zerosDec6 = 0\n\
    \        val onesDec7 = 0\n        val zerosDec7 = 0\n        val onesDec8 = 0\n\
    \        val zerosDec8 = 0\n        val onesDec9 = 0\n        val zerosDec9 =\
    \ 0\n        val onesDec10 = 0\n        val zerosDec10 = 0\n        val onesDec11\
    \ = 0\n        val zerosDec11 = 0\n        val onesDec12 = 0\n        val zerosDec12\
    \ = 0\n        val onesDec13 = 0\n        val zerosDec13 = 0\n        val onesDec14\
    \ = 0\n        val zerosDec14 = 0\n        val onesDec15 = 0\n        val zerosDec15\
    \ = 0\n        val onesDec16 = 0\n        val zerosDec16 = 0\n        val onesDec17\
    \ = 0\n        val zerosDec17 = 0\n        val onesDec18 = 0\n        val zerosDec18\
    \ = 0\n        val onesDec19 = 0\n        val zerosDec19 = 0\n        val onesDec20\
    \ = 0\n        val zerosDec20 = 0\n        val onesDec21 = 0\n        val zerosDec21\
    \ = 0\n        val onesDec22 = 0\n        val zerosDec22 = 0\n        val onesDec23\
    \ = 0\n        val zerosDec23 = 0\n        val onesDec24 = 0\n        val zerosDec24\
    \ = 0\n        val onesDec25 = 0\n        val zerosDec25 = 0\n        val onesDe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpezuow7qs.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpezuow7qs.scala:69:5 ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.length\n        val\
    \ twos_count = twos.length\n        val threes_count = threes.length\n       \
    \ val fours_count = fours.length\n        val fives_count = fives.length\n   \
    \     val sixes_count = sixes.length\n        val sevens_count = sevens.length\n\
    \        val eights_count = eights.length\n        val nines_count = nines.length\n\
    \        val tens_count = tens.length\n        val hundreds_count = hundreds.length\n\
    \        val thousands_count = thousands.length\n        val ten_thousands_count\
    \ = ten_thousands.length\n        val hundred_thousands_count = hundred_thousands.length\n\
    \        val millions_count = millions.length\n        val billions_count = billions.length\n\
    \        val trillions_count = trillions.length\n        val quadrillion\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3xw4erp1.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp3xw4erp1.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmp3xw4erp1.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmp3xw4erp1.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp3xw4erp1.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp3xw4erp1.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val onesArr = arr.filter(x\
    \ => x == 1).map(x => x.toLong).toList\n        val zerosArr = arr.filter(x =>\
    \ x == 0).map(x => x.toLong).toList\n        val onesArr2 = onesArr.sortBy(x =>\
    \ x.toString.toInt)\n        val zerosArr2 = zerosArr.sortBy(x => x.toString.toInt)\n\
    \        val onesArr3 = onesArr2.sortBy(x => x.toString.toInt)\n        val zerosArr3\
    \ = zerosArr2.sortBy(x => x.toString.toInt)\n        val onesArr4 = onesArr3.sortBy(x\
    \ => x.toString.toInt)\n        val zerosArr4 = zerosArr3.sortBy(x => x.toString.toInt)\n\
    \        val onesArr5 = onesArr4.sortBy(x => x.toString.toInt)\n        val zerosArr5\
    \ = zerosArr4.sortBy(x => x.toString.toInt)\n        val onesArr6 = onesArr5.sortBy(x\
    \ => x.toString.toInt)\n        val zerosArr6 = zerosArr5.sortBy(x => x.toString.toInt)\n\
    \        val onesArr7 = onesArr6.sortBy(x => x.toString.toInt)\n        val zerosArr7\
    \ = zerosArr6.sortBy(x => x.toString.toInt)\n        val onesArr8 = onesArr7.sortBy(x\
    \ => x.toString.toInt)\n        val zerosArr8 = zerosArr7.sortBy(x => x.toString.toInt)\n\
    \        val onesArr9 = onesArr8.sortBy(x => x.toString.toInt)\n        val zerosArr9\
    \ = zerosArr8.sortBy(x => x.toString.toInt)\n        val onesArr10 = onesArr9.sortBy(x\
    \ => x.toString.toInt)\n        val zerosArr10 = zerosArr9.sortBy(x => x.toString.toInt)\n\
    \        val onesArr11 = onesArr10.sortBy(x => x.toString.toInt)\n        val\
    \ zerosArr11 = zerosArr10.sortBy(x => x.toString.toInt)\n        val onesArr12\
    \ = onesArr11.sortBy(x => x.toString.toInt)\n        val zerosArr12 = zerosArr11.sortBy(x\
    \ => x.toString.toInt)\n        val onesArr13 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpy7bdfos6.scala:38:23 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36monesArr13\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpy7bdfos6.scala:39:5 ---------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val decimal = arr.map(x\
    \ => math.abs(math.log2(x)))\n        val decimalSorted = decimal.sortBy(x =>\
    \ x)\n        val decimalSortedSortedByDecimal = decimalSorted.sortBy(x => x)\n\
    \        val decimalSortedSortedByDecimalReversed = decimalSortedSortedByDecimal.reverse\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimal = decimalSortedSortedByDecimalReversed.sortBy(x\
    \ => x)\n        val decimalSortedSortedByDecimalReversedSortedByDecimalReversed\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimal.reverse\n        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversed.sortBy(x => x)\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversed\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal.reverse\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversed.sortBy(x\
    \ => x)\n        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversed\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal.reverse\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal.reverse\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversed\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal.reverse\n\
    \        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ = decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversed.sortBy(x\
    \ => x)\n        val decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ = decimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ygeffni.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mdecimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\e\
    [0m = decimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalSortedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimalReversedSortedByDecimal\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2ygeffni.scala:14:49 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecimal\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                    value log2 is not a member of math\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp2ygeffni.scala:15:50 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdecimalSorted\e[0m = decimal.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m                                      \
    \            ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mLong\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2ygeffni.scala:24:135\
    \ --------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalSortedSor"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val twos = arr.filter(x => x == 2).length\n        val threes = arr.filter(x\
    \ => x == 3).length\n        val fours = arr.filter(x => x == 4).length\n    \
    \    val fives = arr.filter(x => x == 5).length\n        val sixes = arr.filter(x\
    \ => x == 6).length\n        val sevens = arr.filter(x => x == 7).length\n   \
    \     val eights = arr.filter(x => x == 8).length\n        val nines = arr.filter(x\
    \ => x == 9).length\n        val tens = arr.filter(x => x == 10).length\n    \
    \    val hundreds = arr.filter(x => x == 11).length\n        val thousands = arr.filter(x\
    \ => x == 12).length\n        val ten_thousands = arr.filter(x => x == 13).length\n\
    \        val hundred_thousands = arr.filter(x => x == 14).length\n        val\
    \ millions = arr.filter(x => x == 15).length\n        val billions = arr.filter(x\
    \ => x == 16).length\n        val trillions = arr.filter(x => x == 17).length\n\
    \        val quadrillions = arr.filter(x => x == 18).length\n        val quintillions\
    \ = arr.filter(x => x == 19).length\n        val sextillions = arr.filter(x =>\
    \ x == 20).length\n        val septillions = arr.filter(x => x == 21).length\n\
    \        val octillions = arr.filter(x => x == 22).length\n        val nonillions\
    \ = arr.filter(x => x == 23).length\n        val decillions = arr.filter(x =>\
    \ x == 24).length\n        val undecillions = arr.filter(x => x == 25).length\n\
    \        val duodecillions = arr.filter(x => x == 26).length\n        val tredecillions\
    \ = arr.filter(x => x == 27).length\n        val quattuordecillions = arr.filter(x\
    \ => x == 28).length\n        val quindecillions = arr.filter(x => x == 29).length\n\
    \        val sexdecillions = arr.filter(x => x == 30).length\n        val septendecillions\
    \ = arr.filter(x => x == 31).length\n        val octodecillions = arr.filter(x\
    \ => x == 32).length\n        val novemdecillions = arr.filter(x => x == 33).length\n\
    \        val vigintillions = arr.filter(x => x == 34\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdqedou3.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbdqedou3.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val sorted = arr.sortBy(x\
    \ => (ones - x.filter(_ % 2 == 0).length))\n        sorted.sortBy(x => (decimals\
    \ - x.filter(_ % 2 == 1).length))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptgas0x91.scala:14:47 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones - x.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).length))\n\e\
    [31m\e[31m   |\e[0m                                             ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                    value filter is not a member\
    \ of Long\n\e[31m\e[31m-- Error: /tmp/tmptgas0x91.scala:14:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones - x.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).length))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => (x % 2 ==\
    \ 0 ? x : -x))\n        val zerosArr = arr.map(x => (x % 2 == 0 ? x : -x))\n \
    \       val onesArr = onesArr.sortWith((x, y) => x - y)\n        val zerosArr\
    \ = zerosArr.sortWith((x, y) => x - y)\n        val onesArr = onesArr.map(x =>\
    \ x % 2 == 0 ? x : -x).toList\n        val zerosArr = zerosArr.map(x => x % 2\
    \ == 0 ? x : -x).toList\n        val onesArr = onesArr.sortWith((x, y) => x -\
    \ y)\n        val zerosArr = zerosArr.sortWith((x, y) => x - y)\n        val onesArr\
    \ = onesArr.map(x => x % 2 == 0 ? x : -x).toList\n        val zerosArr = zerosArr.map(x\
    \ => x % 2 == 0 ? x : -x).toList\n        val onesArr = onesArr.sortWith((x, y)\
    \ => x - y)\n        val zerosArr = zerosArr.sortWith((x, y) => x - y)\n     \
    \   val onesArr = onesArr.map(x => x % 2 == 0 ? x : -x).toList\n        val zerosArr\
    \ = zerosArr.map(x => x % 2 == 0 ? x : -x).toList\n        val onesArr = onesArr.sortWith((x,\
    \ y) => x - y)\n        val zerosArr = zerosArr.sortWith((x, y) => x - y)\n  \
    \      val onesArr = onesArr.map(x => x % 2 == 0 ? x : -x).toList\n        val\
    \ zerosArr = zerosArr.map(x => x % 2 == 0 ? x : -x).toList\n        val onesArr\
    \ = onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.map(x => x % 2 == 0 ? x : -x).toList\n\
    \        val zerosArr = zerosArr.map(x => x % 2 == 0 ? x : -x).toList\n      \
    \  val onesArr = onesArr.sortWith((x, y) => x - y)\n        val zerosArr = zerosArr.sortWith((x,\
    \ y) => x - y)\n        val onesArr = onesArr.map(x => x % 2 == 0 ? x : -x).toList\n\
    \        val zerosArr = zerosArr.map(x => x % 2 == 0 ? x : -x).toList\n      \
    \  \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8gqp69d9.scala:14:55 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = arr.map(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? x : \e[35m-x\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                       ^\e[0m\n\e\
    [31m   |\e[0m                                   an identifier expected, but ')'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8gqp69d9.scala:15:56 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = arr.map(\e\
    [36mx\e[0m => (x % \e[31m2\e[0m == \e[31m0\e[0m ? x : \e[35m-x\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                        ^\e[0m\n\e\
    [31m   |\e[0m                                   an identifier expected, but ')'\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8gqp69d9.scala:18:58 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m ? x : \e[35m-x\e[0m).toList\n\e\
    [31m\e[31m   |\e[0m                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                   an identifier expected,\
    \ but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8gqp69d9.scala:19:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArr\e[0m = zerosArr.map(\e[36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e\
    [0m ? x : \e[35m-x\e[0m).toList\n\e[31m\e[31m   |\e[0m                       \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                   an identifier expected, but ')' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp8gqp69d9.scala:22:58 ---------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.map(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m ? x : \e[35m-x\e[0m).toList\n\e\
    [31m\e[31m   |\e[0m                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                   an identifier expected,\
    \ but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8gqp69d9.scala:23:6"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(x => math.abs(math.log2(x)))\n        val decs = decs.sortBy(x\
    \ => x)\n        val decs = decs.map(x => math.pow(10, x))\n        val decs =\
    \ decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.map(x\
    \ => math.abs(x))\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmprp8xde5h.scala:50:11 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmprp8xde5h.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprp8xde5h.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.pow(\e\
    [31m10\e[0m, x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprp8xde5h.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprp8xde5h.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of to"
  stdout: ''
  timestamp: 1659795237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decs = arr.map(x => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n\
    \        val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.takeWhile(x\
    \ => x < arr.length)\n        val decs = decs.map(x => math.abs(x - math.floor(x\
    \ / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x => x < ones)\n\
    \        val decs = decs.takeWhile(x => x < arr.length)\n        val decs = decs.map(x\
    \ => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.takeWhile(x => x < arr.length)\n     \
    \   val decs = decs.map(x => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n\
    \        val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.takeWhile(x\
    \ => x < arr.length)\n        val decs = decs.map(x => math.abs(x - math.floor(x\
    \ / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x => x < ones)\n\
    \        val decs = decs.takeWhile(x => x < arr.length)\n        val decs = decs.map(x\
    \ => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.takeWhile(x => x < arr.length)\n     \
    \   val decs = decs.map(x => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n\
    \        val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.takeWhile(x\
    \ => x < arr.length)\n        val decs = decs.map(x => math.abs(x - math.floor(x\
    \ / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x => x < ones)\n\
    \        val decs = decs.takeWhile(x => x < arr.length)\n        val decs = decs.map(x\
    \ => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n        val decs = decs.takeWhile(x\
    \ => x < ones)\n        val decs = decs.takeWhile(x => x < arr.length)\n     \
    \   val decs = decs.map(x => math.abs(x - math.floor(x / 2))).sortBy(math.abs)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9644_3gs.scala:41:11 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9644_3gs.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e\
    [36mx\e[0m => x < ones)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9644_3gs.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m =>\
    \ x < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9644_3gs.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.abs(x\
    \ - math.floor(x / \e[31m2\e[0m))).sortBy(math.abs)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9644_3gs.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m =>\
    \ x < ones)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs"
  stdout: ''
  timestamp: 1659795237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = arr.count(x => x == 1)\n\
    \        val twos_count = arr.count(x => x == 2)\n        val threes_count = arr.count(x\
    \ => x == 3)\n        val fours_count = arr.count(x => x == 4)\n        val fives_count\
    \ = arr.count(x => x == 5)\n        val sixes_count = arr.count(x => x == 6)\n\
    \        val sevens_count = arr.count(x => x == 7)\n        val eights_count =\
    \ arr.count(x => x == 8)\n        val nines_count = arr.count(x => x == 9)\n \
    \       val tens_count = arr.count(x => x == 10)\n        val hundreds_count =\
    \ arr.count(x => x == 11)\n        val thousands_count = arr.count(x => x == 100)\n\
    \        val ten_thousands_count = arr.count(x => x == 1000)\n        val hundred_thousands_count\
    \ = arr.count(x => \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpehztlskm.scala:44:52 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mhundred_thousands_count\e\
    [0m = arr.count(\e[36mx\e[0m => \n\e[31m\e[31m   |\e[0m                      \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpehztlskm.scala:28:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e\
    [0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                              number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpehztlskm.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e["
  stdout: ''
  timestamp: 1659795222
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesIndex = arr.lastIndexWhere(_\
    \ == 1)\n        val maxZerosIndex = arr.lastIndexWhere(_ == 0)\n        val maxOnesDecimal\
    \ = maxOnesIndex.toDouble / maxOnes\n        val maxZerosDecimal = maxZerosIndex.toDouble\
    \ / maxZeros\n        val maxOnesDecimalDecimal = maxOnesDecimal / maxOnes\n \
    \       val maxZerosDecimalDecimal = maxZerosDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / maxOnes\n     \
    \   val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / maxOnes\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal /\
    \ maxZeros\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_zerfume.scala:34:11 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_zerfume.scala:26:57 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimal / maxOnes\n\e[31m\e[31m   |\e\
    [0m                                                         ^\e[0m\n\e[31m   |\e\
    [0m   Recursive \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_zerfume.scala:27:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimal\e[0m = maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n\e[31m\e[31m   |\e[0m                                          \
    \                ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_zerfume.scala:32:78\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxOnes\n\e[31m\e[31m   |\e[0m                                           \
    \                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_zerfume.sc"
  stdout: ''
  timestamp: 1659795237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val maxOnes = arr.count(_ == 1)\n\
    \        val maxDecimals = arr.count(_ > 0)\n        val maxOnesDecimals = arr.count(_\
    \ == 1 && _ > 0)\n        val maxDecimalsOnes = arr.count(_ > 0 && _ == 1)\n \
    \       val maxDecimalsOnesDecimals = arr.count(_ > 0 && _ == 1 && _ > 0)\n  \
    \      val maxDecimalsOnesDecimalsOnes = arr.count(_ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1)\n        val maxDecimalsOnesDecimalsOnesDecimals = arr.count(_ > 0 &&\
    \ _ == 1 && _ > 0 && _ == 1 && _ > 0)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1)\n       \
    \ val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimals = arr.count(_ > 0 && _ ==\
    \ 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1 && _ > 0)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1 && _ > 0 && _ == 1)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimals\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1 && _ > 0 && _ == 1 && _ > 0)\n        val maxDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnesDecimalsOnes\
    \ = arr.count(_ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1 && _ > 0 &&\
    \ _ == 1 && _ > 0 && _ == 1 && _ > 0 && _ == 1)\n        val max\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwen65ufz.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpwen65ufz.scala:16:40\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesDecimals\e[0m = arr.count(_ == \e[31m1\e[0m && _ > \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpwen65ufz.scala:17:40\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDecimalsOnes\e[0m = arr.count(_ > \e[31m0\e[0m && _ == \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpwen65ufz.scala:18:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxDecimalsOnesDecimals\e[0m = arr.count(_ > \e[31m0\e[0m && _ == \e[31m1\e\
    [0m && _ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                              \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                     Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpwen65ufz.scala:19:52 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxDecimalsOnesDecimalsOnes\e\
    [0m = arr.count(_ > \e[31m0\e[0m && _ == \e[31m1\e[0m && _ > \e[31m0\e[0m && _\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                             Wrong number of parameters, expected: 1\n\e[31m\e\
    [31m-- [E086] Syntax Error: /tmp/tmpwen65ufz.scala:20:60 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxDecimalsOnesDecimalsOnesDecimals\e\
    [0m = arr.count(_ > \e[31m0\e[0m && _ == \e[31m1\e[0m && _ > \e[31m0\e[0m && _\
    \ == \e[31m1\e["
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(x\
    \ => math.abs(x))\n        val zerosArr = arr.filter(_ == 0).sortBy(x => math.abs(x))\n\
    \        val onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n\
    \        val onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n    \
    \    val onesDiff = onesSum - onesCount\n        val zerosDiff = zerosSum - zerosCount\n\
    \        val onesDiffArr = onesArr.sortBy(x => math.abs(x))\n        val zerosDiffArr\
    \ = zerosArr.sortBy(x => math.abs(x))\n        val onesDiffCount = onesDiffArr.length\n\
    \        val zerosDiffCount = zerosDiffArr.length\n        val onesDiffSum = onesDiffArr.sum\n\
    \        val zerosDiffSum = zerosDiffArr.sum\n        val onesDiffDiff = onesDiffSum\
    \ - onesDiffCount\n        val zerosDiffDiff = zerosDiffSum - zerosDiffCount\n\
    \        val onesDiffDiffArr = onesDiffArr.sortBy(x => math.abs(x))\n        val\
    \ zerosDiffDiffArr = zerosDiffArr.sortBy(x => math.abs(x))\n        val onesDiffDiffCount\
    \ = onesDiffDiffArr.length\n        val zerosDiffDiffCount = zerosDiffDiffArr.length\n\
    \        val onesDiffDiffSum = onesDiffDiffArr.sum\n        val zerosDiffDiffSum\
    \ = zerosDiffDiffArr.sum\n        val onesDiffDiffDiff = onesDiffDiffSum - onesDiffDiffCount\n\
    \        val zerosDiffDiffDiff = zerosDiffDiffSum - zerosDiffDiffCount\n     \
    \   val onesDiffDiffDiffArr = onesDiffDiffArr.sortBy(x => math.abs(x))\n     \
    \   val zerosDiffDiffDiffArr = zerosDiffDiffArr.sortBy(x => math.abs(x))\n   \
    \     val onesDiffDiffDiffCount = onesDiffDiffDiffArr.length\n        val zerosDiffDiffDiffCount\
    \ = zerosDiffDiffDiffArr.length\n        val onesDiffDiffDiffSum = onesDiffDiffDiffArr.sum\n\
    \        val zerosDiffDiffDiffSum = zerosDiffDiffDiffArr.sum\n        val onesDiffDiffDiffDiff\
    \ = onesDiffDiffDiffSum - onesDiffDiffDiffCount\n        val zeros\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplhqr_i16.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplhqr_i16.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.size\n        val zerosDecimal = zerosCount / arr.size\n        val onesDecimalDecimal\
    \ = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal / zeros\n\
    \        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n  \
    \      val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwldx5wn8.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwldx5wn8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpwldx5wn8.scala:28:68 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwldx5wn8.scala:29:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m   \
    \                                                      "
  stdout: ''
  timestamp: 1659795237
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val decimal = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).max\n        val decimal2 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).min\n        val decimal3 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).sum\n        val decimal4 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).product\n        val decimal5 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mean\n        val decimal6 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).median\n        val decimal7 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mode\n        val decimal8 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).min\n        val decimal9 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).max\n        val decimal10 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).sum\n        val decimal11 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).product\n        val decimal12 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mean\n        val decimal13 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).median\n        val decimal14 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mode\n        val decimal15 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).min\n        val decimal16 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).max\n        val decimal17 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).sum\n        val decimal18 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).product\n        val decimal19 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mean\n        val decimal20 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).median\n        val decimal21 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).mode\n        val decimal22 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).min\n        val decimal23 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).max\n        val decimal24 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).sum\n        val decimal25 = arr.map(x\
    \ => math.abs(x - math.floor(x).toInt)).product\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr.scala:18:71 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mdecimal5\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(x - math.floor(x).toInt)).mean\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mean is not a member of List[Long] - did you mean List[Long].head?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr.scala:19:71 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdecimal6\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(x - math.floor(x).toInt)).median\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       value median is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdecimal7\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(x - math.floor(x).toInt)).mode\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mode is not a member of List[Long] - did you mean List[Long].clone?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr.scala:25:72 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mdecimal12\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(x - math.floor(x).toInt)).mean\n\e[31m\e[31m   |\e[0m \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mean is not a member of List[Long] - did you mean List[Long].head?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr.scala:26:72 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimal13\e[0m = arr.map(\e\
    [36mx\e[0m => math.abs(x - math.floor(x).toInt)).median\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value median is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8wvrxojr"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val decimal = arr.map(x\
    \ => (x % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x => (x\
    \ % 2).asInstanceOf[Int]).sum\n        val zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n\
    \        val onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n     \
    \   val zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val\
    \ onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val zerosDecimal\
    \ = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x\
    \ => (x % 2).asInstanceOf[Int]).sum\n        val zerosDecimal = arr.map(x => (x\
    \ % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n\
    \        val zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n    \
    \    val onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val\
    \ zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val onesDecimal\
    \ = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val zerosDecimal = arr.map(x\
    \ => (x % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x => (x\
    \ % 2).asInstanceOf[Int]).sum\n        val zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n\
    \        val onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n     \
    \   val zerosDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val\
    \ onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val zerosDecimal\
    \ = arr.map(x => (x % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x\
    \ => (x % 2).asInstanceOf[Int]).sum\n        val zerosDecimal = arr.map(x => (x\
    \ % 2).asInstanceOf[Int]).sum\n        val onesDecimal = arr.map(x => (x % 2).asInstanceOf[Int\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpilpvr7zr.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpilpvr7zr.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDecimal\e[0m = arr.map(\e[36mx\e[0m => (x % \e[31m2\e[0m).asInstanceOf[\e\
    [35mInt\e[0m]).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpilpvr7zr.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = arr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m).asInstanceOf[\e[35mInt\e[0m]).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mzerosDecimal is already defined as \e[33mvalue\e[0m \e[35mzerosDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpilpvr7zr.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimal\e[0m = arr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m).asInstanceOf[\e[35mInt\e[0m]).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesDecimal is already defined as \e[33mvalue\e[0m \e[35monesDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpilpvr7zr.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimal\e[0m = arr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m).asInstanceOf[\e[35mInt\e[0m]).sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val decimal = arr.filter(_\
    \ % 2 == 0).sum / 2\n        val decimal2 = arr.filter(_ % 2 == 1).sum / 2\n \
    \       val decimal3 = arr.filter(_ % 2 == 0).sum / 3\n        val decimal4 =\
    \ arr.filter(_ % 2 == 1).sum / 3\n        val decimal5 = arr.filter(_ % 2 == 0).sum\
    \ / 5\n        val decimal6 = arr.filter(_ % 2 == 1).sum / 5\n        val decimal7\
    \ = arr.filter(_ % 2 == 0).sum / 7\n        val decimal8 = arr.filter(_ % 2 ==\
    \ 1).sum / 7\n        val decimal9 = arr.filter(_ % 2 == 0).sum / 9\n        val\
    \ decimal10 = arr.filter(_ % 2 == 1).sum / 9\n        val decimal11 = arr.filter(_\
    \ % 2 == 0).sum / 11\n        val decimal12 = arr.filter(_ % 2 == 1).sum / 11\n\
    \        val decimal13 = arr.filter(_ % 2 == 0).sum / 13\n        val decimal14\
    \ = arr.filter(_ % 2 == 1).sum / 13\n        val decimal15 = arr.filter(_ % 2\
    \ == 0).sum / 15\n        val decimal16 = arr.filter(_ % 2 == 1).sum / 15\n  \
    \      val decimal17 = arr.filter(_ % 2 == 0).sum / 17\n        val decimal18\
    \ = arr.filter(_ % 2 == 1).sum / 17\n        val decimal19 = arr.filter(_ % 2\
    \ == 0).sum / 19\n        val decimal20 = arr.filter(_ % 2 == 1).sum / 19\n  \
    \      val decimal21 = arr.filter(_ % 2 == 0).sum / 21\n        val decimal22\
    \ = arr.filter(_ % 2 == 1).sum / 21\n        val decimal23 = arr.filter(_ % 2\
    \ == 0).sum / 23\n        val decimal24 = arr.filter(_ % 2 == 1).sum / 23\n  \
    \      val decimal25 = arr.filter(_ % 2 == 0).sum / 25\n        val decimal26\
    \ = arr.filter(_ % 2 == 1).sum / 25\n        val decimal27 = arr.filter(_ % 2\
    \ == 0).sum / 27\n        val decimal28 = arr.filter(_ % 2 == 1).sum / 27\n  \
    \      val decimal29 = arr.filter(_ % 2 == 0).sum / 29\n        val decimal30\
    \ = arr.filter(_ % 2 == 1).sum / 29\n        val decimal31 = arr.filter(_ % 2\
    \ == 0).sum / 31\n        val decimal32 = arr.filter(_ % 2 == 1).sum / 31\n  \
    \      val decimal33 = arr.filter(_ % 2 == 0).sum / 33\n        val decimal34\
    \ = arr.filter\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxxxiidfz.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795245
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesDecimals = ones * decimals\n\
    \        val onesDecimalsArray = onesDecimals.toArray\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArray.length\n        val decimalsArray = decimals.toArray\n \
    \       val decimalsArrayLength = decimalsArray.length\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength + decimalsArrayLength\n        val onesDecimalsArray\
    \ = onesDecimalsArray.toList\n        val decimalsArray = decimalsArray.toList\n\
    \        val decimalsArrayLength = decimalsArray.length\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength + decimalsArrayLength\n        val onesDecimalsArray\
    \ = onesDecimalsArray.toArray\n        val decimalsArray = decimalsArray.toArray\n\
    \        val onesDecimalsArrayLength = onesDecimalsArrayLength + decimalsArrayLength\n\
    \        val onesDecimalsArray = onesDecimalsArray.toList\n        val decimalsArray\
    \ = decimalsArray.toList\n        val decimalsArrayLength = decimalsArray.length\n\
    \        val onesDecimalsArrayLength = onesDecimalsArrayLength + decimalsArrayLength\n\
    \        val onesDecimalsArray = onesDecimalsArray.toArray\n        val decimalsArray\
    \ = decimalsArray.toArray\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ + decimalsArrayLength\n        val onesDecimalsArray = onesDecimalsArray.toList\n\
    \        val decimalsArray = decimalsArray.toList\n        val decimalsArrayLength\
    \ = decimalsArray.length\n        val onesDecimalsArrayLength = onesDecimalsArrayLength\
    \ + decimalsArrayLength\n        val onesDecimalsArray = onesDecimalsArray.toArray\n\
    \        val decimalsArray = decimalsArray.toArray\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength + decimalsArrayLength\n        val onesDecimalsArray\
    \ = onesDecimalsArray.toList\n        val decimalsArray = decimalsArray.toList\n\
    \        val decimalsArrayLength = decimalsArray.length\n        val onesDecimalsArrayLength\
    \ = onesDecimalsArrayLength + decimalsArrayLength\n        val onesDecimalsArray\
    \ = onesDecimalsArray.toArray\n        val decimalsArray = decimalsArray.toArray\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4p6t9p2q.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArrayLength\e\
    [0m = onesDecimalsArrayLength + decimalsArrayLength\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35monesDecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4p6t9p2q.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsArray\e[0m =\
    \ onesDecimalsArray.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalsArray is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalsArray\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4p6t9p2q.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArray\e[0m = decimalsArray.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecimalsArray is already defined as \e[33mvalue\e[0m \e[35mdecimalsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4p6t9p2q.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArrayLength\e[0m = decimalsArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mdecimalsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4p6t9p2q.scala:23:12 ---------------------------"
  stdout: ''
  timestamp: 1659795247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sorted\n\
    \        val zerosArr = arr.filter(_ == 0).sorted\n        val onesCount = onesArr.length\n\
    \        val zerosCount = zerosArr.length\n        val onesSum = onesArr.foldLeft(0L)(_\
    \ + _)\n        val zerosSum = zerosArr.foldLeft(0L)(_ + _)\n        val onesSumInt\
    \ = onesSum.toInt\n        val zerosSumInt = zerosSum.toInt\n        val onesSumDecimal\
    \ = onesSumInt / onesCount\n        val zerosSumDecimal = zerosSumInt / zerosCount\n\
    \        val onesSumDecimalInt = onesSumDecimal.toInt\n        val zerosSumDecimalInt\
    \ = zerosSumDecimal.toInt\n        val onesSumDecimalDecimal = onesSumDecimalInt\
    \ / onesCount\n        val zerosSumDecimalDecimal = zerosSumDecimalInt / zerosCount\n\
    \        val onesSumDecimalDecimalInt = onesSumDecimalDecimal.toInt\n        val\
    \ zerosSumDecimalDecimalInt = zerosSumDecimalDecimal.toInt\n        val onesSumDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalInt / onesCount\n        val zerosSumDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalInt / zerosCount\n        val onesSumDecimalDecimalDecimalInt\
    \ = onesSumDecimalDecimalDecimal.toInt\n        val zerosSumDecimalDecimalDecimalInt\
    \ = zerosSumDecimalDecimalDecimal.toInt\n        val onesSumDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalInt / onesCount\n        val zerosSumDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalInt / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalInt\
    \ = onesSumDecimalDecimalDecimalDecimal.toInt\n        val zerosSumDecimalDecimalDecimalDecimalInt\
    \ = zerosSumDecimalDecimalDecimalDecimal.toInt\n        val onesSumDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimalDecimalDecimalInt / onesCount\n        val zerosSumDecimalDecimalDecimalDecimalDecimal\
    \ = zerosSumDecimalDecimalDecimalDecimalInt / zerosCount\n        val onesSumDecimalDecimalDecimalDecimalDecimalInt\
    \ = onesSumDecimalDecimalDecimalDecimalDecimal.toInt\n        val zerosSumDecimalDecimalDecimalDecimalDecimalInt\
    \ = zerosSumDecimalDecimalDecimalDecimalDecimal.toInt\n        val onesSumDecimalDecimalDecimalDecimalDecimal\
    \ = onesSumDecimalDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3execigt.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36monesSumDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesSumDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumDecimalDecimalDecimalDecimalDecimal is already defined\
    \ as \e[33mvalue\e[0m \e[35monesSumDecimalDecimalDecimalDecimalDecimal\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3execigt.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArray = arr.map(x => (x % 2\
    \ == 0 ? 1 : 0)).toArray\n        val zerosArray = arr.map(x => (x % 2 == 0 ?\
    \ 0 : 1)).toArray\n        val onesArrayLength = onesArray.length\n        val\
    \ zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArrayLength\
    \ + zerosArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val onesArray\
    \ = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.take(onesArrayLength)\n        val zerosArray\
    \ = zerosArray.take(zerosArrayLength)\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.take(zerosArrayLength)\n        val onesArrayLength\
    \ = onesArray.length\n        val zerosArrayLength = zerosArray.length\n     \
    \   val onesArrayLength = onesArrayLength + zerosArrayLength\n        val onesArray\
    \ = onesArray.take(onesArrayLength)\n        val zerosArray = zerosArray.take(zerosArrayLength)\n\
    \        val onesArrayLength = onesArray.length\n        val zerosArrayLength\
    \ = zerosArray.length\n        val onesArrayLength = onesArrayLength + zerosArrayLength\n\
    \        val onesArray = onesArray.take(onesArrayLength)\n        val zerosArray\
    \ = zerosArray.take(zerosArrayLength)\n        val onesArrayLength = onesArray.length\n\
    \        val zerosArrayLength = zerosArray.length\n        val onesArrayLength\
    \ = onesArrayLength + zerosArrayLength\n        val onesArray = onesArray.take(onesArrayLength)\n\
    \        val zerosArray = zerosArray.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8bulcw1o.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8bulcw1o.scala:18:12 ---------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength +\
    \ zerosArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8bulcw1o.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesArray\e[0m = onesArray.take(onesArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArray is already defined as \e[33mvalue\e[0m \e[35monesArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bulcw1o.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mzerosArray\e[0m = zerosArray.take(zerosArrayLength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArray is already defined as \e[33mvalue\e[0m \e[35mzerosArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bulcw1o.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same g"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.size\n        val\
    \ twos_count = twos.size\n        val threes_count = threes.size\n        val\
    \ fours_count = fours.size\n        val fives_count = fives.size\n        val\
    \ sixes_count = sixes.size\n        val sevens_count = sevens.size\n        val\
    \ eights_count = eights.size\n        val nines_count = nines.size\n        val\
    \ tens_count = tens.size\n        val hundreds_count = hundreds.size\n       \
    \ val thousands_count = thousands.size\n        val ten_thousands_count = ten_thousands.size\n\
    \        val hundred_thousands_count = hundred_thousands.size\n        val millions_count\
    \ = millions.size\n        val billions_count = billions.size\n        val trillions_count\
    \ = trillions.size\n        val quadrillion\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpui58upli.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpui58upli.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = ones /\
    \ onesCount\n        val zerosDecimal = zeros / zerosCount\n        val onesDecimalDecimal\
    \ = onesDecimal / onesCount\n        val zerosDecimalDecimal = zerosDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosCount\n \
    \       val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesCount\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosCount\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpebmii096.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpebmii096.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpebmii096.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defi"
  stdout: ''
  timestamp: 1659795246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => (x % 2 ==\
    \ 0)).sortBy(x => -x)\n        val zerosArr = arr.map(x => (x % 2 == 1)).sortBy(x\
    \ => -x)\n        val onesCount = onesArr.size\n        val zerosCount = zerosArr.size\n\
    \        val onesSum = onesArr.sum\n        val zerosSum = zerosArr.sum\n    \
    \    val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n       \
    \ val zerosSumArr = zerosArr.map(x => (x % 2 == 1)).sortBy(x => -x)\n        val\
    \ onesSumCount = onesSumArr.size\n        val zerosSumCount = zerosSumArr.size\n\
    \        val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n   \
    \     val zerosSumArr = zerosArr.map(x => (x % 2 == 1)).sortBy(x => -x)\n    \
    \    val onesSumCount = onesSumArr.size\n        val zerosSumCount = zerosSumArr.size\n\
    \        val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n   \
    \     val zerosSumArr = zerosArr.map(x => (x % 2 == 1)).sortBy(x => -x)\n    \
    \    val onesSumCount = onesSumArr.size\n        val zerosSumCount = zerosSumArr.size\n\
    \        val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n   \
    \     val zerosSumArr = zerosArr.map(x => (x % 2 == 1)).sortBy(x => -x)\n    \
    \    val onesSumCount = onesSumArr.size\n        val zerosSumCount = zerosSumArr.size\n\
    \        val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n   \
    \     val zerosSumArr = zerosArr.map(x => (x % 2 == 1)).sortBy(x => -x)\n    \
    \    val onesSumCount = onesSumArr.size\n        val zerosSumCount = zerosSumArr.size\n\
    \        val onesSumArr = onesArr.map(x => (x % 2 == 0)).sortBy(x => -x)\n   \
    \     val zerosSumArr = zerosArr.map(x \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9d1wf2_.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn9d1wf2_.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesSumArr\e[0m = onesArr.map(\e[36mx\e[0m => (x % \e[31m2\e[0m == \e\
    [31m0\e[0m)).sortBy(\e[36mx\e[0m => -x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesSumArr is already defined as \e[33mvalue\e[0m \e[35monesSumArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn9d1wf2_.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosSumArr\e[0m = zerosArr.map(\e[36mx\e\
    [0m => (x % \e[31m2\e[0m == \e[31m1\e[0m)).sortBy(\e[36mx\e[0m => -x)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosSumArr is already defined as \e[33mvalue\e[0m \e[35mzerosSumArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn9d1wf2_.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesSumCount\e[0m = onesSumArr.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0monesSumCount is already defined as \e[33mvalue\e[0m \e[35monesSumCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpn9d1wf2_.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosSumCount\e[0m = zerosSumArr.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mzerosSumCount is already defined as \e[33mvalue\e[0m \e[35mzerosSumCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val decs = arr.filter(x => x == 0).map(x => x.toString.toInt).sortBy(_.toInt)\n\
    \        val sorted = decs.zip(ones).sortBy(_._1).map(x => x._2).zip(arr).sortBy(_._1).map(x\
    \ => x._2)\n        sorted.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpealqj5od.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2).zip(arr).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                              ^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (ones : Int)\n\e[31m\
    \   |\e[0m                              Required: IterableOnce[Any]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpealqj5od.scala:14:85 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.zip(ones).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2).zip(arr).sortBy(_._1).map(\e[36mx\e[0m => x._2)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                     ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795246
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val twos = arr.filter(x => x % 2 == 1).length\n        val\
    \ decimals = arr.filter(x => x % 1 == 0).length\n        val result = arr.sortWith(x\
    \ => if (ones > twos) x.toInt else -x.toInt)\n        if (ones > twos) result\
    \ else result.map(x => if (decimals > ones) x.toInt else -x.toInt)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmplb2ri1_p.scala:15:36 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortWith(\e\
    [36mx\e[0m => \e[33mif\e[0m (ones > twos) x.toInt \e[33melse\e[0m -x.toInt)\n\e\
    [31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1659795244
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val sorted = arr.sortWith(\n\
    \            (a: Long, b: Long) => if (ones == 0) a else -ones - b\n        )\n\
    \        sorted.take(decimals)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpszxh9qxf.scala:15:49\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m            (\e[36ma\e[0m: \e\
    [35mLong\e[0m, \e[36mb\e[0m: \e[35mLong\e[0m) => \e[33mif\e[0m (ones == \e[31m0\e\
    [0m) a \e[33melse\e[0m -ones - b\n\e[31m\e[31m   |\e[0m                      \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \                       Found:    (a : Long)\n\e[31m   |\e[0m                \
    \                                 Required: Boolean\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpszxh9qxf.scala:15:56 --------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            (\e[36ma\e[0m: \e[35mLong\e[0m, \e[36mb\e\
    [0m: \e[35mLong\e[0m) => \e[33mif\e[0m (ones == \e[31m0\e[0m) a \e[33melse\e[0m\
    \ -ones - b\n\e[31m\e[31m   |\e[0m                                           \
    \             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \                                 Required: Boolean\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val twos = arr.filter(x => x == 2).size\n        val threes = arr.filter(x\
    \ => x == 3).size\n        val fours = arr.filter(x => x == 4).size\n        val\
    \ fives = arr.filter(x => x == 5).size\n        val sixes = arr.filter(x => x\
    \ == 6).size\n        val sevens = arr.filter(x => x == 7).size\n        val eights\
    \ = arr.filter(x => x == 8).size\n        val nines = arr.filter(x => x == 9).size\n\
    \        val tens = arr.filter(x => x == 10).size\n        val hundreds = arr.filter(x\
    \ => x == 11).size\n        val thousands = arr.filter(x => x == 12).size\n  \
    \      val millions = arr.filter(x => x == 13).size\n        val billions = arr.filter(x\
    \ => x == 14).size\n        val trillions = arr.filter(x => x == 15).size\n  \
    \      val quadrillions = arr.filter(x => x == 16).size\n        val quintillions\
    \ = arr.filter(x => x == 17).size\n        val sextillions = arr.filter(x => x\
    \ == 18).size\n        val septillions = arr.filter(x => x == 19).size\n     \
    \   val octillions = arr.filter(x => x == 20).size\n        val nonillions = arr.filter(x\
    \ => x == 21).size\n        val decillions = arr.filter(x => x == 22).size\n \
    \       val undecillions = arr.filter(x => x == 23).size\n        val duodecillions\
    \ = arr.filter(x => x == 24).size\n        val tredecillions = arr.filter(x =>\
    \ x == 25).size\n        val quattuordecillions = arr.filter(x => x == 26).size\n\
    \        val quindecillions = arr.filter(x => x == 27).size\n        val sexdecillions\
    \ = arr.filter(x => x == 28).size\n        val septendecillions = arr.filter(x\
    \ => x == 29).size\n        val octodecillions = arr.filter(x => x == 30).size\n\
    \        val novemdecillions = arr.filter(x => x == 31).size\n        val vigintillions\
    \ = arr.filter(x => x == 32).size\n        val unvigintillions = arr.filter(x\
    \ => x == 33).size\n        val duovigintillions = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwdo0aym1.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwdo0aym1.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ < 0)\n        val decimalsOrder = decimals.toDouble\
    \ / ones\n        val onesOrder = ones.toDouble / decimals\n        arr.sortWith(x\
    \ => decimalsOrder + onesOrder - x.toDouble)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpso71n3rd.scala:16:23 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.sortWith(\e[36mx\e[0m => decimalsOrder +\
    \ onesOrder - x.toDouble)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1659795243
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val zeros = arr.filter(x => x == 0).size\n        val decimals = arr.filter(x\
    \ => x != 0).size\n        val decimalsDecimals = decimals.toDouble / ones\n \
    \       arr.sortWith(x => decimalsDecimals.toDouble - x.toDouble)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpb_0qf_vl.scala:16:23 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.sortWith(\e[36mx\e[0m => decimalsDecimals.toDouble\
    \ - x.toDouble)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Wrong number of parameters, expected:\
    \ 2\n1 error found\n"
  stdout: ''
  timestamp: 1659795244
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val onesDecimals\
    \ = ones * decimals\n        val onesDecimalsSorted = arr.sortBy(_ % onesDecimals)\n\
    \        onesDecimalsSorted.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbs8dnl31.scala:19)\n\tat Problem.main(tmpbs8dnl31.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decimals = arr.count(x => x == 0)\n        val onesArr = arr.map(x\
    \ => if (x == 1) 1 else 0)\n        val decimalsArr = arr.map(x => if (x == 0)\
    \ 0 else 1)\n        val onesArr = onesArr.sortBy(x => x)\n        val decimalsArr\
    \ = decimalsArr.sortBy(x => x)\n        val onesArr = onesArr.sortBy(x => math.abs(x))\n\
    \        val decimalsArr = decimalsArr.sortBy(x => math.abs(x))\n        onesArr\
    \ ++ decimalsArr\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3won5dqt.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3won5dqt.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3won5dqt.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3won5dqt.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => math.abs(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp3won5dqt.scala:20:8 ---------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        onesArr ++ decimalsArr\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / ones\n \
    \       val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv7bouyx0.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv7bouyx0.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpv7bouyx0.scala:28:68 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv7bouyx0.scala:34:89\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m                                              \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decs = arr.map(x => math.abs(math.log2(x)))\n        val sorted =\
    \ decs.zip(ones).sortBy(_._1).map(x => x._2)\n        sorted.map(x => arr.indexOf(x)).sort\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmo40os4x.scala:13:46 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = arr.map(\e[36mx\e\
    [0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \          value log2 is not a member of math\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmo40os4x.scala:14:30 --------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.zip(ones).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                              ^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (ones : Int)\n\e[31m\
    \   |\e[0m                              Required: IterableOnce[Any]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpmo40os4x.scala:14:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.zip(ones).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \             ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mLong\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val twos = arr.filter(x => x == 2).length\n        val threes = arr.filter(x\
    \ => x == 3).length\n        val fours = arr.filter(x => x == 4).length\n    \
    \    val fives = arr.filter(x => x == 5).length\n        val sixes = arr.filter(x\
    \ => x == 6).length\n        val sevens = arr.filter(x => x == 7).length\n   \
    \     val eights = arr.filter(x => x == 8).length\n        val nines = arr.filter(x\
    \ => x == 9).length\n        val tens = arr.filter(x => x == 10).length\n    \
    \    val hundreds = arr.filter(x => x == 11).length\n        val thousands = arr.filter(x\
    \ => x == 12).length\n        val millions = arr.filter(x => x == 13).length\n\
    \        val billions = arr.filter(x => x == 14).length\n        val trillions\
    \ = arr.filter(x => x == 15).length\n        val quadrillions = arr.filter(x =>\
    \ x == 16).length\n        val quintillions = arr.filter(x => x == 17).length\n\
    \        val sextillions = arr.filter(x => x == 18).length\n        val septillions\
    \ = arr.filter(x => x == 19).length\n        val octillions = arr.filter(x =>\
    \ x == 20).length\n        val nonillions = arr.filter(x => x == 21).length\n\
    \        val decillions = arr.filter(x => x == 22).length\n        val undecillions\
    \ = arr.filter(x => x == 23).length\n        val duodecillions = arr.filter(x\
    \ => x == 24).length\n        val tredecillions = arr.filter(x => x == 25).length\n\
    \        val quattuordecillions = arr.filter(x => x == 26).length\n        val\
    \ quindecillions = arr.filter(x => x == 27).length\n        val sexdecillions\
    \ = arr.filter(x => x == 28).length\n        val septendecillions = arr.filter(x\
    \ => x == 29).length\n        val octodecillions = arr.filter(x => x == 30).length\n\
    \        val novemdecillions = arr.filter(x => x == 31).length\n        val vigintillions\
    \ = arr.filter(x => x == 32).length\n        val unvigintillions = arr.filter(x\
    \ => x == 33).length\n        val duovigintillions = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpucz0ktsr.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpucz0ktsr.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795225
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => if (x ==\
    \ 1) 1 else 0)\n        val zerosArr = arr.map(x => if (x == 0) 0 else 1)\n  \
    \      val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr =\
    \ zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n  \
    \      val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_\
    \ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr =\
    \ onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n \
    \       val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr =\
    \ zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n  \
    \      val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_\
    \ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr =\
    \ onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n \
    \       val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr =\
    \ zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_ < _)\n  \
    \      val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.sortWith(_\
    \ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr =\
    \ onesArr.sortWith(_\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpexk4dbmw.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpexk4dbmw.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArr\e[0m = onesArr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpexk4dbmw.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpexk4dbmw.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith(_ <\
    \ _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpexk4dbmw.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpexk4dbmw.scala:20:12 ---------------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 10000000000000000000000000000000001)\n        val decillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000010)\n        val undecillionsOne = arr.count(_\
    \ == 10000000000000000000000000000000011)\n        val decillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000100)\n        val undecillionsTwo = arr.count(_\
    \ == 100000000000000000000000000000000101)\n        val decillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001000)\n        val undecillionsThree = arr.count(_\
    \ == 1000000000000000000000000000000001001)\n        val decillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010000)\n        val undecillionsFour = arr.count(_\
    \ == 10000000000000000000000000000000010001)\n        val decillionsFive = arr.count(_\
    \ == 100000000000000000000000000000000100000)\n        val undecillionsFive =\
    \ arr.count(_ == 100000000000000000000000000000000100001)\n        val decillionsSix\
    \ = arr.count(_ == 1000000000000000000000000000000001000000)\n        val undecillion\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8xxvypl.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmph8xxvypl.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmph8xxvypl.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:30:41 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmph8xxvypl.scala:31:40 -------------------------------"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(x => math.abs(math.log2(x)))\n        val sorted = decs.sortWith((x,\
    \ y) => math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.sig\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3jugzd8v.scala:15:4 ----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3jugzd8v.scala:13:46\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mdecs\e[0m = arr.map(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m\
    \   |\e[0m                                         ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      value log2 is not a member of math\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp3jugzd8v.scala:14:58 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) * math.signum(x-y) * math.signum(x-y)\
    \ * math.signum(x-y) * math.signum(x-y) *"
  stdout: ''
  timestamp: 1659795200
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val zeros = arr.filter(x => x % 2 == 1).length\n        val\
    \ onesArr = arr.filter(x => x % 2 == 0).sorted\n        val zerosArr = arr.filter(x\
    \ => x % 2 == 1).sorted\n        val onesCount = onesArr.count(_ == 1)\n     \
    \   val zerosCount = zerosArr.count(_ == 0)\n        val onesDecimal = onesArr.map(x\
    \ => math.pow(2,x)).sum\n        val zerosDecimal = zerosArr.map(x => math.pow(2,x)).sum\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.count(_ == zerosDecimal)\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.count(_ == zerosDecimal)\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.count(_ == zerosDecimal)\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.count(_ == zerosDecimal)\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.count(_ == zerosDecimal)\n\
    \        val onesDecimalCount = onesArr.count(_ == onesDecimal)\n        val zerosDecimalCount\
    \ = zerosArr.count(_ == zerosDecimal)\n        val onesDecimalCount = onesArr.count(_\
    \ == onesDecimal)\n        val zerosDecimalCount = zerosArr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj29yy5r0.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj29yy5r0.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m = onesArr.count(_ ==\
    \ onesDecimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj29yy5r0.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.count(_ == zerosDecimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj29yy5r0.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesDecimalCount\e[0m =\
    \ onesArr.count(_ == onesDecimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35monesDecimalCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj29yy5r0.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalCount\e[0m =\
    \ zerosArr.count(_ == zerosDecimal)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalCount is already defined as \e[33mvalue\e[0m \e\
    [35mzerosDecimalCou"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decs = arr.filter(_ % 2 == 1).map(_.toString.toInt).sortWith(_ <\
    \ _)\n        val result = decs.zip(ones).sortWith(_._1 < _._1).map(_._2)\n  \
    \      result.map(_.toLong)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_4sqm78.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = decs.zip(ones).sortWith(_._1 < _._1).map(_._2)\n\e[31m\e[31m   |\e[0m  \
    \                            ^^^^\e[0m\n\e[31m   |\e[0m                      \
    \        Found:    (ones : Int)\n\e[31m   |\e[0m                             \
    \ Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpw_4sqm78.scala:15:21 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        result.map(_.toLong)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Nothing, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e\
    [0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e\
    [0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\e[31m\
    \   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\e\
    [31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val decs = arr.filter(x => x == 0).map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val decs = decs.takeWhile(x => x < ones)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x => x < decs.length)\n\
    \        val decs = decs.takeWhile(x => x < decs.length)\n        val decs = decs.takeWhile(x\
    \ => x < decs.length)\n        val decs = decs.takeWhile(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgxk6mxg_.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgxk6mxg_.scala:14:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m => x < ones)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mdecs\
    \ is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgxk6mxg_.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m => x < decs.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgxk6mxg_.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m =>\
    \ x < decs.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgxk6mxg_.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.takeWhile(\e[36mx\e[0m =>\
    \ x < decs.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Erro"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val maxOnes = arr.filter(x\
    \ => x == 1).max\n        val maxZeros = arr.filter(x => x == 0).max\n       \
    \ val maxOnesDecimal = maxOnes.toString.toDouble\n        val maxZerosDecimal\
    \ = maxZeros.toString.toDouble\n        val maxDecimal = math.max(maxOnesDecimal,\
    \ maxZerosDecimal)\n        val decimal = math.min(maxDecimal, maxOnesDecimal,\
    \ maxZerosDecimal)\n        val onesDecimal = ones / decimal\n        val zerosDecimal\
    \ = zeros / decimal\n        val decimals = arr.map(x => x.toString.toDouble).toList\n\
    \        val decimalsSorted = decimals.sortWith((x, y) => math.abs(x - y) < decimal)\n\
    \        val decimalsSortedWithOnes = decimalsSorted.filter(x => x == onesDecimal)\n\
    \        val decimalsSortedWithZeros = decimalsSorted.filter(x => x == zerosDecimal)\n\
    \        val decimalsSortedWithOnesDecimal = decimalsSortedWithOnes.map(x => x.toString.toDouble).toList\n\
    \        val decimalsSortedWithZerosDecimal = decimalsSortedWithZeros.map(x =>\
    \ x.toString.toDouble).toList\n        val decimalsSortedWithOnesDecimalSorted\
    \ = decimalsSortedWithOnesDecimal.sortWith((x, y) => math.abs(x - y) < decimal)\n\
    \        val decimalsSortedWithZerosDecimalSorted = decimalsSortedWithZerosDecimal.sortWith((x,\
    \ y) => math.abs(x - y) < decimal)\n        val decimalsSortedWithOnesDecimalSortedWithZeros\
    \ = decimalsSortedWithOnesDecimalSorted.filter(x => x == zerosDecimal)\n     \
    \   val decimalsSortedWithOnesDecimalSortedWithOnes = decimalsSortedWithOnesDecimalSorted.filter(x\
    \ => x == onesDecimal)\n        val decimalsSortedWithOnesDecimalSortedWithZerosDecimal\
    \ = decimalsSortedWithOnesDecimalSortedWithZeros.map(x => x.toString.toDouble).toList\n\
    \        val decimalsSortedWithOnesDecimalSortedWithOnesDecimal = decimalsSortedWithOnesDecimalSortedWithOnes.map(x\
    \ => x.toString.toDouble).toList\n        val decimalsSortedWithOnesDecimalSortedWithZerosDecimalSorted\
    \ = decimalsSortedWithOnesDecimalSortedWithZerosDecimal.sortWith((\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3s_q9516.scala:34:134 --------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mdecimalsSortedWithOnesDecimalSortedWithZerosDecimalSorted\e\
    [0m = decimalsSortedWithOnesDecimalSortedWithZerosDecimal.sortWith((\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3s_q9516.scala:19:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e\
    [0m \e[36mdecimal\e[0m = math.min(maxDecimal, maxOnesDecimal, maxZerosDecimal)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmin\e[0m in \e[33mpackage\e\
    [0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x: Double, y: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long,\
    \ y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch\
    \ arguments ((maxDecimal : Double), (maxOnesDecimal : Double), (maxZerosDecimal\
    \ : Double))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3s_q9516.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.toList\n        val zerosCount = zeros.toList\n        val\
    \ onesZeros = ones.zip(zeros)\n        val onesZerosCount = onesZeros.toList\n\
    \        val onesZerosCountSorted = onesZerosCount.sortBy(_._1)\n        val onesZerosCountSortedSorted\
    \ = onesZerosCountSorted.sortBy(_._2)\n        val onesZerosCountSortedSortedSorted\
    \ = onesZerosCountSortedSorted.sortBy(_._1)\n        val onesZerosCountSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSorted.sortBy(_._2)\n        val onesZerosCountSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSorted.sortBy(_._1)\n        val onesZerosCountSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSorted.sortBy(_._2)\n        val onesZerosCountSortedSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSortedSortedSorted.sortBy(_._1)\n  \
    \      val onesZerosCountSortedSortedSortedSortedSortedSortedSortedSorted = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._2)\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._1)\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._2)\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._1)\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\
    \ = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._2)\n\
    \        val onesZerosCountSortedSortedSortedSortedSortedSorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbqpebklb.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbqpebklb.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\e\
    [0m = onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  onesZerosCountSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedSorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpbqpebklb.scala:24:71 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36monesZerosCountSortedSortedSortedSortedSortedSortedSorted\e\
    [0m = onesZerosCountSortedSortedSortedSortedSortedSortedSorted.sortBy(_._1)\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesZerosCountSortedSortedSortedSortedSortedSortedSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbqpebklb.scala:25:77\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesZerosCountSortedSortedSortedSortedSortedSortedSortedSorted\e[0m =\
    \ onesZerosCountSortedSortedSortedSortedSortedSortedSortedSorted.sortBy(_._2)\n\
    \e[31m\e[31m"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val decimals = arr.filter(x => x == 0).length\n        val maxOnes =\
    \ arr.max\n        val maxDecimals = arr.max\n        val onesArr = arr.filter(x\
    \ => x == 1).map(x => x.toLong).toList\n        val decimalsArr = arr.filter(x\
    \ => x == 0).map(x => x.toLong).toList\n        val onesArr = onesArr.sortBy(x\
    \ => onesArr.indexOf(x))\n        val decimalsArr = decimalsArr.sortBy(x => decimalsArr.indexOf(x))\n\
    \        val result = onesArr.zip(decimalsArr).sortBy(x => x._1 - x._2)\n    \
    \    result.map(x => x._1 + x._2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyig96sq6.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortBy(\e\
    [36mx\e[0m => onesArr.indexOf(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyig96sq6.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortBy(\e\
    [36mx\e[0m => decimalsArr.indexOf(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(x => math.abs(x))\n        val zerosArr = arr.filter(_ % 2\
    \ == 1).sortBy(x => math.abs(x))\n        val onesCount = onesArr.length\n   \
    \     val zerosCount = zerosArr.length\n        val onesCountArr = onesArr.sortBy(x\
    \ => math.abs(x))\n        val zerosCountArr = zerosArr.sortBy(x => math.abs(x))\n\
    \        val onesCountCount = onesCountArr.length\n        val zerosCountCount\
    \ = zerosCountArr.length\n        val onesCountCountArr = onesCountArr.sortBy(x\
    \ => math.abs(x))\n        val zerosCountCountArr = zerosCountArr.sortBy(x =>\
    \ math.abs(x))\n        val onesCountCountCount = onesCountCountArr.length\n \
    \       val zerosCountCountCount = zerosCountCountArr.length\n        val onesCountCountCountArr\
    \ = onesCountCountArr.sortBy(x => math.abs(x))\n        val zerosCountCountCountArr\
    \ = zerosCountCountArr.sortBy(x => math.abs(x))\n        val onesCountCountCountCount\
    \ = onesCountCountCountArr.length\n        val zerosCountCountCountCount = zerosCountCountCountArr.length\n\
    \        val onesCountCountCountCountArr = onesCountCountCountArr.sortBy(x =>\
    \ math.abs(x))\n        val zerosCountCountCountArr = zerosCountCountCountArr.sortBy(x\
    \ => math.abs(x))\n        val onesCountCountCountCountCount = onesCountCountCountArr.length\n\
    \        val zerosCountCountCountCount = zerosCountCountCountArr.length\n    \
    \    val onesCountCountCountCountArr = onesCountCountCountArr.sortBy(x => math.abs(x))\n\
    \        val zerosCountCountCountArr = zerosCountCountCountArr.sortBy(x => math.abs(x))\n\
    \        val onesCountCountCountCountCount = onesCountCountCountArr.length\n \
    \       val zerosCountCountCountCount = zerosCountCountCountArr.length\n     \
    \   val onesCountCountCountCountArr = onesCountCountCountArr.sortBy(x => math.abs(x))\n\
    \        val zerosCountCountCountArr = zerosCountCountCountArr.sortBy(x => math.abs(x))\n\
    \        val onesCountCountCountCountCount = onesCountCountCountArr.length\n\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprvist15v.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mzerosCountCountCountArr\e\
    [0m = zerosCountCountCountArr.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCountCountCountArr is already defined as \e[33mvalue\e\
    [0m \e[35mzerosCountCountCountArr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprvist15v.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosCountCountCountCount\e\
    [0m = zerosCountCountCountArr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCountCountCountCount is already defined as \e[33mvalue\e\
    [0m \e[35mzerosCountCountCountCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprvist15v.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesCountCountCountCountArr\e\
    [0m = onesCountCountCountArr.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesCountCountCountCountArr is already defined as \e[33mvalue\e\
    [0m \e[35monesCountCountCountCountArr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprvist15v.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosCountCountCountArr\e\
    [0m = zerosCountCountCountArr.sortBy(\e[36mx\e[0m => math.abs(x))\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosCountCountCountArr is already defined "
  stdout: ''
  timestamp: 1659795253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => if (x ==\
    \ 1) 1 else 0)\n        val zerosArr = arr.map(x => if (x == 0) 0 else 1)\n  \
    \      val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.map(x => if (x == 1) x else 0)\n       \
    \ val zerosArr = zerosArr.map(x => if (x == 0) x else 1)\n        val onesArr\
    \ = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n\
    \        val onesArr = onesArr.map(x => if (x == 1) x else 0)\n        val zerosArr\
    \ = zerosArr.map(x => if (x == 0) x else 1)\n        val onesArr = onesArr.sortWith(_\
    \ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr =\
    \ onesArr.map(x => if (x == 1) x else 0)\n        val zerosArr = zerosArr.map(x\
    \ => if (x == 0) x else 1)\n        val onesArr = onesArr.sortWith(_ < _)\n  \
    \      val zerosArr = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.map(x\
    \ => if (x == 1) x else 0)\n        val zerosArr = zerosArr.map(x => if (x ==\
    \ 0) x else 1)\n        val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr\
    \ = zerosArr.sortWith(_ < _)\n        val onesArr = onesArr.map(x => if (x ==\
    \ 1) x else 0)\n        val zerosArr = zerosArr.map(x => if (x == 0) x else 1)\n\
    \        val onesArr = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_\
    \ < _)\n        val onesArr = onesArr.map(x => if (x == 1) x else 0)\n       \
    \ val zerosArr = zerosArr.map(x => if (x == 0) x else 1)\n        val onesArr\
    \ = onesArr.sortWith(_ < _)\n        val zerosArr = zerosArr.sortWith(_ < _)\n\
    \        val onesArr = onesAr\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpld7neuww.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpld7neuww.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpld7neuww.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.map(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m1\e[0m) x \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpld7neuww.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.map(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m0\e[0m) x \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpld7neuww.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36m"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val onesCount = ones.reduceLeft(_ + _)\n        val decimals\
    \ = arr.map(x => math.log10(x) / math.log10(onesCount))\n        val decimalsCount\
    \ = decimals.reduceLeft(_ + _)\n        val decimalsSorted = decimals.sortBy(x\
    \ => x)\n        val decimalsSortedCount = decimalsSorted.reduceLeft(_ + _)\n\
    \        val decimalsSortedSortedCount = decimalsSorted.sortBy(x => x).reduceLeft(_\
    \ + _)\n        val decimalsSortedSortedSortedCount = decimalsSorted.sortBy(x\
    \ => x).sortBy(x => x).reduceLeft(_ + _)\n        val decimalsSortedSortedSortedSortedCount\
    \ = decimalsSorted.sortBy(x => x).sortBy(x => x).sortBy(x => x).reduceLeft(_ +\
    \ _)\n        val decimalsSortedSortedSortedSortedSortedCount = decimalsSorted.sortBy(x\
    \ => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).reduceLeft(_ + _)\n     \
    \   val decimalsSortedSortedSortedSortedSortedSortedCount = decimalsSorted.sortBy(x\
    \ => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).reduceLeft(_\
    \ + _)\n        val decimalsSortedSortedSortedSortedSortedSortedSortedCount =\
    \ decimalsSorted.sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x\
    \ => x).sortBy(x => x).reduceLeft(_ + _)\n        val decimalsSortedSortedSortedSortedSortedSortedSortedSortedCount\
    \ = decimalsSorted.sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x\
    \ => x).sortBy(x => x).sortBy(x => x).reduceLeft(_ + _)\n        val decimalsSortedSortedSortedSortedSortedSortedSortedSortedSortedCount\
    \ = decimalsSorted.sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x\
    \ => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).reduceLeft(_ + _)\n     \
    \   val decimalsSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedCount\
    \ = decimalsSorted.sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x => x).sortBy(x\
    \ => x).sortBy(\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprvof3j_a.scala:26:185 --------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mdecimalsSortedSortedSortedSortedSortedSortedSortedSortedSortedSortedCount\e\
    [0m = decimalsSorted.sortBy(\e[36mx\e[0m => x).sortBy(\e[36mx\e[0m => x).sortBy(\e\
    [36mx\e[0m => x).sortBy(\e[36mx\e[0m => x).sortBy(\e[36mx\e[0m => x).sortBy(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmprvof3j_a.scala:27:4 ------------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmprvof3j_a.scala:27:5 ---------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val decs = arr.map(x => math.log10(x)).sortBy(x => x).reverse\n     \
    \   val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n       \
    \ val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val\
    \ decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs\
    \ = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs =\
    \ decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x\
    \ => math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x =>\
    \ math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x => math.pow(10,\
    \ x)).sortBy(x => x).reverse\n        val decs = decs.map(x => math.pow(10, x)).sortBy(x\
    \ => x).reverse\n        val decs = decs.map(x => math.pow(10, x)).sortBy(x =>\
    \ x).reverse\n        val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n\
    \        val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n  \
    \      val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n    \
    \    val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n      \
    \  val decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val\
    \ decs = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs\
    \ = decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs =\
    \ decs.map(x => math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x\
    \ => math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x =>\
    \ math.pow(10, x)).sortBy(x => x).reverse\n        val decs = decs.map(x => math.pow(10,\
    \ x)).sortBy(x => x).reverse\n        val decs = decs.map(x => math.pow(10, x)).sortBy(x\
    \ => x).reverse\n        val decs = decs.map(x => math.pow(10, x)).sortBy(x =>\
    \ x).\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_dn0pm8l.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_dn0pm8l.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.pow(\e\
    [31m10\e[0m, x)).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_dn0pm8l.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.pow(\e\
    [31m10\e[0m, x)).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_dn0pm8l.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.pow(\e\
    [31m10\e[0m, x)).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_dn0pm8l.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.pow(\e\
    [31m10\e[0m, x)).sortBy(\e[36mx\e[0m => x).reverse\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val onesAndZeroes = arr.count(_ == 1)\n        val onesAndOnes = arr.count(_\
    \ == 1)\n        val onesAndTwos = arr.count(_ == 2)\n        val onesAndThrees\
    \ = arr.count(_ == 3)\n        val onesAndFours = arr.count(_ == 4)\n        val\
    \ onesAndFives = arr.count(_ == 5)\n        val onesAndSixes = arr.count(_ ==\
    \ 6)\n        val onesAndSevens = arr.count(_ == 7)\n        val onesAndEights\
    \ = arr.count(_ == 8)\n        val onesAndNines = arr.count(_ == 9)\n        val\
    \ onesAndTens = arr.count(_ == 10)\n        val onesAndHundreds = arr.count(_\
    \ == 100)\n        val onesAndThousands = arr.count(_ == 1000)\n        val onesAndMillions\
    \ = arr.count(_ == 1000000)\n        val onesAndBillions = arr.count(_ == 1000000000)\n\
    \        val onesAndTrillions = arr.count(_ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1000000000000000)\n        val onesAndQuintillions = arr.count(_\
    \ == 1000000000000000000)\n        val onesAndOnesAndZeroes = arr.count(_ == 1)\n\
    \        val onesAndOnesAndOnes = arr.count(_ == 1)\n        val onesAndOnesAndTwos\
    \ = arr.count(_ == 2)\n        val onesAndOnesAndThrees = arr.count(_ == 3)\n\
    \        val onesAndOnesAndFours = arr.count(_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpodfmx0ty.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpodfmx0ty.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpodfmx0ty.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpodfmx0ty.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpodfmx0ty.scala:44:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndTrillions\e[0m =\
    \ arr.count(_ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpodfmx0ty.scala:45:49 -----------------------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36monesAndQuadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpodfmx0ty.scala:46:49 ------------------------------"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val quadrillions_2 = arr.map(x => if (x\
    \ == 1000000000000000000000) 1000000000000000000000 else 0)\n        val trillions_2\
    \ = arr.map(x => if (x == 1000000000000000000000000) 1000000000000000000000000\
    \ else 0)\n        val billions_2 = arr.map(x => if (x == 1000000000000000000000000000)\
    \ 1000000000000000000000000000 else 0)\n        val millions_2 = arr.map(x =>\
    \ if (x == 1000000000000000000000000000000) 1000000000000000000000000000000 else\
    \ 0)\n        val thousands_2 = arr.map(x => if (x == 1000000000000000000000000000000000)\
    \ 1000000000000000000000000000000000 else 0)\n        val hundreds_2 = arr.map(x\
    \ => if (x == 1000000000000000000000000000000000) 1000000000000000000000000000000000\
    \  else 0)\n        val tens_2 = arr.map(x => if (x == 100000000000000000000000000000000)\
    \ 100000000000000000000000000000000 else 0)\n        val ones_2 = arr.map(x =>\
    \ if (x == \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpunz1qkaa.scala:38:42 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mones_2\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \n\e[31m\e[31m   |\e[0m                    \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \        expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpunz1qkaa.scala:28:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e\
    [0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                              number too large\n\e[31m\e[31m-- Error: /tmp/tmpunz1qkaa.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpunz1qkaa.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpunz1qkaa.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   "
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.count(_ > 0)\n  \
    \      val twos_count = twos.count(_ > 0)\n        val threes_count = threes.count(_\
    \ > 0)\n        val fours_count = fours.count(_ > 0)\n        val fives_count\
    \ = fives.count(_ > 0)\n        val sixes_count = sixes.count(_ > 0)\n       \
    \ val sevens_count = sevens.count(_ > 0)\n        val eights_count = eights.count(_\
    \ > 0)\n        val nines_count = nines.count(_ > 0)\n        val tens_count =\
    \ tens.count(_ > 0)\n        val hundreds_count = hundreds.count(_ > 0)\n    \
    \    val thousands_count = thousands.count(_ > 0)\n        val ten_thousands_count\
    \ = ten_thousands.count(_ > 0)\n        val hundred_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6vqvv276.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp6vqvv276.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp6vqvv276.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795223
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.size\n        val\
    \ twos_count = twos.size\n        val threes_count = threes.size\n        val\
    \ fours_count = fours.size\n        val fives_count = fives.size\n        val\
    \ sixes_count = sixes.size\n        val sevens_count = sevens.size\n        val\
    \ eights_count = eights.size\n        val nines_count = nines.size\n        val\
    \ tens_count = tens.size\n        val hundreds_count = hundreds.size\n       \
    \ val thousands_count = thousands.size\n        val ten_thousands_count = ten_thousands.size\n\
    \        val hundred_thousands_count = hundred_thousands.size\n        val millions_count\
    \ = millions.size\n        val billions_count = billions.size\n        val trillions_count\
    \ = trillions.size\n        val quadrillion\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpui58upli.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmpui58upli.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpui58upli.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => (x >>> 0).toInt).sortBy(x\
    \ => x)\n        val zerosDec = arr.map(x => (x >>> 0).toInt).sortBy(x => -x)\n\
    \        val onesBin = onesDec.map(x => (x >>> 0).toInt).sortBy(x => x)\n    \
    \    val zerosBin = zerosDec.map(x => (x >>> 0).toInt).sortBy(x => -x)\n     \
    \   val onesBinList = onesBin.toList\n        val zerosBinList = zerosBin.toList\n\
    \        val onesBinList2 = onesBinList.zip(zerosBinList).map(x => x._1 + x._2)\n\
    \        val zerosBinList2 = zerosBinList.zip(onesBinList).map(x => x._1 + x._2)\n\
    \        val onesBinList3 = onesBinList2.zip(zerosBinList2).map(x => x._1 + x._2)\n\
    \        val zerosBinList3 = zerosBinList2.zip(onesBinList2).map(x => x._1 + x._2)\n\
    \        val onesBinList4 = onesBinList3.zip(zerosBinList3).map(x => x._1 + x._2)\n\
    \        val zerosBinList4 = zerosBinList3.zip(onesBinList3).map(x => x._1 + x._2)\n\
    \        val onesBinList5 = onesBinList4.zip(zerosBinList4).map(x => x._1 + x._2)\n\
    \        val zerosBinList5 = zerosBinList4.zip(onesBinList4).map(x => x._1 + x._2)\n\
    \        val onesBinList6 = onesBinList5.zip(zerosBinList5).map(x => x._1 + x._2)\n\
    \        val zerosBinList6 = zerosBinList5.zip(onesBinList5).map(x => x._1 + x._2)\n\
    \        val onesBinList7 = onesBinList6.zip(zerosBinList6).map(x => x._1 + x._2)\n\
    \        val zerosBinList7 = zerosBinList6.zip(onesBinList6).map(x => x._1 + x._2)\n\
    \        val onesBinList8 = onesBinList7.zip(zerosBinList7).map(x => x._1 + x._2)\n\
    \        val zerosBinList8 = zerosBinList7.zip(onesBinList7).map(x => x._1 + x._2)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp98iohn0d.scala:35:5\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.reduceLeft(_ + _)\n        val zerosCount = zeros.reduceLeft(_\
    \ + _)\n        val onesZeros = ones.zip(zeros)\n        val onesZerosCount =\
    \ onesZeros.reduceLeft(_ + _)\n        val onesZerosCountSorted = onesZerosCount.sortBy(x\
    \ => x)\n        val onesZerosCountSortedSortedByOnesCount = onesZerosCountSorted.sortBy(x\
    \ => if (x == 1) 0 else 1)\n        val onesZerosCountSortedSortedByOnesCountReversed\
    \ = onesZerosCountSortedSortedByOnesCount.reverse\n        val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCount\
    \ = onesZerosCountSortedSortedByOnesCountReversed.sortBy(x => if (x == 1) 0 else\
    \ 1)\n        val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversed\
    \ = onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCount.reverse\n \
    \       val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCount\
    \ = onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversed.sortBy(x\
    \ => if (x == 1) 0 else 1)\n        val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversed\
    \ = onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCount.reverse\n\
    \        val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCount\
    \ = onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversed.sortBy(x\
    \ => if (x == 1) 0 else 1)\n        val onesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversed\
    \ = onesZerosCountSortedSortedByOnesCountReversedSortedByOne\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5cf1h16e.scala:17:52 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36monesZerosCount\e[0m = onesZeros.reduceLeft(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of (Int, Int), but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5cf1h16e.scala:18:50 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36monesZerosCountSorted\e[0m\
    \ = onesZerosCount.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m          \
    \                         ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      value sortBy is not a member of (Int, Int)\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5cf1h16e.scala:26:135 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36monesZerosCountSortedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversedSortedByOnesCountReversed\e\
    [0m = onesZerosCountSortedSortedByOnesCountReversedSortedByOne\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     Not found: onesZerosCountSortedSortedByOnesCountReversedSortedByOne\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5cf1h16e.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available whe"
  stdout: ''
  timestamp: 1659795259
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val sorted = arr.sortBy(x\
    \ => (ones - x % ones) * (decimals - x % decimals))\n        sorted.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpapnfunq2.scala:18)\n\tat Problem.main(tmpapnfunq2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => (x >>> 0).toInt)\n\
    \        val zerosDec = arr.map(x => (x >>> 0).toInt)\n        val onesDec.sortWith(_\
    \ < _)\n        val zerosDec.sortWith(_ < _)\n        val onesDec.zip(zerosDec).sortWith(_._1\
    \ < _._1)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8kl06231.scala:17:0 ----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m zerosDec.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=' expected, but 'end of statement' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8kl06231.scala:18:0 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m onesDec.zip(zerosDec).sortWith(_._1\
    \ < _._1)\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e[0m'=' expected, but 'end\
    \ of statement' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8kl06231.scala:18:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ onesDec.zip(zerosDec).sortWith(_._1 < _._1)\n\e[31m\e[31m   |\e[0m         \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \    '=' expected, but '.' found\n\e[31m\e[31m-- [E127] Syntax Error: /tmp/tmp8kl06231.scala:16:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ onesDec.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec.sortWith cannot be used as an extractor in a pattern\
    \ because it lacks an unapply or unapplySeq method\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8kl06231.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m onesDec.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     Not found: <\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E127] Syntax Error:\
    \ /tmp/tmp8kl06231.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m zerosDec.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mzerosDec.sortWith cannot be\
    \ used as an extractor in a pattern because it lacks an unapply or unapplySeq\
    \ method\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/t"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(x => math.pow(2,x)).sortBy(x => math.abs(x))\n        val\
    \ decs = decs.map(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n        val\
    \ decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x => math.abs(x))\n\
    \        val decs = decs.sortBy(x => math.abs(x))\n        val decs = decs.sortBy(x\
    \ => math.abs(x))\n        val decs = decs.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpui4n0oex.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpui4n0oex.scala:14:12 ---------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.map(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpui4n0oex.scala:15:12 ---------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpui4n0oex.scala:16:12 ---------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpui4n0oex.scala:17:12 ---------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = decs.sortBy(\e[36mx\e[0m => math.abs(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mdecs is already defined as \e[33mvalue\e[0m \e[35mdecs\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpui4n0oex.scala:18:12 ------"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val onesArr = arr.filter(x\
    \ => x == 1).map(x => x.toInt)\n        val zerosArr = arr.filter(x => x == 0).map(x\
    \ => x.toInt)\n        val onesMap = onesArr.groupBy(x => x).mapValues(_.size)\n\
    \        val zerosMap = zerosArr.groupBy(x => x).mapValues(_.size)\n        val\
    \ onesMapSorted = onesMap.sortBy(_._1).reverse\n        val zerosMapSorted = zerosMap.sortBy(_._1).reverse\n\
    \        val onesMapSorted2 = onesMapSorted.map(_._2).reverse\n        val zerosMapSorted2\
    \ = zerosMapSorted.map(_._2).reverse\n        val onesMapSorted3 = onesMapSorted2.map(_._3).reverse\n\
    \        val zerosMapSorted3 = zerosMapSorted2.map(_._3).reverse\n        val\
    \ onesMapSorted4 = onesMapSorted3.map(_._4).reverse\n        val zerosMapSorted4\
    \ = zerosMapSorted3.map(_._4).reverse\n        val onesMapSorted5 = onesMapSorted4.map(_._5).reverse\n\
    \        val zerosMapSorted5 = zerosMapSorted4.map(_._5).reverse\n        val\
    \ onesMapSorted6 = onesMapSorted5.map(_._6).reverse\n        val zerosMapSorted6\
    \ = zerosMapSorted5.map(_._6).reverse\n        val onesMapSorted7 = onesMapSorted6.map(_._7).reverse\n\
    \        val zerosMapSorted7 = zerosMapSorted6.map(_._7).reverse\n        val\
    \ onesMapSorted8 = onesMapSorted7.map(_._8).reverse\n        val zerosMapSorted8\
    \ = zerosMapSorted7.map(_._8).reverse\n        val onesMapSorted9 = onesMapSorted8.map(_._9).reverse\n\
    \        val zerosMapSorted9 = zerosMapSorted8.map(_._9).reverse\n        val\
    \ onesMapSorted10 = onesMapSorted9.map(_._10).reverse\n        val zerosMapSorted10\
    \ = zerosMapSorted9.map(_._10).reverse\n        val onesMapSorted11 = onesMapSorted10.map(_._11).reverse\n\
    \        val zerosMapSorted11 = zerosMapSorted10.map(_._11).reverse\n        val\
    \ onesMapSorted12 = onesMapSorted11.map(_._12).reverse\n        val zerosMapSorted12\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptve6q305.scala:41:30 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mzerosMapSorted12\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptve6q305.scala:18:36\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36monesMapSorted\e[0m = onesMap.sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m \
    \                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value sortBy\
    \ is not a member of scala.collection.MapView[Int, Int]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptve6q305.scala:19:38 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosMapSorted\e[0m = zerosMap.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value sortBy is not a member of scala.collection.MapView[Int,\
    \ Int]\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptve6q305.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => math.pow(2,\
    \ math.floor(math.log(x, 2)))).max\n        val zerosDec = arr.map(x => math.pow(2,\
    \ math.floor(math.log(x, 2)))).min\n        val onesBin = arr.map(x => math.pow(2,\
    \ math.floor(math.log(x, 2)))).map(x => math.pow(2, math.floor(math.log(x, 2)))).sum\n\
    \        val zerosBin = arr.map(x => math.pow(2, math.floor(math.log(x, 2)))).map(x\
    \ => math.pow(2, math.floor(math.log(x, 2)))).sum\n        val onesBinDec = onesBin\
    \ / onesDec\n        val zerosBinDec = zerosBin / zerosDec\n        val onesBinBin\
    \ = onesBin / zerosBin\n        val zerosBinBin = zerosBin / onesBin\n       \
    \ val onesBinBinDec = onesBinBin / onesDec\n        val zerosBinBinDec = zerosBinBin\
    \ / zerosDec\n        val onesBinBinBin = onesBinBin / zerosBinBin\n        val\
    \ zerosBinBinBin = zerosBinBin / onesBinBin\n        val onesBinBinBinDec = onesBinBinBin\
    \ / onesDec\n        val zerosBinBinBinDec = zerosBinBinBin / zerosDec\n     \
    \   val onesBinBinBinBin = onesBinBinBin / zerosBinBin\n        val zerosBinBinBinBin\
    \ = zerosBinBinBin / onesBinBinBin\n        val onesBinBinBinBinDec = onesBinBinBinBin\
    \ / onesDec\n        val zerosBinBinBinBinDec = zerosBinBinBinBin / zerosDec\n\
    \        val onesBinBinBinBin = onesBinBinBinBin / zerosBinBinBin\n        val\
    \ zerosBinBinBinBin = zerosBinBinBinBin / onesBinBinBin\n        val onesBinBinBinBinDec\
    \ = onesBinBinBinBin / onesDec\n        val zerosBinBinBinBinDec = zerosBinBinBinBin\
    \ / zerosDec\n        val onesBinBinBinBin = onesBinBinBinBin / zerosBinBinBin\n\
    \        val zerosBinBinBinBin = zerosBinBinBinBin / onesBinBinBin\n        val\
    \ onesBinBinBinBinDe\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_mgcwof2.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_mgcwof2.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesBinBinBinBin\e[0m = onesBinBinBinBin / zerosBinBinBin\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0monesBinBinBinBin is already defined as \e[33mvalue\e[0m \e[35monesBinBinBinBin\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_mgcwof2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosBinBinBinBin\e[0m = zerosBinBinBinBin\
    \ / onesBinBinBin\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBinBin is already defined as \e[33mvalue\e[0m \e\
    [35mzerosBinBinBinBin\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_mgcwof2.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36monesBinBinBinBinDec\e[0m\
    \ = onesBinBinBinBin / onesDec\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesBinBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35monesBinBinBinBinDec\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_mgcwof2.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mzerosBinBinBinBinDec\e[0m\
    \ = zerosBinBinBinBin / zerosDec\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosBinBinBinBinDec is already defined as \e[33mvalue\e[0m\
    \ \e[35mzerosBinBinBinBinDec"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 10000\
    \ else 0)\n        val millions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val billions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val ones_count = ones.count(_ == 1)\n \
    \       val twos_count = twos.count(_ == 2)\n        val threes_count = threes.count(_\
    \ == 3)\n        val fours_count = fours.count(_ == 4)\n        val fives_count\
    \ = fives.count(_ == 5)\n        val sixes_count = sixes.count(_ == 6)\n     \
    \   val sevens_count = sevens.count(_ == 7)\n        val eights_count = eights.count(_\
    \ == 8)\n        val nines_count = nines.count(_ == 9)\n        val tens_count\
    \ = tens.count(_ == 10)\n        val hundreds_count = hundreds.count(_ == 11)\n\
    \        val thousands_count = thousands.count(_ == 100)\n        val ten_thousands_count\
    \ = ten_thousands.count(_ == 1000)\n        val hundred_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp17c54cuv.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp17c54cuv.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \        number too large\n\e[31m\e[31m-- Error: /tmp/tmp17c54cuv.scala:28:61\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmp17c54cuv.scala:29:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmp17c54cuv.scala:29:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmp17c54cuv.scala:30:49 ----------------------"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val onesCount = arr.filter(x\
    \ => x == 1).map(x => x.toString.toInt).sum\n        val zerosCount = arr.filter(x\
    \ => x == 0).map(x => x.toString.toInt).sum\n        val onesDecimal = onesCount\
    \ / ones\n        val zerosDecimal = zerosCount / zeros\n        val onesDecimalDecimal\
    \ = onesDecimal / onesDecimal\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zerosDecimal\n        val onesDecimalDecimalDecimal = onesDecimalDecimal /\
    \ onesDecimalDecimal\n        val zerosDecimalDecimalDecimal = zerosDecimalDecimal\
    \ / zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimal =\
    \ zerosDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    \
    \    val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp61tkg3ir.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is already\
    \ defined as \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp61tkg3ir.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp61tkg3ir.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decimals = arr.filter(_ % 2 == 1).length\n        val maxOnes = arr.filter(_\
    \ % 2 == 0).max\n        val maxDecimals = arr.filter(_ % 2 == 1).max\n      \
    \  val maxDecimalsDecimal = maxDecimals.toDouble\n        val maxOnesDecimal =\
    \ maxOnes.toDouble\n        val maxDecimalsOne = maxDecimals.toInt\n        val\
    \ maxOnesOne = maxOnes.toInt\n        val maxDecimalsOneDecimal = maxDecimalsDecimal.toInt\n\
    \        val maxOnesOneDecimal = maxOnesDecimal.toInt\n        val maxDecimalsOneOne\
    \ = maxDecimalsDecimal.toInt\n        val maxOnesOneOne = maxOnesDecimal.toInt\n\
    \        val maxDecimalsOneOneDecimal = maxDecimalsDecimal.toInt\n        val\
    \ maxOnesOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOne =\
    \ maxOnesDecimal.toInt\n        val maxOnesOneOneOne = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n\
    \        val maxOnesOneOneOneDecimal = maxOnesDecimal.toInt\n        val maxOnesOneOneOneDecimal\
    \ = maxOnesDecimal\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpokf687ue.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOneOneOne\e[0m =\
    \ maxOnesDecimal.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesOneOneOne is already defined as \e[33mvalue\e[0m \e\
    [35mmaxOnesOneOneOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpokf687ue.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOneOneOneDecimal\e\
    [0m = maxOnesDecimal.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesOneOneOneDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesOneOneOneDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpokf687ue.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOneOneOneDecimal\e\
    [0m = maxOnesDecimal.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesOneOneOneDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesOneOneOneDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpokf687ue.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesOneOneOneDecimal\e\
    [0m = maxOnesDecimal.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesOneOneOneDecimal is already defined as \e[33mvalue\e\
    [0m \e[35mmaxOnesOneOneOneDecimal\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpokf687ue.scala:32:12 ---------------------------\e\
    [0m\e["
  stdout: ''
  timestamp: 1659795261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val twos = arr.count(x => x == 2)\n        val threes = arr.count(x =>\
    \ x == 3)\n        val fours = arr.count(x => x == 4)\n        val fives = arr.count(x\
    \ => x == 5)\n        val sixes = arr.count(x => x == 6)\n        val sevens =\
    \ arr.count(x => x == 7)\n        val eights = arr.count(x => x == 8)\n      \
    \  val nines = arr.count(x => x == 9)\n        val tens = arr.count(x => x ==\
    \ 10)\n        val hundreds = arr.count(x => x == 100)\n        val thousands\
    \ = arr.count(x => x == 1000)\n        val millions = arr.count(x => x == 1000000)\n\
    \        val billions = arr.count(x => x == 1000000000)\n        val trillions\
    \ = arr.count(x => x == 1000000000000)\n        val quadrillions = arr.count(x\
    \ => x == 1000000000000000)\n        val quintillions = arr.count(x => x == 1000000000000000000)\n\
    \        val onesSorted = arr.sortWith((x, y) => x - y)\n        val twosSorted\
    \ = arr.sortWith((x, y) => x - y)\n        val threesSorted = arr.sortWith((x,\
    \ y) => x - y)\n        val foursSorted = arr.sortWith((x, y) => x - y)\n    \
    \    val fivesSorted = arr.sortWith((x, y) => x - y)\n        val sixesSorted\
    \ = arr.sortWith((x, y) => x - y)\n        val sevensSorted = arr.sortWith((x,\
    \ y) => x - y)\n        val eightsSorted = arr.sortWith((x, y) => x - y)\n   \
    \     val ninesSorted = arr.sortWith((x, y) => x - y)\n        val tensSorted\
    \ = arr.sortWith((x, y) => x - y)\n        val hundredsSorted = arr.sortWith((x,\
    \ y) => x - y)\n        val thousandsSorted = arr.sortWith((x, y) => x - y)\n\
    \        val millionsSorted = arr.sortWith((x, y) => x - y)\n        val billionsSorted\
    \ = arr.sortWith((x, y) => x - y)\n        val trillionsSorted = arr.sortWith((x,\
    \ y) => x - y)\n        val quadrillionsSorted = arr.sortWith((x, y) => x - y)\n\
    \        val quintillionsSorted = arr.sortWith((x, y) => x - y)\n        val onesSortedReversed\
    \ = onesSorted.reverse\n        val twosSortedReversed = twosSorted.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcbjwnv1q.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpcbjwnv1q.scala:26:44\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(\e[36mx\e[0m => x == \e[31m1000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpcbjwnv1q.scala:27:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                               number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmpcbjwnv1q.scala:28:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(\e\
    [36mx\e[0m => x == \e[31m1000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               number too large\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcbjwnv1q.scala:29:48 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesSorted\e[0m = arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m                   \
    \                             ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                            Found:    Long\n\e[31m   |\e[0m                 \
    \                               Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpcbjwnv1q.scala:30:48 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mtwosSorted\e[0m = arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[3"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt).reverse\n\
    \        val zerosDec = arr.map(_.toString.toInt).sortBy(_.toString.toInt)\n \
    \       val onesBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinBinBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinBin = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinBinBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \        val zerosBinBinBinDec = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \        val onesBinBinBinBin\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfnhf6ur3.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpfnhf6ur3.scala:20:83 --------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \        \e[33mval\e[0m \e[36monesBinBin\e[0m = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                         Found:    \e[1m\e[31mInt\e[0m => String\n\
    \e[31m   |\e[0m                                              Required: \e[1m\e\
    [32mString\e[0m => String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfnhf6ur3.scala:21:84 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosBinBin\e[0m = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                          Found:    \e[1m\e[31mInt\e[0m => String\n\
    \e[31m   |\e[0m                                              Required: \e[1m\e\
    [32mString\e[0m => String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfnhf6ur3.scala:22:86 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36monesBinBinDec\e[0m = arr.map(_.toString.toInt).map(Integer.toBinaryString).map(Integer.toBinaryString).sortBy(_.toString.toInt).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                            Found:    \e[1m\e[31mInt\e[0m =>\
    \ String\n\e"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesIndex = arr.lastIndexWhere(_\
    \ == 1)\n        val maxZerosIndex = arr.lastIndexWhere(_ == 0)\n        val maxOnesDecimal\
    \ = maxOnesIndex.toDouble / maxOnes\n        val maxZerosDecimal = maxZerosIndex.toDouble\
    \ / maxZeros\n        val maxOnesDecimalInt = maxOnesDecimal.toInt\n        val\
    \ maxZerosDecimalInt = maxZerosDecimal.toInt\n        val maxOnesDecimalLong =\
    \ maxOnesDecimal.toLong\n        val maxZerosDecimalLong = maxZerosDecimal.toLong\n\
    \        val maxOnesDecimalFloat = maxOnesDecimal.toFloat\n        val maxZerosDecimalFloat\
    \ = maxZerosDecimal.toFloat\n        val maxOnesDecimalDouble = maxOnesDecimal.toDouble\n\
    \        val maxZerosDecimalDouble = maxZerosDecimal.toDouble\n        val maxOnesDecimalDecimal\
    \ = maxOnesDecimal.toDecimal\n        val maxZerosDecimalDecimal = maxZerosDecimal.toDecimal\n\
    \        val maxOnesDecimalDecimalInt = maxOnesDecimalDecimal.toInt\n        val\
    \ maxZerosDecimalDecimalInt = maxZerosDecimalDecimal.toInt\n        val maxOnesDecimalDecimalLong\
    \ = maxOnesDecimalDecimal.toLong\n        val maxZerosDecimalDecimalLong = maxZerosDecimalDecimal.toLong\n\
    \        val maxOnesDecimalDecimalFloat = maxOnesDecimalDecimal.toFloat\n    \
    \    val maxZerosDecimalDecimalFloat = maxZerosDecimalDecimal.toFloat\n      \
    \  val maxOnesDecimalDecimalDouble = maxOnesDecimalDecimal.toDouble\n        val\
    \ maxZerosDecimalDecimalDouble = maxZerosDecimalDecimal.toDouble\n        val\
    \ maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal.toDecimal\n        val\
    \ maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal.toDecimal\n        val\
    \ maxOnesDecimalDecimalDecimalInt = maxOnesDecimalDecimalDecimal.toInt\n     \
    \   val maxZerosDecimalDecimalDecimalInt = maxZerosDecimalDecimalDecimal.toInt\n\
    \        val maxOnesDecimalDecimalDecimalLong = maxOnesDecimalDecimalDecimal.toLong\n\
    \        val max\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt41sfcsq.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt41sfcsq.scala:28:51\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxOnesDecimalDecimal\e[0m = maxOnesDecimal.toDecimal\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                               value toDecimal is not a member of Double\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt41sfcsq.scala:29:53 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimal\e\
    [0m = maxZerosDecimal.toDecimal\n\e[31m\e[31m   |\e[0m                       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                value toDecimal is not a member of Double\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpt41sfcsq.scala:44:5 ---------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val decimals = arr.filter(x => x % 2 == 1).length\n     \
    \   val sorted = arr.sortBy(x => (ones - x % 2).abs, x => (decimals - x % 10).abs)\n\
    \        sorted.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpazmozu64.scala:14:32 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones - x % \e[31m2\e[0m).abs, \e[36mx\e[0m => (decimals - x % \e\
    [31m10\e[0m).abs)\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\
    \e[31m   |\e[0m                          Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                          I could not infer the type of the\
    \ parameter x.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpazmozu64.scala:14:57\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e\
    [0m \e[36msorted\e[0m = arr.sortBy(\e[36mx\e[0m => (ones - x % \e[31m2\e[0m).abs,\
    \ \e[36mx\e[0m => (decimals - x % \e[31m10\e[0m).abs)\n\e[31m\e[31m   |\e[0m \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                          Missing parameter type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                          I could not infer the type of the parameter\
    \ x.\n\e[31m\e[31m-- Error: /tmp/tmpazmozu64.scala:14:86 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(\e\
    [36mx\e[0m => (ones - x % \e[31m2\e[0m).abs, \e[36mx\e[0m => (decimals - x % \e\
    [31m10\e[0m).abs)\n\e[31m\e[31m   |\e[0m                                     \
    \                                                 ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 1 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 1 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 1 else 0)\n        val fives = arr.map(x => if (x == 5) 1 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 1 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 1 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 1 else 0)\n        val nines = arr.map(x => if (x == 9) 1 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 1 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 1 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 1 else 0)\n        val millions = arr.map(x => if (x == 1000) 1 else\
    \ 0)\n        val billions = arr.map(x => if (x == 10000) 1 else 0)\n        val\
    \ trillions = arr.map(x => if (x == 100000) 1 else 0)\n        val quadrillions\
    \ = arr.map(x => if (x == 1000000) 1 else 0)\n        val quintillions = arr.map(x\
    \ => if (x == 100000000) 1 else 0)\n        val onesAndZeros = ones + twos + threes\
    \ + fours + fives + sixes + sevens + eights + nines + tens + hundreds + thousands\
    \ + millions + billions + trillions + quadrillions + quintillions\n        val\
    \ onesAndOnes = ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + one\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7p323ae8.scala:29:32 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36monesAndZeros\e[0m = ones\
    \ + twos + threes + fours + fives + sixes + sevens + eights + nines + tens + hundreds\
    \ + thousands + millions + billions + trillions + quadrillions + quintillions\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Int], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7p323ae8.scala:30:31\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36monesAndOnes\e[0m = ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + ones + ones + ones + ones + ones + ones + ones + ones + ones +\
    \ ones + ones + one\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   "
  stdout: ''
  timestamp: 1659795264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(x => math.abs(math.log2(x)))\n        val sorted = decs.zip(ones).sortBy(_._1).map(x\
    \ => x._2)\n        sorted.map(x => if (x == 0) 0 else x).reverse\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpllgx5e77.scala:13:46 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mdecs\e[0m = arr.map(\e[36mx\e\
    [0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \          value log2 is not a member of math\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpllgx5e77.scala:14:30 --------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.zip(ones).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                              ^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    (ones : Int)\n\e[31m\
    \   |\e[0m                              Required: IterableOnce[Any]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpllgx5e77.scala:14:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.zip(ones).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \             ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mLong\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659795264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesDecimal = maxOnes.toDouble\
    \ / arr.length\n        val maxZerosDecimal = maxZeros.toDouble / arr.length\n\
    \        val maxOnesDecimalDecimal = maxOnesDecimal.toDouble / arr.length\n  \
    \      val maxZerosDecimalDecimal = maxZerosDecimal.toDouble / arr.length\n  \
    \      val maxOnesDecimalDecimalDecimal = maxOnesDecimalDecimal.toDouble / arr.length\n\
    \        val maxZerosDecimalDecimalDecimal = maxZerosDecimalDecimal.toDouble /\
    \ arr.length\n        val maxOnesDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxZerosDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxOnesDecimalDecimalDecimalDecimalDecimal = maxOnesDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxZerosDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n       \
    \ val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n\
    \        val maxOnesDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpejw0d9bc.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpejw0d9bc.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = maxOnesDecimalDecimalDecimalDecimalDecimalDecimal.toDouble\
    \ / arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpejw0d9bc.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxZerosDecimalDecimalDecimalDecimalDecimalDecimal.toDouble / arr.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpejw0d9bc.scala:35:5 ---------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val sextillions = arr.count(_ == 10000000000000000000000)\n        val\
    \ septillions = arr.count(_ == 1000000000000000000000000)\n        val octillions\
    \ = arr.count(_ == 1000000000000000000000000000)\n        val nonillions = arr.count(_\
    \ == 10000000000000000000000000000000)\n        val decillions = arr.count(_ ==\
    \ 1000000000000000000000000000000000)\n        val undecillions = arr.count(_\
    \ == 10000000000000000000000000000000001)\n        val decillionsOnes = arr.count(_\
    \ == 10000000000000000000000000000000010)\n        val undecillionsOnes = arr.count(_\
    \ == 10000000000000000000000000000000011)\n        val decillionsTwos = arr.count(_\
    \ == 100000000000000000000000000000000100)\n        val undecillionsTwos = arr.count(_\
    \ == 100000000000000000000000000000000101)\n        val decillionsThrees = arr.count(_\
    \ == 1000000000000000000000000000000001000)\n        val undecillionsThrees =\
    \ arr.count(_ == 1000000000000000000000000000000001001)\n        val decillionsFours\
    \ = arr.count(_ == 10000000000000000000000000000000010000)\n        val undecillionsFours\
    \ = arr.count(_ == 10000000000000000000000000000000010001)\n        val decillionsFives\
    \ = arr.count(_ == 100000000000000000000000000000000100000)\n        val undecillionsFives\
    \ = arr.count(_ == 100000000000000000000000000000000100001)\n        val decillionsSixes\
    \ = arr.count(_ == 1000000000000000000000000000000001000000)\n        val undecilli\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm7nzddtn.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpm7nzddtn.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpm7nzddtn.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpm7nzddtn.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpm7nzddtn.scala:29:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msextillions\e[0m = arr.count(_\
    \ == \e[31m10000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpm7nzddtn.scala:30:41 -----------------------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mseptillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpm7nzddtn.scala:31:40 -------------------------------"
  stdout: ''
  timestamp: 1659795266
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesDecimals = ones * decimals\n\
    \        val onesDecimalsSorted = arr.sortBy(_ / onesDecimals)\n        val onesDecimalsSortedReversed\
    \ = onesDecimalsSorted.reverse\n        onesDecimalsSortedReversed.take(onesDecimalsSortedReversed.size\
    \ - ones)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0jz4mp03.scala:20)\n\tat Problem.main(tmp0jz4mp03.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decs = arr.map(_.toString.toInt)\n        val sorted = decs.sortWith(_.compare(decs(0))\
    \ == 0)\n        val result = sorted.map(dec => dec / ones)\n        result.sortWith(_.compare(arr(0))\
    \ == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpnastcp49.scala:14:35 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = decs.sortWith(_.compare(decs(\e\
    [31m0\e[0m)) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E086] Syntax\
    \ Error: /tmp/tmpnastcp49.scala:16:24 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        result.sortWith(_.compare(arr(\e[31m0\e[0m)) == \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        Wrong number of parameters, expected: 2\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 1 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 1 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 1 else 0)\n        val fives = arr.map(x => if (x == 5) 1 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 1 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 1 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 1 else 0)\n        val nines = arr.map(x => if (x == 9) 1 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 1 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 1 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 1 else 0)\n        val ten_thousands = arr.map(x => if (x == 1000)\
    \ 1 else 0)\n        val hundred_thousands = arr.map(x => if (x == 10000) 1 else\
    \ 0)\n        val millions = arr.map(x => if (x == 1000000) 1 else 0)\n      \
    \  val billions = arr.map(x => if (x == 1000000000) 1 else 0)\n        val trillions\
    \ = arr.map(x => if (x == 1000000000000) 1 else 0)\n        val quadrillions =\
    \ arr.map(x => if (x == 1000000000000000) 1 else 0)\n        val quintillions\
    \ = arr.map(x => if (x == 1000000000000000000) 1 else 0)\n        val ones_count\
    \ = ones.length\n        val twos_count = twos.length\n        val threes_count\
    \ = threes.length\n        val fours_count = fours.length\n        val fives_count\
    \ = fives.length\n        val sixes_count = sixes.length\n        val sevens_count\
    \ = sevens.length\n        val eights_count = eights.length\n        val nines_count\
    \ = nines.length\n        val tens_count = tens.length\n        val hundreds_count\
    \ = hundreds.length\n        val thousands_count = thousands.length\n        val\
    \ ten_thousands_count = ten_thousands.length\n        val hundred_thousands_count\
    \ = hundred_thousands.length\n        val millions_count = millions.length\n \
    \       val billions_count = billions.length\n        val trillions_count = trillions.length\n\
    \        val quadrillions_count = quadrillions.length\n        val quintillions_count\
    \ = quintillions.length\n        val one\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgo3pk9d1.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpgo3pk9d1.scala:28:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m\
    \ (x == \e[31m1000000000000\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpgo3pk9d1.scala:29:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000000000000000\e[0m) \e[31m1\e[0m \e\
    [33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                           \
    \                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                 number too large\n\e[31m\e[31m-- Error: /tmp/tmpgo3pk9d1.scala:30:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000000\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 number too\
    \ large\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgo3pk9d1.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decs = arr.map(x => math.pow(2,x)).sum\n        val sorted = arr.sortWith(x\
    \ => math.abs(x - ones) < math.abs(x - decs))\n        sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7wzx9rjg.scala:14:36 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortWith(\e\
    [36mx\e[0m => math.abs(x - ones) < math.abs(x - decs))\n\e[31m\e[31m   |\e[0m\
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1659795266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decs = arr.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res = decs ++ arr.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res2 = res.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res3 = res.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res4 = res2.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res5 = res2.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res6 = res3.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res7 = res3.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res8 = res4.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res9 = res4.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res10 = res5.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res11 = res5.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res12 = res6.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res13 = res6.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res14 = res7.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res15 = res7.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res16 = res8.filter(_ % 2 == 0).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res17 = res8.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val res18 = res9.filter(_ % 2 == \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjyqm9875.scala:31:40 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mres18\e[0m = res9.filter(_\
    \ % \e[31m2\e[0m == \n\e[31m\e[31m   |\e[0m                                  \
    \      ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjyqm9875.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val twos = arr.filter(_ % 2 == 1).length\n        val threes = arr.filter(_\
    \ % 3 == 0).length\n        val fours = arr.filter(_ % 3 == 1).length\n      \
    \  val fives = arr.filter(_ % 5 == 0).length\n        val sixes = arr.filter(_\
    \ % 5 == 1).length\n        val sevens = arr.filter(_ % 7 == 0).length\n     \
    \   val eights = arr.filter(_ % 7 == 1).length\n        val nines = arr.filter(_\
    \ % 9 == 0).length\n        val tens = arr.filter(_ % 9 == 1).length\n       \
    \ val onesArr = arr.filter(_ % 2 == 0).sortBy(x => x)\n        val twosArr = arr.filter(_\
    \ % 2 == 1).sortBy(x => x)\n        val threesArr = arr.filter(_ % 3 == 0).sortBy(x\
    \ => x)\n        val foursArr = arr.filter(_ % 3 == 1).sortBy(x => x)\n      \
    \  val fivesArr = arr.filter(_ % 5 == 0).sortBy(x => x)\n        val sixesArr\
    \ = arr.filter(_ % 5 == 1).sortBy(x => x)\n        val sevensArr = arr.filter(_\
    \ % 7 == 0).sortBy(x => x)\n        val eightsArr = arr.filter(_ % 7 == 1).sortBy(x\
    \ => x)\n        val ninesArr = arr.filter(_ % 9 == 0).sortBy(x => x)\n      \
    \  val tensArr = arr.filter(_ % 9 == 1).sortBy(x => x)\n        val onesArr2 =\
    \ onesArr.filter(_ % 2 == 0).sortBy(x => x)\n        val twosArr2 = twosArr.filter(_\
    \ % 2 == 1).sortBy(x => x)\n        val threesArr2 = threesArr.filter(_ % 3 ==\
    \ 0).sortBy(x => x)\n        val foursArr2 = foursArr.filter(_ % 3 == 1).sortBy(x\
    \ => x)\n        val fivesArr2 = fivesArr.filter(_ % 5 == 0).sortBy(x => x)\n\
    \        val sixesArr2 = sixesArr.filter(_ % 5 == 1).sortBy(x => x)\n        val\
    \ sevensArr2 = sevensArr.filter(_ % 7 == 0).sortBy(x => x)\n        val eightsArr2\
    \ = eightsArr.filter(_ % 7 == 1).sortBy(x => x)\n        val ninesArr2 = ninesArr.filter(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwb71hcji.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwb71hcji.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val decimals = arr.count(_ > 0)\n        val onesArr = arr.map(x => if (x\
    \ == 1) 1 else 0)\n        val decimalsArr = arr.map(x => if (x == 0) 0 else 1)\n\
    \        val onesArr = onesArr.sortWith((x, y) => x - y)\n        val decimalsArr\
    \ = decimalsArr.sortWith((x, y) => x - y)\n        val result = onesArr.zip(decimalsArr).sortWith((x,\
    \ y) => x._1 - y._1).map(x => x._2)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe4fktq59.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesArr\e[0m = onesArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArr is already defined as \e[33mvalue\e[0m \e[35monesArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe4fktq59.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mdecimalsArr\e[0m = decimalsArr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsArr is already defined as \e[33mvalue\e[0m \e[35mdecimalsArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpe4fktq59.scala:18:65 --------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = onesArr.zip(decimalsArr).sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x._1 - y._1).map(\e[36mx\e[0m => x._2)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \ ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                          \
    \             Found:    Int\n\e[31m   |\e[0m                                 \
    \                      Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpe4fktq59.scala:19:8 ---------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    (result : List[Int])\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795272
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1).sortBy(_.toString.toInt)\n\
    \        val zerosArr = arr.filter(_ == 0).sortBy(_.toString.toInt)\n        val\
    \ onesCount = onesArr.length\n        val zerosCount = zerosArr.length\n     \
    \   val onesSum = onesArr.foldLeft(0L)(_ + _)\n        val zerosSum = zerosArr.foldLeft(0L)(_\
    \ + _)\n        val onesAvg = onesSum / onesCount\n        val zerosAvg = zerosSum\
    \ / zerosCount\n        val onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n\
    \        val zerosDev = zerosArr.foldLeft(0L)(_ + _) / zerosCount\n        val\
    \ onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n        val zerosDev = zerosArr.foldLeft(0L)(_\
    \ + _) / zerosCount\n        val onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n\
    \        val zerosDev = zerosArr.foldLeft(0L)(_ + _) / zerosCount\n        val\
    \ onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n        val zerosDev = zerosArr.foldLeft(0L)(_\
    \ + _) / zerosCount\n        val onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n\
    \        val zerosDev = zerosArr.foldLeft(0L)(_ + _) / zerosCount\n        val\
    \ onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n        val zerosDev = zerosArr.foldLeft(0L)(_\
    \ + _) / zerosCount\n        val onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n\
    \        val zerosDev = zerosArr.foldLeft(0L)(_ + _) / zerosCount\n        val\
    \ onesDev = onesArr.foldLeft(0L)(_ + _) / onesCount\n        val zerosDev = zerosArr.foldLeft(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp48oousy6.scala:37:41 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mzerosDev\e[0m = zerosArr.foldLeft(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48oousy6.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesDev\e[0m = onesArr.foldLeft(\e[31m0L\e[0m)(_ + _) / onesCount\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDev is already defined as \e[33mvalue\e[0m \e[35monesDev\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp48oousy6.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mzerosDev\e[0m = zerosArr.foldLeft(\e\
    [31m0L\e[0m)(_ + _) / zerosCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDev is already defined as \e[33mvalue\e[0m \e[35mzerosDev\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp48oousy6.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesDev\e[0m = onesArr.foldLeft(\e[31m0L\e\
    [0m)(_ + _) / onesCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDev is already defined as \e[33mvalue\e[0m \e[35monesDev\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp48oousy6.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mzerosDev\e[0m = zerosArr.foldLeft(\e\
    [31m0L\e[0m)(_ "
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val maxOnes = arr.count(_ == 1)\n \
    \       val maxZeros = arr.count(_ == 0)\n        val maxOnesIndex = arr.indexOfMax(_\
    \ == 1)\n        val maxZerosIndex = arr.indexOfMax(_ == 0)\n        val maxOnesDecimal\
    \ = maxOnesIndex.toDouble / maxOnes\n        val maxZerosDecimal = maxZerosIndex.toDouble\
    \ / maxZeros\n        val maxOnesDecimalDecimal = maxOnesDecimal / maxOnes\n \
    \       val maxZerosDecimalDecimal = maxZerosDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimal / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimal / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / maxOnes\n     \
    \   val maxZerosDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / maxOnes\n\
    \        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n        val maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxOnesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / maxOnes\n        val maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = maxZerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal /\
    \ maxZeros\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmptvb9b2ja.scala:34:11 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmptvb9b2ja.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesIndex\e[0m = arr.indexOfMax(_\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue indexOfMax is not a member of List[Long] - did you mean\
    \ arr.indexOf?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptvb9b2ja.scala:17:32\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxZerosIndex\e[0m = arr.indexOfMax(_ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMax\
    \ is not a member of List[Long] - did you mean arr.indexOf?\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmptvb9b2ja.scala:26:57 ---------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxOnesDecimalDecimalDecimalDecimalDecimal\e\
    [0m = maxOnesDecimalDecimalDecimalDecimalDecimal / maxOnes\n\e[31m\e[31m   |\e\
    [0m                                                         ^\e[0m\n\e[31m   |\e\
    [0m   Recursive \e[33mvalue\e[0m \e[35mmaxOnesDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptvb9b2ja.scala:27:58\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxZerosDecimalDecimalDecimalDecimalDecimal\e[0m = maxZerosDecimalDecimalDecimalDecimalDecimal\
    \ / maxZeros\n\e[31m\e[31m   |\e[0m                                          \
    \                ^\e[0m\n\e[31m   |\e[0m  Recursive \e[33mvalue\e[0m \e[35mmaxZerosDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(x => x == 1)\n\
    \        val decimals = arr.count(x => x == 0)\n        val onesDecimals = ones\
    \ * decimals\n        val onesDecimalsSorted = arr.sortBy(x => math.abs(math.log2(x)))\n\
    \        val onesDecimalsSortedWithOnes = onesDecimalsSorted.take(onesDecimals)\n\
    \        val onesDecimalsSortedWithOnesSorted = onesDecimalsSortedWithOnes.sortBy(x\
    \ => math.abs(math.log2(x)))\n        onesDecimalsSortedWithOnesSorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp433s5s9u.scala:15:63 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                      value log2 is not a member\
    \ of math\n\e[31m\e[31m-- Error: /tmp/tmp433s5s9u.scala:15:72 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36monesDecimalsSorted\e[0m\
    \ = arr.sortBy(\e[36mx\e[0m => math.abs(math.log2(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).size\n\
    \        val twos = arr.filter(x => x == 2).size\n        val threes = arr.filter(x\
    \ => x == 3).size\n        val fours = arr.filter(x => x == 4).size\n        val\
    \ fives = arr.filter(x => x == 5).size\n        val sixes = arr.filter(x => x\
    \ == 6).size\n        val sevens = arr.filter(x => x == 7).size\n        val eights\
    \ = arr.filter(x => x == 8).size\n        val nines = arr.filter(x => x == 9).size\n\
    \        val tens = arr.filter(x => x == 10).size\n        val hundreds = arr.filter(x\
    \ => x == 11).size\n        val thousands = arr.filter(x => x == 12).size\n  \
    \      val millions = arr.filter(x => x == 13).size\n        val billions = arr.filter(x\
    \ => x == 14).size\n        val trillions = arr.filter(x => x == 15).size\n  \
    \      val quadrillions = arr.filter(x => x == 16).size\n        val quintillions\
    \ = arr.filter(x => x == 17).size\n        val sextillions = arr.filter(x => x\
    \ == 18).size\n        val septillions = arr.filter(x => x == 19).size\n     \
    \   val octillions = arr.filter(x => x == 20).size\n        val nonillions = arr.filter(x\
    \ => x == 21).size\n        val decillions = arr.filter(x => x == 22).size\n \
    \       val undecillions = arr.filter(x => x == 23).size\n        val duodecillions\
    \ = arr.filter(x => x == 24).size\n        val tredecillions = arr.filter(x =>\
    \ x == 25).size\n        val quattuordecillions = arr.filter(x => x == 26).size\n\
    \        val quindecillions = arr.filter(x => x == 27).size\n        val sexdecillions\
    \ = arr.filter(x => x == 28).size\n        val septendecillions = arr.filter(x\
    \ => x == 29).size\n        val octodecillions = arr.filter(x => x == 30).size\n\
    \        val novemdecillions = arr.filter(x => x == 31).size\n        val vigintillions\
    \ = arr.filter(x => x == 32).size\n        val unvigintillions = arr.filter(x\
    \ => x == 33).size\n        val duovigintillions = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwdo0aym1.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwdo0aym1.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795209
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val decs = arr.filter(_ % 2 == 1).map(_.toString.toInt).sortBy(_.toString.toInt)\n\
    \        val sorted = decs.zip(ones).sortBy(_._1).map(x => x._2)\n        sorted.map(x\
    \ => arr(x.toInt))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf0c9fnat.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            Found:    (ones : Int)\n\e[31m   |\e[0m                         \
    \     Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpf0c9fnat.scala:15:30 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        sorted.map(\e[36mx\e[0m => arr(x.toInt))\n\e[31m\e[31m   |\e[0m   \
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toInt is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).size\n        val decs = arr.filter(x => x % 2 == 1).map(_.toString.toInt).sorted\n\
    \        val sorted = decs.zip(ones).sortBy(_._1).map(x => x._2)\n        sorted.map(x\
    \ => arr(x - 1))\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5hl77_ty.scala:14:30\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msorted\e\
    [0m = decs.zip(ones).sortBy(_._1).map(\e[36mx\e[0m => x._2)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^\e[0m\n\e[31m   |\e[0m                  \
    \            Found:    (ones : Int)\n\e[31m   |\e[0m                         \
    \     Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp5hl77_ty.scala:15:30 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        sorted.map(\e[36mx\e[0m => arr(x - \e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                            ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of Nothing, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversions.properties AsScalaMap\n\e[31m\
    \   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val twos = arr.count(_ == 2)\n        val threes = arr.count(_ == 3)\n   \
    \     val fours = arr.count(_ == 4)\n        val fives = arr.count(_ == 5)\n \
    \       val sixes = arr.count(_ == 6)\n        val sevens = arr.count(_ == 7)\n\
    \        val eights = arr.count(_ == 8)\n        val nines = arr.count(_ == 9)\n\
    \        val tens = arr.count(_ == 10)\n        val hundreds = arr.count(_ ==\
    \ 100)\n        val thousands = arr.count(_ == 1000)\n        val millions = arr.count(_\
    \ == 1000000)\n        val billions = arr.count(_ == 1000000000)\n        val\
    \ trillions = arr.count(_ == 1000000000000)\n        val quadrillions = arr.count(_\
    \ == 1000000000000000)\n        val quintillions = arr.count(_ == 1000000000000000000)\n\
    \        val onesAndZeros = arr.count(_ == 1)\n        val onesAndOnes = arr.count(_\
    \ == 2)\n        val onesAndTwos = arr.count(_ == 3)\n        val onesAndThrees\
    \ = arr.count(_ == 4)\n        val onesAndFours = arr.count(_ == 5)\n        val\
    \ onesAndFives = arr.count(_ == 6)\n        val onesAndSixes = arr.count(_ ==\
    \ 7)\n        val onesAndSevens = arr.count(_ == 8)\n        val onesAndEights\
    \ = arr.count(_ == 9)\n        val onesAndNines = arr.count(_ == 10)\n       \
    \ val onesAndTens = arr.count(_ == 11)\n        val onesAndHundreds = arr.count(_\
    \ == 100)\n        val onesAndThousands = arr.count(_ == 1000)\n        val onesAndMillions\
    \ = arr.count(_ == 1000000)\n        val onesAndBillions = arr.count(_ == 1000000000)\n\
    \        val onesAndTrillions = arr.count(_ == 1000000000000)\n        val onesAndQuadrillions\
    \ = arr.count(_ == 1000000000000000)\n        val onesAndQuintillions = arr.count(_\
    \ == 1000000000000000000)\n        val onesAndOnesAndZeros = arr.count(_ == 1)\n\
    \        val onesAndOnesAndOnes = arr.count(_ == 2)\n        val onesAndOnesAndTwos\
    \ = arr.count(_ == 3)\n        val onesAndOnesAndThrees = arr.count(_ == 4)\n\
    \        val onesAndOnesAndFours = arr.count(_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk9gj6q58.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:26:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mtrillions\e[0m = arr.count(_ == \e[31m1000000000000\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                       number too large\n\e[31m\e\
    [31m-- Error: /tmp/tmpk9gj6q58.scala:27:42 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         number too large\n\e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:28:42\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.count(_ == \e[31m1000000000000000000\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                          number too large\n\
    \e[31m\e[31m-- Error: /tmp/tmpk9gj6q58.scala:44:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36monesAndTrillions\e[0m =\
    \ arr.count(_ == \e[31m1000000000000\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpk9gj6q58.scala:45:49 -----------------------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36monesAndQuadrillions\e[0m = arr.count(_\
    \ == \e[31m1000000000000000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                       number too large\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpk9gj6q58.scala:46:49 ------------------------------"
  stdout: ''
  timestamp: 1659795199
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesDec = arr.map(x => math.pow(2,\
    \ math.ceil(math.log(x, 2))))\n        val zerosDec = arr.map(x => math.pow(2,\
    \ math.floor(math.log(x, 2))))\n        val onesDec = onesDec.sortWith((x, y)\
    \ => x - y)\n        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n     \
    \   val onesDec = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x\
    \ => math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x =>\
    \ math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x =>\
    \ math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x =>\
    \ math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x =>\
    \ math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDec.map(x => math.pow(x, 2))\n        val zerosDec = zerosDec.map(x =>\
    \ math.pow(10, x))\n        val onesDec = onesDec.sortWith((x, y) => x - y)\n\
    \        val zerosDec = zerosDec.sortWith((x, y) => x - y)\n        val onesDec\
    \ = onesDe\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpplyoffkb.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpplyoffkb.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpplyoffkb.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesDec.map(\e[36mx\e\
    [0m => math.pow(x, \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpplyoffkb.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosDec.map(\e[36mx\e\
    [0m => math.pow(\e[31m10\e[0m, x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDec is already defined as \e[33mvalue\e[0m \e[35mzerosDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpplyoffkb.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36m"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / onesDecimal\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zerosDecimal\n\
    \        val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / onesDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal /\
    \ zerosDecimalDecimal\n        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimal\n        val\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n        val\
    \ zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n   \
    \     val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnrpzjee2.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpnrpzjee2.scala:26:61 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimal / onesDecimalDecimalDecimalDecimalDecimal\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnrpzjee2.scala:27:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m = zerosDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zerosDecimalDecimalDecimalDecimalDecimal\n\e[31m\e[31m   |\e[0m          \
    \                                                    ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimal\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val zeros = arr.map(x => if (x == 0) 0 else 1)\n        val\
    \ onesCount = ones.reduceLeft(_ + _)\n        val zerosCount = zeros.reduceLeft(_\
    \ + _)\n        val onesZeros = ones.zip(zeros)\n        val onesZerosCount =\
    \ onesZeros.reduceLeft(_ + _)\n        val onesZerosZeros = onesZeros.zip(zeros)\n\
    \        val onesZerosZerosCount = onesZerosZeros.reduceLeft(_ + _)\n        val\
    \ onesZerosZerosZerosCount = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount2\
    \ = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount3 = onesZerosZeros.zip(zeros)\n\
    \        val onesZerosZerosZerosCount4 = onesZerosZeros.zip(zeros)\n        val\
    \ onesZerosZerosZerosCount5 = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount6\
    \ = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount7 = onesZerosZeros.zip(zeros)\n\
    \        val onesZerosZerosZerosCount8 = onesZerosZeros.zip(zeros)\n        val\
    \ onesZerosZerosZerosCount9 = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount10\
    \ = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount11 = onesZerosZeros.zip(zeros)\n\
    \        val onesZerosZerosZerosCount12 = onesZerosZeros.zip(zeros)\n        val\
    \ onesZerosZerosZerosCount13 = onesZerosZeros.zip(zeros)\n        val onesZerosZerosZerosCount14\
    \ = onesZerosZeros.\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi3_il2u1.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpi3_il2u1.scala:17:52 ------------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36monesZerosCount\e[0m = onesZeros.reduceLeft(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of (Int, Int), but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpi3_il2u1.scala:19:62 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36monesZerosZerosCount\e[0m\
    \ = onesZerosZeros.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m                  \
    \                                          ^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of ((Int, Int), Int), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi3_il2u1.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val twos = arr.filter(x => x == 2).length\n        val threes = arr.filter(x\
    \ => x == 3).length\n        val fours = arr.filter(x => x == 4).length\n    \
    \    val fives = arr.filter(x => x == 5).length\n        val sixes = arr.filter(x\
    \ => x == 6).length\n        val sevens = arr.filter(x => x == 7).length\n   \
    \     val eights = arr.filter(x => x == 8).length\n        val nines = arr.filter(x\
    \ => x == 9).length\n        val tens = arr.filter(x => x == 10).length\n    \
    \    val hundreds = arr.filter(x => x == 11).length\n        val thousands = arr.filter(x\
    \ => x == 12).length\n        val ten_thousands = arr.filter(x => x == 13).length\n\
    \        val hundred_thousands = arr.filter(x => x == 14).length\n        val\
    \ millions = arr.filter(x => x == 15).length\n        val billions = arr.filter(x\
    \ => x == 16).length\n        val trillions = arr.filter(x => x == 17).length\n\
    \        val quadrillions = arr.filter(x => x == 18).length\n        val quintillions\
    \ = arr.filter(x => x == 19).length\n        val sextillions = arr.filter(x =>\
    \ x == 20).length\n        val septillions = arr.filter(x => x == 21).length\n\
    \        val octillions = arr.filter(x => x == 22).length\n        val nonillions\
    \ = arr.filter(x => x == 23).length\n        val decillions = arr.filter(x =>\
    \ x == 24).length\n        val undecillions = arr.filter(x => x == 25).length\n\
    \        val duodecillions = arr.filter(x => x == 26).length\n        val tredecillions\
    \ = arr.filter(x => x == 27).length\n        val quattuordecillions = arr.filter(x\
    \ => x == 28).length\n        val quindecillions = arr.filter(x => x == 29).length\n\
    \        val sexdecillions = arr.filter(x => x == 30).length\n        val septendecillions\
    \ = arr.filter(x => x == 31).length\n        val octodecillions = arr.filter(x\
    \ => x == 32).length\n        val novemdecillions = arr.filter(x => x == 33).length\n\
    \        val vigintillions = arr.filter(x => x == 34\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong,\
    \ 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong,\
    \ -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong,\
    \ -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdqedou3.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbdqedou3.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x == 1).length\n\
    \        val zeros = arr.filter(x => x == 0).length\n        val decimal = arr.map(x\
    \ => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n        val decimal2\
    \ = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n     \
    \   val decimal3 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal4 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal5 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal6 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal7 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal8 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal9 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal10 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal11 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal12 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal13 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal14 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal15 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal16 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal17 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal18 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal19 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal20 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[Double]).sum\n\
    \        val decimal21 = arr.map(x => math.abs(x - math.floor(x)).asInstanceOf[\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_q1g_v0s.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_q1g_v0s.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val millions = arr.map(x => if (x == 1000) 1000\
    \ else 0)\n        val billions = arr.map(x => if (x == 1000) 1000 else 0)\n \
    \       val trillions = arr.map(x => if (x == 1000) 1000 else 0)\n        val\
    \ quadrillions = arr.map(x => if (x == 1000) 1000 else 0)\n        val quintillions\
    \ = arr.map(x => if (x == 1000) 1000 else 0)\n        val sextillions = arr.map(x\
    \ => if (x == 1000) 1000 else 0)\n        val septillions = arr.map(x => if (x\
    \ == 1000) 1000 else 0)\n        val octillions = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val nonillions = arr.map(x => if (x == 1000) 1000 else\
    \ 0)\n        val decillions = arr.map(x => if (x == 1000) 1000 else 0)\n    \
    \    val undecillions = arr.map(x => if (x == 1000) 1000 else 0)\n        val\
    \ decillions = arr.map(x => if (x == 1000) 1000 else 0)\n        val undecillions\
    \ = arr.map(x => if (x == 1000) 1000 else 0)\n        val decillions = arr.map(x\
    \ => if (x == 1000) 1000 else 0)\n        val undecillions = arr.map(x => if (x\
    \ == 1000) 1000 else 0)\n        val decillions = arr.map(x => if (x == 1000)\
    \ 1000 else 0)\n        val undecillions = arr.map(x => if (x == 1000) 1000 else\
    \ 0)\n        val decilli\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphdcw1r4z.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphdcw1r4z.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m1000\e\
    [0m) \e[31m1000\e[0m \e[33melse\e[0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mdecillions is already defined as \e[33mvalue\e[0m \e[35mdecillions\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphdcw1r4z.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.map(\e[36mx\e[0m\
    \ => \e[33mif\e[0m (x == \e[31m1000\e[0m) \e[31m1000\e[0m \e[33melse\e[0m \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mundecillions is already defined as \e[33mvalue\e[0m \e[35mundecillions\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphdcw1r4z.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mdecillions\e[0m = arr.map(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m1000\e[0m) \e[31m1000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecillions is already defined as \e[33mvalue\e[0m \e[35mdecillions\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphdcw1r4z.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mundecillions\e[0m = arr.map(\e[36mx\e\
    [0m => \e[33mif\e[0m (x == \e[31m1000\e[0m) \e[31m1000\e[0m \e[33melse\e[0"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(x => x % 2 ==\
    \ 0).length\n        val decimals = arr.filter(x => x % 2 == 1).length\n     \
    \   val result = arr.sortWith((x, y) => if (x == y) 0 else (if (x < y) -1 else\
    \ if (x > y) 1 else 0))\n        if (ones == decimals) result else result.map(x\
    \ => if (x == 0) x else x / 2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4a1vtrzo.scala:14:56\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x == y) \e[31m0\e\
    [0m \e[33melse\e[0m (\e[33mif\e[0m (x < y) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (x > y) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                                     Found:    (\e[31m0\e[0m\
    \ : Int)\n\e[31m   |\e[0m                                                    \
    \ Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4a1vtrzo.scala:14:75\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = arr.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x == y) \e[31m0\e\
    [0m \e[33melse\e[0m (\e[33mif\e[0m (x < y) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (x > y) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                                                                           ^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    (\e[31m-1\e[0m : Int)\n\e[31m   |\e[0m                                  \
    \                  Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4a1vtrzo.scala:14:94 --------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e\
    [0m (\e[33mif\e[0m (x < y) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (x > y)\
    \ \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \         Found:    (\e[31m1\e[0m : Int)\n\e[31m   |\e[0m                    \
    \                                 Required: Boolean\n\e[31m   |"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesCount = arr.count(_ == 1)\n\
    \        val zerosCount = arr.count(_ == 0)\n        val onesDecimal = onesCount\
    \ / arr.length\n        val zerosDecimal = zerosCount / arr.length\n        val\
    \ onesDecimalDecimal = onesDecimal / ones\n        val zerosDecimalDecimal = zerosDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimal = onesDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimal = zerosDecimalDecimal / zeros\n      \
    \  val onesDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimal / ones\n \
    \       val zerosDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimal = onesDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal =\
    \ onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\
    \        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal / zeros\n\
    \        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n        val zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n        val onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv7bouyx0.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv7bouyx0.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = zerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / zeros\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ is already defined as \e[33mvalue\e[0m \e[35mzerosDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpv7bouyx0.scala:28:68 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimal / ones\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35monesDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv7bouyx0.scala:34:89\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36monesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\e\
    [0m = onesDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimalDecimal\
    \ / ones\n\e[31m\e[31m   |\e[0m                                              \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).size\n\
    \        val twos = arr.filter(_ % 2 == 1).size\n        val decimals = arr.filter(_\
    \ % 10 == 0).size\n        val decimalsDecimals = arr.filter(_ % 10 == 1).size\n\
    \        val decimalsDecimalsDecimals = arr.filter(_ % 10 == 2).size\n       \
    \ val decimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 3).size\n      \
    \  val decimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ % 10 == 4).size\n\
    \        val decimalsDecimalsDecimalsDecimalsDecimalsDecimals = arr.filter(_ %\
    \ 10 == 5).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 6).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 7).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 8).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 9).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 10).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 11).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 12).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 13).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 14).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 15).size\n        val decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ = arr.filter(_ % 10 == 16).size\n        val decimalsDecimal\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong,\
    \ 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1dqk_tye.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1dqk_tye.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\e\
    [0m = arr.filter(_ % \e[31m10\e[0m == \e[31m10\e[0m).size\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  decimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimalsDecimals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp1dqk_tye.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795274
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.filter(_ == 1)\n\
    \        val zerosArr = arr.filter(_ == 0)\n        val onesCount = onesArr.size\n\
    \        val zerosCount = zerosArr.size\n        val onesSum = onesArr.sum\n \
    \       val zerosSum = zerosArr.sum\n        val onesMax = onesArr.max\n     \
    \   val zerosMax = zerosArr.max\n        val onesMin = onesArr.min\n        val\
    \ zerosMin = zerosArr.min\n        val onesSumAbs = onesSum.abs\n        val zerosSumAbs\
    \ = zerosSum.abs\n        val onesMaxAbs = onesMax.abs\n        val zerosMaxAbs\
    \ = zerosMax.abs\n        val onesMinAbs = onesMin.abs\n        val zerosMinAbs\
    \ = zerosMin.abs\n        val onesSumAbsDiff = onesSumAbs - onesCount\n      \
    \  val zerosSumAbsDiff = zerosSumAbs - zerosCount\n        val onesMaxAbsDiff\
    \ = onesMaxAbs - onesCount\n        val zerosMaxAbsDiff = zerosMaxAbs - zerosCount\n\
    \        val onesMinAbsDiff = onesMinAbs - onesCount\n        val zerosMinAbsDiff\
    \ = zerosMinAbs - zerosCount\n        val onesSumAbsDiffAbs = onesSumAbsDiff +\
    \ onesCount\n        val zerosSumAbsDiffAbs = zerosSumAbsDiff + zerosCount\n \
    \       val onesMaxAbsDiffAbs = onesMaxAbsDiff + onesCount\n        val zerosMaxAbsDiffAbs\
    \ = zerosMaxAbsDiff + zerosCount\n        val onesMinAbsDiffAbs = onesMinAbsDiff\
    \ + onesCount\n        val zerosMinAbsDiffAbs = zerosMinAbsDiff + zerosCount\n\
    \        val onesSumAbsDiffAbsDiff = onesSumAbsDiffAbs - onesCount\n        val\
    \ zerosSumAbsDiffAbsDiff = zerosSumAbsDiffAbs - zerosCount\n        val onesMaxAbsDiffAbsDiff\
    \ = onesMaxAbsDiffAbs - onesCount\n        val zerosMaxAbsDiffAbsDiff = zerosMaxAbsDiffAbs\
    \ - zerosCount\n        val onesMin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptmg8q7sv.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptmg8q7sv.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArray = arr.map(x => (x % 2\
    \ == 0 ? 1 : 0)).toArray\n        val zerosArray = arr.map(x => (x % 2 == 0 ?\
    \ 0 : 1)).toArray\n        val onesArrayLength = onesArray.length\n        val\
    \ zerosArrayLength = zerosArray.length\n        val onesArrayLength = onesArrayLength\
    \ / 2\n        val zerosArrayLength = zerosArrayLength / 2\n        val onesArrayLength\
    \ = onesArrayLength * 2\n        val zerosArrayLength = zerosArrayLength * 2\n\
    \        val onesArrayLength = onesArrayLength * 3\n        val zerosArrayLength\
    \ = zerosArrayLength * 3\n        val onesArrayLength = onesArrayLength * 4\n\
    \        val zerosArrayLength = zerosArrayLength * 4\n        val onesArrayLength\
    \ = onesArrayLength * 5\n        val zerosArrayLength = zerosArrayLength * 5\n\
    \        val onesArrayLength = onesArrayLength * 6\n        val zerosArrayLength\
    \ = zerosArrayLength * 6\n        val onesArrayLength = onesArrayLength * 7\n\
    \        val zerosArrayLength = zerosArrayLength * 7\n        val onesArrayLength\
    \ = onesArrayLength * 8\n        val zerosArrayLength = zerosArrayLength * 8\n\
    \        val onesArrayLength = onesArrayLength * 9\n        val zerosArrayLength\
    \ = zerosArrayLength * 9\n        val onesArrayLength = onesArrayLength * 10\n\
    \        val zerosArrayLength = zerosArrayLength * 10\n        val onesArrayLength\
    \ = onesArrayLength * 11\n        val zerosArrayLength = zerosArrayLength * 11\n\
    \        val onesArrayLength = onesArrayLength * 12\n        val zerosArrayLength\
    \ = zerosArrayLength * 12\n        val onesArrayLength = onesArrayLength * 13\n\
    \        val zerosArrayLength = zerosArrayLength * 13\n        val onesArrayLength\
    \ = onesArrayLength * 14\n        val zerosArrayLength = zerosArrayLength * 14\n\
    \        val onesArrayLength = onesArrayLength * 15\n        val zerosArrayLength\
    \ = zerosArrayLength * 15\n        val onesArrayLength = onesArrayLength * 16\n\
    \        val zerosArrayLength = zerosArrayLength * 16\n        val onesArrayLength\
    \ = onesArrayLength * 17\n        val zerosArrayLength = zerosArrayLength * 17\n\
    \        val onesArrayLength = onesArrayLength * 18\n        val zerosArrayLength\
    \ = zerosArrayLength * 18\n        val onesArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprqvx3q47.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprqvx3q47.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36monesArrayLength\e[0m = onesArrayLength / \e[31m2\e[0m\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0monesArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35monesArrayLength\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprqvx3q47.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mzerosArrayLength\e[0m = zerosArrayLength / \e[31m2\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e[35mzerosArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmprqvx3q47.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36monesArrayLength\e[0m = onesArrayLength\
    \ * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35monesArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprqvx3q47.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mzerosArrayLength\e[0m =\
    \ zerosArrayLength * \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArrayLength is already defined as \e[33mvalue\e[0m \e\
    [35mzerosArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the "
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.map(x => if (x == 1)\
    \ 1 else 0)\n        val twos = arr.map(x => if (x == 2) 2 else 0)\n        val\
    \ threes = arr.map(x => if (x == 3) 3 else 0)\n        val fours = arr.map(x =>\
    \ if (x == 4) 4 else 0)\n        val fives = arr.map(x => if (x == 5) 5 else 0)\n\
    \        val sixes = arr.map(x => if (x == 6) 6 else 0)\n        val sevens =\
    \ arr.map(x => if (x == 7) 7 else 0)\n        val eights = arr.map(x => if (x\
    \ == 8) 8 else 0)\n        val nines = arr.map(x => if (x == 9) 9 else 0)\n  \
    \      val tens = arr.map(x => if (x == 10) 10 else 0)\n        val hundreds =\
    \ arr.map(x => if (x == 11) 11 else 0)\n        val thousands = arr.map(x => if\
    \ (x == 100) 100 else 0)\n        val millions = arr.map(x => if (x == 1000) 1000\
    \ else 0)\n        val billions = arr.map(x => if (x == 1000000) 1000000 else\
    \ 0)\n        val trillions = arr.map(x => if (x == 1000000000) 1000000000 else\
    \ 0)\n        val quadrillions = arr.map(x => if (x == 1000000000000) 1000000000000\
    \ else 0)\n        val quintillions = arr.map(x => if (x == 1000000000000000)\
    \ 1000000000000000 else 0)\n        val sextillions = arr.map(x => if (x == 1000000000000000000)\
    \ 1000000000000000000 else 0)\n        val onesAndZeros = arr.map(x => if (x ==\
    \ 1) 1 else 0)\n        val onesAndOnes = arr.map(x => if (x == 1) 1 else 1)\n\
    \        val onesAndTwos = arr.map(x => if (x == 1) 1 else 2)\n        val onesAndThrees\
    \ = arr.map(x => if (x == 1) 1 else 3)\n        val onesAndFours = arr.map(x =>\
    \ if (x == 1) 1 else 4)\n        val onesAndFives = arr.map(x => if (x == 1) 1\
    \ else 5)\n        val onesAndSixes = arr.map(x => if (x == 1) 1 else 6)\n   \
    \     val onesAndSevens = arr.map(x => if (x == 1) 1 else 7)\n        val onesAndEights\
    \ = arr.map(x => if (x == 1) 1 else 8)\n        val onesAndNines = arr.map(x =>\
    \ if (x == 1) 1 else 9)\n        val onesAndTens = arr.map(x => if (x == 1) 1\
    \ else 10)\n        val onesAndHundreds = arr.map(x => if (x == 1) \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptszfhxh9.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmptszfhxh9.scala:27:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \              number too large\n\e[31m\e[31m-- Error: /tmp/tmptszfhxh9.scala:27:64\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquadrillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000\e[0m) \e[31m1000000000000\e[0m \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                                    number too large\n\e[31m\e[31m-- Error: /tmp/tmptszfhxh9.scala:28:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \                       number too large\n\e[31m\e[31m-- Error: /tmp/tmptszfhxh9.scala:28:67\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \ \e[33mval\e[0m \e[36mquintillions\e[0m = arr.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m1000000000000000\e[0m) \e[31m1000000000000000\e[0m \e[33melse\e\
    [0m \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                                number too large\n\e[31m\e[31m--\
    \ Error: /tmp/tmptszfhxh9.scala:29:48 ----"
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.filter(_ % 2 == 0).length\n\
    \        val zeros = arr.filter(_ % 2 == 1).length\n        val onesArr = arr.filter(_\
    \ % 2 == 0).sortBy(_ % 2).reverse\n        val zerosArr = arr.filter(_ % 2 ==\
    \ 1).sortBy(_ % 2).reverse\n        val onesCount = onesArr.length\n        val\
    \ zerosCount = zerosArr.length\n        val onesSum = onesArr.foldLeft(0)((sum,\
    \ elem) => sum + elem)\n        val zerosSum = zerosArr.foldLeft(0)((sum, elem)\
    \ => sum + elem)\n        val onesDec = onesSum / onesCount\n        val zerosDec\
    \ = zerosSum / zerosCount\n        val onesDec = onesArr.sortBy(_ % 2).reverse\n\
    \        val zerosArr = zerosArr.sortBy(_ % 2).reverse\n        val zerosCount\
    \ = zerosArr.length\n        val zerosSum = zerosArr.foldLeft(0)((sum, elem) =>\
    \ sum + elem)\n        val zerosDec = zerosSum / zerosCount\n        val zerosDec\
    \ = zerosArr.sortBy(_ % 2).reverse\n        val result = onesDec.zip(zerosDec).sortBy(_._1).reverse\n\
    \        result.map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(sortArray((List[Long](1l.toLong,\
    \ 5l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong, 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong,\
    \ -3l.toLong, -4l.toLong, -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong,\
    \ -2l.toLong, -6l.toLong, -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong,\
    \ 0l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong,\
    \ 1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3dmiyqb.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36monesDec\e[0m = onesArr.sortBy(_\
    \ % \e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0monesDec is already defined as \e[33mvalue\e[0m \e[35monesDec\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3dmiyqb.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mzerosArr\e[0m = zerosArr.sortBy(_ %\
    \ \e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mzerosArr is already defined as \e[33mvalue\e[0m \e[35mzerosArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3dmiyqb.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mzerosCount\e[0m = zerosArr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mzerosCount is already defined as \e[33mvalue\e[0m \e[35mzerosCount\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc3dmiyqb.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mzerosSum\e[0m = zerosArr.foldLeft(\e[31m0\e\
    [0m)((\e[36msum\e[0m, \e[36melem\e[0m) => sum + elem)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mzerosSum is already defined as \e[33mvalue\e[0m \e[35mzerosSum\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3dmiyqb.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mzerosDec\e[0m = zerosSum / zerosCount\n\
    \e["
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // In this Kata, you have to sort an array of non-negative integers according\
    \ to\n    // number of ones in their binary representation in ascending order.\n\
    \    // For similar number of ones, sort based on decimal value.\n    // It must\
    \ be implemented like this:\n    // >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n    // >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \    // >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    def sortArray(arr\
    \ : List[Long]) : List[Long] = {\n        val ones = arr.count(_ == 1)\n     \
    \   val zeros = arr.count(_ == 0)\n        val onesArr = arr.map(x => (x >>> 0).toInt)\n\
    \        val zerosArr = arr.map(x => (x >>> 0).toInt)\n        val onesCount =\
    \ onesArr.length\n        val zerosCount = zerosArr.length\n        val onesSum\
    \ = onesArr.sum\n        val zerosSum = zerosArr.sum\n        val onesMax = onesSum\
    \ / onesCount\n        val zerosMax = zerosSum / zerosCount\n        val onesMin\
    \ = onesSum / onesCount\n        val zerosMin = zerosSum / zerosCount\n      \
    \  val onesMinArr = onesArr.map(x => (x >>> 0).toInt)\n        val zerosMinArr\
    \ = zerosArr.map(x => (x >>> 0).toInt)\n        val onesMinCount = onesMinArr.length\n\
    \        val zerosMinCount = zerosMinArr.length\n        val onesMinSum = onesMinArr.sum\n\
    \        val zerosMinSum = zerosMinArr.sum\n        val onesMinMax = onesMinSum\
    \ / onesMinCount\n        val zerosMinMax = zerosMinSum / zerosMinCount\n    \
    \    val onesMinMin = onesMinSum / onesMinCount\n        val zerosMinMin = zerosMinSum\
    \ / zerosMinCount\n        val onesMinMinArr = onesMinArr.map(x => (x >>> 0).toInt)\n\
    \        val zerosMinMinArr = zerosMinArr.map(x => (x >>> 0).toInt)\n        val\
    \ onesMinMinCount = onesMinMinArr.length\n        val zerosMinMinCount = zerosMinMinArr.length\n\
    \        val onesMinMinSum = onesMinMinArr.sum\n        val zerosMinMinSum = zerosMinMinArr.sum\n\
    \        val onesMinMinMax = onesMinMinSum / onesMinMinCount\n        val zerosMinMinMax\
    \ = zerosMinMinSum / zerosMinMinCount\n        val onesMinMinMin = onesMinMinSum\
    \ / onesMinMinCount\n        val zerosMinMinMin = zerosMinMinSum / zerosMinMinCount\n\
    \        val onesMinMinMinArr = onesMinMinArr.map(x => (x >>> 0).toInt)\n    \
    \    val zerosMinMinMinArr = zerosMinMinArr.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(sortArray((List[Long](1l.toLong, 5l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 4l.toLong, 3l.toLong,\
    \ 5l.toLong))));\n    assert(sortArray((List[Long](-2l.toLong, -3l.toLong, -4l.toLong,\
    \ -5l.toLong, -6l.toLong))).equals((List[Long](-4l.toLong, -2l.toLong, -6l.toLong,\
    \ -5l.toLong, -3l.toLong))));\n    assert(sortArray((List[Long](1l.toLong, 0l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](0l.toLong, 1l.toLong,\
    \ 2l.toLong, 4l.toLong, 3l.toLong))));\n    assert(sortArray((List[Long]())).equals((List[Long]())));\n\
    \    assert(sortArray((List[Long](2l.toLong, 5l.toLong, 77l.toLong, 4l.toLong,\
    \ 5l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 2l.toLong, 4l.toLong, 4l.toLong, 3l.toLong, 3l.toLong, 5l.toLong, 5l.toLong,\
    \ 5l.toLong, 7l.toLong, 77l.toLong))));\n    assert(sortArray((List[Long](3l.toLong,\
    \ 6l.toLong, 44l.toLong, 12l.toLong, 32l.toLong, 5l.toLong))).equals((List[Long](32l.toLong,\
    \ 3l.toLong, 5l.toLong, 6l.toLong, 12l.toLong, 44l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    assert(sortArray((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 8l.toLong, 16l.toLong, 32l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp0qpq4j_z.scala:45:51 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mzerosMinMinMinArr\e[0m =\
    \ zerosMinMinArr.map(\n\e[31m\e[31m   |\e[0m                                 \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp0qpq4j_z.scala:46:5 ---------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795276
