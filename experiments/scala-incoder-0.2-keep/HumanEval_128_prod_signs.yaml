name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) == -9\n    // >>> prod_signs([0,\
  \ 1]) == 0\n    // >>> prod_signs([]) == None\n    def prodSigns(arr : List[Long])\
  \ : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.zip(magnitudes).map(x => x._1 * x._2)\n        magnitudes.map(x => math.abs(x)\
    \ * product.getOrElse(0))", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).filter(_._1\
    \ == product).map(_._2)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n        if (result > 0) Some(result) else None", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        val sum = productMagnitudes.foldLeft(0L) { (x, y) =>\
    \ x + y }\n        val productSigns = signs.map(x => if (x == 1) 1 else 0)\n \
    \       val productSignsSum = productSigns.foldLeft(0L) { (x, y) => x + y }\n\
    \        val productSignsSumMagnitudes = productSignsSum.map(x => math.abs(x))\n\
    \        val productSignsSumMagnitudesProduct = productSignsSumMagnitudes.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProduct = productSignsSumMagnitudesProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProduct\
    \ = productSignsSumMagnitudesProductProduct.map(x => x * product)\n        val\
    \ productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProduct.map(x => x * product)\n   \
    \     val productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProduct.map(x => x * product)\n\
    \        val productSignsSumMagnitudesProductProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => ", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        magnitudes.map(x => x * product).sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val productSum = product.sum\n        if (productSum\
    \ == 0) None else Some(productSum)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitude\
    \ = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)", "     \
    \   val product = arr.foldLeft(1L) { (product, item) => product * item }\n   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n \
    \       val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)",
  "        val m = arr.map(_.abs).sum\n        val signs = arr.map(_.signum).sum\n\
    \        Some(m * signs)", "        val product = arr.foldLeft(1L)(_ * _)\n  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    signs.foldLeft(product)(_ * _)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)", "        val product = arr.foldLeft(1L) { (product, value) => product\
    \ * value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        signs.foldLeft(product) { (product, sign) => product * sign\
    \ }", "        val product = arr.foldLeft(1L) { (product, value) => product *\
    \ value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = signs.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        val productSigns = signs.map(x => x * product)\n   \
    \     val productMagnitudes = magnitudes.map(x => x * product)\n        val productSum\
    \ = productSigns.sum\n        val productProductSigns = productSigns.map(x =>\
    \ x * product)\n        val productProductMagnitudes = productMagnitudes.map(x\
    \ => x * product)\n        val productProductSum = productProductSigns.sum\n \
    \       val productProductProductSigns = productProductSigns.map(x => x * product)\n\
    \        val productProductProductMagnitudes = productProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductSum = productProductProductSigns.sum\n\
    \        val productProductProductProductSigns = productProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = ", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(0L) { (x, y) => x + y\
    \ }\n        Some(sum * product)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n  \
    \      val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign) => product\
    \ * sign }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum",
  "        val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x,\
    \ y) => x * y)", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val product = signs.product\n        val magnitudes =\
    \ signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        magnitudes.zip(productMagnitudes).map(x => x._1 * x._2).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        val sign = signs.sum\n\
    \        if (mag == 0) None else Some(mag * sign)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x))\n\
    \        val magSum = mag zip signs map { case (x, y) => x * y }\n        magSum.sum\
    \ == sum match {\n            case true => Some(sum)\n            case false =>\
    \ None\n        }", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ sum = product.sum\n        if (sum > 0) Some(sum) else None", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.zip(signs).map(x => x._1 * x._2).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val sum = product.sum\n        val mag\
    \ = product.map(x => math.abs(x)).sum\n        val result = mag * sum\n      \
    \  if (result == 0) None else Some(result)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        magnitudes.zip(productMagnitudes).filter(_._2 > 0).map(_._1)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n\
    \        val sum = magnitudes.sum\n        if (sum > 0) Some(sum) else None",
  "        val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map { case (m, p) => m * p\
    \ }", "        val product = arr.foldLeft(1L) { (product, value) => product *\
    \ value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        signs.foldLeft(product) { (product, sign) => product * sign }",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitude\
    \ = arr.map(x => math.abs(x)).foldLeft(1L) { (x, y) => x * y }\n        Some(magnitude\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val magnitudesProduct = magnitudes.foldLeft(1L)(_\
    \ * _)\n        magnitudesProduct / product", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.map(x\
    \ => x * product).sum\n        if (result > 0) Some(result) else None", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        val productSigns\
    \ = signs.foldLeft(0L)(_ * _)\n        Some(product * productSigns * sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        magnitudes.zip(signs).map(x => x * product).sum", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(1L) { (x,\
    \ y) => x * y }\n        val result = Some(product * sum)\n        result", " \
    \       val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val result = magnitudes.map(x => x * product)\n   \
    \     if (result.sum == product) Some(result.sum) else None", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduce(_ + _)\n        Some(product * sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val productSigns\
    \ = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudesSigns = magnitudes.map(x\
    \ => math.signum(x))\n        val magnitudesSignsSum = magnitudesSigns.sum\n \
    \       val productSignsSum = productSigns.sum\n        if (magnitude == 0) {\n\
    \            None\n        } else if (sum == 0) {\n            None\n        }\
    \ else if (productSignsSum == 0 && magnitudesSignsSum == 0) {\n            None\n\
    \        } else if (productSignsSum == 0 && magnitudesSignsSum != 0) {\n     \
    \       None\n        } else if (productSignsSum != 0 && magnitudesSignsSum ==\
    \ 0) {\n            None\n        } else if (productSignsSum != 0 && magnitudesSignsSum\
    \ != 0) {\n            Some(product * productSignsSum)\n        } else {\n   \
    \         None\n        }", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x => x\
    \ * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n   \
    \     val result = mag if sum == 0 else mag / sum\n        Some(result)", "  \
    \      val m = arr.map(x => math.abs(x)).foldLeft(0L)(_ * _)\n        val s =\
    \ arr.map(x => math.signum(x)).foldLeft(0L)(_ * _)\n        Some(s * m)", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduce((x, y) => x + y)\n    \
    \    val productSign = signs.reduce((x, y) => x * y)\n        val magnitudeSign\
    \ = magnitudes.reduce((x, y) => x + y)\n        val signsSum = signs.reduce((x,\
    \ y) => x + y)\n        val signsProduct = signs.reduce((x, y) => x * y)\n   \
    \     val signsSumProduct = signs.reduce((x, y) => x + y)\n        val signsProductSign\
    \ = signs.reduce((x, y) => x * y)\n        val signsSumProductSign = signs.reduce((x,\
    \ y) => x + y)\n        val signsProductSign = signs.reduce((x, y) => x * y)\n\
    \        val signsSumProductSign = signs.reduce((x, y) => x + y)\n        val\
    \ signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signs", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_\
    \ + _)\n        Some(product * sum)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)", "        val product\
    \ = arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x => x._1\
    \ * x._2).sum", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        Some(signs.map(x => x * product).sum / m)", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(1L) { (x,\
    \ y) => x * y }\n        Some(sum * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n\
    \        Some(mag)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitude\
    \ = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)", "     \
    \   val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x, y)\
    \ => x * y)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n  \
    \      Some(product * sum)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).getOrElse(None)",
  "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum / m)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(product * sum)", "        val product\
    \ = arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x == 0) -1 else if (x == 1) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x => x._1\
    \ * x._2)", "        val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x\
    \ => math.signum(x)).sum\n        Some(m * s)", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum",
  "        val m = arr.map(x => math.abs(x)).reduce(_ * _)\n        val s = arr.map(x\
    \ => math.signum(x)).reduce(_ * _)\n        Some(m * s)", "        val product\
    \ = arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val\
    \ productOfSigns = signs.foldLeft(1L) { (product, value) => product * value }\n\
    \        val productOfMagnitudes = magnitudes.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val productOfSums = magnitudes.foldLeft(1L) {\
    \ (product, value) => product * value }\n        val productOfProductOfSigns =\
    \ signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfSums = magnitudes.foldLeft(1L) { (product, value) => product\
    \ * value }\n        val productOfProductOfProductOfSigns = signs.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val productOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfSums = magnitudes.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val productOfProductOfProductOfProductOfSigns\
    \ = signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfProductOfSums = magnitudes.foldLeft(1L) { (product,\
    \ value) => product * value }\n        val productOfProductOfProductOfProductOfProductOfSigns\
    \ = signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfProductOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfProductOfProductOfSums = magnitudes.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val productOfProductOfProduct",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(m * signs)", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val result = magnitudes.map(x => x * product).sum\n        if (result\
    \ > 0) Some(result) else None", "        val m = arr.map(x => math.abs(x)).sum\n\
    \        val s = arr.map(x => math.signum(x)).sum\n        Some(m * s)", "   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val result = magnitudes.foldLeft(product)\
    \ { (x, y) => x * y }\n        Some(result)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        Some(mag)", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val product = arr.foldLeft(1L) {\n          \
    \  (acc, x) => acc * x\n        }\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.foldLeft(product) {\n            (acc, x) => acc\
    \ * x\n        }\n        Some(sum)", "        val m = arr.map(x => math.abs(x)).sum\n\
    \        val s = arr.map(x => math.signum(x)).sum\n        Some(s * m)", "   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ m = arr.map(x => math.abs(x)).foldLeft(0)(_ * _)\n        val s = arr.map(x\
    \ => math.signum(x)).foldLeft(0)(_ * _)\n        Some(m * s)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val m = arr.map(x => math.abs(x)).sum\n   \
    \     val s = arr.map(x => math.signum(x)).sum\n        Some(s * m)", "      \
    \  val product = arr.foldLeft(1L) { (product, value) => product * value }\n  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = signs.map(x => math.abs(x))\n        val result = magnitudes.zip(product).map(x\
    \ => x._1 * x._2)\n        if (result.isEmpty) None else Some(result.sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x)).map(math.abs)\n        magnitudes.foldLeft(product)(_ * _)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem }\n        val signs =\
    \ arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.foldLeft(product)(_\
    \ * _)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        val result = if (magnitude == 0) None else Some(magnitude * product)\n\
    \        result", "        val signs = arr.map(x => if (x < 0) -1 else if (x >\
    \ 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.foldLeft(product)(_ * _)", "        val\
    \ m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitude\
    \ = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.foldLeft(product)(_ * _)", "        val\
    \ m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val magnitude = product.map(x => math.abs(x)).sum\n\
    \        val result = if (magnitude == 0) None else Some(sum / magnitude)\n  \
    \      result", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1 ==\
    \ _._2).map(_._2)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduce((x, y) => x * y)\n      \
    \  val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes =\
    \ magnitudes.map(x => x * product)\n        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > 0).map(_._1).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.sum", "        val product\
    \ = arr.foldLeft(1L) { (product, value) =>\n            product * math.signum(value)\n\
    \        }\n        val magnitudes = arr.map(math.abs)\n        val signs = magnitudes.map(math.signum)\n\
    \        magnitudes.zip(signs).map { case (magnitude, sign) =>\n            magnitude\
    \ * sign\n        }.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n    \
    \    val sum = product.sum\n        val mag = product.map(x => math.abs(x))\n\
    \        mag match {\n            case Nil => None\n            case x :: xs =>\
    \ Some(sum * math.prod(x))\n        }", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.sum * product", "        val m = arr.map(_.abs).sum\n    \
    \    val s = arr.map(_.signum).sum\n        Some(arr.map(x => x * m * s).sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        Some(mag)", "  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val mag = product.map(x => math.abs(x)).sum\n        mag match {\n      \
    \      case 0 => None\n            case x if x == 0 => None\n            case\
    \ x => Some(sum / mag)\n        }", "        val m = arr.map(x => math.abs(x)).sum\n\
    \        val s = arr.map(x => math.signum(x)).sum\n        Some(m * s)", "   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)(_ + _)\n        Some(sum\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.product\n        val sum = magnitudes.sum\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val mag = product.map(x => math.abs(x)).sum\n        mag match {\n      \
    \      case 0 => None\n            case x if x == 1 => Some(sum)\n           \
    \ case x if x == -1 => Some(-sum)\n            case _ => None\n        }", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum", " \
    \       val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else 1).sum\n        Some(signs * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        Some(product\
    \ * sum)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        magnitudes.zip(product).map{ case (mag, prod)\
    \ => mag * prod }", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(arr.map(x => x * m / s).sum)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x))\n        val magSum = mags.sum\n        if (magSum > sum) Some(magSum)\
    \ else None", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).getOrElse(None)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x)).filter(x => x >= 0)\n        magnitudes.foldLeft(product)(_\
    \ * _)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        Some(signs.map(x => x * product).sum / m)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val mag = product.map(x => math.abs(x)).sum\n        Some(mag)", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n\
    \        val result = Some(magnitude * product)\n        result", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.map(x => x * x).sum\n\
    \        magnitudes.map(x => x * product).sum", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L) { (x, y) => x * y }\n        Some(signs.map(x\
    \ => x * product).sum / m)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n      \
    \  val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x => x *\
    \ product).sum", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        Some(signs.map(x => x * product).sum / m)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.zip(signs).map(x => x._1 * x._2).sum", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val sum = magnitudes.reduceLeft(_ + _)\n        val result = if (magnitude\
    \ == 0) None else Some(magnitude * product)\n        result", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.zip(signs).map(x => x * product).sum", "        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        Some(signs.map(x => x * product).sum)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.map(x\
    \ => x * magnitudes.getOrElse(0)).sum\n        Some(product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val magnitudesProduct = magnitudes.foldLeft(1L)(_ * _)\n        magnitudesProduct\
    \ / product", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.product\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L) { (x,\
    \ y) => x + y }\n        Some(sum * product)", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)", "        val product\
    \ = arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        Some(signs.map(x => x * product).sum)", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        mag match {\n  \
    \          case 0 => None\n            case x if x == 0 => Some(sum)\n       \
    \     case x => Some(sum - mag)\n        }", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => product * x)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n       \
    \ val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val mag = product.map(x => math.abs(x))\n        val result = mag zip sum\n\
    \        result.find(_._1 == 0)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L) { (x,\
    \ y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.sum\n        val result = if (sum > 0) product / sum else product\n\
    \        Some(result)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n       \
    \ val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n\
    \        mag match {\n            case 0 => None\n            case x if x == 0\
    \ => Some(sum)\n            case x if x > 0 => Some(sum - mag)\n            case\
    \ x if x < 0 => Some(sum + mag)\n        }", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        mag match {\n            case 0 => None\n     \
    \       case x if x == 1 => Some(sum)\n            case x if x == -1 => Some(-sum)\n\
    \            case _ => Some(math.abs(sum))\n        }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)", "        val product\
    \ = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.reduce((x, y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.zip(signs).map(x => x._1 * x._2).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0))\n\
    \        val sum = product.sum\n        val productSigns = product.map(x => if\
    \ (x == 0) 1 else 0)\n        Some(sum * productSigns.sum)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        val result = Some(sum * product)\n    \
    \    result", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val result = magnitudes.foldLeft(product)(_ * _)\n        Some(result)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n        Some(m\
    \ * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes =\
    \ arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x\
    \ => math.abs(x)).sum\n        Some(magnitude * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n\
    \        magnitudes.map(x => x * product).sum", "        val m = arr.map(x =>\
    \ math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n       \
    \ Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.product\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum * product)",
  "        val product = arr.foldLeft(1L) { (product, elem) => product * elem}\n \
    \       val signs = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else\
    \ 0)\n        signs.foldLeft(product) { (product, sign) => product * sign}", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = arr.map(x => x * signs(x))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        Some(mag * sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.reduceLeft(_\
    \ * _)\n        magnitudes.map(x => x * product).sum", "        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.product\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        if (product == 0) None else Some(signs.map(x => x * m).sum)", "     \
    \   val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n        val\
    \ productSign = signs.reduceLeft(_ * _)\n        val magnitudeSigns = magnitudes.map(x\
    \ => math.signum(x))\n        val magnitudeSum = magnitudes.reduceLeft(_ + _)\n\
    \        val magnitudeProductSign = magnitudes.map(x => math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignSum = magnitudes.map(x => math.signum(x) * math.signum(x)\
    \ + math.signum(x) * math.signum(x))\n        val magnitudeProductSignProduct\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x))\n  \
    \      val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProductSum = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.sig", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n\
    \        val result = mag if sum == 0 else mag / sum\n        Some(result)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x._1 * x._2).sum", " \
    \       val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        Some(product * sum)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x * product).sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduceLeft(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val productMagnitudes = magnitudes.map(x => x * product)\n\
    \        productMagnitudes.sum", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n\
    \        val mag2 = mag * mag\n        if (mag2 == 0) None else Some(sum / mag2)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => x * product).sum"]
stop_tokens:
- "\n    }\n"
