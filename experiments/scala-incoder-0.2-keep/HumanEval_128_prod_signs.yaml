name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) == -9\n    // >>> prod_signs([0,\
  \ 1]) == 0\n    // >>> prod_signs([]) == None\n    def prodSigns(arr : List[Long])\
  \ : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = arr.map(x => math.abs(x))\n        val product\
    \ = signs.zip(magnitudes).map(x => x._1 * x._2)\n        magnitudes.map(x => math.abs(x)\
    \ * product.getOrElse(0))", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).filter(_._1\
    \ == product).map(_._2)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val result = magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n        if (result > 0) Some(result) else None", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val productMagnitudes = magnitudes.map(x\
    \ => x * product)\n        val sum = productMagnitudes.foldLeft(0L) { (x, y) =>\
    \ x + y }\n        val productSigns = signs.map(x => if (x == 1) 1 else 0)\n \
    \       val productSignsSum = productSigns.foldLeft(0L) { (x, y) => x + y }\n\
    \        val productSignsSumMagnitudes = productSignsSum.map(x => math.abs(x))\n\
    \        val productSignsSumMagnitudesProduct = productSignsSumMagnitudes.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProduct = productSignsSumMagnitudesProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProduct\
    \ = productSignsSumMagnitudesProductProduct.map(x => x * product)\n        val\
    \ productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProduct.map(x => x * product)\n   \
    \     val productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProduct.map(x => x * product)\n\
    \        val productSignsSumMagnitudesProductProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => ", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        magnitudes.map(x => x * product).sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val productSum = product.sum\n        if (productSum\
    \ == 0) None else Some(productSum)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitude\
    \ = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)", "     \
    \   val product = arr.foldLeft(1L) { (product, item) => product * item }\n   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n \
    \       val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val\
    \ magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude * product)",
  "        val m = arr.map(_.abs).sum\n        val signs = arr.map(_.signum).sum\n\
    \        Some(m * signs)", "        val product = arr.foldLeft(1L)(_ * _)\n  \
    \      val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    signs.foldLeft(product)(_ * _)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)", "        val product = arr.foldLeft(1L) { (product, value) => product\
    \ * value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        signs.foldLeft(product) { (product, sign) => product * sign\
    \ }", "        val product = arr.foldLeft(1L) { (product, value) => product *\
    \ value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val magnitudes = signs.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        val productSigns = signs.map(x => x * product)\n   \
    \     val productMagnitudes = magnitudes.map(x => x * product)\n        val productSum\
    \ = productSigns.sum\n        val productProductSigns = productSigns.map(x =>\
    \ x * product)\n        val productProductMagnitudes = productMagnitudes.map(x\
    \ => x * product)\n        val productProductSum = productProductSigns.sum\n \
    \       val productProductProductSigns = productProductSigns.map(x => x * product)\n\
    \        val productProductProductMagnitudes = productProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductSum = productProductProductSigns.sum\n\
    \        val productProductProductProductSigns = productProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = ", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(0L) { (x, y) => x + y\
    \ }\n        Some(sum * product)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n  \
    \      val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum"]
stop_tokens:
- "\n    }\n"
