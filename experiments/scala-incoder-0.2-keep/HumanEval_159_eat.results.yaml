language: scala
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val carrots_left\
    \ = remaining - carrots\n        val carrots_left_after_meals = carrots_left -\
    \ carrots // carrots_left - carrots_after_meals\n        val carrots_after_meals\
    \ = carrots - carrots_left_after_meals\n        val carrots_after_meals_remaining\
    \ = carrots_after_meals - carrots // carrots_after_meals - carrots_after_meals_remaining\n\
    \        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining\
    \ - carrots // carrots_after_meals_remaining - carrots_after_meals_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining = carrots_after_meals_remaining_remaining\
    \ - carrots // carrots_after_meals_remaining_remaining - carrots_after_meals_remaining_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining\
    \ - carrots // carrots_after_meals_remaining_remaining_remaining - carrots_after_meals_remaining_remaining_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining - carrots // carrots_after_meals_remaining_remaining_remaining_remaining\
    \ - carrots_after_meals_remaining_remaining_remaining_remaining_remaining\n  \
    \      val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining - carrots\
    \ // carrots_after_meals_remaining_remaining_remaining_remaining - carrots_after_meals_remaining_remaining_remaining_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining - carrots\
    \ // carrots_after_meals_remaining_remaining_remaining_remaining - carrots_after_meals_remaining_remaining_remaining_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining - carrots\
    \ // carrots_after_meals_remaining_remaining_remaining_remaining - carrots_after_meals_remaining_remaining_remaining_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining - carrots\
    \ // carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpja8zf1gs.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining -\
    \ carrots \e[34m// carrots_after_meals_remaining_remaining_remaining_remaining\
    \ - carrots_after_meals_remaining_remaining_remaining_remaining_remaining\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpja8zf1gs.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var remaining = remaining\n        while(number > 0 && remaining > 0)\
    \ {\n            carrots += number\n            number -= 1\n            remaining\
    \ -= 1\n        }\n        carrots ++= remaining\n        carrots.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1eqqfqsx.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp1eqqfqsx.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1eqqfqsx.scala:31:19\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            number -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value -= is not a member of Long - did you mean number.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804606
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result match {\n            case List(_, _) => result\n            case _\
    \ => eat(number, need, remaining - carrots)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk2xoh_le.scala:36)\n\tat Problem.main(tmpk2xoh_le.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val remaining\
    \ = remaining - carrots\n        val meals = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / meals) + 1, math.ceil(remaining / meals)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)), 0)\n        val carrots = math.max(math.min(math.ceil(remaining\
    \ / carrots) + 1, math.ceil(remaining / carrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp757b8c76.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp757b8c76.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots\e[0m = math.max(math.min(math.ceil(remaining / meals) + \e[31m1\e\
    [0m, math.ceil(remaining / meals)), \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp757b8c76.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(math.min(math.ceil(remaining\
    \ / carrots) + \e[31m1\e[0m, math.ceil(remaining / carrots)), \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp757b8c76.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(math.min(math.ceil(remaining\
    \ / carrots) + \e[31m1\e[0m, math.ceil(remaining / carrots)), \e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp757b8c76.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrotsRemaining\
    \ = hungryCarrots - hungryMeals\n        val hungryMealsRemaining = hungryMeals\
    \ - hungryCarrots\n        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n\
    \        val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val\
    \ hungryCarrotsRemainingList2 = List(hungryCarrotsRemainingList)\n        val\
    \ hungryMealsRemainingList2 = List(hungryMealsRemainingList)\n        val hungryCarrotsRemainingList3\
    \ = List(hungryCarrotsRemainingList2)\n        val hungryMealsRemainingList3 =\
    \ List(hungryMealsRemainingList2)\n        val hungryCarrotsRemainingList4 = List(hungryCarrotsRemainingList3)\n\
    \        val hungryMealsRemainingList4 = List(hungryMealsRemainingList3)\n   \
    \     val hungryCarrotsRemainingList5 = List(hungryCarrotsRemainingList4)\n  \
    \      val hungryMealsRemainingList5 = List(hungryMealsRemainingList4)\n     \
    \   val hungryCarrotsRemainingList6 = List(hungryCarrotsRemainingList5)\n    \
    \    val hungryMealsRemainingList6 = List(hungryMealsRemainingList5)\n       \
    \ val hungryCarrotsRemainingList7 = List(hungryCarrotsRemainingList6)\n      \
    \  val hungryMealsRemainingList7 = List(hungryMealsRemainingList6)\n        val\
    \ hungryCarrotsRemainingList8 = List(hungryCarrotsRemainingList7)\n        val\
    \ hungryMealsRemainingList8 = List(hungryMealsRemainingList7)\n        val hungr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy6u4svqd.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpy6u4svqd.scala:30:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryCarrots\e[0m = carrots - hungry\n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpy6u4svqd.scala:31:32 -----------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = meals - hungry\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy6u4svqd.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val hungry = true\n        val hungryCarrots = remaining\n        val\
    \ hungryMeals = meals\n        val hungryCarrotsRemaining = hungryCarrots - hungryMeals\n\
    \        val hungryMealsRemaining = hungryMeals - hungryCarrots\n        val hungryCarrotsRemaining2\
    \ = hungryCarrots - hungryMeals\n        val hungryMealsRemaining2 = hungryMeals\
    \ - hungryCarrots\n        val hungryCarrotsRemaining3 = hungryCarrots - hungryMeals\n\
    \        val hungryMealsRemaining3 = hungryMeals - hungryCarrots\n        val\
    \ hungryCarrotsRemaining4 = hungryCarrots - hungryMeals\n        val hungryMealsRemaining4\
    \ = hungryMeals - hungryCarrots\n        val hungryCarrotsRemaining5 = hungryCarrots\
    \ - hungryMeals\n        val hungryMealsRemaining5 = hungryMeals - hungryCarrots\n\
    \        val hungryCarrotsRemaining6 = hungryCarrots - hungryMeals\n        val\
    \ hungryMealsRemaining6 = hungryMeals - hungryCarrots\n        val hungryCarrotsRemaining7\
    \ = hungryCarrots - hungryMeals\n        val hungryMealsRemaining7 = hungryMeals\
    \ - hungryCarrots\n        val hungryCarrotsRemaining8 = hungryCarrots - hungryMeals\n\
    \        val hungryMealsRemaining8 = hungryMeals - hungryCarrots\n        val\
    \ hungryCarrotsRemaining9 = hungryCarrots - hungryMeals\n        val hungryMeals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp67zhw7f5.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp67zhw7f5.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp67zhw7f5.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (remaining <= 0) {\n            List(meals, carrots)\n        } else {\n\
    \            List(meals, carrots).foldLeft(List(meals, carrots))((acc, curr) =>\
    \ acc ++ eat(curr, need, remaining))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List.prependedAll(List.scala:148)\n\
    \tat scala.collection.immutable.List$.from(List.scala:684)\n\tat scala.collection.immutable.List$.from(List.scala:681)\n\
    \tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\
    \tat scala.collection.immutable.List$.apply(List.scala:681)\n\tat Problem$.eat(tmpeb9xoklm.scala:29)\n\
    \tat Problem$.eat$$anonfun$1(tmpeb9xoklm.scala:33)\n\tat Problem$.eat$$anonfun$adapted$1(tmpeb9xoklm.scala:33)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.eat(tmpeb9xoklm.scala:33)\n\
    \tat Problem$.eat$$anonfun$1(tmpeb9xoklm.scala:33)\n\tat Problem$.eat$$anonfun$adapted$1(tmpeb9xoklm.scala:33)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.eat(tmpeb9xoklm.scala:33)\n\
    \tat Problem$.eat$$anonfun$1(tmpeb9xoklm.scala:33)\n\tat Problem$.eat$$anonfun$adapted$1(tmpeb9xoklm.scala:33)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.eat(tmpeb9xoklm.scala:33)\n\
    \tat Problem$.eat$$anonfun$1(tmpeb9xoklm.scala:33)\n\tat Problem$.eat$$anonfun$adapted$1(tmpeb9xoklm.scala:33)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.eat(tmpeb9xoklm.scala:33)\n\
    \tat Problem$.eat$$anonfun$1(tmpeb9xoklm.scala:33)\n\tat Problem$.eat$$anonfun$adapted$1(tmpeb9xoklm.scala:33)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat sca"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left += need\n            carrots += carrots_left\n     \
    \   }\n        carrots.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeo9mpy83.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsList = mutable.ListBuffer[Long]()\n\
    \        val carrotsList = mutable.ListBuffer[Long]()\n        val carrotsNeeded\
    \ = meals - carrots\n        val carrotsNeededList = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList2 = mutable.ListBuffer[Long]()\n        val carrotsNeededList3\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList4 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList5 = mutable.ListBuffer[Long]()\n        val carrotsNeededList6\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList7 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList8 = mutable.ListBuffer[Long]()\n        val carrotsNeededList9\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList10 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList11 = mutable.ListBuffer[Long]()\n        val carrotsNeededList12\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList13 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList14 = mutable.ListBuffer[Long]()\n        val carrotsNeededList15\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList16 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList17 = mutable.ListBuffer[Long]()\n        val carrotsNeededList18\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList19 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList20 = mutable.ListBuffer[Long]()\n        val carrotsNeededList21\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList22 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList23 = mutable.ListBuffer[Long]()\n        val carrotsNeededList24\
    \ = mutable.ListBuffer[Long]()\n        val carro\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpifeyws3z.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpifeyws3z.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsList\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpifeyws3z.scala:30:26\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotsList\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpifeyws3z.scala:32:32 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsNeededList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpifeyws3z.scala:33:33 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mcarrotsNeededList2\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpifeyws3z.scala:34:33 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsNeededList3\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                               "
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsList = ListBuffer[Long]()\n   \
    \     val mealsArray = Array.ofDim[Long](meals)\n        val mealsArrayCopy =\
    \ mealsArray.clone()\n        val mealsArrayCopy2 = mealsArrayCopy.clone()\n \
    \       val mealsArrayCopy3 = mealsArrayCopy2.clone()\n        val mealsArrayCopy4\
    \ = mealsArrayCopy3.clone()\n        val mealsArrayCopy5 = mealsArrayCopy4.clone()\n\
    \        val mealsArrayCopy6 = mealsArrayCopy5.clone()\n        val mealsArrayCopy7\
    \ = mealsArrayCopy6.clone()\n        val mealsArrayCopy8 = mealsArrayCopy7.clone()\n\
    \        val mealsArrayCopy9 = mealsArrayCopy8.clone()\n        val mealsArrayCopy10\
    \ = mealsArrayCopy9.clone()\n        val mealsArrayCopy11 = mealsArrayCopy10.clone()\n\
    \        val mealsArrayCopy12 = mealsArrayCopy11.clone()\n        val mealsArrayCopy13\
    \ = mealsArrayCopy12.clone()\n        val mealsArrayCopy14 = mealsArrayCopy13.clone()\n\
    \        val mealsArrayCopy15 = mealsArrayCopy14.clone()\n        val mealsArrayCopy16\
    \ = mealsArrayCopy15.clone()\n        val mealsArrayCopy17 = mealsArrayCopy16.clone()\n\
    \        val mealsArrayCopy18 = mealsArrayCopy17.clone()\n        val mealsArrayCopy19\
    \ = mealsArrayCopy18.clone()\n        val mealsArrayCopy20 = mealsArrayCopy19.clone()\n\
    \        val mealsArrayCopy21 = mealsArrayCopy20.clone()\n        val mealsArrayCopy22\
    \ = mealsArrayCopy21.clone()\n        val mealsArrayCopy23 = mealsArrayCopy22.clone()\n\
    \        val mealsArrayCopy24 = mealsArrayCopy23.clone()\n        val mealsArrayCopy25\
    \ = mealsArrayCopy24.clone()\n        val mealsArrayCopy26 = mealsArrayCopy25.clone()\n\
    \        val mealsArrayCopy27 = mealsArrayCopy26.clone()\n        val mealsArrayCopy28\
    \ = mealsArrayCopy27.clone()\n        val mealsArrayCopy29 = mealsArrayCopy28.clone()\n\
    \        val mealsArrayCopy30 = mealsArrayCopy29.clone()\n        val mealsArrayCopy31\
    \ = mealsArrayCopy30.clone()\n        val mealsArrayCopy32 = mealsArrayCopy\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbyo5ekau.scala:30:43\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e\
    [0m = Array.ofDim[\e[35mLong\e[0m](meals)\n\e[31m\e[31m   |\e[0m             \
    \                              ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                        Found:    (meals : Long)\n\e[31m   |\e[0m           \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbyo5ekau.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungry = remainingCarrots > 0\n        val hungryCarrots = remainingCarrots\
    \ - carrots\n        val hungryCarrotsList = List(hungryCarrots)\n        val\
    \ hungryCarrotsList2 = List(hungryCarrots)\n        val hungryCarrotsList3 = List(hungryCarrots)\n\
    \        val hungryCarrotsList4 = List(hungryCarrots)\n        val hungryCarrotsList5\
    \ = List(hungryCarrots)\n        val hungryCarrotsList6 = List(hungryCarrots)\n\
    \        val hungryCarrotsList7 = List(hungryCarrots)\n        val hungryCarrotsList8\
    \ = List(hungryCarrots)\n        val hungryCarrotsList9 = List(hungryCarrots)\n\
    \        val hungryCarrotsList10 = List(hungryCarrots)\n        val hungryCarrotsList11\
    \ = List(hungryCarrots)\n        val hungryCarrotsList12 = List(hungryCarrots)\n\
    \        val hungryCarrotsList13 = List(hungryCarrots)\n        val hungryCarrotsList14\
    \ = List(hungryCarrots)\n        val hungryCarrotsList15 = List(hungryCarrots)\n\
    \        val hungryCarrotsList16 = List(hungryCarrots)\n        val hungryCarrotsList17\
    \ = List(hungryCarrots)\n        val hungryCarrotsList18 = List(hungryCarrots)\n\
    \        val hungryCarrotsList19 = List(hungryCarrots)\n        val hungryCarrotsList20\
    \ = List(hungryCarrots)\n        val hungryCarrotsList21 = List(hungryCarrots)\n\
    \        val hungryCarrotsList22 = List(hungryCarrots)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpw4y3cp4q.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw4y3cp4q.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val mealsLeft = mutable.ArrayBuffer(need)\n        val hungry = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft = mutable.ArrayBuffer(need)\n        val hungryLeft2 =\
    \ mutable.ArrayBuffer(need)\n        val hungryLeft3 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft4 = mutable.ArrayBuffer(need)\n        val hungryLeft5\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft6 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft7 = mutable.ArrayBuffer(need)\n        val hungryLeft8\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft9 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft10 = mutable.ArrayBuffer(need)\n        val hungryLeft11\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft12 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft13 = mutable.ArrayBuffer(need)\n        val hungryLeft14\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft15 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft16 = mutable.ArrayBuffer(need)\n        val hungryLeft17\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft18 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft19 = mutable.ArrayBuffer(need)\n        val hungryLeft20\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft21 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft22 = mutable.ArrayBuffer(need)\n        val hungryLeft23\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft24 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft25 = mutable.ArrayBuffer(need)\n        val hungryLeft26\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft27 = mutable.ArrayBuffer(need)\n\
    \        val hungryLeft28 = mutable.ArrayBuffer(need)\n        val hungryLeft29\
    \ = mutable.ArrayBuffer(need)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpeloawikf.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpeloawikf.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpeloawikf.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpeloawikf.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpeloawikf.scala:30:24 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpeloawikf.scala:31:21 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  "
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots <= 0\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n        val hungryCarrots\
    \ = if (hungry) carrots else \"0\"\n        val hungryMeals = if (hungry) meals\
    \ else \"0\"\n        val hungryCarrots = if (hungry) carrots else \"0\"\n   \
    \     val hungryMeals = if (hungry) meals else \"0\"\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8t7ccu8j.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e\
    [33mif\e[0m (hungry) carrots \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t7ccu8j.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry)\
    \ meals \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t7ccu8j.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e[33mif\e[0m (hungry)\
    \ carrots \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t7ccu8j.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry)\
    \ meals \e[33melse\e[0m \e[31m\"0\"\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t7ccu8j.scala:36:12 -----------------"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingCount = hungryRemaining.length\n        val hungryRemainingSumCount\
    \ = hungryRemainingSum * hungryRemainingCount\n        val hungryRemainingSumCount2\
    \ = hungryRemainingSumCount * hungryRemainingCount\n        val hungryRemainingSumCount3\
    \ = hungryRemainingSumCount * hungryRemainingCount * hungryRemainingCount\n  \
    \      val hungryRemainingSumCount4 = hungryRemainingSumCount * hungryRemainingCount\
    \ * hungryRemainingCount * hungryRemainingCount\n        val hungryRemainingSumCount5\
    \ = hungryRemainingSumCount * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount\
    \ * hungryRemainingCount\n        val hungryRemainingSumCount6 = hungryRemainingSumCount\
    \ * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount\
    \ * hungryRemainingCount\n        val hungryRemainingSumCount7 = hungryRemainingSumCount\
    \ * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount\
    \ * hungryRemainingCount * hungryRemainingCount\n        val hungryRemainingSumCount8\
    \ = hungryRemainingSumCount * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount\
    \ * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount * hungryRemainingCount\n\
    \        val hungryRemainingSumCount9 = hungryRemainingSumCount * hungryRemainingCount\
    \ * hungryRemainingCount * hungryRemainingCount * hungryRemain\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprlb0ba40.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprlb0ba40.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprlb0ba40.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprlb0ba40.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804605
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result: List[Long] = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq08xhkwu.scala:33)\n\tat Problem.main(tmpq08xhkwu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        var i = 0\n        while (i < carrots.length && i < meals.length) {\n\
    \            val carrotToEat = carrots(i)\n            val mealToEat = meals(i)\n\
    \            if (carrotToEat >= mealToEat) {\n                carrots(i) = carrotToEat\
    \ - mealToEat\n                meals(i) = mealToEat\n                i += 1\n\
    \            } else {\n                carrots(i) = carrotToEat\n            \
    \    meals(i) = mealToEat\n                i += 1\n            }\n        }\n\
    \        carrots.toList.sortWith(_ < _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf45isbg8.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf45isbg8.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpf45isbg8.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (carrots_left > 0 && hungry) {\n            carrots_left -= 1\n            carrots\
    \ += number\n            hungry = false\n        }\n        if (carrots_left ==\
    \ 0) {\n            carrots += remaining\n        }\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp442cn3qh.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals > 0) {\n            val newRemaining = remaining + meals\n    \
    \        val newNumber = number - meals\n            val newNeed = need - carrots\n\
    \            val newResult = eat(newNumber, newNeed, renewRemaining(newRemaining,\
    \ newNumber))\n            result ::: newResult\n        } else {\n          \
    \  result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9i4pgbj0.scala:34:52 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = eat(newNumber,\
    \ newNeed, renewRemaining(newRemaining, newNumber))\n\e[31m\e[31m   |\e[0m   \
    \                                                 ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                               Not found: renewRemaining\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfombpnd.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsfombpnd.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsfombpnd.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfombpnd.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals > 0) {\n            val newRemaining = remaining + meals\n    \
    \        eat(number, newRemaining, newRemaining)\n        } else {\n         \
    \   result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4pcapdwk.scala:38)\n\tat Problem.main(tmp4pcapdwk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            number -= 1\n           \
    \ carrots_left -= 1\n        }\n        carrots.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz9grr7ho.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz9grr7ho.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n   \
    \     while (i < number) {\n            carrots += i\n            i += 1\n   \
    \     }\n        var j = 0\n        while (j < need) {\n            hungry +=\
    \ j\n            j += 1\n        }\n        var k = 0\n        while (k <= remaining)\
    \ {\n            carrots += k\n            k += 1\n        }\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_c2zyxdo.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_c2zyxdo.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum2 * hungryRemainingSum\n \
    \       val hungryRemainingSum4 = hungryRemainingSum3 * hungryRemainingSum\n \
    \       val hungryRemainingSum5 = hungryRemainingSum4 * hungryRemainingSum\n \
    \       val hungryRemainingSum6 = hungryRemainingSum5 * hungryRemainingSum\n \
    \       val hungryRemainingSum7 = hungryRemainingSum6 * hungryRemainingSum\n \
    \       val hungryRemainingSum8 = hungryRemainingSum7 * hungryRemainingSum\n \
    \       val hungryRemainingSum9 = hungryRemainingSum8 * hungryRemainingSum\n \
    \       val hungryRemainingSum10 = hungryRemainingSum9 * hungryRemainingSum\n\
    \        val hungryRemainingSum11 = hungryRemainingSum10 * hungryRemainingSum\n\
    \        val hungryRemainingSum12 = hungryRemainingSum11 * hungryRemainingSum\n\
    \        val hungryRemainingSum13 = hungryRemainingSum12 * hungryRemainingSum\n\
    \        val hungryRemainingSum14 = hungryRemainingSum13 * hungryRemainingSum\n\
    \        val hungryRemainingSum15 = hungryRemainingSum14 * hungryRemainingSum\n\
    \        val hungryRemainingSum16 = hungryRemainingSum15 * hungryRemainingSum\n\
    \        val hungryRemainingSum17 = hungryRemainingSum16 * hungryRemainingSum\n\
    \        val hungryRemainingSum18 = hungryRemainingSum17 * hungryRemainingSum\n\
    \        val hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpen3uhn2b.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:29:30\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpen3uhn2b.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining2\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining3 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining4 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining5\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining6 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining7 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining8\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining9 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining10 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining11 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining12\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining13 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining14 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining15 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining16\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining17 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining18 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining19 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining20\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining21 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining22 = mutable.ListBuffer[Long]()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1ptod61r.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1ptod61r.scala:32:36 "
  stdout: ''
  timestamp: 1659804613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        var i = 0\n        while(i\
    \ < number) {\n            carrots += i\n            i += 1\n        }\n     \
    \   while(i < need) {\n            hungry += i\n            i += 1\n        }\n\
    \        carrots -= hungry\n        carrots -= remaining\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfgtyw_ue.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfgtyw_ue.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeft2 = mealsLeft * mealsLeft\n        val mealsLeft3 = mealsLeft2\
    \ * mealsLeft\n        val mealsLeft4 = mealsLeft3 * mealsLeft\n        val mealsLeft5\
    \ = mealsLeft4 * mealsLeft\n        val mealsLeft6 = mealsLeft5 * mealsLeft\n\
    \        val mealsLeft7 = mealsLeft6 * mealsLeft\n        val mealsLeft8 = mealsLeft7\
    \ * mealsLeft\n        val mealsLeft9 = mealsLeft8 * mealsLeft\n        val mealsLeft10\
    \ = mealsLeft9 * mealsLeft\n        val mealsLeft11 = mealsLeft10 * mealsLeft\n\
    \        val mealsLeft12 = mealsLeft11 * mealsLeft\n        val mealsLeft13 =\
    \ mealsLeft12 * mealsLeft\n        val mealsLeft14 = mealsLeft13 * mealsLeft\n\
    \        val mealsLeft15 = mealsLeft14 * mealsLeft\n        val mealsLeft16 =\
    \ mealsLeft15 * mealsLeft\n        val mealsLeft17 = mealsLeft16 * mealsLeft\n\
    \        val mealsLeft18 = mealsLeft17 * mealsLeft\n        val mealsLeft19 =\
    \ mealsLeft18 * mealsLeft\n        val mealsLeft20 = mealsLeft19 * mealsLeft\n\
    \        val mealsLeft21 = mealsLeft20 * mealsLeft\n        val mealsLeft22 =\
    \ mealsLeft21 * mealsLeft\n        val mealsLeft23 = mealsLeft22 * mealsLeft\n\
    \        val mealsLeft24 = mealsLeft23 * mealsLeft\n        val mealsLeft25 =\
    \ mealsLeft24 * mealsLeft\n        val mealsLeft26 = mealsLeft25 * mealsLeft\n\
    \        val mealsLeft27 = mealsLeft26 * mealsLeft\n        val mealsLeft28 =\
    \ mealsLeft27 * mealsLeft\n        val mealsLeft29 = mealsLeft28 * mealsLeft\n\
    \        val mealsLeft30 = mealsLeft29 * mealsLeft\n        val mealsLeft31 =\
    \ mealsLeft30 * mealsLeft\n        val mealsLeft32 = mealsLeft31 * mealsLeft\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpei7dg_f3.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpei7dg_f3.scala:62:5 ---------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals < 0) {\n            val carrots = remaining - meals\n         \
    \   val meals = need - carrots\n            val result = List(meals, carrots)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4_iit0sy.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = need -\
    \ carrots\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m\
    \   |\e[0m                               Recursive \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofdzh838.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:34:12\
    \ ------"
  stdout: ''
  timestamp: 1659804615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining2\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining3 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining4 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining5\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining6 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining7 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining8\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining9 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining10 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining11 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining12\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining13 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining14 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining15 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining16\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining17 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining18 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining19 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining20\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining21 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining22 = mutable.ListBuffer[Long]()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1ptod61r.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1ptod61r.scala:32:36 "
  stdout: ''
  timestamp: 1659804613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer(2)\n        val hungry = mutable.ArrayBuffer(true)\n\
    \        val hungryCount = mutable.ArrayBuffer(0)\n        val hungryCount2 =\
    \ mutable.ArrayBuffer(0)\n        val hungryCount3 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount4 = mutable.ArrayBuffer(0)\n        val hungryCount5 =\
    \ mutable.ArrayBuffer(0)\n        val hungryCount6 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount7 = mutable.ArrayBuffer(0)\n        val hungryCount8 =\
    \ mutable.ArrayBuffer(0)\n        val hungryCount9 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount10 = mutable.ArrayBuffer(0)\n        val hungryCount11\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount12 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount13 = mutable.ArrayBuffer(0)\n        val hungryCount14\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount15 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount16 = mutable.ArrayBuffer(0)\n        val hungryCount17\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount18 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount19 = mutable.ArrayBuffer(0)\n        val hungryCount20\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount21 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount22 = mutable.ArrayBuffer(0)\n        val hungryCount23\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount24 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount25 = mutable.ArrayBuffer(0)\n        val hungryCount26\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount27 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount28 = mutable.ArrayBuffer(0)\n        val hungryCount29\
    \ = mutable.ArrayBuffer(0)\n        val hungryCount30 = mutable.ArrayBuffer(0)\n\
    \        val hungryCount31 = mutable.ArrayBuffer(0)\n        val hungr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpafl85e8h.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpafl85e8h.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpafl85e8h.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpafl85e8h.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpafl85e8h.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpafl85e8h.scala:31:21\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(\e[31mtrue\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compili"
  stdout: ''
  timestamp: 1659804617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0, carrots\
    \ - meals)\n        List(meals, leftCarrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeebb5fkw.scala:33)\n\tat Problem.main(tmpeebb5fkw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryCount = mutable.ListBuffer[Long]()\n\
    \        var carrotCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.ListBuffer[Long]()\n\
    \        var hungryCount = 0\n        val hungryCounts = mutable.List\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp29dcm12a.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mhungryCount\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp29dcm12a.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCounts\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mhungryCounts is already defined as \e[33mvalue\e[0m \e[35mhungryCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp29dcm12a.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mvar\e[0m \e[36mhungryCount\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp29dcm12a.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCounts\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mhungryCounts is already defined as \e[33mvalue\e[0m \e[35mhungryCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp29dcm12a.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mvar\e[0m \e[36mhungryCount\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCount\
    \ is already defined as \e[33"
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots += number\n            carrots_left\
    \ -= 1\n            hungry = carrots_left < need\n        }\n        if (carrots_left\
    \ < need) {\n            carrots += remaining\n        }\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuh0xhrjh.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungry = number - remaining\n        val\
    \ hungryCarrots = math.min(need, hungry)\n        val hungryCarrotsToEat = math.min(hungry,\
    \ remaining)\n        val hungryCarrotsToEatRemaining = math.min(hungryCarrots,\
    \ remaining)\n        val hungryCarrotsToEatRemainingToEat = math.min(hungryCarrotsToEatRemaining,\
    \ hungry)\n        val hungryCarrotsToEatRemainingToEatToEat = math.min(hungryCarrotsToEatRemainingToEat,\
    \ hungryCarrots)\n        val hungryCarrotsToEatRemainingToEatToEatToEat = math.min(hungryCarrotsToEatRemainingToEatToEat,\
    \ hungryCarrotsToEatRemaining)\n        val hungryCarrotsToEatRemainingToEatToEatToEatToEat\
    \ = math.min(hungryCarrotsToEatRemainingToEatToEatToEat, hungryCarrotsToEatRemainingToEat)\n\
    \        val hungryCarrotsToEatRemainingToEatToEatToEatToEatToEat = math.min(hungryCarrotsToEatRemainingToEatToEatToEatToEat,\
    \ hungryCarrotsToEatRemainingToEatToEatToEat)\n        val hungryCarrotsToEatRemainingToEatToEatToEatToEatToEatToEat\
    \ = math.min(hungryCarrotsToEatRemainingToEatToEatToEatToEatToEat, hungryCarrotsToEatRemainingToEatToEatToEatToEat)\n\
    \        val hungryCarrotsToEatRemainingToEatToEatToEatToEatToEatToEatToEat =\
    \ math.min(hungryCarrotsToEatRemainingToEatToEatToEatToEatToEatToEat, hungr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp46p87hhz.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46p87hhz.scala:37:145\
    \ -----------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryCarrotsToEatRemainingToEatToEatToEatToEatToEatToEatToEat\e[0m = math.min(hungryCarrotsToEatRemainingToEatToEatToEatToEatToEatToEat,\
    \ hungr\n\e[31m\e[31m   |\e[0m                                               \
    \                                                                            \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                             Not found: hungr\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp46p87hhz.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result: List[Long] = List(carrots, meals)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkv2wum77.scala:33)\n\tat Problem.main(tmpkv2wum77.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsRemaining = meals - carrots\n \
    \       val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n        val\
    \ mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy2\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy3 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy4 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy5 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy6\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy7 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy8 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy9 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy10\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy11 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy12 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy13 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy14\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy15 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy16 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy17 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy18\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy19 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy20 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy21 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy22\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy23 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy24 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy25 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy26\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy27 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy28 = mealsRemain\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk_jpmd57.scala:30:52\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArray\e\
    [0m = Array.ofDim[\e[35mLong\e[0m](mealsRemaining)\n\e[31m\e[31m   |\e[0m    \
    \                                                ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                       Found:    (mealsRemaining : Long)\n\
    \e[31m   |\e[0m                                       Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk_jpmd57.scala:58:40 ------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopy28\e\
    [0m = mealsRemain\n\e[31m\e[31m   |\e[0m                                     \
    \   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                        Not\
    \ found: mealsRemain\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk_jpmd57.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals > 0) {\n            val newRemaining = remaining + meals\n    \
    \        val newNumber = number - newRemaining\n            val newNeed = need\
    \ - newRemaining\n            val newMeals = newNeed - newNumber\n           \
    \ val newResult = List(newMeals, newNumber)\n            result ::: newResult\n\
    \        } else {\n            result ::: List(number, 0)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeez1jg1p.scala:42)\n\tat Problem.main(tmpeez1jg1p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungry = number - remaining\n        val\
    \ hungryCarrots = math.min(need, hungry)\n        val hungryCarrotsLeft = math.max(0,\
    \ hungry - hungryCarrots)\n        val hungryCarrotsLeftList = List(hungryCarrots,\
    \ hungryCarrotsLeft)\n        hungryCarrotsLeftList.map(x => math.max(0, remaining\
    \ - x))\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_267xek.scala:34)\n\tat Problem.main(tmp2_267xek.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots_left -= 1\n      \
    \      number -= 1\n            carrots += number\n            hungry = false\n\
    \        }\n        carrots.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp65ejln9q.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp65ejln9q.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots <= 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryRemaining = if (hungry) remaining else 0\n        val hungryTotal\
    \ = if (hungry) carrots + meals else 0\n        val hungryTotalCarrots = if (hungry)\
    \ hungryTotal else 0\n        val hungryTotalMeals = if (hungry) hungryTotalCarrots\
    \ + hungryMeals else 0\n        val hungryTotalRemaining = if (hungry) hungryTotalCarrots\
    \ + hungryMeals + hungryRemaining else 0\n        val hungryTotalRemainingCarrots\
    \ = if (hungry) hungryTotalRemaining else 0\n        val hungryTotalRemainingMeals\
    \ = if (hungry) hungryTotalRemainingCarrots + hungryTotalMeals else 0\n      \
    \  val hungryTotalRemainingRemaining = if (hungry) hungryTotalRemainingCarrots\
    \ + hungryTotalMeals + hungryRemaining else 0\n        val hungryTotalRemainingRemainingCarrots\
    \ = if (hungry) hungryTotalRemainingRemaining else 0\n        val hungryTotalRemainingRemainingMeals\
    \ = if (hungry) hungryTotalRemainingRemainingCarrots + hungryTotalMeals else 0\n\
    \        val hungryTotalRemainingRemainingRemaining = if (hungry) hungryTotalRemainingRemainingCarrots\
    \ + hungryTotalMeals + hungryRemaining else 0\n        val hungryTotalRemainingRemainingRemainingCarrots\
    \ = if (hungry) hungryTotalRemainingRemainingRemaining else 0\n        val hungryTotalRemainingRemainingRemainingMeals\
    \ = if (hungry) hungryTotalRemainingRemainingRemainingCarrots + hungryTotalMeals\
    \ else 0\n        val h\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7h0ettsc.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7h0ettsc.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804617
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealCarrots = meals.toLong\n       \
    \ val carrotsLeft = remaining - mealCarrots\n        val carrotEaten = carrots.toLong\n\
    \        val carrotEatenLeft = carrotsLeft.toLong\n        val carrotEatenRight\
    \ = carrotsLeft - carrotEaten\n        val carrotEatenRightLeft = carrotEatenRight\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRight = carrotEatenRightLeft\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightRightLeft = carrotEatenRightLeftRight\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRight = carrotEatenRightLeftRightLeft\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightRight = carrotEatenRightLeftRightLeftRight\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightRightLeft =\
    \ carrotEatenRightLeftRightLeftRightRight - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightLeftRight\
    \ = carrotEatenRightLeftRightLeftRightRightLeft - carrotEatenLeft\n        val\
    \ carrotEatenRightLeftRightLeftRightLeftRightLeft = carrotEatenRightLeftRightLeftRightLeftRight\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightLeftRightRight\
    \ = carrotEatenRightLeftRightLeftRightLeftRightLeft - carrotEatenLeft\n      \
    \  val carrotEatenRightLeftRightLeftRightLeftRightLeftRight = carrotEatenRightLeftRightLeftRightLeftRightLeftRight\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightLeftRightLeftRightLeft\
    \ = carrotEatenRightLeftRightLeftRightLeftRightLeftRight - carrotEatenLeft\n \
    \       val carrotEatenRightLeftRightLeftRightLeftRightLeftRightLeftRight = carrotEatenRightLeftRightLeftRightLeftRightLeftRightLeft\
    \ - carrotEatenLeft\n        val carrotEatenRightLeftRightLeftRightLeftRightLeftRight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9jyax53u.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9jyax53u.scala:37:49\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotEatenRightLeftRightLeftRight\e[0m = carrotEatenRightLeftRightLeft -\
    \ carrotEatenLeft\n\e[31m\e[31m   |\e[0m                                     \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                   Not found: carrotEatenRightLeftRightLeft\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9jyax53u.scala:43:67 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mcarrotEatenRightLeftRightLeftRightLeftRightLeftRight\e\
    [0m = carrotEatenRightLeftRightLeftRightLeftRightLeftRight - carrotEatenLeft\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mcarrotEatenRightLeftRightLeftRightLeftRightLeftRight\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9jyax53u.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val leftOver = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount2 = mutable.ArrayBuffer(need)\n        val leftOverCount2\
    \ = mutable.ArrayBuffer(remaining)\n        val hungryCount3 = mutable.ArrayBuffer(need)\n\
    \        val leftOverCount3 = mutable.ArrayBuffer(remaining)\n        val hungryCount4\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount4 = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount5 = mutable.ArrayBuffer(need)\n        val leftOverCount5\
    \ = mutable.ArrayBuffer(remaining)\n        val hungryCount6 = mutable.ArrayBuffer(need)\n\
    \        val leftOverCount6 = mutable.ArrayBuffer(remaining)\n        val hungryCount7\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount7 = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount8 = mutable.ArrayBuffer(need)\n        val leftOverCount8\
    \ = mutable.ArrayBuffer(remaining)\n        val hungryCount9 = mutable.ArrayBuffer(need)\n\
    \        val leftOverCount9 = mutable.ArrayBuffer(remaining)\n        val hungryCount10\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount10 = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount11 = mutable.ArrayBuffer(need)\n        val leftOverCount11\
    \ = mutable.ArrayBuffer(remaining)\n        val hungryCount12 = mutable.ArrayBuffer(need)\n\
    \        val leftOverCount12 = mutable.ArrayBuffer(remaining)\n        val hungryCount13\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount13 = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount14 = mutable.ArrayBuffer(need)\n        val leftOverCount14\
    \ = mutable.ArrayBuffer(remaining)\n        val hungryCount15 = mutable.ArrayBuffer(need)\n\
    \        val leftOverCount15 = mutable.ArrayBuffer(remaining)\n        val hungryCount16\
    \ = mutable.ArrayBuffer(need)\n        val leftOverCount16 = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCount17 = mut\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmmr4usd4.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmmr4usd4.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpmmr4usd4.scala:29:23 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mleftOver\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmmr4usd4.scala:30:21 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmmr4usd4.scala:31:26 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmmr4usd4.scala:32:28 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mleftOverCount\e[0m ="
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots += number\n      \
    \      carrots_left -= 1\n            hungry = false\n            number -= 1\n\
    \        }\n        carrots ++= carrots_left\n        carrots.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8wdrm4vw.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp8wdrm4vw.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while (carrots_left > 0) {\n  \
    \          carrots_left -= 1\n            carrots += number\n        }\n     \
    \   carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprubgp2vf.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        val hungry = mutable.ArrayBuffer(true)\n\
    \        val hungryCount = mutable.ArrayBuffer.empty[Long]\n        val hungryCount2\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount3 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount4 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount5\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount6 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount7 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount8\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount9 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount10 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount11\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount12 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount13 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount14\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount15 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount16 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount17\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount18 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount19 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount20\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount21 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount22 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount23\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount24 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount25 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount26\
    \ = mutable.ArrayBuffer.empty[Long]\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn130_e6i.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpn130_e6i.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpn130_e6i.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpn130_e6i.scala:30:21 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpn130_e6i.scala:31:21 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(\e\
    [31mtrue\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpn130_e6i.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result: List[Long] = List(meals, carrots)\n\
    \        if (meals == 0) {\n            List(meals, carrots)\n        } else {\n\
    \            val newRemaining = remaining - meals\n            val newNumber =\
    \ number + meals\n            val newNeed = need + carrots\n            val newResult\
    \ = eat(newNumber, newNeed, remaining = newRemaining)\n            result ++ newResult\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.ArrayOps$ArrayIterator.<init>(ArrayOps.scala:125)\n\
    \tat scala.collection.ArrayOps$ArrayIterator$mcJ$sp.<init>(ArrayOps.scala:123)\n\
    \tat scala.collection.immutable.ArraySeq$ofLong.iterator(ArraySeq.scala:541)\n\
    \tat scala.collection.immutable.List.prependedAll(List.scala:151)\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:29)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36)\n\
    \tat Problem$.eat(tmpx8xj4m03.scala:36)\n\tat Problem$.eat(tmpx8xj4m03.scala:36"
  stdout: ''
  timestamp: 1659804623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfombpnd.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsfombpnd.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsfombpnd.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfombpnd.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer(0)\n        val hungry = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex = mutable.ArrayBuffer(0)\n        val hungryIndex2 =\
    \ mutable.ArrayBuffer(0)\n        val hungryIndex3 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex4 = mutable.ArrayBuffer(0)\n        val hungryIndex5 =\
    \ mutable.ArrayBuffer(0)\n        val hungryIndex6 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex7 = mutable.ArrayBuffer(0)\n        val hungryIndex8 =\
    \ mutable.ArrayBuffer(0)\n        val hungryIndex9 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex10 = mutable.ArrayBuffer(0)\n        val hungryIndex11\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex12 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex13 = mutable.ArrayBuffer(0)\n        val hungryIndex14\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex15 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex16 = mutable.ArrayBuffer(0)\n        val hungryIndex17\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex18 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex19 = mutable.ArrayBuffer(0)\n        val hungryIndex20\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex21 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex22 = mutable.ArrayBuffer(0)\n        val hungryIndex23\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex24 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex25 = mutable.ArrayBuffer(0)\n        val hungryIndex26\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex27 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex28 = mutable.ArrayBuffer(0)\n        val hungryIndex29\
    \ = mutable.ArrayBuffer(0)\n        val hungryIndex30 = mutable.ArrayBuffer(0)\n\
    \        val hungryIndex31 = mutable.ArrayBuffer(0)\n        val hungry\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq168474u.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq168474u.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq168474u.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq168474u.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq168474u.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq168474u.scala:31:21\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling "
  stdout: ''
  timestamp: 1659804623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        val carrots_left\
    \ = mutable.ArrayBuffer(number)\n        val needs_left = mutable.ArrayBuffer(need)\n\
    \        val remaining_left = mutable.ArrayBuffer(remaining)\n        val carrots_left_to_eat\
    \ = mutable.ArrayBuffer(number)\n        val needs_left_to_eat = mutable.ArrayBuffer(need)\n\
    \        val remaining_left_to_eat = mutable.ArrayBuffer(remaining)\n        val\
    \ carrots_left_to_eat_remaining = mutable.ArrayBuffer(number)\n        val needs_left_to_eat_remaining\
    \ = mutable.ArrayBuffer(need)\n        val remaining_left_to_eat_remaining = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left_to_eat_needs = mutable.ArrayBuffer(number)\n       \
    \ val needs_left_to_eat_needs = mutable.ArrayBuffer(need)\n        val remaining_left_to_eat_needs\
    \ = mutable.ArrayBuffer(remaining)\n        val carrots_left_to_eat_needs_remaining\
    \ = mutable.ArrayBuffer(number)\n        val needs_left_to_eat_needs_remaining\
    \ = mutable.ArrayBuffer(need)\n        val remaining_left_to_eat_needs_remaining\
    \ = mutable.ArrayBuffer(remaining)\n        val carrots_left_to_eat_needs_needs\
    \ = mutable.ArrayBuffer(number)\n        val needs_left_to_eat_needs_needs = mutable.ArrayBuffer(need)\n\
    \        val remaining_left_to_eat_needs_needs = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left_to_eat_needs_needs_remaining = mutable.ArrayBuffer(number)\n\
    \        val needs_left_to_eat_needs_needs_remaining = mutable.ArrayBuffer(need)\n\
    \        val remaining_left_to_eat_needs_needs_remaining = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left_to_eat_needs_needs_needs = mutable.ArrayBuffer(number)\n\
    \        val needs_left_to_eat_needs_needs_needs = mutable.ArrayBuffer(need)\n\
    \        val remaining_left_to_eat_needs_needs_needs = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left_to_eat_needs_needs_needs_remaining = mutable.ArrayBuffer(number)\n\
    \        val needs_left_to_eat_needs_needs_needs_remaining = mutable.ArrayBuffer(need)\n\
    \        val remaining_left_to_e\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5i51sion.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i51sion.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i51sion.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i51sion.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i51sion.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5i51sion.scala:31:27\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m   \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation av"
  stdout: ''
  timestamp: 1659804623
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val left\
    \ = (remaining + meals).toLong\n        val result: List[Long] = if (hungry) List(left,\
    \ carrots) else List(left, 0)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1p8954od.scala:35)\n\tat Problem.main(tmp1p8954od.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfombpnd.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsfombpnd.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsfombpnd.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfombpnd.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryCount = mutable.ListBuffer[Long]()\n\
    \        val hungryCount2 = mutable.ListBuffer[Long]()\n        val hungryCount3\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount4 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount5 = mutable.ListBuffer[Long]()\n        val hungryCount6\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount7 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount8 = mutable.ListBuffer[Long]()\n        val hungryCount9\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount10 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount11 = mutable.ListBuffer[Long]()\n        val hungryCount12\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount13 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount14 = mutable.ListBuffer[Long]()\n        val hungryCount15\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount16 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount17 = mutable.ListBuffer[Long]()\n        val hungryCount18\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount19 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount20 = mutable.ListBuffer[Long]()\n        val hungryCount21\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount22 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount23 = mutable.ListBuffer[Long]()\n        val hungryCount24\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount25 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount26 = mutable.ListBuffer[Long]()\n        val hungryCount27\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount28 = mut\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcnkn2505.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:32:27 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while(i < number) {\n            carrots += i\n  \
    \          i += 1\n        }\n        val needToEat = mutable.ListBuffer[Long]()\n\
    \        while(i < need) {\n            needToEat += i\n            i += 1\n \
    \       }\n        val remaining = mutable.ListBuffer[Long]()\n        while(i\
    \ < remaining) {\n            remaining += i\n            i += 1\n        }\n\
    \        val result = mutable.ListBuffer[Long]()\n        while(i < carrots.size)\
    \ {\n            val carrotToEat = carrots(i)\n            val needToEatIndex\
    \ = needToEat.indexOf(carrotToEat)\n            if(needToEatIndex == -1) {\n \
    \               result += carrotToEat\n                i += 1\n            } else\
    \ {\n                val needToEatValue = needToEat(needToEatIndex)\n        \
    \        val remainingIndex = remaining.indexOf(carrotToEat)\n               \
    \ if(remainingIndex == -1) {\n                    result += carrotToEat\n    \
    \                i += 1\n                } else {\n                    val remainingValue\
    \ = remaining(remainingIndex)\n                    val newRemaining = remainingValue\
    \ - needToEatValue\n                    result += carrotToEat\n              \
    \      result += newRemaining\n                    i += 1\n                }\n\
    \            }\n        }\n        return result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps39c24e0.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps39c24e0.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mneedToEat\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps39c24e0.scala:38:24 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps39c24e0.scala:43:21 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        var carrotCount = 0\n        var hungryCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var carrotEaten = 0\n   \
    \     var hungryEaten = 0\n        var hungryRemainingEaten = 0\n        var carrotEatenCount\
    \ = 0\n        var hungryEatenCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var hungryRemainingEatenCount\
    \ = 0\n        var hungryRemainingCount = 0\n        var \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpwovltjgc.scala:72:11 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpwovltjgc.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mvar\e[0m \e[36mhungryRemainingCount\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCount is already defined as \e[33mvariable\e\
    [0m \e[35mhungryRemainingCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwovltjgc.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mvar\e[0m \e[36mhungryRemainingEatenCount\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingEatenCount is already defined as \e[33mvariable\e\
    [0m \e[35mhungryRemainingEatenCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwovltjgc.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mhungryRemainingCount\e[0m\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingCount is already defined as \e[33mvariable\e\
    [0m \e[35mhungryRemainingCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwovltjgc.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mvar\e[0m \e[36mhungryRemainingEatenCount\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingEatenCount is already defined as \e[33mvariable\e\
    [0m \e[35mhungryRemainingEatenCount\e[0m\n"
  stdout: ''
  timestamp: 1659804626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val meals_left = meals - carrots\n     \
    \   val carrots_left = carrots - meals\n        val carrots_left_to_eat = (carrots_left\
    \ / meals).toInt\n        val meals_left_to_eat = (meals_left / carrots).toInt\n\
    \        val carrots_left_to_eat_and_meals = carrots_left_to_eat * meals_left_to_eat\n\
    \        val meals_left_to_eat_and_carrots = meals_left_to_eat * carrots_left_to_eat\n\
    \        val carrots_left_to_eat_and_meals_and_carrots = carrots_left_to_eat_and_meals\
    \ + carrots_left_to_eat_and_carrots\n        val meals_left_to_eat_and_carrots_and_meals\
    \ = meals_left_to_eat_and_carrots + meals_left_to_eat_and_meals\n        val carrots_left_to_eat_and_meals_and_carrots_and_meals\
    \ = carrots_left_to_eat_and_meals_and_carrots + carrots_left_to_eat_and_carrots_and_meals\n\
    \        val carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots =\
    \ carrots_left_to_eat_and_meals_and_carrots_and_meals + carrots_left_to_eat_and_carrots_and_meals_and_carrots\n\
    \        val carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_meals\
    \ = carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots + carrots_left_to_eat_and_carrots_and_meals_and_carrots_and_meals\n\
    \        val carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_meals_and_carrots\
    \ = carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_meals\
    \ + carrots_left_to_eat_and_carrots_and_meals_and_carrots_and_meals_and_carrots\n\
    \        val carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_meals_and_carrots_and_meals\
    \ = carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_me\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaso5nm7.scala:35:88 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_and_meals_and_carrots\e\
    [0m = carrots_left_to_eat_and_meals + carrots_left_to_eat_and_carrots\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Not found: carrots_left_to_eat_and_carrots\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaso5nm7.scala:36:86\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals_left_to_eat_and_carrots_and_meals\e[0m = meals_left_to_eat_and_carrots\
    \ + meals_left_to_eat_and_meals\n\e[31m\e[31m   |\e[0m                       \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: meals_left_to_eat_and_meals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgaso5nm7.scala:41:110\
    \ -----------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_meals_and_carrots_and_meals\e\
    [0m = carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_me\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: carrots_left_to_eat_and_meals_and_carrots_and_meals_and_carrots_and_me\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgaso5nm7.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659804626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrotsRemaining\
    \ = hungryCarrots - hungryMeals\n        val hungryMealsRemaining = hungryMeals\
    \ - hungryCarrots\n        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n\
    \        val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val\
    \ hungryCarrotsRemainingList2 = List(hungryCarrotsRemainingList)\n        val\
    \ hungryMealsRemainingList2 = List(hungryMealsRemainingList)\n        val hungryCarrotsRemainingList3\
    \ = List(hungryCarrotsRemainingList2)\n        val hungryMealsRemainingList3 =\
    \ List(hungryMealsRemainingList2)\n        val hungryCarrotsRemainingList4 = List(hungryCarrotsRemainingList3)\n\
    \        val hungryMealsRemainingList4 = List(hungryMealsRemainingList3)\n   \
    \     val hungryCarrotsRemainingList5 = List(hungryCarrotsRemainingList4)\n  \
    \      val hungryMealsRemainingList5 = List(hungryMealsRemainingList4)\n     \
    \   val hungryCarrotsRemainingList6 = List(hungryCarrotsRemainingList5)\n    \
    \    val hungryMealsRemainingList6 = List(hungryMealsRemainingList5)\n       \
    \ val hungryCarrotsRemainingList7 = List(hungryCarrotsRemainingList6)\n      \
    \  val hungryMealsRemainingList7 = List(hungryMealsRemainingList6)\n        val\
    \ hungryCarrotsRemainingList8 = List(hungryCarrotsRemainingList7)\n        val\
    \ hungryMealsRemainingList8 = List(hungryMealsRemainingList7)\n        val hungr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy6u4svqd.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpy6u4svqd.scala:30:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryCarrots\e[0m = carrots - hungry\n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpy6u4svqd.scala:31:32 -----------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = meals - hungry\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy6u4svqd.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals == 0) {\n            List(number - carrots)\n        } else {\n\
    \            List(number - carrots, carrots)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp48ot6pux.scala:37)\n\tat Problem.main(tmp48ot6pux.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        if (meals > 0) {\n            val carrotsLeft = meals - carrots\n   \
    \         val carrotsLeftAfterMeals = carrots - carrotsLeft\n            val carrotsLeftAfterMealsRemaining\
    \ = carrotsLeft - carrotsLeftAfterMeals\n            val carrotsLeftAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMeals - carrotsLeftAfterMealsRemaining\n            val carrotsLeftAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals =\
    \ carrotsLeftAfterMealsRemainingAfterMeals - carrotsLeftAfterMealsRemainingAfterMealsRemaining\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdp8w6xs2.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdp8w6xs2.scala:53:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpdp8w6xs2.scala:29:25 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdp8w6xs2.scala:38:168 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\e\
    [0m = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpdp8w6xs2.scala:39:106 --------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\e\
    [0m = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \e[31m\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659804628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(carrots, meals)\n    \
    \    if (meals > 0) {\n            val carrotsToEat = math.min(meals, remaining)\n\
    \            val remainingCarrots = remaining - carrotsToEat\n            val\
    \ newRemaining = remainingCarrots + carrotsToEat\n            val newNumber =\
    \ number + carrotsToEat\n            val newNeed = need + carrotsToEat\n     \
    \       val newMeals = newNeed - carrotsToEat\n            val newResult = eat(newNumber,\
    \ newNeed, newRemaining)\n            result ::: newResult\n        } else {\n\
    \            result\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.ArrayOps$ArrayIterator.<init>(ArrayOps.scala:125)\n\
    \tat scala.collection.ArrayOps$ArrayIterator$mcJ$sp.<init>(ArrayOps.scala:123)\n\
    \tat scala.collection.immutable.ArraySeq$ofLong.iterator(ArraySeq.scala:541)\n\
    \tat scala.collection.immutable.List.prependedAll(List.scala:151)\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:29)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\
    \tat Problem$.eat(tmp7sbkjsfq.scala:37)\n\tat Problem$.eat(tmp7sbkjsfq.scala:37"
  stdout: ''
  timestamp: 1659804629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals == 0) {\n            List(meals, carrots)\n        } else {\n \
    \           val newRemaining = remaining - meals\n            val newNumber =\
    \ number + meals\n            val newNeed = need + carrots\n            val newResult\
    \ = eat(newNumber, newNeed, renewRemaining(newRemaining))\n            result\
    \ ::: newResult\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzwjj9llr.scala:36:52 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = eat(newNumber,\
    \ newNeed, renewRemaining(newRemaining))\n\e[31m\e[31m   |\e[0m              \
    \                                      ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                             Not found: renewRemaining\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result: List[Long] = new ArrayList[Long]()\n\
    \        if (meals > 0) {\n            val carrotsLeft = meals - carrots\n   \
    \         val carrotsLeftAfterMeals = carrots - carrotsLeft\n            val carrotsLeftAfterMealsRemaining\
    \ = carrotsLeft - carrotsLeftAfterMeals\n            val carrotsLeftAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMeals - carrotsLeftAfterMealsRemaining\n            val carrotsLeftAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals =\
    \ carrotsLeftAfterMealsRemainingAfterMeals - carrotsLeftAfterMealsRemainingAfterMealsRemaining\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \            val car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyxaf5l7g.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyxaf5l7g.scala:53:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpyxaf5l7g.scala:29:37 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e\
    [0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                    Not found: type ArrayList\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyxaf5l7g.scala:38:168 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\e\
    [0m = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMeals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpyxaf5l7g.scala:39:106 --------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\e\
    [0m = carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemainingAfterMealsRemaining\
    \ - carrotsLeftAfterMealsRemainingAfterMealsRemainingAfterMealsRemaini"
  stdout: ''
  timestamp: 1659804628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= need\n            carrots += need\n        }\n  \
    \      carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp48i8izdj.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            carrots_left -= 1\n     \
    \       number -= 1\n        }\n        carrots.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaesg215z.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpaesg215z.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804628
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val leftCarrots = remaining - carrots\n\
    \        val result: List[Long] = List(meals, leftCarrots)\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2aim9g23.scala:34)\n\tat Problem.main(tmp2aim9g23.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsRemaining = remaining - meals\n\
    \        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n       \
    \ val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopyCopy\
    \ = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy =\
    \ mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopyCopy\
    \ = mealsRemainingArrayCopyCopy.clone()\n        val mealsRemainingArrayCopyCopy\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpehgqzcip.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpehgqzcip.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayCopyCopy\e[0m = mealsRemainingArrayCopy.clone()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpehgqzcip.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopyCopy\e\
    [0m = mealsRemainingArrayCopyCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpehgqzcip.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayCopyCopyCopy\e[0m = mealsRemainingArrayCopyCopy.clone()\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpehgqzcip.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayCopyCopyCopy\e[0m = mealsRemainingArrayCopyCopy.clone("
  stdout: ''
  timestamp: 1659804629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val hungryRemaining = mutable.ArrayBuffer(need)\n        val hungryRemaining2\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining3 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining4 = mutable.ArrayBuffer(need)\n        val hungryRemaining5\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining6 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining7 = mutable.ArrayBuffer(need)\n        val hungryRemaining8\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining9 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining10 = mutable.ArrayBuffer(need)\n        val hungryRemaining11\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining12 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining13 = mutable.ArrayBuffer(need)\n        val hungryRemaining14\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining15 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining16 = mutable.ArrayBuffer(need)\n        val hungryRemaining17\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining18 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining19 = mutable.ArrayBuffer(need)\n        val hungryRemaining20\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining21 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining22 = mutable.ArrayBuffer(need)\n        val hungryRemaining23\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining24 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining25 = mutable.ArrayBuffer(need)\n        val hungryRemaining26\
    \ = mutable.ArrayBuffer(need)\n        val hungryRemaining27 = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining28 = mutable.ArrayBuffer(need)\n        val hungryRemaining29\
    \ = mutable.ArrayBuffer(\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmposc3oxn2.scala:58:52 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining29\e[0m =\
    \ mutable.ArrayBuffer(\n\e[31m\e[31m   |\e[0m                                \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmposc3oxn2.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmposc3oxn2.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmposc3oxn2.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmposc3oxn2.scala:30:30 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmposc3oxn2.scala:31:31 ------------------"
  stdout: ''
  timestamp: 1659804629
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = math.min(need, math.max(0, remaining - carrots))\n        val result\
    \ = List(meals, carrots)\n        if (meals == 0) List(meals, carrots)\n     \
    \   else result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5wmb_i87.scala:34)\n\tat Problem.main(tmp5wmb_i87.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedNeedRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n  \
    \      val hungryNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n    \
    \    val hungryNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n  \
    \      val hungryNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining =\
    \ mutable.ListBuffer[Long]()\n        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedNeedNeedNeedNeedNeedNeedNeedNeedNeedNeed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr4wqc5j4.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr4wqc5j4.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryNeedNeedNeedNeedRemaining\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedNeedNeedNeedRemaining is already defined as \e[33mvalue\e\
    [0m \e[35mhungryNeedNeedNeedNeedRemaining\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr4wqc5j4.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryNeedNeedNeedNeedNeedRemaining\e[0m = mutable.ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedNeedNeedNeedNeedRemaining is already defined as\
    \ \e[33mvalue\e[0m \e[35mhungryNeedNeedNeedNeedNeedRemaining\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr4wqc5j4.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining is already\
    \ defined as \e[33mvalue\e[0m \e[35mhungryNeedNeedNeedNeedNeedNeedNeedNeedRemaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr4wqc5j4.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m "
  stdout: ''
  timestamp: 1659804629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryCount = mutable.ListBuffer[Long]()\n\
    \        var carrotCount = 0\n        var hungryCount = 0\n        var hungryCountIndex\
    \ = 0\n        var needCount = 0\n        var needCountIndex = 0\n        var\
    \ remainingCount = 0\n        var remainingCountIndex = 0\n        var needCountIndex\
    \ = 0\n        var hungryCountIndex = 0\n        var needCountIndex = 0\n    \
    \    var remainingCountIndex = 0\n        var needCountIndex = 0\n        var\
    \ hungryCountIndex = 0\n        var needCountIndex = 0\n        var remainingCountIndex\
    \ = 0\n        var needCountIndex = 0\n        var hungryCountIndex = 0\n    \
    \    var needCountIndex = 0\n        var remainingCountIndex = 0\n        var\
    \ needCountIndex = 0\n        var hungryCountIndex = 0\n        var needCountIndex\
    \ = 0\n        var remainingCountIndex = 0\n        var needCountIndex = 0\n \
    \       var hungryCountIndex = 0\n        var needCountIndex = 0\n        var\
    \ remainingCountIndex = 0\n        var needCountIndex = 0\n        var hungryCountIndex\
    \ = 0\n        var needCountIndex = 0\n        var remainingCountIndex = 0\n \
    \       var needCountIndex = 0\n        var hungryCountIndex = 0\n        var\
    \ needCountIndex = 0\n        var remainingCountIndex = 0\n        var needCountIndex\
    \ = 0\n        var hungryCountIndex = 0\n        var needCountIndex = 0\n    \
    \    var remainingCountIndex = 0\n        var needCountIndex = 0\n        var\
    \ hungryCountIndex = 0\n        var needCountIndex = 0\n        var remainingCountIndex\
    \ = 0\n        var needCountIndex = 0\n        var hungryCountIndex = 0\n    \
    \    var needCountIndex = 0\n        var remainingCountIndex = 0\n        var\
    \ needCountIndex = 0\n        var hungryCountIndex = 0\n        var needCountIndex\
    \ = 0\n        var remainingCountIndex = 0\n        var needCountIndex = 0\n \
    \       var hungryCountIndex = 0\n        var needCountIndex = 0\n        var\
    \ remainingCountIndex = 0\n        var needCountIndex = 0\n        var hungryCountIndex\
    \ = 0\n        var needCountIndex = 0\n        var remainingCountIndex = 0\n \
    \       var needCountIndex = 0\n        var hungryCountIndex = 0\n        var\
    \ needCountIndex = 0\n        var remainingCountIndex = 0\n        var needCountIndex\
    \ = 0\n        var hungryCountIndex = 0\n        var needCountIndex = 0\n    \
    \    var remainingCountIndex = 0\n        var needCountIndex = 0\n        var\
    \ hungryCountIndex = 0\n        var need\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptw0e7ma2.scala:100:4 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptw0e7ma2.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mhungryCount\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCount is already defined as \e[33mvalue\e[0m \e[35mhungryCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptw0e7ma2.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mvar\e[0m \e[36mneedCountIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneedCountIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mneedCountIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptw0e7ma2.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mvar\e[0m \e[36mhungryCountIndex\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCountIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mhungryCountIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptw0e7ma2.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mvar\e[0m \e[36mneedCountIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneedCountIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mneedCountIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmptw0e7ma2.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mvar\e"
  stdout: ''
  timestamp: 1659804628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots += carrots_left\n            carrots_left -= need\n     \
    \   }\n        carrots ++ carrots.takeWhile(_ < carrots_left)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7bqgzv2f.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsRight = meals + carrots\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsRight = mealsRight.toString.toInt\n        val mealsRight =\
    \ mealsRight.max\n        val mealsRight = mealsRight.min\n        val mealsRight\
    \ = mealsRight.toString.toInt\n        val mealsRight = mealsRight.max\n     \
    \   val mealsRight = mealsRight.min\n        val mealsRight = mealsRight.toString.toInt\n\
    \        val mealsRight = mealsRight.max\n        val mealsRight = mealsRight.min\n\
    \        val mealsRight = mealsRight.toString.toInt\n        val mealsRight =\
    \ mealsRight.max\n        val mealsRight = mealsRight.min\n        val mealsRight\
    \ = mealsRight.toString.toInt\n        val mealsRight = mealsRight.max\n     \
    \   val mealsRight = mealsRight.min\n        val mealsRight = mealsRight.toString.toInt\n\
    \        val mealsRight = mealsRight.max\n        val mealsRight = mealsRight.min\n\
    \        val mealsRight = mealsRight.toString.toInt\n        val mealsRight =\
    \ mealsRight.max\n        val mealsRight = mealsRight.min\n        val mealsRight\
    \ = mealsRight.toString.toInt\n        val mealsRight = mealsRight.max\n     \
    \   val mealsRight = mealsRight.min\n        val mealsRight = mealsRight.toString.toInt\n\
    \        val mealsRight = mealsRight.max\n        val mealsRight = mealsRight.min\n\
    \        val mealsRight = mealsRight.toString.toInt\n        val mealsRight =\
    \ mealsRight.max\n        val mealsRight = mealsRight.min\n        val mealsRight\
    \ = mealsRight.toString.toInt\n        val mealsRight = mealsRight.max\n     \
    \   val mealsRight = mealsRight.min\n        val mealsRight = mealsRight.toString.toInt\n\
    \        val mealsRight = mealsRight.max\n        val mealsRight = mealsRight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxt1u47_i.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxt1u47_i.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight.toString.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmealsRight is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxt1u47_i.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight.max\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsRight is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxt1u47_i.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight.min\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsRight\
    \ is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxt1u47_i.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRight\e[0m = mealsRight.toString.toInt\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsRight\
    \ is alrea"
  stdout: ''
  timestamp: 1659804630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(0, mealsLeft)\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val mealsLeftListArrayLength\
    \ = mealsLeftListArray.length\n        val mealsLeftListArray = mealsLeftList.toArray\n\
    \        val mealsLeftListArrayLength = mealsLeftListArray.length\n        val\
    \ mealsLeftListArray = mealsLeftList.toArray\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9i4edf95.scala:62:11 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9i4edf95.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftListArray\e[0m\
    \ = mealsLeftList.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftListArray is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftListArray\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4edf95.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftListArrayLength\e\
    [0m = mealsLeftListArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftListArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mmealsLeftListArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9i4edf95.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftListArray\e[0m\
    \ = mealsLeftList.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftListArray is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftListArray\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9i4edf95.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftListArrayLength\e\
    [0m = mealsLeftListArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m"
  stdout: ''
  timestamp: 1659804634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var total = 0L\n        var left = 0L\n        while(number > 0 && left\
    \ < remaining) {\n            total += number\n            number -= 1\n     \
    \       left += 1\n            carrots += number\n        }\n        if(left <\
    \ remaining) {\n            carrots += remaining\n        }\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6nwqa6e5.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6nwqa6e5.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804635
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0_whltxe.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_whltxe.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_whltxe.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_whltxe.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0_whltxe.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m]("
  stdout: ''
  timestamp: 1659804636
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryCarrots = number - remaining\n \
    \       val eatenCarrots = math.min(need, remaining)\n        val remainingCarrots\
    \ = math.max(need, eatenCarrots)\n        val hungryCarrotsList: List[Long] =\
    \ List(hungryCarrots)\n        val eatenCarrotsList: List[Long] = List(eatenCarrots)\n\
    \        val remainingCarrotsList: List[Long] = List(remainingCarrots)\n     \
    \   val hungryCarrotsListWithRemainingCarrots: List[Long] = hungryCarrotsList\
    \ ++ remainingCarrotsList\n        val hungryCarrotsListWithRemainingCarrotsList:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrots.toList\n        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrots:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsList ++ remainingCarrotsList\n\
    \        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsList:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsList.toList\n        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrots:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrots.toList\n\
    \        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrotsList:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrots.toList\n\
    \        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrots:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsList.toList\n\
    \        val hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrotsListWithRemainingCarrotsList:\
    \ List[Long] = hungryCarrotsListWithRemainingCarrotsListWithRemainingCarrotsList.toList\n\
    \        val hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd29t06lx.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpd29t06lx.scala:42:5 ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            carrots_left -= 1\n     \
    \       number -= 1\n        }\n        carrots.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaesg215z.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpaesg215z.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= need\n            carrots += need\n        }\n  \
    \      carrots ++ carrots.takeWhile(_ < remaining)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8l3oj3xm.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= need\n            carrots += need\n        }\n  \
    \      carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp48i8izdj.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftArray = Array.ofDim[Long](mealsLeft)\n        val mealsLeftArrayCopy\
    \ = mealsLeftArray.clone()\n        val mealsLeftArrayCopy2 = mealsLeftArrayCopy.clone()\n\
    \        val mealsLeftArrayCopy3 = mealsLeftArrayCopy2.clone()\n        val mealsLeftArrayCopy4\
    \ = mealsLeftArrayCopy3.clone()\n        val mealsLeftArrayCopy5 = mealsLeftArrayCopy4.clone()\n\
    \        val mealsLeftArrayCopy6 = mealsLeftArrayCopy5.clone()\n        val mealsLeftArrayCopy7\
    \ = mealsLeftArrayCopy6.clone()\n        val mealsLeftArrayCopy8 = mealsLeftArrayCopy7.clone()\n\
    \        val mealsLeftArrayCopy9 = mealsLeftArrayCopy8.clone()\n        val mealsLeftArrayCopy10\
    \ = mealsLeftArrayCopy9.clone()\n        val mealsLeftArrayCopy11 = mealsLeftArrayCopy10.clone()\n\
    \        val mealsLeftArrayCopy12 = mealsLeftArrayCopy11.clone()\n        val\
    \ mealsLeftArrayCopy13 = mealsLeftArrayCopy12.clone()\n        val mealsLeftArrayCopy14\
    \ = mealsLeftArrayCopy13.clone()\n        val mealsLeftArrayCopy15 = mealsLeftArrayCopy14.clone()\n\
    \        val mealsLeftArrayCopy16 = mealsLeftArrayCopy15.clone()\n        val\
    \ mealsLeftArrayCopy17 = mealsLeftArrayCopy16.clone()\n        val mealsLeftArrayCopy18\
    \ = mealsLeftArrayCopy17.clone()\n        val mealsLeftArrayCopy19 = mealsLeftArrayCopy18.clone()\n\
    \        val mealsLeftArrayCopy20 = mealsLeftArrayCopy19.clone()\n        val\
    \ mealsLeftArrayCopy21 = mealsLeftArrayCopy20.clone()\n        val mealsLeftArrayCopy22\
    \ = mealsLeftArrayCopy21.clone()\n        val mealsLeftArrayCopy23 = mealsLeftArrayCopy22.clone()\n\
    \        val mealsLeftArrayCopy24 = mealsLeftArrayCopy23.clone()\n        val\
    \ mealsLeftArrayCopy25 = mealsLeftArrayCopy24.clone()\n        val mealsLeftArrayCopy26\
    \ = mealsLeftArrayCopy25.clone()\n        val mealsLeftArrayCopy27 = mealsLeftArrayCopy26.clone()\n\
    \        val mealsLeftArrayCopy28 = mealsLeftArrayCopy27.clone()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6wvfd5dq.scala:30:47\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftArray\e\
    [0m = Array.ofDim[\e[35mLong\e[0m](mealsLeft)\n\e[31m\e[31m   |\e[0m         \
    \                                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                     Found:    (mealsLeft : Long)\n\e[31m   |\e\
    [0m                                            Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6wvfd5dq.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804636
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(carrots, meals)\n    \
    \    if (meals > 0) {\n            val newRemaining = remaining + meals\n    \
    \        val newNumber = number - newRemaining\n            val newNeed = need\
    \ - newRemaining\n            val newResult = eat(newNumber, newNeed, newRemaining)\n\
    \            result ::: newResult\n        } else {\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9geqnc57.scala:41)\n\tat Problem.main(tmp9geqnc57.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryRabbit = number - remaining\n  \
    \      val hungryRabbits = hungryRabbit / need\n        val carrots = hungryRabbit\
    \ % need\n        val hungryRabbits = hungryRabbits + carrots\n        val hungryRabbits\
    \ = hungryRabbits :: Nil\n        hungryRabbits\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpribp306o.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits\
    \ + carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpribp306o.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits ::\
    \ Nil\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpribp306o.scala:32:8 ---------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m        hungryRabbits\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (hungryRabbits : Long)\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungry = mutable.ListBuffer.empty[Long]\n        val hungryRemaining\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeeds = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer.empty[Long]\n        val\
    \ hungryNeedsRemaining2 = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining3\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining4 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining5 = mutable.ListBuffer.empty[Long]\n        val\
    \ hungryNeedsRemaining6 = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining7\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining8 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining9 = mutable.ListBuffer.empty[Long]\n        val\
    \ hungryNeedsRemaining10 = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining11\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining12 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining13 = mutable.ListBuffer.empty[Long]\n       \
    \ val hungryNeedsRemaining14 = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining15\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining16 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining17 = mutable.ListBuffer.empty[Long]\n       \
    \ val hungryNeedsRemaining18 = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining19\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryNeedsRemaining20 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryNeedsRemaining21 = mutable.ListBuffer.empty[Long]\n       \
    \ val hungryNeedsRemaining22 = mutable.ListBuffer.empty[Long]\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpujx9c1tu.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpujx9c1tu.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpujx9c1tu.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpujx9c1tu.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpujx9c1tu.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m         \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpu"
  stdout: ''
  timestamp: 1659804637
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungry = number - remaining\n        val\
    \ rest = remaining - need\n        val hungryList = List(hungry, rest)\n     \
    \   val hungryList2 = List(hungry, rest)\n        val hungryList3 = List(hungry,\
    \ rest)\n        val hungryList4 = List(hungry, rest)\n        val hungryList5\
    \ = List(hungry, rest)\n        val hungryList6 = List(hungry, rest)\n       \
    \ val hungryList7 = List(hungry, rest)\n        val hungryList8 = List(hungry,\
    \ rest)\n        val hungryList9 = List(hungry, rest)\n        val hungryList10\
    \ = List(hungry, rest)\n        val hungryList11 = List(hungry, rest)\n      \
    \  val hungryList12 = List(hungry, rest)\n        val hungryList13 = List(hungry,\
    \ rest)\n        val hungryList14 = List(hungry, rest)\n        val hungryList15\
    \ = List(hungry, rest)\n        val hungryList16 = List(hungry, rest)\n      \
    \  val hungryList17 = List(hungry, rest)\n        val hungryList18 = List(hungry,\
    \ rest)\n        val hungryList19 = List(hungry, rest)\n        val hungryList20\
    \ = List(hungry, rest)\n        val hungryList21 = List(hungry, rest)\n      \
    \  val hungryList22 = List(hungry, rest)\n        val hungryList23 = List(hungry,\
    \ rest)\n        val hungryList24 = List(hungry, rest)\n        val hungryList25\
    \ = List(hungry, rest)\n        val hungryList26 = List(hungry, rest)\n      \
    \  val hungryList27 = List(hungry, rest)\n        val hungryList28 = List(hungry,\
    \ rest)\n        val hungryList29 = List(hungry, rest)\n        val hungryList30\
    \ = List(hungry, \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaj_07cud.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpaj_07cud.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofdzh838.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:34:12\
    \ ------"
  stdout: ''
  timestamp: 1659804615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftInStock = remaining - meals\n        val mealsLeftInStockInStock\
    \ = mealsLeft - mealsLeftInStock\n        val mealsLeftInStockInStockInStock =\
    \ mealsLeftInStockInStock - mealsLeftInStockInStock\n        val mealsLeftInStockInStockInStockInStock\
    \ = mealsLeftInStockInStockInStockInStock - mealsLeftInStockInStockInStockInStock\n\
    \        val mealsLeftInStockInStockInStockInStockInStock = mealsLeftInStockInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStockInStock\n        val mealsLeftInStockInStockInStockInStockInStockInStock\
    \ = mealsLeftInStockInStockInStockInStockInStockInStock - mealsLeftInStockInStockInStockInStockInStockInStock\n\
    \        val mealsLeftInStockInStockInStockInStockInStockInStockInStock = mealsLeftInStockInStockInStockInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStockInStockInStockInStock\n        val mealsLeftInStockInStockInStockInStockInStockInStockInStockInStock\
    \ = mealsLeftInStockInStockInStockInStockInStockInStockInStockInStock - mealsLeftInStockInStockInStockInStockInStockInStockInStockInStock\n\
    \        val mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStock\
    \ = mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStock -\
    \ mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStock\n \
    \       val mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStockInStock\
    \ = mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStockInStockInStock\n\
    \        val mealsLeftInStockInStockInStockInStockInStockInStockInStockInStockInStock\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp23v86yqg.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp23v86yqg.scala:33:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftInStockInStockInStockInStock\e[0m = mealsLeftInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStock\n\e[31m\e[31m   |\e[0m             \
    \                                       ^\e[0m\n\e[31m   |\e[0m        Recursive\
    \ \e[33mvalue\e[0m \e[35mmealsLeftInStockInStockInStockInStock\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp23v86yqg.scala:34:59\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftInStockInStockInStockInStockInStock\e[0m = mealsLeftInStockInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStockInStock\n\e[31m\e[31m   |\e[0m      \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \ Recursive \e[33mvalue\e[0m \e[35mmealsLeftInStockInStockInStockInStockInStock\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp23v86yqg.scala:35:66\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftInStockInStockInStockInStockInStockInStock\e[0m = mealsLeftInStockInStockInStockInStockInStockInStock\
    \ - mealsLeftInStockInStockInStockInStockInStockInStock\n\e[31m\e[31m   |\e[0m\
    \                                                                  ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmealsLeftInStockInStockInStockInStockInStockInStock\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp23v86yqg.scala:36:73\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftInStockInStockInStockInStockInStockI"
  stdout: ''
  timestamp: 1659804638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsList = List(meals)\n        val\
    \ carrotsList = List(carrots)\n        val carrotsList2 = List(carrots)\n    \
    \    val carrotsList3 = List(carrots)\n        val carrotsList4 = List(carrots)\n\
    \        val carrotsList5 = List(carrots)\n        val carrotsList6 = List(carrots)\n\
    \        val carrotsList7 = List(carrots)\n        val carrotsList8 = List(carrots)\n\
    \        val carrotsList9 = List(carrots)\n        val carrotsList10 = List(carrots)\n\
    \        val carrotsList11 = List(carrots)\n        val carrotsList12 = List(carrots)\n\
    \        val carrotsList13 = List(carrots)\n        val carrotsList14 = List(carrots)\n\
    \        val carrotsList15 = List(carrots)\n        val carrotsList16 = List(carrots)\n\
    \        val carrotsList17 = List(carrots)\n        val carrotsList18 = List(carrots)\n\
    \        val carrotsList19 = List(carrots)\n        val carrotsList20 = List(carrots)\n\
    \        val carrotsList21 = List(carrots)\n        val carrotsList22 = List(carrots)\n\
    \        val carrotsList23 = List(carrots)\n        val carrotsList24 = List(carrots)\n\
    \        val carrotsList25 = List(carrots)\n        val carrotsList26 = List(carrots)\n\
    \        val carrotsList27 = List(carrots)\n        val carrotsList28 = List(carrots)\n\
    \        val carrotsList29 = List(carrots)\n        val carrotsList30 = List(carrots)\n\
    \        val carrotsList31 = List(carrots)\n        val carrotsList32 = List(carrots)\n\
    \        val carrotsList33 = List(carrots)\n        val carrotsList34 = List(carrots)\n\
    \        val carrotsList35 = List(carrots)\n        val carro\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp03tmpz01.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp03tmpz01.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots_left -= 1\n      \
    \      number -= 1\n            carrots += number\n            hungry = number\
    \ <= need\n        }\n        carrots.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnspny2lm.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnspny2lm.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val carrots_left = need - carrots\n        val carrots_left_after_meals = carrots_left\
    \ - carrots // carrots_left - carrots_after_meals\n        val carrots_after_meals\
    \ = carrots - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_after_meals\n        val carrots_after_meals_after_meals\
    \ = carrots_after_meals - carrots_left_after_meals_after_meals\n        val carrots_after_meals_after_meals_after_meals\
    \ = carrots_after_meals_after_meals - carrots_after_meals_after_meals\n      \
    \  val carrots_after_meals_after_meals_after_meals_after_meals = carrots_after_meals_after_meals_after_meals\
    \ - carrots_after_meals_after_meals_after_meals\n        val carrots_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_after_meals_after_meals_after_meals_after_meals - carrots_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_after_meals_after_meals_after_meals_after_meals_after_meals - carrots_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_after_meals_after_meals_after_meals_after_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeuoybloo.scala:37:106 --------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                  ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpeuoybloo.scala:38:130 -----------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_after_meals_after_meals_after_meals_after_\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           Not found: carrots_after_meals_after_meals_after_meals_after_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeuoybloo.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryCarrots = number - remaining\n \
    \       val hungryCarrotsToEat = need - remaining\n        val hungryCarrotsToEatInStock\
    \ = math.min(hungryCarrots, hungryCarrotsToEat)\n        val hungryCarrotsToEatInStockList\
    \ = List(hungryCarrotsToEatInStock)\n        val hungryCarrotsToEatInStockListWithRemaining\
    \ = hungryCarrotsToEatInStockList ++ List(remaining)\n        val hungryCarrotsToEatInStockListWithRemainingWithRemaining\
    \ = hungryCarrotsToEatInStockListWithRemaining ++ List(remaining)\n        val\
    \ hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemaining = hungryCarrotsToEatInStockListWithRemainingWithRemaining\
    \ ++ List(remaining)\n        val hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemaining ++ List(remaining)\n\
    \        val hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemaining\
    \ ++ List(remaining)\n        val hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ ++ List(remaining)\n        val hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ ++ List(remaining)\n        val hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemain\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0vw275o3.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0vw275o3.scala:37:135\
    \ --------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\e\
    [0m = hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ ++ List(remaining)\n\e[31m\e[31m   |\e[0m                                  \
    \                                                                            \
    \                         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35m\n\e[31m   |\e[0m  hungryCarrotsToEatInStockListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0vw275o3.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804640
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryRabbit = number - remaining\n  \
    \      val hungryRabbits = hungryRabbit / need\n        val hungryRabbitsLeft\
    \ = hungryRabbit % need\n        val eatenCarrots = hungryRabbits.toLong\n   \
    \     val leftCarrots = hungryRabbitsLeft\n        val result = List(hungryRabbits,\
    \ hungryRabbitsLeft)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdtzth6s3.scala:36)\n\tat Problem.main(tmpdtzth6s3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots_left -= 1\n            carrots\
    \ += number\n            hungry = carrots_left > need\n        }\n        if (hungry)\
    \ {\n            carrots += remaining\n        }\n        carrots.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwgn86f4d.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val leftCarrots\
    \ = carrots - meals\n        val leftMeals = meals - hungry\n        val hungryMeals\
    \ = hungry && leftMeals > 0\n        val leftHungry = hungry && leftCarrots >\
    \ 0\n        val hungryLeftMeals = hungryMeals && leftHungry\n        val hungryLeftCarrots\
    \ = hungryLeftMeals && leftCarrots\n        val hungryLeftCarrots = hungryLeftCarrots.map(x\
    \ => if (x == 0) 0 else 1)\n        val hungryLeftCarrots = hungryLeftCarrots.toArray\n\
    \        val hungryLeftCarrots = hungryLeftCarrots.map(x => if (x == 0) 0 else\
    \ 1)\n        val hungryLeftCarrots = hungryLeftCarrots.toArray\n        val hungryLeftCarrots\
    \ = hungryLeftCarrots.map(x => if (x == 0) 0 else 1)\n        val hungryLeftCarrots\
    \ = hungryLeftCarrots.toArray\n        val hungryLeftCarrots = hungryLeftCarrots.map(x\
    \ => if (x == 0) 0 else 1)\n        val hungryLeftCarrots = hungryLeftCarrots.toArray\n\
    \        val hungryLeftCarrots = hungryLeftCarrots.map(x => if (x == 0) 0 else\
    \ 1)\n        val hungryLeftCarrots = hungryLeftCarrots.toArray\n        val hungryLeftCarrots\
    \ = hungryLeftCarrots.map(x => if (x == 0) 0 else 1)\n        val hungryLeftCarrots\
    \ = hungryLeftCarrots.toArray\n        val hungryLeftCarrots = hungryLeftCarrots.map(x\
    \ => if (x == 0) 0 else 1)\n        val hungryLeftCarrots = hungryLeftCarrots.toArray\n\
    \        val hungryLeftCarrots = hungryLeftCarrots.map(x => if (x == 0) 0 else\
    \ 1)\n        val hungryLeftCar\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjajxjkm_.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjajxjkm_.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryLeftCarrots\e[0m = hungryLeftCarrots.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (x == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjajxjkm_.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m =\
    \ hungryLeftCarrots.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjajxjkm_.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m =\
    \ hungryLeftCarrots.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m0\e[0m) \e[31m0\e\
    [0m \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjajxjkm_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftCarrots\e[0m =\
    \ hungryLeftCarrots.toArray\n\e[31m\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659804641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val hungry = math.min(need, carrots)\n        val eaten = math.min(need, carrots)\n\
    \        val left = (carrots - eaten)\n        val result = List(hungry, left)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnrbbuat8.scala:35)\n\tat Problem.main(tmpnrbbuat8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(mealsLeft)\n        val carrotsList = List(carrots)\n\
    \        val mealsLeftList2 = List(mealsLeft)\n        val carrotsList2 = List(carrots)\n\
    \        val mealsLeftList3 = List(mealsLeft)\n        val carrotsList3 = List(carrots)\n\
    \        val mealsLeftList4 = List(mealsLeft)\n        val carrotsList4 = List(carrots)\n\
    \        val mealsLeftList5 = List(mealsLeft)\n        val carrotsList5 = List(carrots)\n\
    \        val mealsLeftList6 = List(mealsLeft)\n        val carrotsList6 = List(carrots)\n\
    \        val mealsLeftList7 = List(mealsLeft)\n        val carrotsList7 = List(carrots)\n\
    \        val mealsLeftList8 = List(mealsLeft)\n        val carrotsList8 = List(carrots)\n\
    \        val mealsLeftList9 = List(mealsLeft)\n        val carrotsList9 = List(carrots)\n\
    \        val mealsLeftList10 = List(mealsLeft)\n        val carrotsList10 = List(carrots)\n\
    \        val mealsLeftList11 = List(mealsLeft)\n        val carrotsList11 = List(carrots)\n\
    \        val mealsLeftList12 = List(mealsLeft)\n        val carrotsList12 = List(carrots)\n\
    \        val mealsLeftList13 = List(mealsLeft)\n        val carrotsList13 = List(carrots)\n\
    \        val mealsLeftList14 = List(mealsLeft)\n        val carrotsList14 = List(carrots)\n\
    \        val mealsLeftList15 = List(mealsLeft)\n        val carrotsList15 = List(carrots)\n\
    \        val mealsLeftList16 = List(mealsLeft)\n        val carrotsList16 = List(carrots)\n\
    \        val mealsLeftList17 = List(mealsLeft)\n        val carrotsList17 = List(carrots)\n\
    \        val mealsLeftList18 = List(mealsLeft)\n        val carrotsList18 = List(carrots)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpha7az0gm.scala:66:11 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpha7az0gm.scala:67:5 ---------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804640
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (carrots > 0) result :+ remaining\n        else result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4rram_tx.scala:34)\n\tat Problem.main(tmp4rram_tx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804641
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val hungry = carrots % need\n        val leftover = carrots - hungry\n     \
    \   val result = List(hungry, leftover)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj_gmsoe8.scala:34)\n\tat Problem.main(tmpj_gmsoe8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdw_w0x9y.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e\
    [33mif\e[0m (hungry) carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCarrots\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdw_w0x9y.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry) meals \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdw_w0x9y.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e[33mif\e[0m (hungry)\
    \ carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdw_w0x9y.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry)\
    \ meals \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdw_w0x9y.scala:36:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1659804641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while (carrots_left > 0) {\n  \
    \          carrots_left -= 1\n            carrots += number\n        }\n     \
    \   carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprubgp2vf.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots_left -= 1\n      \
    \      carrots += number\n            hungry = false\n        }\n        carrots.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhpbvdho.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left = mutable.ArrayBuffer(number)\n        val meals = mutable.ArrayBuffer(number)\n\
    \        val meals_left = mutable.ArrayBuffer(number)\n        val meals_count\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count = mutable.ArrayBuffer(number)\n\
    \        val meals_count_left = mutable.ArrayBuffer(number)\n        val meals_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count_left_count = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count_left_count_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count_left_count_left_count = mutable.ArrayBuffer(number)\n\
    \        val meals_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ = mutable.ArrayBuffer(number)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpwoaw95to.scala:54:11 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpwoaw95to.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mmeals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\e\
    [0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmeals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  meals_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left_count_left\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwoaw95to.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwoaw95to.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwoaw95to.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mva"
  stdout: ''
  timestamp: 1659804645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryCount = mutable.ListBuffer[Long]()\n\
    \        val hungryCount2 = mutable.ListBuffer[Long]()\n        val hungryCount3\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount4 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount5 = mutable.ListBuffer[Long]()\n        val hungryCount6\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount7 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount8 = mutable.ListBuffer[Long]()\n        val hungryCount9\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount10 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount11 = mutable.ListBuffer[Long]()\n        val hungryCount12\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount13 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount14 = mutable.ListBuffer[Long]()\n        val hungryCount15\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount16 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount17 = mutable.ListBuffer[Long]()\n        val hungryCount18\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount19 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount20 = mutable.ListBuffer[Long]()\n        val hungryCount21\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount22 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount23 = mutable.ListBuffer[Long]()\n        val hungryCount24\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount25 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount26 = mutable.ListBuffer[Long]()\n        val hungryCount27\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount28 = mut\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcnkn2505.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:32:27 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8v408ud9.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804644
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals == 0) List(meals, carrots)\n        else eat(meals, carrots, remaining)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659804650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungryCarrots = if (remainingCarrots > 0) remainingCarrots else 0\n\
    \        val hungryMeals = if (meals > 0) meals else 0\n        val hungryRabbits\
    \ = if (carrots > 0) carrots else 0\n        val hungryRabbitsAndMeals = hungryRabbits\
    \ + hungryMeals\n        val hungryRabbitsAndMealsAndCarrots = hungryRabbitsAndMeals\
    \ + hungryCarrots\n        val hungryRabbitsAndMealsAndCarrotsAndMeals = hungryRabbitsAndMealsAndCarrots\
    \ + hungryMeals\n        val hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots\
    \ = hungryRabbitsAndMealsAndCarrotsAndMeals + hungryCarrots\n        val hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\
    \ = hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots + hungryMeals\n        val\
    \ hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrots = hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots\
    \ + hungryCarrots\n        val hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\
    \ = hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots + hungryMeals\n        val\
    \ hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\
    \ = hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots + hungryCarrots\n      \
    \  val hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrots\
    \ = hungryRabbitsAndMealsAnd\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpowzhru4b.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\e\
    [0m = hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrots + hungryCarrots\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMeals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpowzhru4b.scala:41:100 -----------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrotsAndMealsAndCarrots\e\
    [0m = hungryRabbitsAndMealsAnd\n\e[31m\e[31m   |\e[0m                        \
    \                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: hungryRabbitsAndMealsAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpowzhru4b.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots_left -= 1\n            carrots\
    \ += carrots_left\n            hungry = carrots_left > need\n        }\n     \
    \   if (hungry) {\n            carrots.toList\n        } else {\n            carrots.toList\
    \ :+ remaining\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3sl935hz.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(carrots, meals)\n    \
    \    if (meals > 0) {\n            val carrotsLeft = remaining - meals\n     \
    \       val mealsLeft = need - carrots\n            val result2 = List(carrotsLeft,\
    \ mealsLeft)\n            result :: result2\n        } else {\n            result\
    \ :: List(0, 0)\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9tr17enx.scala:34:12\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            result :: result2\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    (result : List[Long])\n\e[31m   |\e[0m            Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9tr17enx.scala:36:12 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            result :: List(\e[31m0\e[0m, \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \          Found:    List[Matchable]\n\e[31m   |\e[0m            Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val leftOver = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        while (carrots.size\
    \ < need && hungry.size < remaining && leftOver.size > 0) {\n            val carrotToEat\
    \ = math.min(leftOver.head, carrots.size)\n            carrots += carrotToEat\n\
    \            hungry += carrotToEat\n            leftOver -= carrotToEat\n    \
    \    }\n        while (carrots.size < need && hungry.size < remaining) {\n   \
    \         carrots += carrots.head\n            hungry += hungry.head\n       \
    \     leftOver -= carrots.head\n        }\n        while (carrots.size < need)\
    \ {\n            carrots += carrots.head\n            hungry += hungry.head\n\
    \            leftOver -= carrots.head\n        }\n        result ++= carrots.take(hungry.size)\n\
    \        result ++= hungry.take(leftOver.size)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvayn4oym.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpvayn4oym.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvayn4oym.scala:29:23 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mleftOver\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpvayn4oym.scala:30:21 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots += number\n            carrots_left\
    \ -= 1\n            hungry = false\n        }\n        if (carrots_left == 0)\
    \ {\n            carrots += remaining\n        }\n        carrots.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbvlka_y1.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots_left -= 1\n      \
    \      carrots += number\n            hungry = number > need && carrots_left >\
    \ 0\n        }\n        carrots.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpym7ut985.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var total = 0\n        var left = 0\n        while (remaining > 0) {\n\
    \            total += number\n            left += number\n            carrots\
    \ += number\n            remaining -= 1\n        }\n        if (remaining > 0)\
    \ {\n            total += remaining\n            carrots += remaining\n      \
    \  }\n        carrots.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp9h3a0w5.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpp9h3a0w5.scala:31:18 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            total += number\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp9h3a0w5.scala:32:17\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            left += number\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpp9h3a0w5.scala:34:22 ------------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m            remaining -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -= is not a member\
    \ of Long - did you mean remaining.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpp9h3a0w5.scala:37:18 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m            total += remaining\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ Int.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659804649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = if (carrots > 0) true else\
    \ false\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk_1ytoox.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e\
    [33mif\e[0m (hungry) carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCarrots\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk_1ytoox.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry) meals \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk_1ytoox.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e[33mif\e[0m (hungry)\
    \ carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk_1ytoox.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry)\
    \ meals \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpk_1ytoox.scala:36:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1659804649
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val meals\
    \ = math.min(math.max(math.ceil(remaining / carrots), 0), 1000)\n        val remaining\
    \ = math.min(math.max(math.ceil(remaining - carrots * meals), 0), 1000)\n    \
    \    val result = List(meals, remaining)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqgrxm7ej.scala:29:52 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = math.min(math.max(math.ceil(remaining\
    \ - carrots * meals), \e[31m0\e[0m), \e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                  Recursive \e[33mvalue\e[0m \e[35mremaining\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgrxm7ej.scala:31:8\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Double])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val leftCarrots\
    \ = remaining - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        if (leftCarrots > 0) {\n            result.add(carrots)\n           \
    \ eat(leftCarrots, need, remaining)\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcyiihzq2.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n   \
    \     while (i < carrots.length && needs.length < remaining.length) {\n      \
    \      val carrotLeft = carrots.takeWhile(_ <= 0).length\n            val needLeft\
    \ = needs.takeWhile(_ <= 0).length\n            if (carrotLeft <= needLeft) {\n\
    \                carrots += carrots.takeWhile(_ <= 0).take(needLeft)\n       \
    \         needs += needs.takeWhile(_ <= 0).take(carrotLeft)\n                remaining\
    \ += remaining.takeWhile(_ <= 0).take(carrotLeft)\n                result += carrots.takeWhile(_\
    \ <= 0).take(needLeft) ++ needs.takeWhile(_ <= 0).take(carrotLeft) ++ remaining.takeWhile(_\
    \ <= 0).take(carrotLeft)\n                i += 1\n            } else {\n     \
    \           carrots += carrots.takeWhile(_ <= 0).take(needLeft)\n            \
    \    needs += needs.takeWhile(_ <= 0).take(carrotLeft)\n                remaining\
    \ += remaining.takeWhile(_ <= 0).take(carrotLeft)\n                result += carrots.takeWhile(_\
    \ <= 0).take(needLeft) ++ needs.takeWhile(_ <= 0).take(carrotLeft) ++ remaining.takeWhile(_\
    \ <= 0).take(carrotLeft)\n                i += 1\n            }\n        }\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp68_ioimy.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp68_ioimy.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp68_ioimy.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp68_ioimy.scala:30:21 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= need\n            carrots += need\n        }\n  \
    \      carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_n_zpuh.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        var carrotLeft = 0\n        while(number\
    \ > 0 && carrotLeft < need) {\n            carrots += number\n            carrotLeft\
    \ += number\n            hungry += remaining\n            hungryRemaining += remaining\n\
    \            number -= 1\n        }\n        carrots.toList ++ hungry.toList ++\
    \ hungryRemaining.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyit2ucw_.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpyit2ucw_.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpyit2ucw_.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyit2ucw_.scala:33:23 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            carrotLeft += number\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not\
    \ a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpyit2ucw_.scala:36:19 ------------------------\e[0m\e[0m\n\e[31m36 |\e\
    [0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value -= is not a member of Long - did you mean\
    \ number.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659804651
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result match {\n            case Nil => result\n            case x :: xs\
    \ => eat(number, need, carrots + xs.head)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659804657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungry = mutable.ListBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount2 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount3 = mutable.ListBuffer.empty[Long]\n        val hungryCount4\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount5 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount6 = mutable.ListBuffer.empty[Long]\n        val hungryCount7\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount8 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount9 = mutable.ListBuffer.empty[Long]\n        val hungryCount10\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount11 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount12 = mutable.ListBuffer.empty[Long]\n        val hungryCount13\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount14 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount15 = mutable.ListBuffer.empty[Long]\n        val hungryCount16\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount17 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount18 = mutable.ListBuffer.empty[Long]\n        val hungryCount19\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount20 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount21 = mutable.ListBuffer.empty[Long]\n        val hungryCount22\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount23 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount24 = mutable.ListBuffer.empty[Long]\n        val hungryCount25\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCount26 = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCount27 = mutable.ListBuffer.empty[Long]\n        val hungryCount28\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplorpyojf.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplorpyojf.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplorpyojf.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplorpyojf.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplorpyojf.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmplorpyojf.scala:32:27 -------------"
  stdout: ''
  timestamp: 1659804651
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val hungry = mutable.ArrayBuffer(0)\n        val hungryRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryNeeds = mutable.ArrayBuffer(0)\n        val hungryRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemainingNeeds = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeeds\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsq3znhzh.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsq3znhzh.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsq3znhzh.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsq3znhzh.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsq3znhzh.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsq3znhzh.scala:31:30\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanatio"
  stdout: ''
  timestamp: 1659804651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        var remaining = remaining\n        var need = need\n        var carrots_left\
    \ = 0\n        while(remaining > 0 && carrots_left < need) {\n            carrots_left\
    \ += carrots.last\n            carrots += carrots.last\n            remaining\
    \ -= 1\n        }\n        carrots.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8mlh6x8p.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp8mlh6x8p.scala:28:24 ---------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8mlh6x8p.scala:29:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mneed\e[0m = need\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m\
    \   |\e[0m                   Recursive \e[33mvariable\e[0m \e[35mneed\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804649
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result match {\n            case List(_, _) => result\n            case _\
    \ => eat(number, need, remaining - carrots)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk2xoh_le.scala:36)\n\tat Problem.main(tmpk2xoh_le.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (remaining <= 0) result.reverse\n        else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_wsivgcv.scala:34)\n\tat Problem.main(tmp_wsivgcv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val carrots_left = mutable.ArrayBuffer(number)\n        val meals = mutable.ArrayBuffer(number)\n\
    \        val meals_left = mutable.ArrayBuffer(number)\n        val meals_left_to_eaten\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_to_need = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_remaining = mutable.ArrayBuffer(number)\n        val\
    \ meals_left_to_needs = mutable.ArrayBuffer(number)\n        val meals_left_to_remainings\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_to_needs_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_left_left = mutable.ArrayBuffer(number)\n   \
    \     val meals_left_to_needs_left_right = mutable.ArrayBuffer(number)\n     \
    \   val meals_left_to_needs_right_left = mutable.ArrayBuffer(number)\n       \
    \ val meals_left_to_needs_right_right = mutable.ArrayBuffer(number)\n        val\
    \ meals_left_to_needs_right_right_left = mutable.ArrayBuffer(number)\n       \
    \ val meals_left_to_needs_right_right_right = mutable.ArrayBuffer(number)\n  \
    \      val meals_left_to_needs_right_right_right_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right_right = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right_right_left = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right_right_right = mutable.ArrayBuffer(number)\n\
    \        val meals_left_to_needs_right_right_right_right_right_right_right_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_to_needs_right_right_right_right_right_right_right_right\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_to_needs_right_right_right_right_right_right_right_right_left\
    \ = mutable.ArrayBuffer(number)\n        val meals_left_to_needs_right_right_right_right_right_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu6_6u2js.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6_6u2js.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6_6u2js.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6_6u2js.scala:29:24\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6_6u2js.scala:30:27\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m   \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6_6u2js.scala:31:20\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m          \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when com"
  stdout: ''
  timestamp: 1659804651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungry = carrots > 0\n        val hungryCarrots = carrots - hungry\n\
    \        val hungryMeals = meals - hungry\n        val hungryRemaining = remainingCarrots\
    \ - hungryCarrots\n        val hungryRemainingMeals = hungryRemaining - hungryMeals\n\
    \        val hungryRemainingCarrots = hungryRemainingMeals - hungryMeals\n   \
    \     val hungryRemainingCarrotsMeals = hungryRemainingCarrots - hungryCarrots\n\
    \        val hungryRemainingCarrotsMealsMeals = hungryRemainingCarrotsMeals -\
    \ hungryMeals\n        val hungryRemainingCarrotsMealsMealsMeals = hungryRemainingCarrotsMealsMeals\
    \ - hungryMeals\n        val hungryRemainingCarrotsMealsMealsMealsMeals = hungryRemainingCarrotsMealsMealsMeals\
    \ - hungryMeals\n        val hungryRemainingCarrotsMealsMealsMealsMealsMeals =\
    \ hungryRemainingCarrotsMealsMealsMealsMealsMeals - hungryMeals\n        val hungryRemainingCarrotsMealsMealsMealsMealsMealsMeals\
    \ = hungryRemainingCarrotsMealsMealsMealsMealsMealsMeals - hungryMeals\n     \
    \   val hungryRemainingCarrotsMealsMealsMealsMealsMealsMealsMeals = hungryRemainingCarrotsMealsMealsMealsMealsMealsMealsMeals\
    \ - hungryMeals\n        val hungryRemainingCarrotsMealsMealsMealsMealsMealsMealsMealsMeals\
    \ = hungryRemainingCarrotsMealsMealsMealsMealsMealsMealsMealsMeals - hun\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmprhntoqup.scala:31:36 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = carrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprhntoqup.scala:32:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryMeals\e[0m = meals - hungry\n\e[31m\e[31m   |\e[0m           \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmprhntoqup.scala:40:62 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrotsMealsMealsMealsMealsMeals\e\
    [0m = hungryRemainingCarrotsMealsMealsMealsMealsMeals - hungryMeals\n\e[31m\e\
    [31m   |\e[0m                                                              ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mhungryRemainingCarrotsMealsMealsMealsMealsMeals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprhntoqup.scala:41:67\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRemainingCarrotsMealsMealsMealsMealsMealsMeals\e[0m = hungryRemainingCarrotsMealsMealsMealsMealsMealsMeals\
    \ - hungryMeals\n\e[31m\e[31m  "
  stdout: ''
  timestamp: 1659804653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= 1\n            carrots += carrots_left\n        }\n\
    \        carrots.takeWhile(_ < need).takeWhile(_ < remaining).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprmxb7dkr.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots_left -= 1\n            carrots\
    \ += number\n            hungry = false\n        }\n        if (hungry) {\n  \
    \          carrots += remaining\n        }\n        carrots.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcbfx8slo.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804652
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals == 0) List(meals, carrots)\n        else eat(number - carrots,\
    \ need - carrots, remaining - carrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659804660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungry = mutable.ListBuffer.empty[Long]\n        var carrots_left\
    \ = remaining\n        var hungry_left = remaining\n        while(number > 0 &&\
    \ carrots_left > 0 && hungry_left > 0) {\n            carrots_left -= 1\n    \
    \        hungry_left -= 1\n            number -= 1\n            carrots += number\n\
    \            hungry += need\n        }\n        if(carrots_left > 0 && hungry_left\
    \ > 0) {\n            carrots += remaining\n            hungry += hungry_left\n\
    \        }\n        carrots.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcznm2vxg.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcznm2vxg.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcznm2vxg.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryCount = mutable.ListBuffer[Long]()\n\
    \        val hungryCount2 = mutable.ListBuffer[Long]()\n        val hungryCount3\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount4 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount5 = mutable.ListBuffer[Long]()\n        val hungryCount6\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount7 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount8 = mutable.ListBuffer[Long]()\n        val hungryCount9\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount10 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount11 = mutable.ListBuffer[Long]()\n        val hungryCount12\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount13 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount14 = mutable.ListBuffer[Long]()\n        val hungryCount15\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount16 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount17 = mutable.ListBuffer[Long]()\n        val hungryCount18\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount19 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount20 = mutable.ListBuffer[Long]()\n        val hungryCount21\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount22 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount23 = mutable.ListBuffer[Long]()\n        val hungryCount24\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount25 = mutable.ListBuffer[Long]()\n\
    \        val hungryCount26 = mutable.ListBuffer[Long]()\n        val hungryCount27\
    \ = mutable.ListBuffer[Long]()\n        val hungryCount28 = mut\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcnkn2505.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcnkn2505.scala:32:27 ------------------------\e\
    [0m\e[0m\n"
  stdout: ''
  timestamp: 1659804625
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals > 0) {\n            val carrotsLeft = remaining - meals\n     \
    \       val mealsLeft = need - carrots\n            val result2 = List(mealsLeft,\
    \ carrotsLeft)\n            result ::: result2\n        } else {\n           \
    \ List(meals, carrots)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsgasce78.scala:40)\n\tat Problem.main(tmpsgasce78.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            number -= 1\n           \
    \ carrots_left -= 1\n        }\n        carrots ++ List(0, carrots_left)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjrxnmjkm.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpjrxnmjkm.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        val hungry = mutable.ArrayBuffer(true)\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        val hungryIndex = mutable.ArrayBuffer.empty[Int]\n        val hungryIndex\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7w224a3s.scala:60:25 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp7w224a3s.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryIndex is already defined as \e[33mvalue\e[0m \e[35mhungryIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7w224a3s.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryIndex is already defined as \e[33mvalue\e[0m \e[35mhungryIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7w224a3s.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryIndex is already defined as \e[33mvalue\e[0m \e[35mhungryIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7w224a3s.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659804656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft\
    \ + 1)\n        val mealsLeftList3 = List(mealsLeft + 2)\n        val mealsLeftList4\
    \ = List(mealsLeft + 3)\n        val mealsLeftList5 = List(mealsLeft + 4)\n  \
    \      val mealsLeftList6 = List(mealsLeft + 5)\n        val mealsLeftList7 =\
    \ List(mealsLeft + 6)\n        val mealsLeftList8 = List(mealsLeft + 7)\n    \
    \    val mealsLeftList9 = List(mealsLeft + 8)\n        val mealsLeftList10 = List(mealsLeft\
    \ + 9)\n        val mealsLeftList11 = List(mealsLeft + 10)\n        val mealsLeftList12\
    \ = List(mealsLeft + 11)\n        val mealsLeftList13 = List(mealsLeft + 12)\n\
    \        val mealsLeftList14 = List(mealsLeft + 13)\n        val mealsLeftList15\
    \ = List(mealsLeft + 14)\n        val mealsLeftList16 = List(mealsLeft + 15)\n\
    \        val mealsLeftList17 = List(mealsLeft + 16)\n        val mealsLeftList18\
    \ = List(mealsLeft + 17)\n        val mealsLeftList19 = List(mealsLeft + 18)\n\
    \        val mealsLeftList20 = List(mealsLeft + 19)\n        val mealsLeftList21\
    \ = List(mealsLeft + 20)\n        val mealsLeftList22 = List(mealsLeft + 21)\n\
    \        val mealsLeftList23 = List(mealsLeft + 22)\n        val mealsLeftList24\
    \ = List(mealsLeft + 23)\n        val mealsLeftList25 = List(mealsLeft + 24)\n\
    \        val mealsLeftList26 = List(mealsLeft + 25)\n        val mealsLeftList27\
    \ = List(mealsLeft + 26)\n        val mealsLeftList28 = List(mealsLeft + 27)\n\
    \        val mealsLeftList29 = List(mealsLeft + 28)\n        val mealsLeftList30\
    \ = List(mealsLeft + 29)\n        val mealsLeftList31 = List(mealsLeft + 30)\n\
    \        val mealsLeftList32 = List(mealsLeft + 31)\n        val mealsLeftList33\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa1pbj_8x.scala:62:29 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftList33\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa1pbj_8x.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryRabbit = number - remaining\n  \
    \      val hungryRabbits = hungryRabbit / need\n        val hungryRabbitsLeft\
    \ = hungryRabbit % need\n        val hungryRabbits = hungryRabbits.toList\n  \
    \      val hungryRabbitsLeft = hungryRabbitsLeft.toList\n        val hungryRabbitsLeft:\
    \ List[Long] = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long]\
    \ = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n\
    \        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n     \
    \   val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n        val\
    \ hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft:\
    \ List[Long] = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long]\
    \ = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n\
    \        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n     \
    \   val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n        val\
    \ hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft:\
    \ List[Long] = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long]\
    \ = hungryRabbitsLeft.reverse\n        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n\
    \        val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n     \
    \   val hungryRabbitsLeft: List[Long] = hungryRabbitsLeft.reverse\n        val\
    \ hungryR\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2z35j49x.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2z35j49x.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRabbits\e[0m = hungryRabbits.toList\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryRabbits\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2z35j49x.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRabbitsLeft\e[0m = hungryRabbitsLeft.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mhungryRabbitsLeft is already defined as \e[33mvalue\e[0m \e[35mhungryRabbitsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2z35j49x.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsLeft\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = hungryRabbitsLeft.reverse\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryRabbitsLeft is already defined as \e[33mvalue\e[0m \e[35mhungryRabbitsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2z35j49x.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsLeft\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = hungryRabbitsLeft.reverse\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryRabbitsLeft is already defined as \e[33mvalue\e[0m \e[35mhungryRabbitsLeft"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        var hungryRemainingIndex = 0\n     \
    \   var hungryIndex = 0\n        var hungryIndex2 = 0\n        var hungryIndex3\
    \ = 0\n        var hungryIndex4 = 0\n        var hungryIndex5 = 0\n        var\
    \ hungryIndex6 = 0\n        var hungryIndex7 = 0\n        var hungryIndex8 = 0\n\
    \        var hungryIndex9 = 0\n        var hungryIndex10 = 0\n        var hungryIndex11\
    \ = 0\n        var hungryIndex12 = 0\n        var hungryIndex13 = 0\n        var\
    \ hungryIndex14 = 0\n        var hungryIndex15 = 0\n        var hungryIndex16\
    \ = 0\n        var hungryIndex17 = 0\n        var hungryIndex18 = 0\n        var\
    \ hungryIndex19 = 0\n        var hungryIndex20 = 0\n        var hungryIndex21\
    \ = 0\n        var hungryIndex22 = 0\n        var hungryIndex23 = 0\n        var\
    \ hungryIndex24 = 0\n        var hungryIndex25 = 0\n        var hungryIndex26\
    \ = 0\n        var hungryIndex27 = 0\n        var hungryIndex28 = 0\n        var\
    \ hungryIndex29 = 0\n        var hungryIndex30 = 0\n        var hungryIndex31\
    \ = 0\n        var hungryIndex32 = 0\n        var hungryIndex33 = 0\n        var\
    \ hungryIndex34 = 0\n        var hungryIndex35 = 0\n        var hungryIndex36\
    \ = 0\n        var hungryIndex37 = 0\n        var hungryIndex38 = 0\n        var\
    \ hungryIndex39 = 0\n        var hungryIndex40 = 0\n        var hungryIndex41\
    \ = 0\n        var hungryIndex42 = 0\n        var hungryIndex43 = 0\n        var\
    \ hungryIndex44 = 0\n        var hungryIndex45 = 0\n        var hungryIndex46\
    \ = 0\n        var hungryIndex47 = 0\n        var hungryIndex48 = 0\n        var\
    \ hungryIndex49 = 0\n        var hungryIndex50 = 0\n        var hungryIndex51\
    \ = 0\n        var hungry\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw_39mfop.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_39mfop.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_39mfop.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw_39mfop.scala:29:30\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpw_39mfop.scala:83:5 ---------------------\e[0m\e[0m\n\e[31m83\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(mealsLeft)\n        val carrotsLeft = carrots - meals\n\
    \        val carrotsLeftList = List(carrotsLeft)\n        val mealsLeftListWithCarrotsLeft\
    \ = mealsLeftList ++ carrotsLeftList\n        val mealsLeftListWithCarrotsLeftList\
    \ = mealsLeftListWithCarrotsLeft ++ List(mealsLeft)\n        val mealsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftList ++ carrotsLeftList\n        val mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftListWithCarrotsLeft ++ carrotsLeftList\n     \
    \   val mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft ++ carrotsLeftList\n\
    \        val mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ ++ carrotsLeftList\n        val mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ ++ carrotsLeftList\n        val mealsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeftListWithCarrotsLeft\
    \ = mealsLeftListWithCarrotsLeftList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9yoq7hwt.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val meals  = mutable.ArrayBuffer(number)\n        val result: List[Long]\
    \ = mutable.ArrayBuffer.empty\n        while(left.length > 0) {\n            val\
    \ carrotToEat = carrots.take()\n            val hungryToEat = hungry.take()\n\
    \            val leftToEat = left.take()\n            val mealToEat = meals.take()\n\
    \            val result = if (carrotToEat == 0) mealToEat else mealToEat + carrotToEat\n\
    \            left.remove(leftToEat)\n            hungry.remove(leftToEat)\n  \
    \          carrots.remove(carrotToEat)\n            meals.remove(mealToEat)\n\
    \            result :+ result(0)\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9cic16e.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpb9cic16e.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb9cic16e.scala:29:20 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mleft\e[0m  = mutable.ArrayBuffer(remaining)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb9cic16e.scala:30:21 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mmeals\e[0m  = mutable.ArrayBuffer(number)\n\e\
    [31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb9cic16e.scala:31:33 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = mutable.ArrayBuffer.empty\n\e[31m\e[31m   |\e[0m                         \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659804655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        while (carrots.size\
    \ < needs.size && remaining.size > 0) {\n            carrots += carrots.last\n\
    \            needs += needs.last\n            remaining += remaining.last\n  \
    \      }\n        val carrots_left = carrots.size - needs.size\n        val carrots_left_after\
    \ = carrots.size - remaining.size\n        if (carrots_left > 0 && carrots_left_after\
    \ > 0) {\n            result ++= carrots.take(carrots_left) ++ carrots.take(carrots_left_after)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5varrbsg.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5varrbsg.scala:28:20 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5varrbsg.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5varrbsg.scala:30:21 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsRemaining = remaining - carrots\n\
    \        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n       \
    \ val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val\
    \ mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable\
    \ = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable =\
    \ mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n\
    \        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n  \
    \      val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n    \
    \    val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n      \
    \  val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val\
    \ mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable\
    \ = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable =\
    \ mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n\
    \        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n  \
    \      val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n    \
    \    val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n      \
    \  val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val\
    \ mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable\
    \ = mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable =\
    \ mutable.ArrayBuffer.empty[Long]\n        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n\
    \        val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n  \
    \      val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n    \
    \    val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n      \
    \  val mealsRemainingArrayMutable = mutable.ArrayBuffer.empty[Long]\n        val\
    \ mealsRemainingArrayMutable = mutable.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkibt6tko.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkibt6tko.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayMutable\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayMutable is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayMutable\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkibt6tko.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayMutable\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsRemainingArrayMutable is already defined as \e[33mvalue\e[0m \e\
    [35mmealsRemainingArrayMutable\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkibt6tko.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayMutable\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsRemainingArrayMutable is already defined as \e[33mvalue\e[0m \e\
    [35mmealsRemainingArrayMutable\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkibt6tko.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayMutable\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1659804660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount3 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount6 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount7\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount9 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount10\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount11 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount12 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount13\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount15 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount16\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount17 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount18 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount19\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount21 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount22\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount23 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount24 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount25\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount27 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount28\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu91agpt.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsu91agpt.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsu91agpt.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu91agpt.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu91agpt.scala:31:27 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpsu91agpt.scala:32:27 --------"
  stdout: ''
  timestamp: 1659804661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungry = number - remaining\n        val\
    \ eaten = need\n        val left  = remaining - eaten\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        if (hungry > 0) {\n            result.add(\
    \ eaten )\n        }\n        if (left > 0) {\n            result.add( left )\n\
    \        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4y5ir6oh.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while (carrots_left > 0) {\n  \
    \          carrots += number\n            carrots_left -= 1\n        }\n     \
    \   carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp31p465xg.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots_left -= 1\n            number -= 1\n           \
    \ carrots += number\n        }\n        carrots.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnblr7uwa.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnblr7uwa.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val meals_left = meals + carrots\n     \
    \   val meals_left_list = List(meals_left)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrots_left_list = List(number\
    \ - meals)\n        val carrots_left_list = List(number - meals)\n        val\
    \ carrots_left_list = List(number - meals)\n        val carrot\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphw9k1n4l.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphw9k1n4l.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_list\e[0m = List(number - meals)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left_list\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots_left_list\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphw9k1n4l.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(number - meals)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e[35mcarrots_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphw9k1n4l.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(number\
    \ - meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphw9k1n4l.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(number - meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659804661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft\
    \ + 1)\n        val mealsLeftList3 = List(mealsLeft + 2)\n        val mealsLeftList4\
    \ = List(mealsLeft + 3)\n        val mealsLeftList5 = List(mealsLeft + 4)\n  \
    \      val mealsLeftList6 = List(mealsLeft + 5)\n        val mealsLeftList7 =\
    \ List(mealsLeft + 6)\n        val mealsLeftList8 = List(mealsLeft + 7)\n    \
    \    val mealsLeftList9 = List(mealsLeft + 8)\n        val mealsLeftList10 = List(mealsLeft\
    \ + 9)\n        val mealsLeftList11 = List(mealsLeft + 10)\n        val mealsLeftList12\
    \ = List(mealsLeft + 11)\n        val mealsLeftList13 = List(mealsLeft + 12)\n\
    \        val mealsLeftList14 = List(mealsLeft + 13)\n        val mealsLeftList15\
    \ = List(mealsLeft + 14)\n        val mealsLeftList16 = List(mealsLeft + 15)\n\
    \        val mealsLeftList17 = List(mealsLeft + 16)\n        val mealsLeftList18\
    \ = List(mealsLeft + 17)\n        val mealsLeftList19 = List(mealsLeft + 18)\n\
    \        val mealsLeftList20 = List(mealsLeft + 19)\n        val mealsLeftList21\
    \ = List(mealsLeft + 20)\n        val mealsLeftList22 = List(mealsLeft + 21)\n\
    \        val mealsLeftList23 = List(mealsLeft + 22)\n        val mealsLeftList24\
    \ = List(mealsLeft + 23)\n        val mealsLeftList25 = List(mealsLeft + 24)\n\
    \        val mealsLeftList26 = List(mealsLeft + 25)\n        val mealsLeftList27\
    \ = List(mealsLeft + 26)\n        val mealsLeftList28 = List(mealsLeft + 27)\n\
    \        val mealsLeftList29 = List(mealsLeft + 28)\n        val mealsLeftList30\
    \ = List(mealsLeft + 29)\n        val mealsLeftList31 = List(mealsLeft + 30)\n\
    \        val mealsLeftList32 = List(mealsLeft + 31)\n        val mealsLeftList33\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa1pbj_8x.scala:62:29 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftList33\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa1pbj_8x.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804658
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val carrotsNeeded = need - carrots\n        val carrotsNeededToEat = math.min(carrotsNeeded,\
    \ remaining)\n        val carrotsNeededToEatList = List(carrotsNeededToEat)\n\
    \        val carrotsNeededToEatListWithRemaining = carrotsNeededToEatList :+ remaining\n\
    \        val carrotsNeededToEatListWithRemainingList = carrotsNeededToEatListWithRemaining\
    \ :+ carrots\n        carrotsNeededToEatListWithRemainingList.sortWith(_ < _)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9uxpw5pe.scala:36)\n\tat Problem.main(tmp9uxpw5pe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining2\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining3 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining4 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining5\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining6 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining7 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining8\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining9 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining10 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining11 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining12\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining13 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining14 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining15 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining16\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining17 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining18 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining19 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining20\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining21 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining22 = mutable.ListBuffer[Long]()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1ptod61r.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1ptod61r.scala:32:36 "
  stdout: ''
  timestamp: 1659804613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            number -= 1\n           \
    \ carrots_left -= 1\n        }\n        carrots.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz9grr7ho.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz9grr7ho.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining2\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining3 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining4 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining5\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining6 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining7 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining8\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining9 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining10 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining11 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining12\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining13 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining14 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining15 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining16\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining17 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining18 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining19 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining20\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining21 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining22 = mutable.ListBuffer[Long]()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1ptod61r.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:30:26 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1ptod61r.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1ptod61r.scala:32:36 "
  stdout: ''
  timestamp: 1659804613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result: List[Long] = new ArrayList[Long]()\n\
    \        if (meals > 0) {\n            val carrots = carrots + meals\n       \
    \     val remaining = remaining - meals\n            result.add(carrots)\n   \
    \     }\n        if (remaining > 0) {\n            val carrots = carrots + remaining\n\
    \            val remaining = remaining - remaining\n            result.add(carrots)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3sgz5z1w.scala:29:37 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3sgz5z1w.scala:31:26 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = carrots\
    \ + meals\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e\
    [0m                          Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3sgz5z1w.scala:32:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = remaining - meals\n\e[31m\e[31m   |\e[0m          \
    \                  ^\e[0m\n\e[31m   |\e[0m                            Recursive\
    \ \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp3sgz5z1w.scala:33:19 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            result.add(carrots)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value add is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3sgz5z1w.scala:36:26\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mcarrots\e[0m = carrots + remaining\n\e[31m\e[31m   |\e[0m          \
    \                ^\e[0m\n\e[31m   |\e[0m                          Recursive \e\
    [33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp3sgz5z1w.scala:37:28 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0"
  stdout: ''
  timestamp: 1659804664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val hungryCarrots = math.max(0, math.min(need, carrots))\n        val hungryCarrotsRemaining\
    \ = math.max(0, math.min(remaining, carrots))\n        val hungryCarrotsRemainingToEat\
    \ = math.max(0, math.min(remaining, hungryCarrots))\n        val hungryCarrotsRemainingToEatRemaining\
    \ = math.max(0, math.min(remaining, hungryCarrotsRemainingToEat))\n        val\
    \ hungryCarrotsRemainingToEatRemainingToEat = math.max(0, math.min(remaining,\
    \ hungryCarrotsRemainingToEatRemaining))\n        val hungryCarrotsRemainingToEatRemainingToEatRemaining\
    \ = math.max(0, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEat))\n\
    \        val hungryCarrotsRemainingToEatRemainingToEatRemainingToEat = math.max(0,\
    \ math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemaining))\n \
    \       val hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemaining =\
    \ math.max(0, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingToEat))\n\
    \        val hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEat\
    \ = math.max(0, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEat))\n\
    \        val hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\
    \ = math.max(0, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining))\n\
    \        val hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat\
    \ = math.max(0, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoey2xgb1.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoey2xgb1.scala:36:116\
    \ --------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e\
    [0m = math.max(\e[31m0\e[0m, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEat))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0mRecursive \e[33mvalue\e[0m \e[35mhungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoey2xgb1.scala:37:125\
    \ --------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\e\
    [0m = math.max(\e[31m0\e[0m, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemaining\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpoey2xgb1.scala:38:130 -----------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryCarrotsRemainingToEatRemainingToEatRemainingToEatRemainingToEatRemainingToEat\e\
    [0m = math.max(\e[31m0\e[0m, math.min(remaining, hungryCarrotsRemainingToEatRemainingToEatRemainingTo\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             "
  stdout: ''
  timestamp: 1659804663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots += number\n      \
    \      carrots_left -= 1\n            number -= 1\n            hungry = false\n\
    \        }\n        carrots.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fx1bg58.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5fx1bg58.scala:33:19 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        while (carrots_left > 0) {\n            carrots_left -= 1\n         \
    \   carrots += number\n            hungry += need\n        }\n        carrots.toList\
    \ ++ hungry.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvn9oe4nl.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvn9oe4nl.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfombpnd.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsfombpnd.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsfombpnd.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfombpnd.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val meals  = mutable.ArrayBuffer(0)\n        val hungryMeals = mutable.ArrayBuffer(0)\n\
    \        val leftMeals  = mutable.ArrayBuffer(0)\n        val hungryLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeft   = mutable.ArrayBuffer(0)\n        val hungryLeftMeals\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftMeals  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeft  = mutable.ArrayBuffer(0)\n        val leftLeftLeft\
    \   = mutable.ArrayBuffer(0)\n        val hungryLeftLeftMeals  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftMeals  = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeft\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeft   = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftMeals  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftMeals\
    \  = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeft   = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftMeals\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftLeftMeals  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n        val\
    \ leftLeftLeftLeftLeftLeft   = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftLeftMeals\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftLeftLeftMeals  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n      \
    \  val leftLeftLeftLeftLeftLeftLeft   = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftLeftLeftMeals\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftLeftLeftLeftMeals  =\
    \ mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeft   = mutable.ArrayBuffer(0)\n   \
    \     val hungryLeftLeftLeftLeftLeftLeftLeftMeals  = mutable.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbreddytg.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpbreddytg.scala:27:22 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbreddytg.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbreddytg.scala:29:20 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mleft\e[0m  = mutable.ArrayBuffer(remaining)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbreddytg.scala:30:21 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mmeals\e[0m  = mutable.ArrayBuffer(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbreddytg.scala:31:26 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = mutable.ArrayBuffer(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available"
  stdout: ''
  timestamp: 1659804667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsRemaining = remaining - meals\n\
    \        val mealsRemainingInt = mealsRemaining.toInt\n        val mealsRemainingList\
    \ = List(mealsRemainingInt)\n        val carrotsRemaining = meals - mealsRemainingInt\n\
    \        val carrotsRemainingInt = carrotsRemaining.toInt\n        val carrotsRemainingList\
    \ = List(carrotsRemainingInt)\n        val result = List(mealsRemainingInt, carrotsRemainingInt)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpce03ve02.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungryCarrots = remainingCarrots - meals\n        val hungryCarrotsList\
    \ = List(hungryCarrots)\n        val hungryCarrotsList2 = List(hungryCarrots)\n\
    \        val hungryCarrotsList3 = List(hungryCarrots)\n        val hungryCarrotsList4\
    \ = List(hungryCarrots)\n        val hungryCarrotsList5 = List(hungryCarrots)\n\
    \        val hungryCarrotsList6 = List(hungryCarrots)\n        val hungryCarrotsList7\
    \ = List(hungryCarrots)\n        val hungryCarrotsList8 = List(hungryCarrots)\n\
    \        val hungryCarrotsList9 = List(hungryCarrots)\n        val hungryCarrotsList10\
    \ = List(hungryCarrots)\n        val hungryCarrotsList11 = List(hungryCarrots)\n\
    \        val hungryCarrotsList12 = List(hungryCarrots)\n        val hungryCarrotsList13\
    \ = List(hungryCarrots)\n        val hungryCarrotsList14 = List(hungryCarrots)\n\
    \        val hungryCarrotsList15 = List(hungryCarrots)\n        val hungryCarrotsList16\
    \ = List(hungryCarrots)\n        val hungryCarrotsList17 = List(hungryCarrots)\n\
    \        val hungryCarrotsList18 = List(hungryCarrots)\n        val hungryCarrotsList19\
    \ = List(hungryCarrots)\n        val hungryCarrotsList20 = List(hungryCarrots)\n\
    \        val hungryCarrotsList21 = List(hungryCarrots)\n        val hungryCarrotsList22\
    \ = List(hungryCarrots)\n        val hungryCarrotsList23 = List(hun\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnzf3roda.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnzf3roda.scala:53:39\
    \ ------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryCarrotsList23\e[0m = List(hun\n\e[31m\e[31m   |\e[0m               \
    \                        ^^^\e[0m\n\e[31m   |\e[0m                           \
    \            Not found: hun\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnzf3roda.scala:54:5 ---------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val hungryRabbit = number - remaining\n  \
    \      val hungryRabbits = hungryRabbit / need\n        val hungryRabbitsLeft\
    \ = hungryRabbit % need\n        val hungryRabbits = hungryRabbits.toList\n  \
    \      val hungryRabbitsLeftList = hungryRabbitsLeft.toList\n        val hungryRabbitsLeftListReversed\
    \ = hungryRabbitsLeftList.reverse\n        val hungryRabbitsLeftListReversedReversed\
    \ = hungryRabbitsLeftListReversed.reverse\n        val hungryRabbitsLeftListReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversed.reverse\n        val hungryRabbitsLeftListReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversed.reverse\n        val\
    \ hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val hungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = hungryRabbitsLeftListReversedReversedReversedReversedReverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx2karl4d.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpx2karl4d.scala:31:54 ------------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsLeftList\e[0m = hungryRabbitsLeft.toList\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toList is not a member of Long - did you mean hungryRabbitsLeft.toInt?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx2karl4d.scala:35:76 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsLeftListReversedReversedReversedReversedReversed\e\
    [0m = hungryRabbitsLeftListReversedReversedReversedReversed.reverse\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Not found: hungryRabbitsLeftListReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx2karl4d.scala:36:92\
    \ ------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRabbitsLeftListReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = hungryRabbitsLeftListReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: hungryRabbitsLeftListReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available "
  stdout: ''
  timestamp: 1659804668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryEaten = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenRemaining = mutable.ListBuffer[Long]()\n        val hungryEatenNeeds\
    \ = mutable.ListBuffer[Long]()\n        val hungryEatenNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeeds = mutable.ListBuffer[Long]()\n        val hungryEatenNeedsNeedsRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryEatenNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n  \
    \      val hungryEatenNeedsNeedsNeedsNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsNeedsNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeedsNeedsNeedsNeedsNeedsNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryEatenNeedsNeedsNeeds\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi6ubkeol.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ubkeol.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ubkeol.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ubkeol.scala:29:30\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpi6ubkeol.scala:30:26 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryEaten\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ubkeol.scala:31:35 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 "
  stdout: ''
  timestamp: 1659804668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp28e592jn.scala:33)\n\tat Problem.main(tmp28e592jn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804618
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsfombpnd.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpsfombpnd.scala:28:21 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpsfombpnd.scala:29:30 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsfombpnd.scala:49:5 ---------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val hungry = carrots > 0\n        val hungryLeft = carrots - hungry\n     \
    \   val hungryLeftList = List(hungryLeft)\n        val hungryLeftList2 = List(hungryLeft)\n\
    \        val hungryLeftList3 = List(hungryLeft)\n        val hungryLeftList4 =\
    \ List(hungryLeft)\n        val hungryLeftList5 = List(hungryLeft)\n        val\
    \ hungryLeftList6 = List(hungryLeft)\n        val hungryLeftList7 = List(hungryLeft)\n\
    \        val hungryLeftList8 = List(hungryLeft)\n        val hungryLeftList9 =\
    \ List(hungryLeft)\n        val hungryLeftList10 = List(hungryLeft)\n        val\
    \ hungryLeftList11 = List(hungryLeft)\n        val hungryLeftList12 = List(hungryLeft)\n\
    \        val hungryLeftList13 = List(hungryLeft)\n        val hungryLeftList14\
    \ = List(hungryLeft)\n        val hungryLeftList15 = List(hungryLeft)\n      \
    \  val hungryLeftList16 = List(hungryLeft)\n        val hungryLeftList17 = List(hungryLeft)\n\
    \        val hungryLeftList18 = List(hungryLeft)\n        val hungryLeftList19\
    \ = List(hungryLeft)\n        val hungryLeftList20 = List(hungryLeft)\n      \
    \  val hungryLeftList21 = List(hungryLeft)\n        val hungryLeftList22 = List(hungryLeft)\n\
    \        val hungryLeftList23 = List(hungryLeft)\n        val hungryLeftList24\
    \ = List(hungryLeft)\n        val hungryLeftList25 = List(hungryLeft)\n      \
    \  val hungryLeftList26 = List(hungryLeft)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpihn7mqyu.scala:31:33 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryLeft\e[0m = carrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((hungry : Boolean))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpihn7mqyu.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val carrotsLeft\
    \ = remaining - carrots\n        val carrotsLeftAfterMeals = carrotsLeft - carrots\n\
    \        val carrotsLeftAfterMealsAfterMeals = carrotsLeft - carrots\n       \
    \ val carrotsLeftAfterMealsAfterMealsAfterMeals = carrotsLeft - carrots\n    \
    \    val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals = carrotsLeft - carrots\n\
    \        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals = carrotsLeft\
    \ - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeft - carrots\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfmat7j2g.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfmat7j2g.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = carrotsLeft - carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpfmat7j2g.scala:42:5 ---------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofdzh838.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpofdzh838.scala:34:12\
    \ ------"
  stdout: ''
  timestamp: 1659804615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val leftOver = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        while(number >\
    \ 0 && need > 0 && remaining > 0) {\n            number -= 1\n            hungry\
    \ -= 1\n            leftOver -= 1\n            result += number\n        }\n \
    \       if(number > 0 && need > 0 && remaining > 0) {\n            result += (number\
    \ - need)\n        }\n        if(number > 0 && need > 0 && remaining > 0) {\n\
    \            result += (number - need)\n        }\n        if(number > 0 && need\
    \ > 0 && remaining > 0) {\n            result += (number - need)\n        }\n\
    \        if(number > 0 && need > 0 && remaining > 0) {\n            result +=\
    \ (number - need)\n        }\n        if(number > 0 && need > 0 && remaining >\
    \ 0) {\n            result += (number - need)\n        }\n        if(number >\
    \ 0 && need > 0 && remaining > 0) {\n            result += (number - need)\n \
    \       }\n        if(number > 0 && need > 0 && remaining > 0) {\n           \
    \ result += (number - need)\n        }\n        if(number > 0 && need > 0 && remaining\
    \ > 0) {\n            result += (number - need)\n        }\n        if(number\
    \ > 0 && need > 0 && remaining > 0) {\n            result += (number - need)\n\
    \        }\n        if(number > 0 && need > 0 && remaining > 0) {\n          \
    \  result += (number - need)\n        }\n        if(number > 0 && need > 0 &&\
    \ remaining > 0) {\n            result += (number - need)\n        }\n       \
    \ if(number > 0 && need > 0 && remaining > 0) {\n            result += (number\
    \ - need)\n        }\n        if(number > 0 && need > 0 && remaining > 0) {\n\
    \            result += (number - need)\n        }\n        if(number > 0 && need\
    \ > 0 && remaining > 0) {\n            result += (number - need)\n        }\n\
    \        if(number > 0 && need > 0 && remaining > 0) {\n            result +=\
    \ (number - need)\n        }\n        if(number > 0 && need > 0 && remaining >\
    \ 0) {\n            result += (number - need)\n        }\n        if(number >\
    \ 0 && need > 0 && remaining > 0) {\n            result += (number - need)\n \
    \       }\n        if(number > 0 && need > 0 && remaining > 0) {\n           \
    \ result += (number - need)\n        }\n        if(number > 0 && need > 0 && remaining\
    \ > 0) {\n            result += (number - need)\n        }\n        if(number\
    \ > 0 && need > 0 && remaining > 0) {\n            result += (number - need)\n\
    \        }\n        if(number > 0 && need > 0 && remaining > 0) {\n          \
    \  result += (number - need)\n        }\n        if(number > 0 && need > 0 &&\
    \ remaining > 0) {\n            \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj50918h1.scala:113:0 ---------------------------\e\
    [0m\e[0m\n\e[31m113 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj50918h1.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj50918h1.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj50918h1.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mleftOver\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m    \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj50918h1.scala:30:21\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj50918h1.scala:32:19\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            number -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           value -= is not a member of Long - did you mean number.!=?\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj50918h1.scala:112:1 -----------------"
  stdout: ''
  timestamp: 1659804670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val hungry = carrots % need\n        val eaten = carrots - hungry\n        val\
    \ left = (remaining - eaten) % need\n        val meals = (eaten + left) / need\n\
    \        List(meals, left)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdrjhsmuo.scala:35)\n\tat Problem.main(tmpdrjhsmuo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots_left -= 1\n            carrots\
    \ += number\n            hungry = carrots_left > need\n        }\n        if (hungry)\
    \ {\n            carrots += remaining\n        }\n        carrots.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwgn86f4d.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        var remaining = remaining\n        var need = need\n        var carrots\
    \ = number\n        while (remaining > 0) {\n            carrots += carrots.last\n\
    \            remaining -= 1\n        }\n        carrots.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4i3tpc9n.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mvar\e[0m \e[36mcarrots\e[0m = number\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots is\
    \ already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4i3tpc9n.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ListBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4i3tpc9n.scala:28:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mremaining\e[0m = remaining\n\e[31m\e[31m   |\e[0m                    \
    \    ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvariable\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp4i3tpc9n.scala:29:19 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mvar\e[0m \e[36mneed\e[0m = need\n\e[31m\e[31m   |\e[0m \
    \                  ^\e[0m\n\e[31m   |\e[0m                   Recursive \e[33mvariable\e\
    [0m \e[35mneed\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer.empty[Long]\n\
    \        var remaining = remaining\n        var carrots_left = number\n      \
    \  while (remaining > 0) {\n            carrots_left -= 1\n            carrots\
    \ += carrots_left\n            remaining -= 1\n        }\n        carrots.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpft9ped5h.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpft9ped5h.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftAfterMeals = mealsLeft - carrots\n        val mealsLeftAfterMealsAfterMeals\
    \ = mealsLeftAfterMeals - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMeals - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMeals - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMeals - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - carrots\n\
    \        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n        val mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx3gjg1qd.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx3gjg1qd.scala:35:84\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals -\
    \ carrots\n\e[31m\e[31m   |\e[0m                                             \
    \                                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mmealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx3gjg1qd.scala:36:94\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n\e[31m\e[31m   |\e[0m                                           \
    \                                                   ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpx3gjg1qd.scala:37:104 --------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = mealsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots\n\e[31m\e[31m   |\e[0m                                           \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsLeftAfterMealsAfterMealsA"
  stdout: ''
  timestamp: 1659804670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - need\n        val carrots_left\
    \ = remaining - carrots\n        val meals = if (carrots_left <= 0) 0 else carrots_left\
    \ / 2\n        val carrots_after_meals = if (carrots_left <= 0) 0 else carrots_left\
    \ - meals\n        val carrots_left_after_meals = if (carrots_left <= 0) 0 else\
    \ carrots_left - meals - carrots_after_meals\n        val carrots_after_meals_remaining\
    \ = if (carrots_left <= 0) 0 else carrots_left - meals - carrots_after_meals -\
    \ carrots_left_after_meals\n        val carrots_left_after_meals_remaining = if\
    \ (carrots_left <= 0) 0 else carrots_left - meals - carrots_after_meals - carrots_left_after_meals\
    \ - carrots_after_meals_remaining\n        val carrots_after_meals_remaining_remaining\
    \ = if (carrots_left <= 0) 0 else carrots_left - meals - carrots_after_meals -\
    \ carrots_left_after_meals - carrots_after_meals_remaining - carrots_left_after_meals_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining = if (carrots_left\
    \ <= 0) 0 else carrots_left - meals - carrots_after_meals - carrots_left_after_meals\
    \ - carrots_after_meals_remaining - carrots_left_after_meals_remaining - carrots_after_meals_remaining_remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining = if\
    \ (carrots_left <= 0) 0 else carrots_left - meals - carrots_after_meals - carrots_left_after_meals\
    \ - carrots_after_meals_remaining - carrots_left_after_meals_remaining - carrots_after_meals_remaining_remaining\
    \ - carrots_left_after_meals_remaining_remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining\
    \ = if (carrots_left <= 0) 0 else carrots_left - meals - carrots_after_meals -\
    \ carrots_left_after_meals - carrots_after_meals_remaining - carrots_left_after_meals_remaining\
    \ - carrots_after_meals_remaining_remaining - carrots_left_after_meals_remaining_remaining\
    \ - carrots_after_meals_remaining_remaining_remaining\n        val \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp1jiojf89.scala:38:11 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1jiojf89.scala:36:287 -----------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining\e\
    [0m = \e[33mif\e[0m (carrots_left <= \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m\
    \ carrots_left - meals - carrots_after_meals - carrots_left_after_meals - carrots_after_meals_remaining\
    \ - carrots_left_after_meals_remaining - carrots_after_meals_remaining_remaining\
    \ - carrots_left_after_meals_remaining_remaining\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Not found: carrots_left_after_meals_remaining_remaining\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1jiojf89.scala:37:297\
    \ -----------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining\e[0m\
    \ = \e[33mif\e[0m (carrots_left <= \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m\
    \ carrots_left - meals - carrots_after_meals - carrots_left_after_meals - carrots_after_meals_remaining\
    \ - carrots_left_after_meals_remaining - carrots_after_meals_remaining_remaining\
    \ - carrots_left_after_meals_remaining_remaining - carrots_after_meals_remaining_remaining_remaining\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \              "
  stdout: ''
  timestamp: 1659804671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum2 * hungryRemainingSum\n \
    \       val hungryRemainingSum4 = hungryRemainingSum3 * hungryRemainingSum\n \
    \       val hungryRemainingSum5 = hungryRemainingSum4 * hungryRemainingSum\n \
    \       val hungryRemainingSum6 = hungryRemainingSum5 * hungryRemainingSum\n \
    \       val hungryRemainingSum7 = hungryRemainingSum6 * hungryRemainingSum\n \
    \       val hungryRemainingSum8 = hungryRemainingSum7 * hungryRemainingSum\n \
    \       val hungryRemainingSum9 = hungryRemainingSum8 * hungryRemainingSum\n \
    \       val hungryRemainingSum10 = hungryRemainingSum9 * hungryRemainingSum\n\
    \        val hungryRemainingSum11 = hungryRemainingSum10 * hungryRemainingSum\n\
    \        val hungryRemainingSum12 = hungryRemainingSum11 * hungryRemainingSum\n\
    \        val hungryRemainingSum13 = hungryRemainingSum12 * hungryRemainingSum\n\
    \        val hungryRemainingSum14 = hungryRemainingSum13 * hungryRemainingSum\n\
    \        val hungryRemainingSum15 = hungryRemainingSum14 * hungryRemainingSum\n\
    \        val hungryRemainingSum16 = hungryRemainingSum15 * hungryRemainingSum\n\
    \        val hungryRemainingSum17 = hungryRemainingSum16 * hungryRemainingSum\n\
    \        val hungryRemainingSum18 = hungryRemainingSum17 * hungryRemainingSum\n\
    \        val hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpen3uhn2b.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:27:22\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:28:21\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpen3uhn2b.scala:29:30\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpen3uhn2b.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots <= 0\n        val left\
    \  = remaining <= 0\n        if(hungry && left) List(number, need) else eat(carrots,\
    \ need, remaining - carrots)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphlw90ms4.scala:34)\n\tat Problem.main(tmphlw90ms4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804672
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val hungry = carrots > need\n        val eaten = if (hungry) carrots - need\
    \ else 0\n        val left = (remaining + eaten) - carrots\n        if (left <\
    \ 0) List(0) else List(eaten, left)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp72iuymeo.scala:34)\n\tat Problem.main(tmp72iuymeo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        val hungryIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndex = mutable.ArrayBuffer.empty[Long]\n       \
    \ val hungryIndexCountIndexCount = mutable.ArrayBuffer.empty[Long]\n        val\
    \ hungryIndexCountIndexCountIndex = mutable.ArrayBuffer.empty[Long]\n        val\
    \ hungryIndexCountIndexCountIndexCount = mutable.ArrayBuffer.empty[Long]\n   \
    \     val hungryIndexCountIndexCountIndexCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndexCountIndexCountIndexCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndexCountIndexCountIndexCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndexCountIndexCountIndexCountIndexCount = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndex = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsozy61fx.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsozy61fx.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\e\
    [0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndexCountIndex\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsozy61fx.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsozy61fx.scala:28:21 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpsozy61fx.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryIndex\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1659804672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (meals == 0) {\n            List(meals, carrots)\n        } else {\n \
    \           val newRemaining = remaining - meals\n            val newNumber =\
    \ number + meals\n            val newNeed = need + carrots\n            val newResult\
    \ = eat(newNumber, newNeed, newRemaining)\n            result ::: newResult\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.ArrayOps$ArrayIterator.<init>(ArrayOps.scala:125)\n\
    \tat scala.collection.ArrayOps$ArrayIterator$mcJ$sp.<init>(ArrayOps.scala:123)\n\
    \tat scala.collection.immutable.ArraySeq$ofLong.iterator(ArraySeq.scala:541)\n\
    \tat scala.collection.immutable.List.prependedAll(List.scala:151)\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:29)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36)\n\
    \tat Problem$.eat(tmpful8jg7a.scala:36)\n\tat Problem$.eat(tmpful8jg7a.scala:36"
  stdout: ''
  timestamp: 1659804673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrotsRemaining\
    \ = remaining - hungry\n        val hungryMealsRemaining = need - hungry\n   \
    \     val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n        val\
    \ hungryMealsRemainingList = List(hungryMealsRemaining)\n        val hungryCarrotsRemainingList\
    \ = List(hungryCarrotsRemaining)\n        val hungryMealsRemainingList = List(hungryMealsRemaining)\n\
    \        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n     \
    \   val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val hungryCarrotsRemainingList\
    \ = List(hungryCarrotsRemaining)\n        val hungryMealsRemainingList = List(hungryMealsRemaining)\n\
    \        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n     \
    \   val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val hungryCarrotsRemainingList\
    \ = List(hungryCarrotsRemaining)\n        val hungryMealsRemainingList = List(hungryMealsRemaining)\n\
    \        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n     \
    \   val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val hungryCarrotsRemainingList\
    \ = List(hungryCarrotsRemaining)\n        val hungryMealsRemainingList = List(hungryMealsRemaining)\n\
    \        val hungryCarrotsRemainingList = List(hungryCarrotsRemaining)\n     \
    \   val hungryMealsRemainingList = List(hungryMealsRemaining)\n        val hungryCarrotsRemainingList\
    \ = List(hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwmzzxh_v.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwmzzxh_v.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsRemainingList\e[0m = List(hungryCarrotsRemaining)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsRemainingList is already defined as \e[33mvalue\e\
    [0m \e[35mhungryCarrotsRemainingList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwmzzxh_v.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryMealsRemainingList\e\
    [0m = List(hungryMealsRemaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMealsRemainingList is already defined as \e[33mvalue\e\
    [0m \e[35mhungryMealsRemainingList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwmzzxh_v.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsRemainingList\e\
    [0m = List(hungryCarrotsRemaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsRemainingList is already defined as \e[33mvalue\e\
    [0m \e[35mhungryCarrotsRemainingList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwmzzxh_v.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryMealsRemainingList\e\
    [0m = List(hungryMealsRemaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhun"
  stdout: ''
  timestamp: 1659804673
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0, carrots\
    \ - meals)\n        val result = List(meals, leftCarrots)\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnc54seik.scala:34)\n\tat Problem.main(tmpnc54seik.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804674
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    result match {\n            case List(_, _) => result\n            case _\
    \ => eat(number, need, remaining - carrots)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk2xoh_le.scala:36)\n\tat Problem.main(tmpk2xoh_le.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungry = carrots > 0\n        val hungryCarrots = carrots - hungry\n\
    \        val hungryMeals = meals - hungry\n        val hungryRemainingCarrots\
    \ = remainingCarrots - hungry\n        val hungryRemainingMeals = hungryMeals\
    \ - hungryCarrots\n        val hungryRemainingHungryCarrots = hungryRemainingCarrots\
    \ - hungryRemainingMeals\n        val hungryRemainingHungryMeals = hungryRemainingMeals\
    \ - hungryRemainingHungryCarrots\n        val hungryRemainingHungryHungryCarrots\
    \ = hungryRemainingHungryCarrots - hungryRemainingHungryMeals\n        val hungryRemainingHungryHungryMeals\
    \ = hungryRemainingHungryMeals - hungryRemainingHungryHungryCarrots\n        val\
    \ hungryRemainingHungryHungryHungryCarrots = hungryRemainingHungryHungryCarrots\
    \ - hungryRemainingHungryHungryMeals\n        val hungryRemainingHungryHungryHungryMeals\
    \ = hungryRemainingHungryHungryMeals - hungryRemainingHungryHungryHungryCarrots\n\
    \        val hungryRemainingHungryHungryHungryHungryCarrots = hungryRemainingHungryHungryHungryHungryMeals\
    \ - hungryRemainingHungryHungryHungryHungryHungryCarrots\n        val hungryRemainingHungryHungryHungryHun\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjkjjuago.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpjkjjuago.scala:31:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryCarrots\e[0m = carrots - hungry\n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpjkjjuago.scala:32:32 -----------------------------\e[0m\e[0m\n\
    \e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = meals - hungry\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpjkjjuago.scala:33:54 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingCarrots\e\
    [0m = remainingCarrots - hungry\n\e[31m\e[31m   |\e[0m                       \
    \              ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659804674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val mealsLeft = meals - carrots\n      \
    \  val mealsLeftList = List(mealsLeft)\n        val carrotsLeft = carrots - meals\n\
    \        val carrotsLeftList = List(carrotsLeft)\n        val mealsLeftAndCarrotsLeft\
    \ = List(mealsLeft, carrotsLeft)\n        val mealsLeftAndCarrotsLeftList = List(mealsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeft = List(mealsLeftAndCarrotsLeft,\
    \ carrotsLeft)\n        val mealsLeftAndCarrotsLeftAndCarrotsLeftList = List(mealsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAnd\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkos9xpz9.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkos9xpz9.scala:37:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\e[0m = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkos9xpz9.scala:38:75\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\e[0m = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkos9xpz9.scala:39:89\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\e[0m\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- ["
  stdout: ''
  timestamp: 1659804674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remainingCarrots = remaining - carrots\n\
    \        val hungryCarrots = remainingCarrots - meals\n        val hungryCarrotsList\
    \ = List(hungryCarrots)\n        val hungryCarrotsList2 = List(hungryCarrots,\
    \ hungryCarrots)\n        val hungryCarrotsList3 = List(hungryCarrots, hungryCarrots,\
    \ hungryCarrots)\n        val hungryCarrotsList4 = List(hungryCarrots, hungryCarrots,\
    \ hungryCarrots, hungryCarrots)\n        val hungryCarrotsList5 = List(hungryCarrots,\
    \ hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots)\n        val hungryCarrotsList6\
    \ = List(hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots,\
    \ hungryCarrots)\n        val hungryCarrotsList7 = List(hungryCarrots, hungryCarrots,\
    \ hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots)\n\
    \        val hungryCarrotsList8 = List(hungryCarrots, hungryCarrots, hungryCarrots,\
    \ hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots)\n\
    \        val hungryCarrotsList9 = List(hungryCarrots, hungryCarrots, hungryCarrots,\
    \ hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots, hungryCarrots)\n\
    \        val hungryCarrotsList10 = List(hungryCarrots, hungryCarrots, hungryCarrots,\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpom11u8y8.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpom11u8y8.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val remaining = carrots + meals\n      \
    \  val hungry = remaining > 0\n        val eaten = if (hungry) remaining else\
    \ 0\n        val left = (number - eaten) - meals\n        val result = if (hungry)\
    \ List(left, eaten) else List(left, eaten + meals)\n        result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1ptfep9o.scala:29:24 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ + meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804673
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val result = List(meals, carrots)\n    \
    \    if (remaining < need) {\n            val carrots = remaining\n          \
    \  val meals = need - carrots\n            val result = List(meals, carrots)\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqsoltah5.scala:38)\n\tat Problem.main(tmpqsoltah5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804676
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = need - carrots\n        val hungry = carrots > 0\n        val hungryCarrots\
    \ = carrots - hungry\n        val hungryMeals = meals - hungry\n        val hungryCarrots\
    \ = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n     \
    \   val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi72vkao2.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpi72vkao2.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = number - remaining\n       \
    \ val meals = math.max(need - carrots, 0)\n        val hungry = math.max(remaining\
    \ - carrots, 0)\n        val hungryCarrots = math.max(hungry - meals, 0)\n   \
    \     val hungryCarrotsToEat = math.max(hungryCarrots - meals, 0)\n        val\
    \ hungryCarrotsToEatList = List(hungryCarrotsToEat)\n        val hungryCarrotsToEatList2\
    \ = List(hungryCarrotsToEat, hungryCarrotsToEat)\n        val hungryCarrotsToEatList3\
    \ = List(hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat)\n       \
    \ val hungryCarrotsToEatList4 = List(hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat)\n        val hungryCarrotsToEatList5\
    \ = List(hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarro\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqyjqe9jm.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqyjqe9jm.scala:36:503\
    \ -----------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryCarrotsToEatList5\e[0m = List(hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat, hungryCarrotsToEat,\
    \ hungryCarrotsToEat, hungryCarro\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                                 Not found: hungryCarro\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqyjqe9jm.scala:37:5 ---------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer(need)\n        val leftCount = mutable.ArrayBuffer(remaining)\n\
    \        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n        val leftCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val leftCounts = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val leftCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n        val leftCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val leftCounts = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val leftCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n        val leftCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val leftCounts = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val leftCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n        val leftCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val leftCounts = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val leftCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n        val leftCounts\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCounts = mutable.ArrayBuffer.empty[Long]\n\
    \        val leftCounts = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5uhh_jlt.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5uhh_jlt.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCounts\e[0m = mutable.ArrayBuffer.empty[\e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mhungryCounts is already defined as \e[33mvalue\e[0m \e[35mhungryCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5uhh_jlt.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mleftCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftCounts is already defined as \e[33mvalue\e[0m \e[35mleftCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5uhh_jlt.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCounts is already defined as \e[33mvalue\e[0m \e[35mhungryCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5uhh_jlt.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mleftCounts\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftCounts is already defined as \e[33mvalue\e[0m \e[35mleftCounts\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must al"
  stdout: ''
  timestamp: 1659804675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += number\n            carrots_left -= 1\n     \
    \       number -= 1\n        }\n        carrots.takeWhile(_ > 0).reverse.toList\
    \ ++ List(need)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9h2c7ycw.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9h2c7ycw.scala:32:19 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659804675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while (carrots_left > 0) {\n  \
    \          carrots_left -= 1\n            carrots += number\n        }\n     \
    \   carrots.takeWhile(_ < need).takeWhile(_ < remaining).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpedc1cwuq.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // * eat(5, 6, 10) -> [11, 4]\n\
    \    // * eat(4, 8, 9) -> [12, 1]\n    // * eat(1, 10, 10) -> [11, 0]\n    //\
    \ * eat(2, 11, 5) -> [7, 0]\n    // Variables:\n    // @number : integer\n   \
    \ // the number of carrots that you have eaten.\n    // @need : integer\n    //\
    \ the number of carrots that you need to eat.\n    // @remaining : integer\n \
    \   // the number of remaining carrots thet exist in stock\n    // Constrain:\n\
    \    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    // * 0 <= remaining\
    \ <= 1000\n    // Have fun :)\n    def eat(number : Long, need : Long, remaining\
    \ : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        while(number > carrots_left) {\n\
    \            carrots_left -= 1\n            carrots += carrots_left\n        }\n\
    \        carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpimhw3out.scala:27:22 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659804674
