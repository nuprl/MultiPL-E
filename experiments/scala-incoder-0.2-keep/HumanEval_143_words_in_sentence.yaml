name: HumanEval_143_words_in_sentence
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a string representing a sentence,\n    // the sentence contains\
  \ some words separated by a space,\n    // and you have to return a string that\
  \ contains the words from the original sentence,\n    // whose lengths are prime\
  \ numbers,\n    // the order of the words in the new string should be the same as\
  \ the original one.\n    // Example 1:\n    // Input: sentence = \"This is a test\"\
  \n    // Output: \"is\"\n    // Example 2:\n    // Input: sentence = \"lets go for\
  \ swimming\"\n    // Output: \"go for\"\n    // Constraints:\n    // * 1 <= len(sentence)\
  \ <= 100\n    // * sentence contains only letters\n    def wordsInSentence(sentence\
  \ : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(wordsInSentence((\"\
  This is a test\")).equals((\"is\")));\n    assert(wordsInSentence((\"lets go for\
  \ swimming\")).equals((\"go for\")));\n    assert(wordsInSentence((\"there is no\
  \ place available here\")).equals((\"there is no place\")));\n    assert(wordsInSentence((\"\
  Hi I am Hussein\")).equals((\"Hi am Hussein\")));\n    assert(wordsInSentence((\"\
  go for it\")).equals((\"go for it\")));\n    assert(wordsInSentence((\"here\")).equals((\"\
  \")));\n    assert(wordsInSentence((\"here is\")).equals((\"is\")));\n    }\n\n\
  }\n"
completions: ["        val words = sentence.split(\" \").toList\n        val primes\
    \ = words.map(x => x.length)\n        val primesSet = primes.toSet\n        val\
    \ result = primes.filter(x => primesSet.contains(x)).mkString(\" \")\n       \
    \ result", "        val words = sentence.split(\" \")\n        val primes = words.map(_.length).filter(x\
    \ => x > 1 && x % 2 != 0).distinct\n        val result = primes.foldLeft(\"\"\
    )( (acc, prime) => acc + prime + \" \" + words.filter(_.length == prime).mkString(\"\
    \ \"))\n        result", "        val words = sentence.split(\" \")\n        val\
    \ result = new mutable.ListBuffer[String]()\n        for(word <- words) {\n  \
    \          val length = word.length\n            if(length == 2 || length == 3\
    \ || length == 5 || length == 7) {\n                result.add(word)\n       \
    \     }\n        }\n        result.mkString(\" \")", "        val words = sentence.split(\"\
    \ \")\n        val result = new mutable.ListBuffer[String]()\n        for (word\
    \ <- words) {\n            val length = word.length\n            if (isPrime(length))\
    \ {\n                result += word\n            }\n        }\n        result\
    \ mkString \" \"", "        val words = sentence.split(\" \")\n        val primes\
    \ = words.map(_.length).filter(x => x % 2 == 0).toList\n        val result = primes.foldLeft(\"\
    \")((acc, prime) => acc + (prime + \" \"))\n        result", "        val words\
    \ = sentence.split(\" \")\n        val result = new mutable.ListBuffer[String]()\n\
    \        words.foreach(word => {\n            val length = word.length\n     \
    \       val prime = length.toInt\n            val isPrime = true\n           \
    \ for(i <- 2 to prime) {\n                if(length % i == 0) {\n            \
    \        isPrime = false\n                    break\n                }\n     \
    \       }\n            if(isPrime) {\n                result += word\n       \
    \     }\n        })\n        result.mkString(\" \")", "        val words = sentence.split(\"\
    \ \").map(_.toUpperCase)\n        val primes = words.map(_.length).filter(x =>\
    \ x % 2 == 0).map(x => x + 1)\n        val result = primes.filter(x => words.count(y\
    \ => y == x.toString) == primes.count(y => y == x.toString + \" \"))\n       \
    \ words.filter(x => words.count(y => y == x.toString + \" \") == primes.count(y\
    \ => y == x.toString)).mkString(\" \")", "        val words = sentence.split(\"\
    \ \").toList\n        val primes = words.map(_.length).filter(x => x % 2 == 0).distinct\n\
    \        val result = primes.foldLeft(\"\")( (acc, prime) => acc + prime + \"\
    \ \" + words.filter(_.length == prime).mkString(\" \"))\n        result", "  \
    \      val words = sentence.split(\" \").toList\n        val primes = words.map(x\
    \ => prime(x))\n        val result = primes.filter(x => words.count(y => x ==\
    \ y) == 1).mkString(\" \")\n        result", "        val words = sentence.split(\"\
    \ \").map(_.toUpperCase)\n        val primes = words.map(_.length).filter(x =>\
    \ x % 2 == 0).map(x => x * x)\n        val result = primes.filter(x => words.count(_.length\
    \ == x) == primes.length).map(x => words.find(_.length == x).mkString(\" \"))\n\
    \        result.mkString(\" \")", "        val words = sentence.split(\" \").map(_.toUpperCase)\n\
    \        val primes = words.map(_.length)\n        val result = primes.filter(x\
    \ => x % 2 == 0).mkString(\" \")\n        primes.filter(x => x % 2 == 0).mkString(\"\
    \ \")", "        val words = sentence.split(\" \").map(_.toUpperCase)\n      \
    \  val primes = words.map(_.length)\n        val primesSet = primes.toSet\n  \
    \      val result = words.filter(word => primesSet.contains(word.length))\n  \
    \      result.mkString(\" \")", "        val words = sentence.split(\" \").map(_.toUpperCase)\n\
    \        val primes = words.map(_.length).filter(x => x % 2 != 0)\n        val\
    \ result = primes.map(x => words.filter(y => y.length == x).mkString(\" \")).mkString(\"\
    \ \")\n        result", "        val words = sentence.split(\" \").toList\n  \
    \      val primes = words.map(_.length).filter(x => x % 2 == 0).toList\n     \
    \   val result = primes.foldLeft(\"\")( (acc, prime) => acc + words.filter(_.length\
    \ == prime).mkString(\" \"))\n        result", "        val words = sentence.split(\"\
    \ \").filter(_.isLetter).toList\n        val primes = words.map(_.length).filter(x\
    \ => x % 2 != 0).distinct\n        val result = primes.foldLeft(\"\")( (acc, prime)\
    \ => acc + prime + \" \" + words.filter(_.length == prime).mkString(\" \"))\n\
    \        result", "        val words = sentence.split(\" \")\n        val result\
    \ = new mutable.ListBuffer[String]()\n        for(word <- words) {\n         \
    \   val len = word.length\n            val primes = primeFactors(len)\n      \
    \      for(prime <- primes) {\n                if(len % prime == 0) {\n      \
    \              result.add(word)\n                    break\n                }\n\
    \            }\n        }\n        result.mkString(\" \")", "        val words\
    \ = sentence.split(\" \").filter(_.isLetter).toList\n        val primes = words.map(_.length).filter(x\
    \ => x > 1).distinct\n        val result = primes.foldLeft(\"\")((acc, prime)\
    \ => acc + (prime + \" \"))\n        result + words.mkString(\" \")", "      \
    \  val words = sentence.split(\" \").map(_.toInt)\n        val primes = words.filter(x\
    \ => isPrime(x)).map(x => x.toString)\n        val result = primes.mkString(\"\
    \ \")\n        result", "        val words = sentence.split(\" \")\n        val\
    \ result = new mutable.ListBuffer[String]()\n        for(word <- words) {\n  \
    \          val length = word.length\n            if(isPrime(length)) {\n     \
    \           result += (word + \" \")\n            }\n        }\n        result\
    \ mkString \" \"", "        val words = sentence.split(\" \").map(_.toUpperCase)\n\
    \        val primes = words.map(_.length).filter(_.isPrime)\n        val result\
    \ = primes.map(_.toString).mkString(\" \")\n        result"]
stop_tokens:
- "\n    }\n"
