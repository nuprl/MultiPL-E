name: HumanEval_74_total_match
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that accepts two lists of strings and returns the list\
  \ that has \n    // total number of chars in the all strings of the list less than\
  \ the other list.\n    // if the two lists have the same number of chars, return\
  \ the first list.\n    // Examples\n    // total_match([], []) \u279E []\n    //\
  \ total_match(['hi', 'admin'], ['hI', 'Hi']) \u279E ['hI', 'Hi']\n    // total_match(['hi',\
  \ 'admin'], ['hi', 'hi', 'admin', 'project']) \u279E ['hi', 'admin']\n    // total_match(['hi',\
  \ 'admin'], ['hI', 'hi', 'hi']) \u279E ['hI', 'hi', 'hi']\n    // total_match(['4'],\
  \ ['1', '2', '3', '4', '5']) \u279E ['4']\n    def totalMatch(lst1 : List[String],\
  \ lst2 : List[String]) : List[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(totalMatch((List[String]()),\
  \ (List[String]())).equals((List[String]())));\n    assert(totalMatch((List[String](\"\
  hi\", \"admin\")), (List[String](\"hi\", \"hi\"))).equals((List[String](\"hi\",\
  \ \"hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"\
  hi\", \"hi\", \"admin\", \"project\"))).equals((List[String](\"hi\", \"admin\"))));\n\
  \    assert(totalMatch((List[String](\"4\")), (List[String](\"1\", \"2\", \"3\"\
  , \"4\", \"5\"))).equals((List[String](\"4\"))));\n    assert(totalMatch((List[String](\"\
  hi\", \"admin\")), (List[String](\"hI\", \"Hi\"))).equals((List[String](\"hI\",\
  \ \"Hi\"))));\n    assert(totalMatch((List[String](\"hi\", \"admin\")), (List[String](\"\
  hI\", \"hi\", \"hi\"))).equals((List[String](\"hI\", \"hi\", \"hi\"))));\n    assert(totalMatch((List[String](\"\
  hi\", \"admin\")), (List[String](\"hI\", \"hi\", \"hii\"))).equals((List[String](\"\
  hi\", \"admin\"))));\n    assert(totalMatch((List[String]()), (List[String](\"this\"\
  ))).equals((List[String]())));\n    assert(totalMatch((List[String](\"this\")),\
  \ (List[String]())).equals((List[String]())));\n    }\n\n}\n"
completions: ["        lst1 match {\n            case Nil => lst2\n            case\
    \ _ => lst1 ++ lst2.filter(x => lst1.count(_ < x) == lst2.count(_ < x))\n    \
    \    }", "        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.groupBy(x =>\
    \ x).mapValues(_.size)\n        val lst5 = lst4.filter(_._2 < lst3.size)\n   \
    \     lst5.map(_._1)", "        val lst3 = lst1.filterNot(lst2.contains)\n   \
    \     if(lst3.isEmpty) lst1\n        else lst3", "        val lst3 = lst1 ++ lst2\n\
    \        val lst4 = lst3.toSet\n        lst4.filter(_ < lst3.size)", "       \
    \ val lst3 = lst1.filter(_ < lst2)\n        val lst4 = lst2.filter(_ < lst1)\n\
    \        if(lst3.size == lst4.size) lst3\n        else lst4", "        val lst3\
    \ = lst1 ++ lst2\n        val lst4 = lst3.distinct\n        val lst5 = lst4.filter(_\
    \ < lst3.last)\n        lst5.take(lst3.size)", '        lst1.zip(lst2).filter(_._1.length
    < _._2.length).map(_._1)', "        val lst3 = lst1.filterNot(lst2.contains)\n\
    \        if(lst3.isEmpty) lst3\n        else lst3.head :: totalMatch(lst3.tail,\
    \ lst2)", '        lst1.zip(lst2).filter(_._1 < _._2).map(_._1).distinct', " \
    \       lst1 match {\n            case Nil => lst2\n            case _ => lst1\
    \ ++ lst2.filter(x => lst1.count(_ < x) < lst2.count(_ < x))\n        }", "  \
    \      val lst3 = lst1.filterNot(lst2.contains)\n        val lst4 = lst2.filterNot(lst1.contains)\n\
    \        if(lst3.size == lst4.size) lst3\n        else lst4", "        lst1.foldLeft(lst2)((lst1,\
    \ lst2) => {\n            lst1.zip(lst2).filter(_._1 < _._2).map(_._1).distinct\n\
    \        })", "        val lst3 = lst1 ++ lst2\n        val lst4 = lst3.toSet\n\
    \        lst4.filter(_ < lst3.size)", "        val lst3 = lst1.filter(_ < lst2)\n\
    \        val lst4 = lst2.filter(_ < lst1)\n        if (lst3.size == lst4.size)\
    \ lst3\n        else lst4", "        lst1 match {\n            case Nil => lst2\n\
    \            case _ => lst1 ++ lst2.filterNot(lst1.contains)\n        }", "  \
    \      val lst3 = lst1.filterNot(lst2.contains)\n        if(lst3.isEmpty) lst1\n\
    \        else lst3", "        val lst3 = lst1.filterNot(lst2.contains)\n     \
    \   val lst4 = lst2.filterNot(lst1.contains)\n        lst3.length <= lst4.length\
    \ ? lst3 : lst4", "        val lst3 = lst1.filterNot(lst2.contains)\n        val\
    \ lst4 = lst2.filterNot(lst1.contains)\n        if(lst3.size == lst4.size) lst3\n\
    \        else lst4", "        val lst3 = lst1.filterNot(lst2.contains)\n     \
    \   if(lst3.length == lst2.length) lst3\n        else lst1", "        val lst3\
    \ = lst1.filterNot(lst2.contains)\n        if(lst3.length == lst2.length){\n \
    \           return lst3\n        }\n        val lst4 = lst2.filterNot(lst1.contains)\n\
    \        if(lst4.length == lst1.length){\n            return lst4\n        }\n\
    \        val lst5 = lst1.filterNot(lst2.contains)\n        val lst6 = lst2.filterNot(lst1.contains)\n\
    \        if(lst5.length == lst1.length && lst6.length == lst2.length){\n     \
    \       return lst5\n        }\n        lst1"]
stop_tokens:
- "\n    }\n"
