language: scala
name: HumanEval_128_prod_signs
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.zip(magnitudes).map(x => x._1 *\
    \ x._2)\n        magnitudes.map(x => math.abs(x) * product.getOrElse(0))\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8g0dinjc.scala:16:50 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e[0m => math.abs(x) *\
    \ product.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                    \
    \                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \            value getOrElse is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).filter(_._1\
    \ == product).map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphb37e0jn.scala:16:57\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).filter(_._1\
    \ == product).map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[Int]\n\e[31m   |\e[0m        Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.zip(signs).map(x => x._1 * x._2).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj6wjcf1z.scala:20)\n\tat Problem.main(tmpj6wjcf1z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val productMagnitudes = magnitudes.map(x => x * product)\n        val sum\
    \ = productMagnitudes.foldLeft(0L) { (x, y) => x + y }\n        val productSigns\
    \ = signs.map(x => if (x == 1) 1 else 0)\n        val productSignsSum = productSigns.foldLeft(0L)\
    \ { (x, y) => x + y }\n        val productSignsSumMagnitudes = productSignsSum.map(x\
    \ => math.abs(x))\n        val productSignsSumMagnitudesProduct = productSignsSumMagnitudes.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProduct = productSignsSumMagnitudesProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProduct\
    \ = productSignsSumMagnitudesProductProduct.map(x => x * product)\n        val\
    \ productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProduct.map(x => x * product)\n   \
    \     val productSignsSumMagnitudesProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProduct.map(x => x * product)\n\
    \        val productSignsSumMagnitudesProductProductProductProductProduct = productSignsSumMagnitudesProductProductProductProduct.map(x\
    \ => x * product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => x *\
    \ product)\n        val productSignsSumMagnitudesProductProductProductProductProductProduct\
    \ = productSignsSumMagnitudesProductProductProductProductProduct.map(x => \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_ub9lsj3.scala:31:151 --------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mproductSignsSumMagnitudesProductProductProductProductProductProduct\e\
    [0m = productSignsSumMagnitudesProductProductProductProductProduct.map(\e[36mx\e\
    [0m => \n\e[31m\e[31m   |\e[0m                                               \
    \                                                                            \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp_ub9lsj3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mproductSignsSumMagnitudesProductProductProductProduct\e\
    [0m = productSignsSumMagnitudesProductProductProduct.map(\e[36mx\e[0m => x * product)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductSignsSumMagnitudesProductProductProductProduct is already\
    \ defined as \e[33mvalue\e[0m \e[35mproductSignsSumMagnitudesProductProductProductProduct\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_ub9lsj3.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mproductSignsSumMagnitudesProductProductProductProduct\e\
    [0m = productSignsSumMagnitudesProductProductProductProduct.map(\e[36mx\e[0m =>\
    \ x * product)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductSignsSumMagnitudesProductProductProductProduct is already\
    \ defined as \e[33mvalue\e[0m \e[35mproductSignsSumMagnitudesProductProductProductProduct\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must a"
  stdout: ''
  timestamp: 1659795668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.foldLeft(1L) { (x, y) => x * y\
    \ }\n        magnitudes.map(x => x * product).sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm9buggba.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val productSum = product.sum\n        if (productSum\
    \ == 0) None else Some(productSum)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprdeql5zh.scala:19)\n\tat Problem.main(tmprdeql5zh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpymwxu4ao.scala:19)\n\tat Problem.main(tmpymwxu4ao.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, item) => product * item }\n        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_e0ylvqs.scala:20)\n\tat Problem.main(tmp_e0ylvqs.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplr9p4pf8.scala:18)\n\tat Problem.main(tmplr9p4pf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(m * signs)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdx_jwbnd.scala:18)\n\tat Problem.main(tmpdx_jwbnd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpex2fmbx1.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_2fbntc.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign }\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val\
    \ productSigns = signs.map(x => x * product)\n        val productMagnitudes =\
    \ magnitudes.map(x => x * product)\n        val productSum = productSigns.sum\n\
    \        val productProductSigns = productSigns.map(x => x * product)\n      \
    \  val productProductMagnitudes = productMagnitudes.map(x => x * product)\n  \
    \      val productProductSum = productProductSigns.sum\n        val productProductProductSigns\
    \ = productProductSigns.map(x => x * product)\n        val productProductProductMagnitudes\
    \ = productProductMagnitudes.map(x => x * product)\n        val productProductProductSum\
    \ = productProductProductSigns.sum\n        val productProductProductProductSigns\
    \ = productProductProductSigns.map(x => x * product)\n        val productProductProductProductMagnitudes\
    \ = productProductProductMagnitudes.map(x => x * product)\n        val productProductProductProductSum\
    \ = productProductProductProductSigns.sum\n        val productProductProductProductProductSigns\
    \ = productProductProductProductSigns.map(x => x * product)\n        val productProductProductProductMagnitudes\
    \ = productProductProductProductMagnitudes.map(x => x * product)\n        val\
    \ productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductMagnitudes = productProductProductProductMagnitudes.map(x\
    \ => x * product)\n        val productProductProductProductSum = \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpmt39cp0g.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mproductProductProductProductSum\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                             ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmt39cp0g.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mproductProductProductProductMagnitudes\e\
    [0m = productProductProductProductMagnitudes.map(\e[36mx\e[0m => x * product)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductProductProductProductMagnitudes is already defined\
    \ as \e[33mvalue\e[0m \e[35mproductProductProductProductMagnitudes\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmt39cp0g.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mproductProductProductProductSum\e[0m = productProductProductProductProductSigns.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mproductProductProductProductSum is already defined as \e[33mvalue\e\
    [0m \e[35mproductProductProductProductSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmt39cp0g.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mproductProductProductProductProductSigns\e[0m = productProductProductProductProductSigns.map(\e\
    [36mx\e[0m => x * product)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[3"
  stdout: ''
  timestamp: 1659795668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcjwvlos2.scala:20)\n\tat Problem.main(tmpcjwvlos2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkgj95o2h.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_2fbntc.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign }\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkgj95o2h.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x, y) => x * y)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk7e3qkb_.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)((\e\
    [36mx\e[0m, \e[36my\e[0m) => x * y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        magnitudes.zip(productMagnitudes).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6942rg2k.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        magnitudes.zip(productMagnitudes).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        val sign = signs.sum\n        if\
    \ (mag == 0) None else Some(mag * sign)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptsawkj04.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmptsawkj04.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x))\n        val magSum = mag zip signs map { case\
    \ (x, y) => x * y }\n        magSum.sum == sum match {\n            case true\
    \ => Some(sum)\n            case false => None\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2cb72_27.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmp2cb72_27.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        if (sum > 0) Some(sum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoutiukku.scala:19)\n\tat Problem.main(tmpoutiukku.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        val result = mag * sum\n        if (result == 0)\
    \ None else Some(result)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb8fdfnnr.scala:21)\n\tat Problem.main(tmpb8fdfnnr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_38yt1x.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp7_38yt1x.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > 0).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo6agp8v9.scala:17:62\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mOption\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795684
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n        val\
    \ sum = magnitudes.sum\n        if (sum > 0) Some(sum) else None\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp55gd3kqb.scala:20)\n\tat Problem.main(tmp55gd3kqb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.zip(product).map { case (m, p) => m * p }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphny9slln.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map\
    \ { \e[33mcase\e[0m (m, p) => m * p }\n\e[31m\e[31m   |\e[0m                 \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (product\
    \ : Long)\n\e[31m   |\e[0m                       Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmphny9slln.scala:16:55\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map\
    \ { \e[33mcase\e[0m (m, p) => m * p }\n\e[31m\e[31m   |\e[0m                 \
    \                                    ^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload.\
    \ The overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e\
    [0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Int\n\e[31m   |\e[0m (x: Char): Int\n\e[31m   |\e[0m (x: Short): Int\n\e[31m\
    \   |\e[0m (x: Byte): Int\n\e[31m   |\e[0mall match arguments ((p : Nothing))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu_2fbntc.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign }\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitude = arr.map(x => math.abs(x)).foldLeft(1L)\
    \ { (x, y) => x * y }\n        Some(magnitude * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyjomdw41.scala:19)\n\tat Problem.main(tmpyjomdw41.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val magnitudesProduct\
    \ = magnitudes.foldLeft(1L)(_ * _)\n        magnitudesProduct / product\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptxu73fwp.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        magnitudesProduct /\
    \ product\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795686
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsn6x9u5e.scala:20)\n\tat Problem.main(tmpsn6x9u5e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        val productSigns = signs.foldLeft(0L)(_ * _)\n     \
    \   Some(product * productSigns * sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpicmzikv4.scala:21)\n\tat Problem.main(tmpicmzikv4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_38yt1x.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp7_38yt1x.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkgj95o2h.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(1L) { (x, y) => x * y }\n        val result\
    \ = Some(product * sum)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplzvkx0km.scala:21)\n\tat Problem.main(tmplzvkx0km.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val result = magnitudes.map(x => x * product)\n        if (result.sum\
    \ == product) Some(result.sum) else None\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpipaqf6uj.scala:20)\n\tat Problem.main(tmpipaqf6uj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd213052j.scala:20)\n\tat Problem.main(tmpd213052j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.sum\n        val productSigns = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudesSigns = magnitudes.map(x => math.signum(x))\n\
    \        val magnitudesSignsSum = magnitudesSigns.sum\n        val productSignsSum\
    \ = productSigns.sum\n        if (magnitude == 0) {\n            None\n      \
    \  } else if (sum == 0) {\n            None\n        } else if (productSignsSum\
    \ == 0 && magnitudesSignsSum == 0) {\n            None\n        } else if (productSignsSum\
    \ == 0 && magnitudesSignsSum != 0) {\n            None\n        } else if (productSignsSum\
    \ != 0 && magnitudesSignsSum == 0) {\n            None\n        } else if (productSignsSum\
    \ != 0 && magnitudesSignsSum != 0) {\n            Some(product * productSignsSum)\n\
    \        } else {\n            None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0yr0tecy.scala:20:43 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mproductSignsSum\e[0m = productSigns.sum\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value sum is not a member of Long\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp0yr0tecy.scala:21:12 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (magnitude == \e[31m0\e[0m) {\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Not\
    \ found: magnitude\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795689
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        val result = mag if sum == 0 else mag / sum\n \
    \       Some(result)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzbr377b2.scala:17:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mag \e[33mif\e\
    [0m sum == \e[31m0\e[0m \e[33melse\e[0m mag / sum\n\e[31m\e[31m   |\e[0m     \
    \                    ^^\e[0m\n\e[31m   |\e[0m                         end of statement\
    \ expected but 'if' found\n1 error found\n"
  stdout: ''
  timestamp: 1659795685
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).foldLeft(0L)(_ * _)\n        val s = arr.map(x => math.signum(x)).foldLeft(0L)(_\
    \ * _)\n        Some(s * m)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjrdc2e99.scala:18)\n\tat Problem.main(tmpjrdc2e99.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.reduce((x, y) => x + y)\n        val productSign = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudeSign = magnitudes.reduce((x, y) => x + y)\n\
    \        val signsSum = signs.reduce((x, y) => x + y)\n        val signsProduct\
    \ = signs.reduce((x, y) => x * y)\n        val signsSumProduct = signs.reduce((x,\
    \ y) => x + y)\n        val signsProductSign = signs.reduce((x, y) => x * y)\n\
    \        val signsSumProductSign = signs.reduce((x, y) => x + y)\n        val\
    \ signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signsSumProductSign\
    \ = signs.reduce((x, y) => x + y)\n        val signsProductSign = signs.reduce((x,\
    \ y) => x * y)\n        val signsSumProductSign = signs.reduce((x, y) => x + y)\n\
    \        val signsProductSign = signs.reduce((x, y) => x * y)\n        val signs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplxi2zhlg.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplxi2zhlg.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36msignsProductSign\e[0m = signs.reduce((\e[36mx\e[0m, \e[36my\e[0m) => x\
    \ * y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msignsProductSign is already defined as \e[33mvalue\e[0m \e\
    [35msignsProductSign\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplxi2zhlg.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msignsSumProductSign\e[0m\
    \ = signs.reduce((\e[36mx\e[0m, \e[36my\e[0m) => x + y)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msignsSumProductSign is already defined as \e[33mvalue\e[0m \e[35msignsSumProductSign\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplxi2zhlg.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36msignsProductSign\e[0m = signs.reduce((\e\
    [36mx\e[0m, \e[36my\e[0m) => x * y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msignsProductSign is already defined as \e[33mvalue\e[0m \e\
    [35msignsProductSign\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplxi2zhlg.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msignsSumProductSign\e[0m\
    \ = signs.reduce((\e[36mx\e[0m, \e[36my\e[0m) => x + y)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msignsSumProductSign is al"
  stdout: ''
  timestamp: 1659795689
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd213052j.scala:20)\n\tat Problem.main(tmpd213052j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9f61mdvq.scala:20)\n\tat Problem.main(tmp9f61mdvq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x => x._1\
    \ * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfmd_0uf4.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Long)\n\e[31m\
    \   |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmpfmd_0uf4.scala:16:46 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \ (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\
    \e[31m   |\e[0m (x: Short): Int\n\e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpfmd_0uf4.scala:16:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2).sum\n\e[31m\e[31m   |\e[0m                                         \
    \                ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1659795691
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.product\n        Some(signs.map(x => x * product).sum\
    \ / m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpltu1dclp.scala:19)\n\tat Problem.main(tmpltu1dclp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795693
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpneltlco9.scala:18)\n\tat Problem.main(tmpneltlco9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(1L) { (x, y) => x * y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptr765165.scala:20)\n\tat Problem.main(tmptr765165.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795693
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        Some(mag)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboanfsvl.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpboanfsvl.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795704
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x, y) => x * y)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk7e3qkb_.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)((\e\
    [36mx\e[0m, \e[36my\e[0m) => x * y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd213052j.scala:20)\n\tat Problem.main(tmpd213052j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_4zqzbs.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795703
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x\
    \ * product).sum / m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1u72atdv.scala:19)\n\tat Problem.main(tmp1u72atdv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(product * sum)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph9ona70r.scala:20)\n\tat Problem.main(tmph9ona70r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795708
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x == 0) -1 else if (x == 1) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x => x._1\
    \ * x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphrnjknxx.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Found:    (product : Long)\n\e[31m\
    \   |\e[0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E051] Reference Error: /tmp/tmphrnjknxx.scala:16:46 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map(\e[36mx\e[0m => x._1\
    \ * x._2)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m\
    \ (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\
    \e[31m   |\e[0m (x: Short): Int\n\e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e\
    [0mall match arguments ((x._2 : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpneltlco9.scala:18)\n\tat Problem.main(tmpneltlco9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwleq7zls.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      magnitudes.zip(signs).map(x => x._1 * x._2).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd1sk3pyy.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795708
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).reduce(_ * _)\n        val s = arr.map(x => math.signum(x)).reduce(_\
    \ * _)\n        Some(m * s)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpitr21c61.scala:18)\n\tat Problem.main(tmpitr21c61.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val\
    \ productOfSigns = signs.foldLeft(1L) { (product, value) => product * value }\n\
    \        val productOfMagnitudes = magnitudes.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val productOfSums = magnitudes.foldLeft(1L) {\
    \ (product, value) => product * value }\n        val productOfProductOfSigns =\
    \ signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfSums = magnitudes.foldLeft(1L) { (product, value) => product\
    \ * value }\n        val productOfProductOfProductOfSigns = signs.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val productOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfSums = magnitudes.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val productOfProductOfProductOfProductOfSigns\
    \ = signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfProductOfSums = magnitudes.foldLeft(1L) { (product,\
    \ value) => product * value }\n        val productOfProductOfProductOfProductOfProductOfSigns\
    \ = signs.foldLeft(1L) { (product, value) => product * value }\n        val productOfProductOfProductOfProductOfProductOfMagnitudes\
    \ = magnitudes.foldLeft(1L) { (product, value) => product * value }\n        val\
    \ productOfProductOfProductOfProductOfProductOfSums = magnitudes.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val productOfProductOfProduct\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp8vzhu5c.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpp8vzhu5c.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795710
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(_.signum).sum\n        Some(m * signs)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdx_jwbnd.scala:18)\n\tat Problem.main(tmpdx_jwbnd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.map(x => x * product).sum\n        if (result > 0) Some(result)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptonk36xi.scala:20)\n\tat Problem.main(tmptonk36xi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val result = magnitudes.foldLeft(product) { (x, y) => x * y }\n       \
    \ Some(result)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpahm92l4s.scala:20)\n\tat Problem.main(tmpahm92l4s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        Some(mag)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboanfsvl.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpboanfsvl.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) {\n            (acc, x) => acc * x\n        }\n        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(product)\
    \ {\n            (acc, x) => acc * x\n        }\n        Some(sum)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoczgyt1m.scala:24)\n\tat Problem.main(tmpoczgyt1m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(s * m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx8ayxabh.scala:18)\n\tat Problem.main(tmpx8ayxabh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwleq7zls.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).foldLeft(0)(_ * _)\n        val s = arr.map(x => math.signum(x)).foldLeft(0)(_\
    \ * _)\n        Some(m * s)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp65uwarns.scala:13:54\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mm\e\
    [0m = arr.map(\e[36mx\e[0m => math.abs(x)).foldLeft(\e[31m0\e[0m)(_ * _)\n\e[31m\e\
    [31m   |\e[0m                                                      ^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                      Found:  \
    \  Long\n\e[31m   |\e[0m                                                     \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp65uwarns.scala:14:57\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36ms\e\
    [0m = arr.map(\e[36mx\e[0m => math.signum(x)).foldLeft(\e[31m0\e[0m)(_ * _)\n\e\
    [31m\e[31m   |\e[0m                                                         ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppmyo_9dx.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(s * m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx8ayxabh.scala:18)\n\tat Problem.main(tmpx8ayxabh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) => product * value }\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val result = magnitudes.zip(product).map(x\
    \ => x._1 * x._2)\n        if (result.isEmpty) None else Some(result.sum)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppsmah0c_.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = magnitudes.zip(product).map(\e[36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m \
    \  |\e[0m                                    ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                 Found:    (product : Long)\n\e[31m   |\e[0m\
    \                                    Required: IterableOnce[Any]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmppsmah0c_.scala:16:59 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitudes.zip(product).map(\e\
    [36mx\e[0m => x._1 * x._2)\n\e[31m\e[31m   |\e[0m                            \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m\
    \ \e[35mInt\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Int\n\e[31m   |\e[0m (x: Char): Int\n\e[31m   |\e[0m (x: Short): Int\n\e[31m\
    \   |\e[0m (x: Byte): Int\n\e[31m   |\e[0mall match arguments ((x._2 : => Nothing))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x)).map(math.abs)\n   \
    \     magnitudes.foldLeft(product)(_ * _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmvbij4os.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpovswvxyc.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpovswvxyc.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem }\n        val signs =\
    \ arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm3y43d2i.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign }\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.foldLeft(product)(_\
    \ * _)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpogf1hwjz.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        val result = if (magnitude == 0) None\
    \ else Some(magnitude * product)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpazpstnv5.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (magnitude == \e[31m0\e[0m) None \e[33melse\e[0m Some(magnitude * product)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         Not found: magnitude\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpazpstnv5.scala:17:56 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (magnitude == \e[31m0\e[0m) None \e[33melse\e[0m Some(magnitude * product)\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Not found:\
    \ magnitude\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.foldLeft(product)(_\
    \ * _)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpogf1hwjz.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.foldLeft(product)(_\
    \ * _)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpogf1hwjz.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_38yt1x.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp7_38yt1x.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795688
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd213052j.scala:20)\n\tat Problem.main(tmpd213052j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpneltlco9.scala:18)\n\tat Problem.main(tmpneltlco9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795692
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val magnitude\
    \ = product.map(x => math.abs(x)).sum\n        val result = if (magnitude == 0)\
    \ None else Some(sum / magnitude)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpje6gh7b5.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpje6gh7b5.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mLongIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795714
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzbyrzv27.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).filter(_._1\
    \ == _._2).map(_._2)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (product : Int)\n\e[31m   |\e\
    [0m                       Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzbyrzv27.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).filter(_._1 == _._2).map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                       value _1 is not a member of Long\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ productMagnitudes = magnitudes.map(x => x * product)\n        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > 0).map(_._1).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppurkckk2.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        magnitudes.zip(productMagnitudes).filter(_._2\
    \ > \e[31m0\e[0m).map(_._1).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795724
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5g0ljmk.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Int\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, value) =>\n            product * math.signum(value)\n\
    \        }\n        val magnitudes = arr.map(math.abs)\n        val signs = magnitudes.map(math.signum)\n\
    \        magnitudes.zip(signs).map { case (magnitude, sign) =>\n            magnitude\
    \ * sign\n        }.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi8xwf0by.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        magnitudes.zip(signs).map\
    \ { \e[33mcase\e[0m (magnitude, sign) =>\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m19 |\e[0m            magnitude * sign\n\e[31m20 |\e[0m        }.sum\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7_38yt1x.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp7_38yt1x.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795688
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x))\n        mag match {\n            case Nil =>\
    \ None\n            case x :: xs => Some(sum * math.prod(x))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgqatb9vx.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpgqatb9vx.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1sdxf744.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1sdxf744.scala:16:8 ---------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m \
    \       Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.sum\
    \ * product\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz0b1e8sm.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum * product\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    Int\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(arr.map(x => x * m * s).sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcv9ngtpl.scala:18)\n\tat Problem.main(tmpcv9ngtpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        Some(mag)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboanfsvl.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpboanfsvl.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795704
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 0 => None\n            case x => Some(sum /\
    \ mag)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2itj9tbl.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmp2itj9tbl.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(sum * product)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyp_siqfg.scala:20)\n\tat Problem.main(tmpyp_siqfg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795734
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.product\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo3ddv32u.scala:20)\n\tat Problem.main(tmpo3ddv32u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795735
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 1 => Some(sum)\n            case x if x ==\
    \ -1 => Some(-sum)\n            case _ => None\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplqa2j50i.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmplqa2j50i.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ 1).sum\n        Some(signs * product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyibljv23.scala:18)\n\tat Problem.main(tmpyibljv23.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.sum\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ke8in9a.scala:20)\n\tat Problem.main(tmp6ke8in9a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795735
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9f61mdvq.scala:20)\n\tat Problem.main(tmp9f61mdvq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795691
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(product).map{\
    \ case (mag, prod) => mag * prod }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9e06gaje.scala:16:23\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map{\
    \ \e[33mcase\e[0m (mag, prod) => mag * prod }\n\e[31m\e[31m   |\e[0m         \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Found:    (product\
    \ : Int)\n\e[31m   |\e[0m                       Required: IterableOnce[Any]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp9e06gaje.scala:16:61\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(product).map{\
    \ \e[33mcase\e[0m (mag, prod) => mag * prod }\n\e[31m\e[31m   |\e[0m         \
    \                                                ^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mall match arguments ((prod\
    \ : Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795734
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(arr.map(x => x * m / s).sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpod9ze796.scala:18)\n\tat Problem.main(tmpod9ze796.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x))\n        val magSum = mags.sum\n        if (magSum > sum) Some(magSum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdfw93p29.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmagSum\e[0m = mags.sum\n\
    \e[31m\e[31m   |\e[0m                     ^^^^\e[0m\n\e[31m   |\e[0m         \
    \            Not found: mags\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).getOrElse(None)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv_4zqzbs.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e[0m => x * product).getOrElse(None)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        value getOrElse is not a member of List[Long]\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659795703
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x)).filter(x => x >= 0)\n\
    \        magnitudes.foldLeft(product)(_ * _)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7f2ne4ox.scala:16:36\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795734
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x\
    \ * product).sum / m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1u72atdv.scala:19)\n\tat Problem.main(tmp1u72atdv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        Some(mag)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpboanfsvl.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpboanfsvl.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795704
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        val result\
    \ = Some(magnitude * product)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw7q58nhg.scala:20)\n\tat Problem.main(tmpw7q58nhg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795736
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * x).sum\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_v7p04t1.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795734
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L) { (x, y) => x * y }\n        Some(signs.map(x\
    \ => x * product).sum / m)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprapbpq_u.scala:19)\n\tat Problem.main(tmprapbpq_u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwleq7zls.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L) { (x, y) => x * y }\n        Some(signs.map(x\
    \ => x * product).sum / m)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprapbpq_u.scala:19)\n\tat Problem.main(tmprapbpq_u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwleq7zls.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplr9p4pf8.scala:18)\n\tat Problem.main(tmplr9p4pf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        val result = if (magnitude == 0) None\
    \ else Some(magnitude * product)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpazpstnv5.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (magnitude == \e[31m0\e[0m) None \e[33melse\e[0m Some(magnitude * product)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         Not found: magnitude\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpazpstnv5.scala:17:56 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (magnitude == \e[31m0\e[0m) None \e[33melse\e[0m Some(magnitude * product)\n\
    \e[31m\e[31m   |\e[0m                                                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Not found:\
    \ magnitude\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpovswvxyc.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpovswvxyc.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795713
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x\
    \ * product).sum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7hwnekmg.scala:19)\n\tat Problem.main(tmp7hwnekmg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795736
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        Some(sum * product)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpssm8fa9p.scala:20)\n\tat Problem.main(tmpssm8fa9p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795737
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5g0ljmk.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Int\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0)).sum\n\
    \        Some(product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz07k8a3u.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0\e[0m)).sum\n\e[31m\e[31m   |\e\
    [0m                                         ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmpz07k8a3u.scala:15:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0\e[0m)).sum\n\e[31m\e[31m   |\e\
    [0m                                                                     ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mCharIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795744
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val magnitudesProduct\
    \ = magnitudes.foldLeft(1L)(_ * _)\n        magnitudesProduct / product\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptxu73fwp.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        magnitudesProduct /\
    \ product\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795686
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.foldLeft(0L) { (x, y) => x + y }\n        Some(sum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcjwvlos2.scala:20)\n\tat Problem.main(tmpcjwvlos2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplr9p4pf8.scala:18)\n\tat Problem.main(tmplr9p4pf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        Some(signs.map(x => x * product).sum)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwi7ok_c3.scala:18)\n\tat Problem.main(tmpwi7ok_c3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 0 => Some(sum)\n            case x => Some(sum\
    \ - mag)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzn702w76.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpzn702w76.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => product * x)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkgra6wc3.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => product * x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mOption\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795746
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x))\n        val result = mag zip sum\n        result.find(_._1\
    \ == 0)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4blkptla.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmp4blkptla.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4blkptla.scala:18:19 --------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        result.find(_._1 == \e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Option[(Int, Nothing)]\n\e[31m   |\e[0m        Required: Option[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795749
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)\
    \ { (x, y) => x * y }\n        val magnitudes = arr.map(x => math.abs(x))\n  \
    \      val sum = magnitudes.sum\n        val result = if (sum > 0) product / sum\
    \ else product\n        Some(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpducldb6t.scala:21)\n\tat Problem.main(tmpducldb6t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt76n0x_m.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpt76n0x_m.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 0 => Some(sum)\n            case x if x > 0\
    \ => Some(sum - mag)\n            case x if x < 0 => Some(sum + mag)\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpap7rq26k.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpap7rq26k.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        mag match {\n            case 0 =>\
    \ None\n            case x if x == 1 => Some(sum)\n            case x if x ==\
    \ -1 => Some(-sum)\n            case _ => Some(math.abs(sum))\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1nec7xa.scala:14:45 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e\
    [36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                      value getOrElse is not a member of List[Int]\n\e[31m\e\
    [31m-- Error: /tmp/tmpl1nec7xa.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659795750
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduce(_ + _)\n        Some(product * sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd213052j.scala:20)\n\tat Problem.main(tmpd213052j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpex2fmbx1.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce((x,\
    \ y) => x * y)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ahcnrz0.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0))\n\
    \        val sum = product.sum\n        val productSigns = product.map(x => if\
    \ (x == 0) 1 else 0)\n        Some(sum * productSigns.sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe5jp1mi4.scala:15:52 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = signs.map(\e\
    [36mx\e[0m => x * magnitudes.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m \
    \                                        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value getOrElse is not a member of List[Long]\n\e\
    [31m\e[31m-- Error: /tmp/tmpe5jp1mi4.scala:16:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mLongIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659795752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val result = Some(sum * product)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp266e_0da.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Some[Int])\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwleq7zls.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795707
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppmyo_9dx.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795709
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplr9p4pf8.scala:18)\n\tat Problem.main(tmplr9p4pf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val result\
    \ = magnitudes.foldLeft(product)(_ * _)\n        Some(result)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpldjux1ai.scala:20)\n\tat Problem.main(tmpldjux1ai.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(_.signum).sum\n        Some(m * s)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplr9p4pf8.scala:18)\n\tat Problem.main(tmplr9p4pf8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L) { (product, elem) => product * elem}\n        val signs = arr.map(elem\
    \ => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign}\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd26r_3n8.scala:15:32\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)\
    \ { (\e[36mproduct\e[0m, \e[36msign\e[0m) => product * sign}\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs(x))\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        Some(mag * sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkvj3u89k.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mproduct\e\
    [0m = arr.map(\e[36mx\e[0m => x * signs(x))\n\e[31m\e[31m   |\e[0m           \
    \                                  ^\e[0m\n\e[31m   |\e[0m                   \
    \                          Found:    (x : Long)\n\e[31m   |\e[0m             \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp88t7ev0m.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795690
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaxngqrwf.scala:20)\n\tat Problem.main(tmpaxngqrwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.product\n        if (product == 0) None else Some(signs.map(x\
    \ => x * m).sum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpep1xkwea.scala:19)\n\tat Problem.main(tmpep1xkwea.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ * _)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpex2fmbx1.scala:15:31\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        signs.foldLeft(product)(_\
    \ * _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.reduceLeft(_ + _)\n        val productSign = signs.reduceLeft(_ *\
    \ _)\n        val magnitudeSigns = magnitudes.map(x => math.signum(x))\n     \
    \   val magnitudeSum = magnitudes.reduceLeft(_ + _)\n        val magnitudeProductSign\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x))\n        val magnitudeProductSignSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x))\n\
    \        val magnitudeProductSignProduct = magnitudes.map(x => math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.signum(x) + math.signum(x)\
    \ * math.signum(x) * math.signum(x))\n        val magnitudeProductSignProductSum\
    \ = magnitudes.map(x => math.signum(x) * math.signum(x) * math.sig\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6isizm86.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6isizm86.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmagnitudeProductSignProductSum\e[0m = magnitudes.map(\e[36mx\e[0m => math.signum(x)\
    \ * math.signum(x) * math.signum(x) + math.signum(x) * math.signum(x) * math.signum(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmagnitudeProductSignProductSum is already defined as \e[33mvalue\e\
    [0m \e[35mmagnitudeProductSignProductSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6isizm86.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmagnitudeProductSignProductSum\e\
    [0m = magnitudes.map(\e[36mx\e[0m => math.signum(x) * math.signum(x) * math.signum(x)\
    \ + math.signum(x) * math.signum(x) * math.signum(x))\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmagnitudeProductSignProductSum is already defined as \e[33mvalue\e\
    [0m \e[35mmagnitudeProductSignProductSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6isizm86.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmagnitudeProductSignProductSum\e\
    [0m = magnitudes.map(\e[36mx\e[0m => math.signum(x) * math.signum(x) * math.signum(x)\
    \ + math.signum(x) * math.signum(x) * math.signum(x))\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659795754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.getOrElse(0))\n        val sum = product.sum\n        val mag =\
    \ product.map(x => math.abs(x)).sum\n        val result = mag if sum == 0 else\
    \ mag / sum\n        Some(result)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpypwtskvt.scala:17:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mag \e[33mif\e\
    [0m sum == \e[31m0\e[0m \e[33melse\e[0m mag / sum\n\e[31m\e[31m   |\e[0m     \
    \                    ^^\e[0m\n\e[31m   |\e[0m                         end of statement\
    \ expected but 'if' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpypwtskvt.scala:14:45\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mproduct\e[0m = arr.map(\e[36mx\e[0m => x * signs.getOrElse(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            value getOrElse is not a member\
    \ of List[Int]\n\e[31m\e[31m-- Error: /tmp/tmpypwtskvt.scala:15:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = product.sum\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x._1 * x._2).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4l0pg3mh.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e\
    [36mx\e[0m => x._1 * x._2).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n    \
    \    Some(m * s)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7crqweb0.scala:18)\n\tat Problem.main(tmp7crqweb0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795712
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitude = arr.map(x => math.abs(x)).sum\n        Some(magnitude\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpto95o31t.scala:19)\n\tat Problem.main(tmpto95o31t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795669
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        Some(product * sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_99z7i_l.scala:20)\n\tat Problem.main(tmp_99z7i_l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt76n0x_m.scala:16:41 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of (Long, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpt76n0x_m.scala:16:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        magnitudes.zip(signs).map(\e[36mx\e[0m => x *\
    \ product).sum\n\e[31m\e[31m   |\e[0m                                        \
    \               ^\e[0m\n\e[31m   |\e[0m          No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          where:    B is a type variable\
    \ with constraint <: Option[Long]\n\e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1659795750
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduceLeft(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = magnitudes.map(x => x * product)\n        productMagnitudes.sum\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzxd23vs1.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        productMagnitudes.sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        val mag2 = mag * mag\n        if (mag2 == 0) None\
    \ else Some(sum / mag2)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeyaxb_gh.scala:21)\n\tat Problem.main(tmpeyaxb_gh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659795754
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given an array arr of integers and you need to return\n  \
    \  // sum of magnitudes of integers multiplied by product of all signs\n    //\
    \ of each number in the array, represented by 1, -1 or 0.\n    // Note: return\
    \ None for empty arr.\n    // Example:\n    // >>> prod_signs([1, 2, 2, -4]) ==\
    \ -9\n    // >>> prod_signs([0, 1]) == 0\n    // >>> prod_signs([]) == None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x\
    \ => x * product).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp21rmqamv.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * product).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659795667
