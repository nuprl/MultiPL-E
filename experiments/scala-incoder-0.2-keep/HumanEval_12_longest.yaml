name: HumanEval_12_longest
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n    // strings of the same length. Return None in case the input\
  \ list is empty.\n    // >>> longest([])\n    // >>> longest(['a', 'b', 'c'])\n\
  \    // 'a'\n    // >>> longest(['a', 'bb', 'ccc'])\n    // 'ccc'\n    def longest(strings\
  \ : List[String]) : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(longest((List[String]())).equals(None));\n\
  \    assert(longest((List[String](\"x\", \"y\", \"z\"))).equals(\"x\"));\n    assert(longest((List[String](\"\
  x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"))).equals(\"zzzz\"));\n    }\n\
  \n}\n"
completions: ["        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \") {\n            case (acc, s) => if (acc.length < s.length) acc else s}", " \
    \       strings.foldLeft(Option(\"No strings\")) {\n            (maxLength, string)\
    \ =>\n                maxLength match {\n                    case Some(maxLength)\
    \ if string.length >= maxLength => Some(string)\n                    case Some(maxLength)\
    \ if string.length < maxLength => Some(string.substring(0, maxLength))\n     \
    \               case _ => maxLength\n                }\n        }", "        if\
    \ (strings.length == 0) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(Option.empty[String]) { (longest, s) =>\n\
    \            val len = s.length\n            if (len > longest.get || len == 0)\n\
    \                Some(s)\n            else\n                longest\n        }",
  "        strings.foldLeft(List[String]()){\n            case (acc, s) => acc match\
    \ {\n                case Nil => List(s)\n                case _ => if (acc.length\
    \ < s.length) acc else List(s)\n            }\n        }.maxBy(_.length)", " \
    \       if (strings.isEmpty) None\n        else strings.sortWith(_ < _).lastOption",
  '        strings.foldLeft(List[String]())((list, s) => if (list.length < s.length)
    list :+ s else list)', "        strings.foldLeft(List[String]()){\n          \
    \  case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  "        strings.foldLeft(List[String]()){ (list, s) =>\n            if (list.size\
    \ < s.length) list :+ s\n            else s\n        }.maxBy(_.length)", "   \
    \     if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            strings.find(s => s == longest) else\
    \ None\n        }", "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, str) => {\n            if (list.isEmpty\
    \ || list.length < str.length) list :+ str\n            else list\n        })\n\
    \            .maxBy(_.length)", "        strings.foldLeft(Option(\"No strings\"\
    )) {\n            (acc, s) => acc.map(_ => s).find(_.length == acc.head.length).getOrElse(acc.head)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            Some(longest)\n        }",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length) a else\
    \ b )\n            strings.find(s => s == longest).map(s => longest)\n       \
    \ }", "        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)\
    \ acc else s :: acc)\n            .maxBy(_.length)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())(\n            list => list.foldLeft(List[String]())(\n\
    \                list => list.foldLeft(List[String]())(\n                    list\
    \ => list.foldLeft(List[String]())(\n                        list => list.foldLeft(List[String]())(\n\
    \                            list => list.foldLeft(List[String]())(\n        \
    \                        list => list.foldLeft(List[String]())(\n            \
    \                        list => list.foldLeft(List[String]())(\n            \
    \                            list => list.foldLeft(List[String]())(\n        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                        list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \    list => list.foldLeft(List[String]())(\n                                \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \            list => list.foldLeft(List[String]())(\n                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                    list => list.foldLeft(List[String]())(\n                \
    \                                                                            \
    \        list => list.foldLeft(List[String]())(\n                            \
    \                                                                            list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                    list => list.foldLeft(List[String]())(\n",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => acc match {\n            case Nil => Some(s)\n            case _ => if\
    \ (acc.length < s.length) Some(s) else acc\n        })", "        strings.foldLeft(None)\
    \ {\n            case (Some(longest), s) =>\n                val len = s.length\n\
    \                if (len > longest.length)\n                    Some(s)\n    \
    \            else\n                    longest\n            case _ => None\n \
    \       }", '        strings.sortWith(_ < _).lastOption', "        strings.foldLeft(None)\
    \ { (longest, s) =>\n            if (longest == None) Some(s) else longest.map(x\
    \ => if (x.length > s.length) x else s)\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .sortWith((a, b) => a.length <= b.length)\n  \
    \          .lastOption", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => {\n       \
    \         if (acc.length < s.length) acc else s\n            })\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(None)\
    \ {\n            case (Some(longest), s) => if (s.length() > longest.length) Some(s)\
    \ else longest\n            case _ => None\n        }", '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        strings.foldLeft(None)\
    \ { (max, str) =>\n            if (str.length >= max.getOrElse(0) && str.length\
    \ > 0) Some(str) else max\n        }", "        strings.length match {\n     \
    \       case 0 => None\n            case 1 => Some(strings.head)\n           \
    \ case _ =>\n                val longest = strings.foldLeft(\"\")(_ + _.length)\n\
    \                strings.find(_.length == longest).map(_.head)\n        }", " \
    \       if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.isEmpty) None\n \
    \       else strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc\
    \ else s)", "        if (strings.length == 0) None\n        else {\n         \
    \   val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, s) => {\n      \
    \      if (list.length < s.length) list :+ s\n            else list\n        })\n\
    \            .maxBy(_.length)", "        strings.foldLeft(None) { (max, s) =>\n\
    \            val len = s.length\n            if (len > max.getOrElse(len)) {\n\
    \                Some(s)\n            } else {\n                max\n        \
    \    }\n        }", "        strings.length match {\n            case 0 => None\n\
    \            case 1 => Some(strings.head)\n            case _ => {\n         \
    \       val longest = strings.foldLeft(\"\")(_ + _.length).length\n          \
    \      strings.find(_.length == longest).map(_.head)\n            }\n        }",
  "        strings.foldLeft(List[String]())((list, s) => {\n            if (list.exists(_.length\
    \ == s.length)) {\n                list :+ s\n            } else {\n         \
    \       list\n            }\n        })", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.sortWith(_ < _).last\n            strings.find(s => s.size == longest.size).getOrElse(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(Option(\"\
    no strings\")) {\n            case (Some(longest), s) =>\n                val\
    \ len = s.length\n                if (len > longest.length) Some(s) else None\n\
    \            case (None, s) => Some(s) }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.sortWith(_ < _).last\n    \
    \        if (longest.length == strings.length) Some(longest)\n            else\
    \ longest.headOption\n        }", '        strings.sortWith(_.length < _.length).lastOption',
  "        strings.foldLeft(List[String]())((list, str) => {\n            if (list.length\
    \ < str.length) list :+ str\n            else str\n        })", '        strings.sortWith(_
    < _).lastOption', "        if (strings.length == 0) None\n        else {\n   \
    \         val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => if (acc.length < s.length) acc :+ s else acc\n        }.maxBy(_.length)",
  '        strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length)
    acc else s)', "        strings.foldLeft(List[String]())((list, str) => {\n   \
    \         if (list.length < str.length) {\n                list :+ str\n     \
    \       } else {\n                list\n            }\n        }).maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            longest.length == strings.length ? Some(longest)\
    \ : longest.headOption\n        }", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else strings.foldLeft(strings(0))(\
    \ (s, t) => if (s.length < t.length) s else t)", "        if (strings.length ==\
    \ 0) None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", "        strings.foldLeft(None) {\n\
    \            case (Some(longest), s) =>\n                val length = s.length\n\
    \                if (length > longest.length)\n                    Some(s)\n \
    \               else\n                    longest\n            case _ => None\n\
    \        }", "        strings.foldLeft(None) {\n            case (Some(longest),\
    \ s) =>\n                val l = s.length\n                if (l > longest.length)\
    \ Some(s) else None\n            case (None, s) => Some(s) }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    if (acc.length < s.length) acc else s\n\
    \                })\n                Some(longest)\n            }\n        }",
  "        if (strings.length == 0) None\n        else {\n            var maxLength\
    \ = 0\n            var maxString = \"\"\n            for (s <- strings) {\n  \
    \              if (s.length >= maxLength) {\n                    maxString = s\n\
    \                    maxLength = s.length\n                }\n            }\n\
    \            Some(maxString)\n        }", "        strings.foldLeft(List[String]())(\
    \ (list, str) => list match {\n            case Nil => Some(str)\n           \
    \ case head :: tail => if (head.length == str.length) head :: list else list\n\
    \        })", "        strings.foldLeft(Option(\"No strings\")) {\n          \
    \  case (Some(longest), s) =>\n                val len = s.length\n          \
    \      if (len > longest.length)\n                    (Some(s), len)\n       \
    \         else\n                    (None, len)\n        }.headOption", "    \
    \    if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            Some(longest)\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  '        strings.foldLeft(List[String]())((list, s) => if (list.length < s.length)
    list :+ s else list)', "        strings.length match {\n            case 0 =>\
    \ None\n            case 1 => Some(strings.head)\n            case _ => {\n  \
    \              val longest = strings.foldLeft(\"\")( (acc, s) => {\n         \
    \           if (acc.length < s.length) acc else s\n                })\n      \
    \          Some(longest)\n            }\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", "        if (strings.length == 0)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (a,\
    \ b) => if (a.length < b.length) a else b )\n            strings.find(s => s ==\
    \ longest).getOrElse(longest)\n        }", "        if (strings.length == 0) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)\n            Some(longest)\n        }",
  "        strings.foldLeft(List[String]())( (list, str) => list match {\n       \
    \     case Nil => Some(str)\n            case list :: tail => if (str.length ==\
    \ list.length) str else list\n        })", "        if (strings.isEmpty) None\n\
    \        else {\n            val longest = strings.foldLeft(\"\")( (a,b) => if\
    \ (a.length < b.length) a else b )\n            strings.find(s => s == longest)\
    \ match {\n                case Some(longest) => Some(longest)\n             \
    \   case None => None\n            }\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(List[String]())((acc, s) => if\
    \ (acc.length < s.length) acc else s)\n            longest.headOption\n      \
    \  }", "        strings.foldLeft(List[String]())((acc, s) => {\n            if\
    \ (acc.length < s.length) acc :+ s\n            else Some(s)\n        })", " \
    \       if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(None)( (longest, string) => {\n       \
    \     if (longest.isEmpty || string.length == longest.get + 1) {\n           \
    \     Some(string)\n            } else {\n                longest\n          \
    \  }\n        })", "        strings.foldLeft(Option.empty[String]){\n        \
    \    case (Some(longest), s) =>\n                if (s.length() > longest.length)\
    \ Some(s) else None\n            case (None, _) => None\n        }", "       \
    \ if (strings.isEmpty) None\n        else strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)", "        strings.sortWith(_ < _)\n\
    \            .lastOption\n            .orElse(None)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((acc, s) => if (acc.length\
    \ < s.length) acc else s :: acc)\n            .maxBy(s => s.length)", "      \
    \  if (strings.length == 0) None\n        else {\n            val longest = strings.sortWith(_\
    \ < _).last\n            if (longest.length == strings.length) Some(longest)\n\
    \            else longest.headOption\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.sortWith(_ < _).last\n\
    \            if (longest.length == strings.length) Some(longest)\n           \
    \ else longest.headOption\n        }", "        strings.foldLeft(None) {\n   \
    \         case (Some(longest), s) => if (s.length() > longest.length()) Some(s)\
    \ else longest\n            case _ => None\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            Some(longest)\n        }",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length) acc else s)\n\
    \            longest.length match {\n                case 1 => longest\n     \
    \           case _ => longest.headOption\n            }\n        }", "       \
    \ if (strings.isEmpty) None\n        else strings.foldLeft(\"\")( (acc, s) =>\
    \ if (acc.length < s.length) acc else s)", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => acc match {\n            case Nil => List(s)\n            case x\
    \ :: xs => if (x.length > s.length) x :: acc else acc match {\n              \
    \  case Nil => List(s)\n                case x :: xs => x :: longest(xs)\n   \
    \         }\n        })", "        strings.foldLeft(List[String]())(\n       \
    \     list => list.foldLeft(List[String]())(\n                list => list.foldLeft(List[String]())(\n\
    \                    list => list.foldLeft(List[String]())(\n                \
    \        list => list.foldLeft(List[String]())(\n                            list\
    \ => list.foldLeft(List[String]())(\n                                list => list.foldLeft(List[String]())(\n\
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                        list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \    list => list.foldLeft(List[String]())(\n                                \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \            list => list.foldLeft(List[String]())(\n                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                    list => list.foldLeft(List[String]())(\n                \
    \                                                                            \
    \        list => list.foldLeft(List[String]())(\n                            \
    \                                                                            list\
    \ => list.foldLeft(List[String]())(\n                                        \
    \                                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                    list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                        list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                            list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                list => list.foldLeft(List[String]())(\n\
    \                                                                            \
    \                                                                    list => list.foldLeft(List[String]())(\n",
  "        strings.foldLeft(List.empty[String]) { (list, s) =>\n            val l\
    \ = list.size\n            if (l > 0 && s.size == l) {\n                list\n\
    \            } else {\n                list :+ s\n            }\n        }.maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(List[String]())((list, str) => if (list.length < str.length)\
    \ list :+ str else str)\n            if (longest.length == strings.length) longest.headOption\n\
    \            else longest.headOption\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            strings.find(s => s == longest) else None\n        }", "   \
    \     strings.foldLeft(None: Option[String]){\n            case (Some(longest),\
    \ s) =>\n                val len = s.length\n                if (len > longest.length)\
    \ Some(s) else longest\n            case (None, _) => None\n        }", "    \
    \    strings.foldLeft(Option.empty[String])((acc, s) => {\n            val length\
    \ = s.length\n            if (acc.isEmpty) {\n                Some(s)\n      \
    \      } else if (acc.lastOption.map(_.length).max > length) {\n             \
    \   Some(acc.lastOption.get)\n            } else {\n                None\n   \
    \         }\n        })", "        strings.foldLeft(Option(\"\")) {\n        \
    \    (acc, s) =>\n                acc.map(_ + s).max match {\n               \
    \     case Some(max) => Some(max)\n                    case None => Some(s)\n\
    \                }\n        }", "        strings.foldLeft(Option.empty[String])\
    \ { (longest, s) =>\n            val length = s.length\n            if (length\
    \ > longest.get || length == 0) longest = Some(s) else longest\n        }", " \
    \       strings.foldLeft(List[String]())((list, s) => {\n            val length\
    \ = s.length\n            if (length == list.length) list :+ s\n            else\
    \ if (length > list.length) list :+ s\n            else list\n        })\n   \
    \         .maxBy(_.length)", "        strings.foldLeft(List[String]())( (acc,\
    \ s) => {\n            if (acc.length < s.length) acc :+ s\n            else acc\n\
    \        })\n            .maxBy(_.length)", "        strings.sortWith(_ < _)\n\
    \        strings.headOption", "        strings.foldLeft(None) { (longest, s) =>\n\
    \            val l = longest.getOrElse(s.length)\n            if (l > s.length)\
    \ Some(s) else longest\n        }", "        strings.length match {\n        \
    \    case 0 => None\n            case 1 => Some(strings.head)\n            case\
    \ _ => {\n                val longest = strings.foldLeft(\"\")( (acc, s) => {\n\
    \                    if (acc.length < s.length) acc else s\n                })\n\
    \                Some(longest)\n            }\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.maxBy(_.length)\n  \
    \          if (longest.length == strings.length) Some(longest)\n            else\
    \ longest.headOption\n        }", "        strings.sortWith(_.length < _.length)\n\
    \        strings.lastOption", "        if (strings.length == 0) None\n       \
    \ else {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        strings.foldLeft(List[String]())((list, string)\
    \ => {\n            if (list.isEmpty || list.length < string.length) list :+ string\n\
    \            else list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(None)(\
    \ (max, str) => max match {\n            case None => Some(str)\n            case\
    \ Some(maxStr) if maxStr.length < str.length => Some(str)\n            case Some(maxStr)\
    \ if maxStr.length == str.length => maxStr\n            case Some(maxStr) => maxStr\n\
    \        })", "        if (strings.length == 0) None\n        else {\n       \
    \     val longest = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length)\
    \ a else b )\n            strings.find(s => s == longest) match {\n          \
    \      case Some(longest) => Some(longest)\n                case None => None\n\
    \            }\n        }", "        strings.foldLeft(None) {\n            case\
    \ (Some(longest), s) =>\n                if (longest.length < s.length) Some(s)\
    \ else longest\n            case (None, None)  => None\n        }", "        strings.foldLeft(List[String]()){\
    \ (list, str) =>\n            if (list.isEmpty || list.length < str.length) list\
    \ :+ str\n            else list\n        }.maxBy(_.length)", "        if (strings.length\
    \ == 0) None\n        else strings.maxBy(_.length)", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(List[String]())((acc, s) => if (acc.length < s.length) acc\
    \ else s)\n            if (longest.length == strings.length) Some(longest)\n \
    \           else longest.headOption\n        }", "        strings.foldLeft(None)(\
    \ (acc, s) => {\n            val l = s.length\n            if (acc != None) acc\
    \ match {\n                case None => Some(s)\n                case Some(acc2)\
    \ => if (acc2.length < l) Some(acc2) else Some(s)\n            }\n           \
    \ else Some(s)\n        })", "        strings.foldLeft(List[String]())((acc, s)\
    \ => if (acc.length < s.length) acc else s :: acc)\n            .maxBy(_.length)",
  "        strings.foldLeft(None) {\n            case (Some(longest), s) =>\n    \
    \            val l = s.length\n                if (l > longest.length) Some(s)\
    \ else longest\n            case _ => None\n        }", "        strings.foldLeft(List[String]())(\n\
    \            list => list match {\n                case Nil => None\n        \
    \        case head :: tail => if (head.length == list.head.length) Some(head)\
    \ else longest(tail)\n            }\n        )", "        if (strings.length ==\
    \ 0) None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n  \
    \      }", "        strings.foldLeft(List[String]()){\n            case (acc,\
    \ s) => acc match {\n                case Nil => List(s)\n                case\
    \ x :: xs => if (x.length > s.length) x :: xs else s :: xs\n            }\n  \
    \      }.maxBy(_.length)", "        strings.foldLeft(Option.empty[String]) {\n\
    \            case (Some(longest), s) => if (s.length() > longest.length) Some(s)\
    \ else longest\n            case _ => None\n        }", "        strings.foldLeft(None)\
    \ { (longest, s) =>\n            if (longest == None) Some(s) else longest.map(x\
    \ => if (x.length > s.length) x else s)\n        }", "        strings.foldLeft(List.empty[String])\
    \ { (list, s) =>\n            val l = list.size\n            if (l > 0 && l <\
    \ s.length) list :+ s\n            else list\n        }.maxBy(_.length)", "  \
    \      if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (a, b) => if (a.length < b.length) a else b )\n  \
    \          strings.find(s => s == longest).getOrElse(longest)\n        }", " \
    \       strings.foldLeft(List[String]())( (acc, s) => acc match {\n          \
    \  case Nil => List(s)\n            case x :: xs => if (x.length > s.length) x\
    \ :: acc else acc match {\n                case Nil => List(s)\n             \
    \   case x :: xs => x :: longest(xs)\n            }\n        })", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            strings.find(s => s == longest).getOrElse(longest)\n\
    \        }", "        strings.foldLeft(List.empty[String]) { (list, str) =>\n\
    \            if (list.isEmpty || list.length < str.length) {\n               \
    \ list :+ str\n            } else {\n                list\n            }\n   \
    \     }.maxBy(_.length)", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length\
    \ < s.length) acc else s)\n            Some(longest)\n        }", "        if\
    \ (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            strings.find(s\
    \ => s == longest) match {\n                case Some(longest) => Some(longest)\n\
    \                case None => None\n            }\n        }", "        strings.foldLeft(List[String]())((list,\
    \ s) => {\n            if (list.length < s.length) list :+ s\n            else\
    \ list\n        })\n            .maxBy(_.length)", "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        strings.length match {\n            case 0\
    \ => None\n            case 1 => Some(strings.head)\n            case _ => {\n\
    \                val longest = strings.foldLeft(\"\")( (acc, s) => {\n       \
    \             if (acc.length < s.length) acc else s\n                })\n    \
    \            Some(longest)\n            }\n        }", "        strings.length\
    \ match {\n            case 0 => None\n            case 1 => Some(strings.head)\n\
    \            case _ => {\n                val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                    val l = acc.length\n                   \
    \ val c = s.charAt(l)\n                    if(c > 0) acc else s + acc\n      \
    \          })\n                Some(longest)\n            }\n        }", "   \
    \     strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else acc\n        })\n            .sortWith((s1,\
    \ s2) => s1.length < s2.length)\n            .headOption", "        strings.foldLeft(Option.empty[String])\
    \ { (longest, s) =>\n            val len = s.length\n            if (len > longest.get\
    \ || len == 0)\n                Some(s)\n            else\n                longest\n\
    \        }", "        if (strings.isEmpty) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b\
    \ )\n            strings.find(s => s == longest) match {\n                case\
    \ Some(longest) => Some(longest)\n                case None => None\n        \
    \    }\n        }", '        strings.foldLeft(List[String]())( (acc, s) => if
    (acc.length < s.length) acc else s)', '        strings.foldLeft(List[String]())((acc,
    s) => if (acc.length < s.length) acc else s)', "        if (strings.length ==\
    \ 0) None\n        else {\n            val longest = strings.foldLeft(\"\")( (acc,\
    \ s) => {\n                if (acc.length < s.length) acc else s\n           \
    \ })\n            Some(longest)\n        }", '        strings.sortWith(_ < _).lastOption',
  "        strings.foldLeft(List[String]())((acc, s) => {\n            if (acc.length\
    \ < s.length) acc :+ s\n            else acc\n        })\n            .maxBy(_.length)",
  "        strings.foldLeft(List[String]())((list, s) => {\n            if (list.length\
    \ < s.length) list :+ s\n            else list\n        })\n            .maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            Some(longest)\n        }", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else s)', "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => {\n                if (acc.length < s.length) acc else s\n    \
    \        })\n            Some(longest)\n        }", "        strings.length match\
    \ {\n            case 0 => None\n            case 1 => Some(strings.head)\n  \
    \          case _ => {\n                val longest = strings.foldLeft(\"\")(\
    \ (acc, s) => {\n                    if (acc.length < s.length) acc else s\n \
    \               })\n                Some(longest)\n            }\n        }",
  "        strings.foldLeft(List[String]())((list, s) => {\n            if (list.length\
    \ < s.length) list :+ s\n            else list\n        })\n            .maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else strings.foldLeft(\"\"){\n     \
    \       case (acc, s) => if (acc.length < s.length) acc else s}", "        if\
    \ (strings.length == 0) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => {\n                if (acc.length < s.length) acc else s\n  \
    \          })\n            Some(longest)\n        }", '        strings.sortWith(_
    < _).lastOption', "        strings.foldLeft(List[String]())((acc, s) => acc match\
    \ {\n            case Nil => Some(s)\n            case x :: xs => if (s.length\
    \ == x.length) Some(s) else x\n        })", "        strings.foldLeft(List[String]())(\
    \ (acc, s) => {\n            if (acc.length < s.length) acc :+ s\n           \
    \ else acc\n        })", "        if (strings.length == 0) None\n        else\
    \ strings.foldLeft(\"\"){ (longest, s) =>\n            if (longest.length < s.length)\
    \ longest\n            else s\n        }", '        strings.sortWith(_ < _).lastOption',
  "        strings.length match {\n            case 0 => None\n            case 1\
    \ => Some(strings.head)\n            case _ =>\n                val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => {\n                    val len = s.length\n\
    \                    val newLen = acc.length\n                    if (newLen >\
    \ len) acc else s\n                })\n                Some(longest)\n       \
    \ }", "        if (strings.length == 0) None\n        else {\n            val\
    \ longest = strings.foldLeft(\"\")( (a,b) => if (a.length < b.length) a else b\
    \ )\n            strings.find(s => s == longest).map(s => longest)\n        }",
  "        strings.foldLeft(List[String]())((list, s) => {\n            if (list.size\
    \ < s.length) list :+ s\n            else s\n        })", '        strings.foldLeft(List[String]())(
    (acc, s) => if (acc.length < s.length) acc else s)', "        strings.foldLeft(List[String]())((list,\
    \ str) => {\n            if (list.length < str.length) list :+ str\n         \
    \   else str\n        })", "        if (strings.isEmpty) None\n        else {\n\
    \            val longest = strings.foldLeft(\"\")( (acc, s) => {\n           \
    \     if (acc.length < s.length) acc else s\n            })\n            Some(longest)\n\
    \        }", '        strings.sortWith(_ < _).lastOption', "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())(\n            list => list\
    \ match {\n                case Nil => None\n                case head :: tail\
    \ => if (head.length == tail.length) head else longest(tail)\n            }\n\
    \        )", "        if (strings.length == 0) None\n        else {\n        \
    \    val longest = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length\
    \ < s.length) acc else s\n            })\n            strings.find(s => s == longest)\
    \ match {\n                case Some(longest) => Some(longest)\n             \
    \   case None => None\n            }\n        }", "        strings.foldLeft(Option(\"\
    no strings\")) {\n            (longest, string) =>\n                if (string.length\
    \ == longest.get || string.length == longest.get.length)\n                   \
    \ Some(string)\n                else\n                    longest\n        }",
  "        strings.foldLeft(List[String]()){\n            case (acc, s) => acc match\
    \ {\n                case Nil => List(s)\n                case _ => if (acc.length\
    \ < s.length) acc else List(s)\n            }\n        }.maxBy(_.length)", " \
    \       strings.foldLeft(List[String]())( (list, string) => {\n            if\
    \ (list.length < string.length) list :+ string\n            else list\n      \
    \  })\n            .maxBy(_.length)", "        if (strings.isEmpty) None\n   \
    \     else strings.foldLeft(\"\") {\n            case (acc, s) => if (acc.length\
    \ < s.length) acc else s}", "        strings.foldLeft(Option(\"No strings\"))\
    \ {\n            case (Some(longest), s) =>\n                val l = s.length\n\
    \                if (l > longest.length)\n                    Some(s)\n      \
    \          else\n                    None\n        }", '        strings.sortWith(_
    < _).lastOption', "        strings.foldLeft(List[String]())((list, str) => if\
    \ (list.length < str.length) list :+ str else str)\n            .maxBy(_.length)",
  "        if (strings.length == 0) None\n        else {\n            val longest\
    \ = strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            Some(longest)\n        }", "       \
    \ if (strings.length == 0) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => {\n                if (acc.length < s.length) acc else s\n  \
    \          })\n            strings.find(s => s == longest) match {\n         \
    \       case Some(longest) => Some(longest)\n                case None => None\n\
    \            }\n        }", "        if (strings.length == 0) None\n        else\
    \ strings.foldLeft(strings(0))((acc, s) => if (acc.length < s.length) acc else\
    \ s)", "        strings.foldLeft(List[String]()){\n            (acc, s) => if\
    \ (acc.length < s.length) acc else s :: acc\n        }.maxBy(_.length)", "   \
    \     if (strings.length == 0) None\n        else {\n            val longest =\
    \ strings.foldLeft(\"\")( (acc, s) => {\n                if (acc.length < s.length)\
    \ acc else s\n            })\n            Some(longest)\n        }", "       \
    \ strings.foldLeft(List[String]())((list, s) => {\n            if (list.length\
    \ < s.length) list :+ s\n            else list\n        })\n            .maxBy(_.length)",
  "        if (strings.isEmpty) None\n        else {\n            val longest = strings.foldLeft(\"\
    \")( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(Option(\"no strings\")) {\n           \
    \ (maxLength, string) =>\n                maxLength match {\n                \
    \    case Some(maxLength) if string.length >= maxLength => Some(string)\n    \
    \                case Some(maxLength) => Some(maxLength)\n                   \
    \ case None => Some(string)\n                }\n        }", "        if (strings.isEmpty)\
    \ None\n        else {\n            val longest = strings.foldLeft(\"\")( (max:\
    \ String, current: String) => if (current.length >= max.length) max else current)\n\
    \            strings.find(s => s == longest).getOrElse(longest)\n        }", " \
    \       strings.foldLeft(List[String]())((list, string) => {\n            if (list.length\
    \ < string.length) list :+ string\n            else list\n        })\n       \
    \     .maxBy(_.length)", "        strings.foldLeft(List[String]())((list, string)\
    \ => {\n            if (list.length < string.length) list :+ string\n        \
    \    else list\n        })\n            .maxBy(_.length)", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.foldLeft(List[String]())((list, str) => {\n    \
    \        if (list.length >= str.length) list :+ str\n            else str\n  \
    \      })", "        strings.foldLeft(List[String]())( (list, str) => list match\
    \ {\n            case Nil => Some(str)\n            case _ => if (str.length <\
    \ list.last.length) Some(str) else list\n        })", "        strings.foldLeft(List[String]()){\n\
    \            case (acc, s) => if (acc.length < s.length) acc :+ s else acc\n \
    \       }.maxBy(_.length)", "        if (strings.length == 0) None\n        else\
    \ {\n            val longest = strings.foldLeft(List[String]())((acc, s) => {\n\
    \                if (acc.length < s.length) acc :+ s\n                else acc\n\
    \            })\n            if (longest.length == strings.length) longest.headOption\n\
    \            else longest.headOption\n        }", "        if (strings.length\
    \ == 0) None\n        else {\n            val longest = strings.foldLeft(\"\"\
    )( (acc, s) => if (acc.length < s.length) acc else s)\n            Some(longest)\n\
    \        }", "        strings.length match {\n            case 0 => None\n   \
    \         case 1 => Some(strings.head)\n            case _ => {\n            \
    \    val longest = strings.foldLeft(List[String]())((acc, s) => {\n          \
    \          if (acc.length < s.length) acc :+ s\n                    else s\n \
    \               })\n                longest.maxBy(s.length)\n            }\n \
    \       }", "        strings.length match {\n            case 0 => None\n    \
    \        case 1 => Some(strings.head)\n            case _ =>\n               \
    \ val longest = strings.foldLeft(\"\")( (acc, s) =>\n                    if (acc.length\
    \ < s.length) acc else s\n                )\n                Some(longest)\n \
    \       }", "        if (strings.length == 0) None\n        else {\n         \
    \   val longest = strings.foldLeft(\"\")( (acc, s) => if (acc.length < s.length)\
    \ acc else s)\n            Some(longest)\n        }", "        strings.foldLeft(List[String]())((acc,\
    \ s) => {\n            val l = acc.length\n            if (l < s.length) acc :+\
    \ s\n            else acc\n        })\n            .maxBy(_.length)", "      \
    \  if (strings.isEmpty) None\n        else strings.foldLeft(\"\") { (longest,\
    \ s) =>\n            if (longest.length < s.length) longest\n            else\
    \ s\n        }", "        strings.foldLeft(None: Option[String]){\n          \
    \  case (Some(longest), s) =>\n                val len = s.length\n          \
    \      if (len > longest.length) Some(s) else None\n            case (None, s)\
    \ => Some(s)\n        }", '        strings.foldLeft(List[String]())((list, s)
    => if (list.length < s.length) list :+ s else list)', "        strings.sortWith(_\
    \ < _)\n            .takeWhile(_ != strings.last)\n            .lastOption"]
stop_tokens:
- "\n    }\n"
