name: HumanEval_49_modp
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n   \
  \ // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n    // 1\n\
  \    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n    def\
  \ modp(n : Long, p : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
  \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
  \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
  \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
  \ == (3l));\n    }\n\n}\n"
completions: ["        val r = n % p\n        if (r < 0) r + p else r", "        val\
    \ m = math.pow(2, n)\n        val r = math.mod(m, p)\n        if (r == 0) 1 else\
    \ r", "        val r = n % p\n        if (r < 0) r + p else r", "        val m\
    \ = math.pow(2, n)\n        val r = math.mod(m, p)\n        if (r < 0) r + p else\
    \ r", "        val r = n % p\n        if (r < 0) r + p else r", "        val m\
    \ = math.pow(2,n)\n        val r = math.mod(m, p)\n        val r2 = math.pow(2,r)\n\
    \        val r3 = math.pow(2,r2)\n        val r4 = math.pow(2,r3)\n        val\
    \ r5 = math.pow(2,r4)\n        val r6 = math.pow(2,r5)\n        val r7 = math.pow(2,r6)\n\
    \        val r8 = math.pow(2,r7)\n        val r9 = math.pow(2,r8)\n        val\
    \ r10 = math.pow(2,r9)\n        val r11 = math.pow(2,r10)\n        val r12 = math.pow(2,r11)\n\
    \        val r13 = math.pow(2,r12)\n        val r14 = math.pow(2,r13)\n      \
    \  val r15 = math.pow(2,r14)\n        val r16 = math.pow(2,r15)\n        val r17\
    \ = math.pow(2,r16)\n        val r18 = math.pow(2,r17)\n        val r19 = math.pow(2,r18)\n\
    \        val r20 = math.pow(2,r19)\n        val r21 = math.pow(2,r20)\n      \
    \  val r22 = math.pow(2,r21)\n        val r23 = math.pow(2,r22)\n        val r24\
    \ = math.pow(2,r23)\n        val r25 = math.pow(2,r24)\n        val r26 = math.pow(2,r25)\n\
    \        val r27 = math.pow(2,r26)\n        val r28 = math.pow(2,r27)\n      \
    \  val r29 = math.pow(2,r28)\n        val r30 = math.pow(2,r29)\n        val r31\
    \ = math.pow(2,r30)\n        val r32 = math.pow(2,r31)\n        val r33 = math.pow(2,r32)\n\
    \        val r34 = math.pow(2,r33)\n        val r35 = math.pow(2,r34)\n      \
    \  val r36 = math.pow(2,r35)\n        val r37 = math.pow(2,r36)\n        val r38\
    \ = math.pow(2,r37)\n        val r39 = math.pow(2,r38)\n        val r40 = math.pow(2,r39)\n\
    \        val r41 = math.pow(2,r40)\n        val r42 = math.pow(2,r41)\n      \
    \  val r43 = math.pow(2,r42)\n        val r44 = math.pow(2,r43)\n        val r45\
    \ = math.pow(2,r44)\n        val r46 = math.pow(2,r", "        val r = n % p\n\
    \        if (r == 0) 1 else r", "        val r = n % p\n        if (p < 0)\n \
    \           r + p\n        else\n            r", "        val r = n % p\n    \
    \    if (r == 0) 1 else r", "        val n = n.toInt\n        val p = p.toInt\n\
    \        val r = scala.math.pow(2, n)\n        val m = scala.math.mod(r, p)\n\
    \        if (m == 0) 1 else m", "        val m = n % p\n        if (m == 0) 1\n\
    \        else m + 1", "        val r = n % p\n        if (r < 0) r + p else r",
  "        val r = n % p\n        if (r < 0) r + p else r", "        val r = scala.math.BigInt(n).mod(scala.math.BigInt(p))\n\
    \        r.toLong", "        val r = n % p\n        if (r == 0) 1 else r", " \
    \       val m = math.pow(2, n)\n        val r = math.mod(m, p)\n        val s\
    \ = math.signum(r)\n        if (s == -1) 1 else s", "        val n = n.toInt\n\
    \        val p = p.toInt\n        if (n == 0 || p == 0) 1\n        else if (n\
    \ % p == 0) n\n        else n % p + modp(n / p, p)", "        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r", "        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r", "        val m = math.pow(2,\
    \ n)\n        val r = math.mod(m, p)\n        val s = math.signum(r)\n       \
    \ if (s == 0) 1 else s"]
stop_tokens:
- "\n    }\n"
