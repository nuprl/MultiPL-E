name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // search([4, 1, 2, 2, 3, 1]) == 2\n    // search([1,\
  \ 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n    // search([5, 5, 4, 4, 4]) == -1\n    def search(lst\
  \ : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        var max = 0L\n        var freq = 0L\n        var i = 0\n  \
    \      while (i < lst.length) {\n            if (lst(i) > 0) {\n             \
    \   freq += 1\n                if (freq > lst(i)) {\n                    max =\
    \ lst(i)\n                }\n            }\n            i += 1\n        }\n  \
    \      if (max < 0) {\n            return -1\n        }\n        return max",
  "        val freq = mutable.HashMap[Long, Int]()\n        for (i <- lst) {\n   \
    \         freq += i -> freq.getOrElse(i, 0) + 1\n        }\n        val max =\
    \ freq.maxBy(_._2)._1\n        val maxFreq = freq.maxBy(_._2)._2\n        if (maxFreq\
    \ >= max) {\n            max\n        } else {\n            -1\n        }", " \
    \       val freq = mutable.Map[Long, Int]()\n        lst.foreach(x => freq +=\
    \ x -> freq.getOrElse(x, 0) + 1)\n        val max = freq.maxBy(_._2)._1\n    \
    \    if (max > 0) max else -1", "        val freq = mutable.Map[Long, Int]()\n\
    \        val max = mutable.Map[Long, Long]()\n        lst.foreach(x => freq +=\
    \ x -> freq.getOrElse(x, 0) + 1)\n        lst.foreach(x => max += x -> lst.count(_\
    \ == x))\n        max.max.map(_._1).getOrElse(-1)", "        val freq = mutable.Map[Long,\
    \ Int]()\n        for (i <- 0 until lst.length) {\n            freq += (lst(i)\
    \ -> freq(lst(i))+1)\n        }\n        val max = freq.maxBy(_._2)._1\n     \
    \   if (max > 0) max else -1", "        val freq = mutable.HashMap[Long, Int]()\n\
    \        for (i <- lst) {\n            if (freq.contains(i)) {\n             \
    \   freq(i) += 1\n            } else {\n                freq.put(i, 1)\n     \
    \       }\n        }\n        val max = freq.maxBy(_._2)\n        if (max._2 >=\
    \ freq(max._1)) {\n            return max._1\n        } else {\n            return\
    \ -1\n        }", "        val freq = mutable.HashMap[Long, Int]()\n        lst.foreach(x\
    \ => freq += x -> freq.getOrElse(x, 0) + 1)\n        val max = freq.maxBy(_._2)._1\n\
    \        if (max > 0) max else -1", "        val freq = mutable.Map[Long, Int]()\n\
    \        for (i <- 0 until lst.length) {\n            freq += (lst(i) -> freq.getOrElse(lst(i),\
    \ 0) + 1)\n        }\n        val maxFreq = freq.maxBy(_._2)\n        if (maxFreq._2\
    \ >= 0) {\n            return maxFreq._1\n        } else {\n            return\
    \ -1\n        }", "        val freq = mutable.HashMap.empty[Long, Int]\n     \
    \   for(i <- lst) freq += i -> freq.getOrElse(i, 0) + 1\n        val max = freq.maxBy(_._2)._1\n\
    \        if(max > 0) max else -1", "        val freq = mutable.Map[Long, Int]()\n\
    \        lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1)\n        val\
    \ max = freq.maxBy(_._2)._1\n        if (max >= freq.maxBy(_._1)._1) -1\n    \
    \    else max", "        var max = 0\n        var maxIndex = 0\n        var maxFreq\
    \ = 0\n        for (i <- 0 until lst.size) {\n            val freq = lst.count(_\
    \ == lst(i))\n            if (freq > maxFreq) {\n                max = lst(i)\n\
    \                maxIndex = i\n                maxFreq = freq\n            }\n\
    \        }\n        if (maxFreq > 0) {\n            return max\n        } else\
    \ {\n            return -1\n        }", "        val freq = mutable.Map[Long,\
    \ Int]()\n        val max = -1L\n        lst.foreach{x => freq += x -> freq.getOrElse(x,\
    \ 0)}\n        lst.foreach{x => if (freq.getOrElse(x, 0) > max) max = freq.getOrElse(x,\
    \ 0)}\n        max", "        val freq = mutable.HashMap[Long, Int]()\n      \
    \  lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1L)\n        val max =\
    \ freq.maxBy(_._2)\n        if (max._2 >= freq.size)\n            -1\n       \
    \ else\n            max._1", "        val freq = mutable.HashMap[Long, Int]()\n\
    \        lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1)\n        val\
    \ max = freq.maxBy(_._2)._1\n        if (max >= 0) max else -1", "        var\
    \ max = 0\n        var maxCount = 0\n        var maxFreq = 0\n        for(i <-\
    \ 0 until lst.size) {\n            val freq = lst.count(_ == lst(i))\n       \
    \     if(freq > maxFreq) {\n                max = lst(i)\n                maxCount\
    \ = freq\n                maxFreq = freq\n            }\n        }\n        if(maxCount\
    \ == 0) {\n            return -1\n        }\n        return max", "        val\
    \ freq = mutable.Map[Long, Int]()\n        lst.foreach(x => freq += x -> freq.getOrElse(x,\
    \ 0) + 1)\n        val max = freq.maxBy(_._2)._1\n        if (max > 0) max else\
    \ -1", "        val freq = mutable.HashMap.empty[Long, Int]\n        lst.foreach(x\
    \ => freq += x -> freq.getOrElse(x, 0) + 1)\n        val max = freq.maxBy(_._2)._1\n\
    \        if (max > 0) max else -1", "        val freq = mutable.HashMap.empty[Long,\
    \ Int]\n        val max = mutable.Long.MinValue\n        lst.foreach(x => freq\
    \ += x -> freq.getOrElse(x, 0) + 1)\n        lst.foreach(x => if (freq.getOrElse(x,\
    \ 0) > max) max = freq.getOrElse(x, 0))\n        if (max > 0) max else -1", " \
    \       val freq = mutable.Map[Long, Int]()\n        lst.foreach(x => freq +=\
    \ (x -> freq.getOrElse(x, 0) + 1L))\n        val max = freq.maxBy(_._2)._1\n \
    \       if (max > 0) max else -1", "        val freq = mutable.Map[Long, Int]()\n\
    \        lst.foreach(x => freq += x -> freq.getOrElse(x, 0) + 1)\n        val\
    \ max = freq.maxBy(_._2)._1\n        if (max >= freq.maxBy(_._1)._1) -1 else max"]
stop_tokens:
- "\n    }\n"
