language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(0)(_ + _) == maxSum\n        isPalindromic && isBalanced\
    \ && maxWeight <= q.sum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqt5ekl5u.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqt5ekl5u.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) == maxSum\n\e[31m\e[31m   |\e[0m       \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = maxSum > maxWeight\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndBalancedAndPalindromic\
    \ = isFlippableAndBalanced && isPalindromic\n        isFlippableAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx4sokvrh.scala:26)\n\tat Problem.main(tmpx4sokvrh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuq26h67z.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q)\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpogf8m1oz.scala:18:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n     \
    \   val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x\
    \ => x != q.head && x != q.last)\n        isPalindromic && isBalanced && isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7j0o99bq.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxWeight = sumOfElements\
    \ < maxWeight\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight\
    \ && isBalanced\n        val isLessThanMaxWeightAndPalindromic = isLessThanMaxWeight\
    \ && isPalindromic\n        isLessThanMaxWeightAndBalanced || isLessThanMaxWeightAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphcjwsrtr.scala:27)\n\tat Problem.main(tmphcjwsrtr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxWeightAndBalanced = isLessThanMaxWeight && isBalanced\n       \
    \ val isLessThanMaxSumAndBalanced = isLessThanMaxSum && isBalanced\n        isPalindromic\
    \ && isBalanced && isLessThanMaxWeightAndBalanced && isLessThanMaxSumAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprjqqrpqq.scala:27)\n\tat Problem.main(tmprjqqrpqq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w.toInt\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isPalindromic || !isBalanced\n      \
    \  isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeohwf6hx.scala:25)\n\tat Problem.main(tmpeohwf6hx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum - q.sum < maxWeight\n        val isFlipped = q.tail.forall(_ == q.head)\n\
    \        isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfqtzte0g.scala:24)\n\tat Problem.main(tmpfqtzte0g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x != q)\n        val sumOfElements = q.sum\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isFlipped = palindromic\
    \ && isBalanced\n        val isFlippedOrBalanced = isFlipped || isBalanced\n \
    \       isFlippedOrBalanced\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1b36ezea.scala:17:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x != q)\n\e[31m\e[31m   |\e[0m                                 \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and List[Long]\
    \ cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && q.forall(x => x <= maxWeight)\n        val sumLessThanMax =\
    \ q.sum < maxWeight\n        val sumLessThanMaxButNotBalanced = q.sum < maxWeight\
    \ && !balanced\n        val sumGreaterThanMaxButNotBalanced = q.sum > maxWeight\
    \ && !balanced\n        val sumGreaterThanMax = q.sum > maxWeight\n        val\
    \ sumLessThanMaxButBalanced = q.sum < maxWeight && balanced\n        val sumGreaterThanMaxButBalanced\
    \ = q.sum > maxWeight && balanced\n        val sumLessThanMaxButNotBalanced =\
    \ q.sum < maxWeight && !balanced\n        val sumGreaterThanMaxButNotBalanced\
    \ = q.sum > maxWeight && !balanced\n        val sumLessThanMaxButBalancedAndNotPalindromic\
    \ = q.sum < maxWeight && balanced && !palindromic\n        val sumGreaterThanMaxButBalancedAndNotPalindromic\
    \ = q.sum > maxWeight && balanced && !palindromic\n        val sumLessThanMaxButNotBalancedAndNotPalindromic\
    \ = q.sum < maxWeight && !balanced && !palindromic\n        val sumGreaterThanMaxButNotBalancedAndNotPalindromic\
    \ = q.sum > maxWeight && !balanced && !palindromic\n        val sumLessThanMaxButBalancedAndPalindromic\
    \ = q.sum < maxWeight && balanced && palindromic\n        val sumGreaterThanMaxButBalancedAndPalindromic\
    \ = q.sum > maxWeight && balanced && palindromic\n        val sumLessThanMaxButNotBalancedAndPalindromic\
    \ = q.sum < maxWeight && !balanced && palindromic\n        val sumGreaterThanMaxButNotBalancedAndPalindromic\
    \ = q.sum > maxWeight && !balanced && palindromic\n        val sumLessThanMaxButBalancedAndNotPalindromicAndNotBalanced\
    \ = q.sum < maxWeight && balanced && !palindromic && !balanced\n        val sumGreaterThanMaxButBalancedAndNotPalindromicAndNotBalanced\
    \ = q.sum > maxWeight && balanced && !palindromic && !balance\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv5zdd7sj.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msumLessThanMaxButNotBalanced\e\
    [0m = q.sum < maxWeight && !balanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumLessThanMaxButNotBalanced is already defined as \e[33mvalue\e\
    [0m \e[35msumLessThanMaxButNotBalanced\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv5zdd7sj.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msumGreaterThanMaxButNotBalanced\e\
    [0m = q.sum > maxWeight && !balanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msumGreaterThanMaxButNotBalanced is already defined as \e[33mvalue\e\
    [0m \e[35msumGreaterThanMaxButNotBalanced\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv5zdd7sj.scala:37:124\
    \ -----------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e\
    [36msumGreaterThanMaxButBalancedAndNotPalindromicAndNotBalanced\e[0m = q.sum >\
    \ maxWeight && balanced && !palindromic && !balance\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                             ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                                    Not found: balance\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv5zdd7sj.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlight = maxSum <= maxWeight\
    \ && isPalindromic && isBalanced\n        isFlight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6wh9dre2.scala:24)\n\tat Problem.main(tmp6wh9dre2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isLessOrEqual = maxSum - q.sum <= maxWeight\n        val isLessOrEqualPalindromic\
    \ = maxSum - q.reverse.sum <= maxWeight\n        val isLessOrEqualBalanced = maxSum\
    \ - q.sum <= maxWeight - q.length\n        val isLessOrEqualBalancedPalindromic\
    \ = maxSum - q.reverse.sum <= maxWeight - q.length\n        val isLessOrEqualBalancedAndPalindromic\
    \ = maxSum - q.sum <= maxWeight - q.length && maxSum - q.reverse.sum <= maxWeight\
    \ - q.length\n        val isLessOrEqualBalancedAndPalindromicPalindromic = maxSum\
    \ - q.sum <= maxWeight - q.length && maxSum - q.reverse.sum <= maxWeight - q.length\
    \ && maxSum - q.reverse.reverse.sum <= maxWeight - q.length\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromic\
    \ = maxSum - q.sum <= maxWeight - q.length && maxSum - q.reverse.sum <= maxWeight\
    \ - q.length && maxSum - q.reverse.reverse.sum <= maxWeight - q.length && maxSum\
    \ - q.reverse.reverse.reverse.sum <= maxWeight - q.length\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum - q.sum <= maxWeight - q.length && maxSum - q.reverse.sum <= maxWeight\
    \ - q.length && maxSum - q.reverse.reverse.sum <= maxWeight - q.length && maxSum\
    \ - q.reverse.reverse.reverse.sum <= maxWeight - q.length && maxSum - q.reverse.reverse.reverse.reverse.sum\
    \ <= maxWeight - q.length\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum - q.sum <= maxWeight - q.length && maxSum - q.reverse.sum <= maxWeight\
    \ - q.length && maxSum - q.reverse.reverse.sum <= maxWeight - q.length && maxSum\
    \ - q.reverse.reverse.reverse.sum <= maxWeight - q.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1zs7hsa3.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1zs7hsa3.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxWeight\
    \ = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = maxSumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isLessOrEqualToMaxWeight = maxSumOfElements <= maxWeight\n\
    \        val isLessOrEqualToMaxSum = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxWeight\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElements.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight && isBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight && isPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48mmxzlg.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp48mmxzlg.scala:28:147 -----------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\e\
    [0m = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElements.toLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Boolean, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp48mmxzlg.scala:33:5 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoi0u8in.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.reduce((x, y) => x + y)\n  \
    \      val maxWeight = q.reduce((x, y) => if (x > y) x else y)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxWeight <= w\n   \
    \     val isLessThanMax = maxSum - w <= 0\n        val isLessThanMaxOrBalanced\
    \ = isLessThanMax || isBalanced\n        isPalindromic && isLessThanMaxOrBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkuvizncf.scala:25)\n\tat Problem.main(tmpkuvizncf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = maxSumOfElements.toLong\
    \ == maxSum\n        val isBalanced = isPalindromic && maxSumOfElements.toLong\
    \ <= w\n        val isFlippable = isBalanced && maxSumOfElements.toLong <= maxSum\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplubkyyq4.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\n        val isLessThanMax\
    \ = q.sum < maxWeight\n        val isLessThanMaxAndBalanced = q.sum < maxWeight\
    \ && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\
    \ && q.reverse.forall(x => x == q(0))\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\
    \ && q.reverse.forall(x => x == q(0)) && q.forall(x => x != 0)\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\
    \ && q.reverse.forall(x => x == q(0)) && q.forall(x => x != 0) && (q.forall(x\
    \ => x != 0))\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\
    \ && q.reverse.forall(x => x == q(0)) && q.forall(x => x != 0) && (q.forall(x\
    \ => x != 0)) && (q.forall(x => x != 0))\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum)\
    \ && q.reverse.forall(x => x == q(0)) && q.forall(x => x != 0) && (q.forall(x\
    \ => x != 0)) && (q.forall(x => x != 0)) && (q.forall(x => x != 0))\n        val\
    \ isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= maxWeight - q.sum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0ludfstr.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp0ludfstr.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxList = q.max\n        val maxListSum = maxList.sum\n        val\
    \ maxListWeight = maxList.max\n        val maxListWeightSum = maxListWeight.sum\n\
    \        val maxListWeightSumLessOrEqualToMaxWeight = maxListWeightSum < maxWeight\n\
    \        val maxListSumLessOrEqualToMaxSum = maxListSum < maxSum\n        val\
    \ maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight = maxListSumLessOrEqualToMaxWeight\
    \ && maxListWeightSumLessOrEqualToMaxWeight\n        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\
    \ = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxSum\n\
    \        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight\
    \ = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight\n\
    \        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\
    \ = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\n\
    \        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight\
    \ = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight\n\
    \        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\
    \ = maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\n\
    \        val maxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\
    \ = maxListSumLessOrEqualToMaxWeight \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxvcasokl.scala:19:33 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxListSum\e[0m = maxList.sum\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value sum is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxvcasokl.scala:21:45 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxListWeightSum\e[0m = maxListWeight.sum\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               value sum is not a member of Long\
    \ => Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxvcasokl.scala:24:82\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeight\e[0m =\
    \ maxListSumLessOrEqualToMaxWeight && maxListWeightSumLessOrEqualToMaxWeight\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: maxListSumLessOrEqualToMaxWeight\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxvcasokl.scala:25:79\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxSum\e[0m = maxListSumLessOrEqualToMaxWeight\
    \ && maxListWeightSumLessOrEqualToMaxSum\n\e[31m\e[31m   |\e[0m              \
    \                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: maxListSumLessOrEqualToMaxWeight\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxvcasokl.scala:26:117\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxListSumLessOrEqualToMaxWeightAndListWeightLessOrEqualToMaxWeightAndListWeightLessOrEqu"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoi0u8in.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n\
    \        val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n   \
    \     isPalindromic && isBalanced && isLessThanMax && isLessThanMaxButNotBalanced\
    \ && isLessThanMaxButBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqn2mgj33.scala:26)\n\tat Problem.main(tmpqn2mgj33.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse == q\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n        isPalindromic\
    \ && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi4_sde1a.scala:25)\n\tat Problem.main(tmpi4_sde1a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n\
    \        val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n   \
    \     val isLessThanMaxButNotBalancedAndPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced\n      \
    \  val isLessThanMaxButBalancedAndPalindromicAndBalanced = maxSum < maxWeight\
    \ && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic =\
    \ maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced && !isP\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_s589uo6.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_s589uo6.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_s589uo6.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced && !isP\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659800752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight * 2\n        val isLessThanMaxSum = maxSum < maxWeight * 3\n   \
    \     val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxSumAndBalanced = isLessThanMaxSum && isBalanced\n  \
    \      isPalindromic && isBalanced && isLessThanMaxWeightAndBalanced && isLessThanMaxSumAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo60kmq8k.scala:27)\n\tat Problem.main(tmpo60kmq8k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800753
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val palindromic = q.reverse.forall(x => x <= maxWeight)\n\
    \        val sum = q.sum\n        val isBalanced = sum <= maxSum\n        val\
    \ isPalindromic = palindromic && sum == sum.reverse\n        isBalanced && isPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmporfiyafx.scala:21:54 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = palindromic\
    \ && sum == sum.reverse\n\e[31m\e[31m   |\e[0m                               \
    \                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \           value reverse is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659800762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isLessOrEqual = q.forall(x => x <= maxWeight && x >= maxWeight -\
    \ q.length)\n        val isLessOrEqualPalindromic = q.reverse.forall(x => x <=\
    \ maxWeight && x >= maxWeight - q.length)\n        val isLessOrEqualBalanced =\
    \ q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n        val isLessOrEqualPalindromicBalanced\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromic = q.reverse.forall(x => x <= maxWeight\
    \ && x >= maxWeight - q.length)\n        val isLessOrEqualBalancedPalindromicBalanced\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromic = q.reverse.forall(x\
    \ => x <= maxWeight && x >= maxWeight - q.length)\n        val isLessOrEqualBalancedPalindromicBalancedPalindromicBalanced\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromic\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromicBalanced\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromicBalancedPalindromic\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromicBalancedPalindromicBalanced\
    \ = q.reverse.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n     \
    \   val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromicBalancedPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9gss9pvs.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp9gss9pvs.scala:17:35 --------------------\e[0m\e[0m\n\e[31m17 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp9gss9pvs.scala:33:5 ---------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800762
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q.head)\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMax = maxSum\
    \ - q.sum < maxWeight\n        isPalindromic && isBalanced && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp85mrphmd.scala:24)\n\tat Problem.main(tmp85mrphmd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptiidcstw.scala:23)\n\tat Problem.main(tmptiidcstw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.length\n        val maxWeight2 = w.toLong * q.length\n\
    \        val maxWeight3 = w.toLong * q.length\n        val maxWeight4 = w.toLong\
    \ * q.length\n        val maxWeight5 = w.toLong * q.length\n        val maxWeight6\
    \ = w.toLong * q.length\n        val maxWeight7 = w.toLong * q.length\n      \
    \  val maxWeight8 = w.toLong * q.length\n        val maxWeight9 = w.toLong * q.length\n\
    \        val maxWeight10 = w.toLong * q.length\n        val maxWeight11 = w.toLong\
    \ * q.length\n        val maxWeight12 = w.toLong * q.length\n        val maxWeight13\
    \ = w.toLong * q.length\n        val maxWeight14 = w.toLong * q.length\n     \
    \   val maxWeight15 = w.toLong * q.length\n        val maxWeight16 = w.toLong\
    \ * q.length\n        val maxWeight17 = w.toLong * q.length\n        val maxWeight18\
    \ = w.toLong * q.length\n        val maxWeight19 = w.toLong * q.length\n     \
    \   val maxWeight20 = w.toLong * q.length\n        val maxWeight21 = w.toLong\
    \ * q.length\n        val maxWeight22 = w.toLong * q.length\n        val maxWeight23\
    \ = w.toLong * q.length\n        val maxWeight24 = w.toLong * q.length\n     \
    \   val maxWeight25 = w.toLong * q.length\n        val maxWeight26 = w.toLong\
    \ * q.length\n        val maxWeight27 = w.toLong * q.length\n        val maxWeight28\
    \ = w.toLong * q.length\n        val maxWeight29 = w.toLong * q.length\n     \
    \   val maxWeight30 = w.toLong * q.length\n        val maxWeight31 = w.toLong\
    \ * q.length\n        val maxWeight32 = w.toLong * q.length\n        val maxWeight33\
    \ = w.toLong * q.length\n        val maxWeight34 = w.toLong * q.length\n     \
    \   val maxWeight35 = w.toLong * q.length\n        val maxWeight36 = w.toLong\
    \ * q.length\n        val maxWeight37 = w.toLong * q.length\n        val maxWeight38\
    \ = w.toLong * q.length\n        val maxWeight39 = w.toLong * q.length\n     \
    \   val maxWeight40\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpby2x7s21.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpby2x7s21.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800761
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val palindromic = q.reverse.forall(x =>\
    \ x <= maxWeight)\n        val balanced = palindromic && q.sum <= maxSum\n   \
    \     !balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp00_20wkx.scala:23)\n\tat Problem.main(tmp00_20wkx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n     \
    \   val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic &&\
    \ isBalanced\n        val isNotFly = !isPalindromic && !isBalanced\n        isFly\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplf45fg0_.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxSumAndBalanced = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalance\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7g4b9y25.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7g4b9y25.scala:17:35 --------------------\e[0m\e[0m\n\e[31m17 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7g4b9y25.scala:33:5 ---------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.foldLeft(0)(_ + _)\n       \
    \ val maxWeight = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val sumOfElements = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = sumOfElements <= maxWeight\n        val isFly = isPalindromic &&\
    \ isBalanced\n        val isNotFly = !isFly\n        val isNotBalanced = !isBalanced\n\
    \        val isNotPalindromic = !isPalindromic\n        val isNotFly_or_NotBalanced\
    \ = isNotFly || isNotBalanced\n        val isNotPalindromic_or_NotBalanced = isNotPalindromic\
    \ || isNotBalanced\n        val isNotFly_or_NotPalindromic = isNotFly_or_NotBalanced\
    \ || isNotPalindromic_or_NotBalanced\n        isFly_or_NotPalindromic\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdh3lkdnq.scala:16:35\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdh3lkdnq.scala:17:38\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                     ^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \          Found:    Long\n\e[31m   |\e[0m                                   \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdh3lkdnq.scala:19:42\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpdh3lkdnq.scala:28:8 -------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        isFly_or_NotPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: isFly_or_NotPalindromic\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxPalindrome = q.reverse.mkString\n        val maxPalindromeLength\
    \ = maxPalindrome.length\n        val maxPalindromeWeight = maxPalindromeLength\
    \ * maxWeight\n        val maxPalindromeSum = maxPalindromeWeight.times(maxPalindromeLength)\n\
    \        val maxPalindromeSumLessOrEqualToMaxWeight = maxPalindromeSum.lt(maxWeight)\n\
    \        val maxPalindromeSumLessOrEqualToMaxWeightAndBalanced = maxPalindromeSumLessOrEqualToMaxWeight\
    \ && maxPalindromeLength.lt(maxPalindromeWeight)\n        val maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindrome\
    \ = maxPalindromeSumLessOrEqualToMaxWeightAndBalanced && !maxPalindrome.isPalindrome\n\
    \        val maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmpty\
    \ = maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindrome && !maxPalindrome.isEmpty\n\
    \        val maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmptyAndNotEmpty\
    \ = maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmpty\
    \ && !maxPalindrome.isEmpty && !maxPalindrome.isEmpty\n        val maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmptyAndNotEmpty\
    \ && !maxPalindrome.isEmpty && !maxPalindrome.isEmpty && !maxPalindrome.isEmpty\n\
    \        val maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmptyAndNotEmptyAndNotEmptyAndNotEmpty\
    \ = maxPalindromeSumLessOrEqualToMaxWeightAndBalancedAndNotPalindromeAndNotEmptyAndNotEmptyAndNotEmpty\
    \ && !maxPalindrome.isEmpty && !maxPalindrome.isEmpty && !max\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplmz9i44q.scala:21:51 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxPalindromeSum\e[0m =\
    \ maxPalindromeWeight.times(maxPalindromeLength)\n\e[31m\e[31m   |\e[0m      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           value times is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmplmz9i44q.scala:29:5 ---------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlipped = isPalindromic &&\
    \ isBalanced\n        !isFlipped\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyah_tf99.scala:25)\n\tat Problem.main(tmpyah_tf99.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse.forall(x\
    \ => x == sums.head)\n        val isBalanced = sums.forall(x => x <= maxSum)\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7r5fph6n.scala:23)\n\tat Problem.main(tmp7r5fph6n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isPalindromic && isBalanced && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3ekni_xq.scala:24)\n\tat Problem.main(tmp3ekni_xq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduceLeft(_ + _)\n \
    \       isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz3hgdn1r.scala:25)\n\tat Problem.main(tmpz3hgdn1r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = maxSumOfElements == maxSum\n        val isBalanced\
    \ = isPalindromic && maxSumOfElements <= maxWeight\n        val isLessThanMaxWeight\
    \ = maxSumOfElements < maxWeight\n        isBalanced && isLessThanMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptlnrdka9.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        \n        val result = isFly\n        println(s\"$q => $result\")\n \
    \       result\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk8crodgf.scala:27)\n\tat Problem.main(tmpk8crodgf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: 'List(3, 2, 3) => false

    '
  timestamp: 1659800765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldRight(true)((x, y) => x && y <= maxWeight)\n        val\
    \ isLessThanMaxWeight = q.foldRight(false)((x, y) => x && y <= maxWeight)\n  \
    \      val isLessThanMaxSum = q.foldRight(false)((x, y) => x && y <= maxSum)\n\
    \        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyj3n2o20.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyj3n2o20.scala:19:55\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36misBalanced\e[0m = q.foldRight(\e[31mtrue\e[0m)((\e[36mx\e[0m, \e[36my\e[0m)\
    \ => x && y <= maxWeight)\n\e[31m\e[31m   |\e[0m                             \
    \                        ^^^^\e[0m\n\e[31m   |\e[0m                          \
    \              value && is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyj3n2o20.scala:19:63 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = q.foldRight(\e[31mtrue\e\
    [0m)((\e[36mx\e[0m, \e[36my\e[0m) => x && y <= maxWeight)\n\e[31m\e[31m   |\e\
    [0m                                                               ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    (maxWeight\
    \ : Long)\n\e[31m   |\e[0m                                            Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyj3n2o20.scala:20:65\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxWeight\e[0m = q.foldRight(\e[31mfalse\e[0m)((\e[36mx\e[0m, \e\
    [36my\e[0m) => x && y <= maxWeight)\n\e[31m\e[31m   |\e[0m                   \
    \                                            ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                  value && is not a member of Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpyj3n2o20.scala:20:73 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxWeight\e[0m\
    \ = q.foldRight(\e[31mfalse\e[0m)((\e[36mx\e[0"
  stdout: ''
  timestamp: 1659800765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.last)\n\
    \        val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n  \
    \      isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46gcaly8.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isPalindromic\n        val isBalanced\
    \ = isPalindromic && sumOfElements <= maxWeight\n        val isFlipped = !isPalindromic\
    \ && !isBalanced\n        isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyx3x4ppd.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8nw5g9co.scala:23)\n\tat Problem.main(tmp8nw5g9co.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800765
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlipped = isPalindromic && isBalanced\n\
    \        isFlipped\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg9kj02mz.scala:24)\n\tat Problem.main(tmpg9kj02mz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxSumOfWeights = q.foldLeft(0)(_ + _)\n \
    \       val isBalanced = maxSumOfWeights <= maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfWeights\
    \ < maxSum\n        val isLessThanMaxButBalanced = isLessThanMax && isBalanced\n\
    \        val isLessThanMaxButPalindromic = isLessThanMax && isPalindromic\n  \
    \      val isLessThanMaxButNotBalanced = isLessThanMax && !isBalanced\n      \
    \  val isLessThanMaxButNotPalindromic = isLessThanMax && !isPalindromic\n    \
    \    val isLessThanMaxButNotBalancedAndPalindromic = isLessThanMaxButNotBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isBalanced\n        val\
    \ isLessThanMaxButNotBalancedAndNotPalindromicAndBalanced = isLessThanMaxButNotBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndBalancedAndPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndBalancedAndPalindromicAndNotBalanced\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndBalancedAndPalindromicAndNotBalancedAndPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndBalancedAndPalindromicAndNotBalancedAndPalindromicAndNotPalin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_dmo195n.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_dmo195n.scala:18:44 --------------------\e[0m\e[0m\n\e[31m18 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfWeights\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                            ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    Long\n\
    \e[31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_dmo195n.scala:33:5 ---------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659800764
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxWeight2 = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeight3 = w.toLong * q.foldRight(0)(_ + _)\n        val\
    \ maxWeight4 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight5\
    \ = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight6 = w.toLong\
    \ * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight7 = w.toLong * q.foldRight(BigInt(0))(_\
    \ + _)\n        val maxWeight8 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n  \
    \      val maxWeight9 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val\
    \ maxWeight10 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight11\
    \ = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight12 = w.toLong\
    \ * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight13 = w.toLong * q.foldRight(BigInt(0))(_\
    \ + _)\n        val maxWeight14 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n \
    \       val maxWeight15 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val\
    \ maxWeight16 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight17\
    \ = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight18 = w.toLong\
    \ * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight19 = w.toLong * q.foldRight(BigInt(0))(_\
    \ + _)\n        val maxWeight20 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n \
    \       val maxWeight21 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val\
    \ maxWeight22 = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight23\
    \ = w.toLong * q.foldRight(BigInt(0))(_ + _)\n        val maxWeight24 = w.toLong\
    \ * q.foldRight(BigInt(0))(_ + \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsxeilng7.scala:40:63 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight24\e[0m = w.toLong\
    \ * q.foldRight(BigInt(\e[31m0\e[0m))(_ + \n\e[31m\e[31m   |\e[0m            \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                     expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsxeilng7.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight2\e\
    [0m = w.toLong * q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m      \
    \                                            ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                             Found:    Long\n\e[31m   |\e[0m\
    \                                                  Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsxeilng7.scala:19:51 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight3\e[0m = w.toLong\
    \ * q.foldRight(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                  \
    \                                 ^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                                   Found:    Long\n\e[31m   |\e[0m          \
    \                                         Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpsxeilng7.scala:41:5 ---------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659800765
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n  \
    \      isPalindromic && isBalanced && isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbtp49yhn.scala:24)\n\tat Problem.main(tmpbtp49yhn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxWeightSum = w.toLong * q.sum\n\
    \        val maxWeightSumOfQ = q.sum\n        val maxWeightSumOfQAndQ = q.sum\
    \ * q.length\n        val maxWeightSumOfQAndQAndQ = q.sum * q.length * q.length\n\
    \        val maxWeightSumOfQAndQAndQAndQ = q.sum * q.length * q.length * q.length\n\
    \        val maxWeightSumOfQAndQAndQAndQAndQAndQ = q.sum * q.length * q.length\
    \ * q.length * q.length * q.length\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.sum * q.length * q.length * q.length * q.length * q.length * q.length *\
    \ q.length\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ = q.sum\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.sum * q.length * q.length * q.length * q.length * q.length * q.length *\
    \ q.length * q.length * q.length * q.length\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.sum * q.length * q.length * q.length * q.length * q.length * q.length *\
    \ q.length * q.length * q.length * q.length * q.length\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.sum * q.length * q.length * q.length * q.length * q.length * q.length *\
    \ q.length * q.length * q.length * q.length * q.length * q.length * q.length\n\
    \        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ =\
    \ q.sum * q.length * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgf8consh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.sum * q.length * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpgf8consh.scala:30:5 ---------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800773
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x =>\
    \ x > maxWeight)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isFlippableAndBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi_u08_up.scala:25)\n\tat Problem.main(tmpi_u08_up.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q.head)\n        val balanced\
    \ = palindromic && maxSum < maxWeight\n        val unbalanced = !palindromic &&\
    \ maxSum > maxWeight\n        balanced && unbalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm_fjj55e.scala:24)\n\tat Problem.main(tmpm_fjj55e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuq26h67z.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x =>\
    \ x < maxWeight)\n        isPalindromic && isBalanced && isFlippable\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2mcx3i05.scala:24)\n\tat Problem.main(tmp2mcx3i05.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val balanced = q.reverse.foldLeft(false)((acc, x) => acc && x\
    \ == maxSum)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n \
    \       val isBalanced = balanced && isPalindromic\n        val isLessThanMaxWeight\
    \ = maxSum - q.sum <= maxWeight\n        isBalanced && isLessThanMaxWeight\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4n28xir8.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp165hngdn.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800773
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMax\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxPalindromic = isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxPalindromicBalanced = isLessThanMaxPalindromic && isBalanced\n\
    \        val isLessThanMaxPalindromicBalancedAndPalindromic = isLessThanMaxPalindromicBalanced\
    \ && isPalindromic\n        val isLessThanMaxPalindromicBalancedAndPalindromicBalanced\
    \ = isLessThanMaxPalindromicBalancedAndPalindromic && isBalanced\n        val\
    \ isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromic = isLessThanMaxPalindromicBalancedAndPalindromicBalanced\
    \ && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromicBalanced\
    \ = isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromic && isBalanced\
    \ && isPalindromic\n        val isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromicBalancedAndPalindromic\
    \ = isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromic && isBalanced\
    \ && isPalindromic && isPalindromic\n        val isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromicBalancedAndPalindromicBalanced\
    \ = isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromicBalanced\
    \ && isPalindromic && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicBalancedAndPalindromicBalancedAndPalindromicBalancedAndPalindromicBalancedAndPalindromic\
    \ = isLessThanMax\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpc982hcnx.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromicAndIsBalancedAndIsLessThanMaxWeightAndIsPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndIsPalindromicAndIsBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6c6ff1av.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6c6ff1av.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isPalindromic\n        val isBalanced\
    \ = isPalindromic && sumOfElements <= maxWeight\n        val isLessThanMaxWeight\
    \ = sumOfElements < maxWeight\n        isBalanced && isLessThanMaxWeight\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp72x6krbr.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = q.forall(_ <= maxWeight)\n        val isFlippable = q.forall(_\
    \ <= maxSum)\n        isPalindromic && isBalanced && isFlippable\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp62s8nbf4.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q == q.reverse\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isLessOrEqual = maxSum == maxWeight\n        isPalindromic\
    \ && isBalanced && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsjzyvr2u.scala:24)\n\tat Problem.main(tmpsjzyvr2u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = q == q.reverse\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isFlippable\
    \ = isPalindromic && isBalanced\n        val isLessThanMax = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n\
    \        isFlippable && isLessThanMaxAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp272pe9hf.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = maxSumOfElements.toLong == maxSum\n        val isBalanced\
    \ = maxSumOfElements.toLong <= maxWeight\n        val isFlippable = maxSumOfElements.toLong\
    \ <= maxSum\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced &&\
    \ isPalindromic\n        isFlippableAndBalancedAndPalindromic\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqoxtshf.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(_ < 0)\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        isPalindromic\
    \ && isBalanced && isFlippableAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_wyf56pr.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sum = 0L\n        q.foreach { x => sum += x }\n        sum < maxSum && sum ==\
    \ sum.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcxilztba.scala:18:29 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpcxilztba.scala:19:35 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        sum < maxSum && sum == sum.reverse\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                               value reverse is not a member of Long\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxWeightSum = w.toLong * q.length\n     \
    \   val maxWeightSumOfQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5d07pnix.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5d07pnix.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group o"
  stdout: ''
  timestamp: 1659800777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxSumOfElements = q.map(x => math.abs(x - maxSum)).max\n       \
    \ val isPalindromic = q.isPalindromic\n        val isBalanced = isPalindromic\
    \ && maxSumOfElements <= maxWeight\n        val isLessThanMaxWeight = maxSumOfElements\
    \ < maxWeight\n        val isLessThanMaxSum = maxSumOfElements < maxSum\n    \
    \    val isLessThanMaxSumOfElements = maxSumOfElements < maxSumOfElements\n  \
    \      val isLessThanMaxSumOfElementsAndBalanced = isLessThanMaxSumOfElements\
    \ && isBalanced\n        val isLessThanMaxSumOfElementsAndNotBalanced = isLessThanMaxSumOfElements\
    \ && !isBalanced\n        isLessThanMaxWeight || isLessThanMaxSum || isLessThanMaxSumOfElements\
    \ || isLessThanMaxSumOfElementsAndBalanced || isLessThanMaxSumOfElementsAndNotBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpocwu2z0n.scala:19:30 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong).sum\n        sums <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpan8out18.scala:22)\n\tat Problem.main(tmpan8out18.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong).sum\n        sums <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpan8out18.scala:22)\n\tat Problem.main(tmpan8out18.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptiidcstw.scala:23)\n\tat Problem.main(tmptiidcstw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqualToMaxSum = maxSumOfElements <= maxSum\n        isBalanced\
    \ && isPalindromic && isLessOrEqualToMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppmf8kzvr.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isReverse.forall(x => x == q.head)\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = q.tail.forall(x => x == q.head)\n        val isFlippable = q.tail.forall(x\
    \ => x == q.tail.head)\n        val isFlippable = q.tail.forall(x => x == q.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.head)\n  \
    \      val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head)\n\
    \        val isFlippable = q.tail.forall(x => x == q.tail.tail.tail.tail.tail.tail\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpir3ebqzo.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpir3ebqzo.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.tail.forall(\e[36mx\e[0m => x == q.tail.head)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir3ebqzo.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.tail.forall(\e\
    [36mx\e[0m => x == q.tail.tail.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir3ebqzo.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.tail.forall(\e\
    [36mx\e[0m => x == q.tail.tail.tail.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir3ebqzo.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.tail.forall(\e\
    [36mx\e[0m => x == q.tail.tail.tail.tail.head)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as"
  stdout: ''
  timestamp: 1659800777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxSumAndBalanced = maxSum < maxWeight && maxSum == maxWeight\n  \
    \      val isLessThanMaxWeightAndBalanced = maxSum < maxWeight && maxSum == maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight &&\
    \ maxSum == maxWeight && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isLessThanMaxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndLessThanMaxSum\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxWeightAndLessThanMaxSum\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxWeightAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum && isLessThanMaxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxWeightAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && maxSum == maxWeight && is\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmn4pdafc.scala:31:161 -----------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxWeightAndLessThanMaxSumAndLessThanMaxWeight\e\
    [0m = maxSum < maxWeight && maxSum == maxWeight && is\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \                                                                            \
    \        ^^\e[0m\n\e[31m   |\e[0m                                            \
    \               Not found: is\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmn4pdafc.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800776
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong).sum\n        sums <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpan8out18.scala:22)\n\tat Problem.main(tmpan8out18.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced\
    \ = maxSum - q.sum < maxWeight\n        isPalindromic && isBalanced\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbhfn1b0x.scala:23)\n\tat Problem.main(tmpbhfn1b0x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800778
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxWeightSum = w.toLong * q.length\n     \
    \   val maxWeightSumOfElements = w.toLong * q.sum\n        val maxWeightSumOfElementsOfElements\
    \ = w.toLong * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum\n       \
    \ val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum\n\
    \        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum *\
    \ q.sum * q.sum\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong * q.sum * q.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv42ejufr.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpv42ejufr.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800784
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w.toLong\n        val maxSum\
    \ = q.reduce(_ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight * 2\n        val isLessThanMaxSum = maxSum < maxWeight\
    \ * 3\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxSumAndBalanced = isLessThanMaxSum && isBalanced\n  \
    \      val isLessThanMaxWeightAndBalancedAndPalindromic = isLessThanMaxWeightAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic = isLessThanMaxSumAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic = isLessThanMaxSumAndBalancedAndPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic && !isPalindromic\
    \ && !isBalanced\n        isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9bozh786.scala:33)\n\tat Problem.main(tmp9bozh786.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum -\
    \ maxWeight < 0\n        val isLessThanMaxSum = maxSum < 0\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxWeightAndBalanced\
    \ = isLessThanMaxSum && isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxWeightAndBalanced && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = isLessThanMaxSumAndBalancedAndPalindromic\n        val isLessThanMaxSumAndBalancedAndP\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxenc8lsb.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxenc8lsb.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxSumAndBalancedAndPalindromic\e[0m = isLessThanMaxSumAndBalancedAndPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxenc8lsb.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromic\e\
    [0m = isLessThanMaxSumAndBalancedAndPalindromic\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpxenc8lsb.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromic\e\
    [0m = isLessThanMaxSumAndBalancedAndPalindromic\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxSumAndBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Err"
  stdout: ''
  timestamp: 1659800785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxWeightAndBalanced = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp76pf7va1.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp76pf7va1.scala:35:5 ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800783
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.last\n        val palindromic = q.reverse.forall(x\
    \ => x <= maxWeight)\n        val sum = palindromic && q.sum <= maxSum\n     \
    \   sum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp34hza95i.scala:24)\n\tat Problem.main(tmp34hza95i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessOrEqual = maxSum <=\
    \ maxWeight\n        isPalindromic && isBalanced && isLessOrEqual\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3s2b96ak.scala:24)\n\tat Problem.main(tmp3s2b96ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        val isLessOrEqualBalanced = maxSum < maxWeight && isBalanced\n      \
    \  val isLessOrEqualPalindromic = maxSum < maxWeight && isPalindromic\n      \
    \  val isLessOrEqualBalancedPalindromic = maxSum < maxWeight && isBalanced &&\
    \ isPalindromic\n        val isLessOrEqualPalindromicBalanced = maxSum < maxWeight\
    \ && isPalindromic && isBalanced\n        val isLessOrEqualBalancedPalindromicBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced\n        val\
    \ isLessOrEqualPalindromicBalancedPalindromic = maxSum < maxWeight && isPalindromic\
    \ && isBalanced && isPalindromic\n        val isLessOrEqualBalancedPalindromicBalancedPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && isPalindromic\n\
    \        val isLessOrEqualPalindromicBalancedPalindromicBalanced = maxSum < maxWeight\
    \ && isPalindromic && isBalanced && isPalindromic && isBalanced\n        val isLessOrEqualBalancedPalindromicBalancedPalindromicBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && isPalindromic\
    \ && isBalanced\n        val isLessOrEqualPalindromicBalancedPalindromicBalancedPalindromic\
    \ = maxSum < maxWeight && isPalindromic && isBalanced && isPalindromic && isBalanced\
    \ && isPalindromic\n        val isLessOrEqualBalancedPalindromicBalancedPalindromicBalancedPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && isPalindromic\
    \ && isBalanced && isPalindromic\n        val isLessOrEqualPalindromicBalancedPalindromicBalancedPalindromicBalancedPalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5n18s5l3.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5n18s5l3.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoi0u8in.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isPalindromic && !isBalanced\n        isFly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjzxcbdqy.scala:25)\n\tat Problem.main(tmpjzxcbdqy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.reverse.forall(_ == q.head)\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isPalindromic && !isBalanced\n      \
    \  isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1o_lnism.scala:25)\n\tat Problem.main(tmp1o_lnism.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqualToMaxSum = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxSumOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxSumOfElements\n        isBalanced && isPalindromic\
    \ && isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElements\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqgneij9q.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqgneij9q.scala:21:60 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxSumOfElements\n\e[31m\e[31m   |\e\
    [0m                                                            ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                          Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum - q.length <= maxWeight\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9dm79j6k.scala:23)\n\tat Problem.main(tmp9dm79j6k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x => x !=\
    \ q.head)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n  \
    \      val isFlippableAndPalindromic = isFlippable && isPalindromic\n        val\
    \ isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced && isPalindromic\n\
    \        isFlippableAndBalancedAndPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpedis3fwn.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800785
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = maxSumOfElements <= maxSum\n       \
    \ isPalindromic && isBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8mhvdnz.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(x => x\
    \ == q(0))\n        val isBalanced = maxSumOfElements <= maxSum\n        val isFlipped\
    \ = q.forall(x => x == q.reverse(0))\n        isPalindromic && isBalanced && isFlipped\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0qputena.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800786
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q(0))\n  \
    \      val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n    \
    \    isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsz_94mx0.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.isPalindromic\n        val isBalanced = isPalindromic\
    \ && maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n   \
    \     val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val\
    \ isLessThanMaxAndBalancedAndNotPalindromic = isLessThanMaxAndBalanced && !isPalindromic\n\
    \        val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxAndBalancedAndPalindromic && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced\n \
    \       val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced &&\
    \ !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced &&\
    \ !isPalindromic && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced &&\
    \ !isPalindromic && !isPalindromic && !isBalanced\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced &&\
    \ !isPalin\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0kvv7un.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0kvv7un.scala:29:224 -----------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic && !isBalanced &&\
    \ !isPalin\n\e[31m\e[31m   |\e[0m                                            \
    \                                                                            \
    \                                                                            \
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                                   Not found: isPalin\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf0kvv7un.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlipped = q.forall(x => x\
    \ != q(0))\n        val isLessThanMaxWeight = maxSum < maxWeight\n        val\
    \ isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && maxSum == q.reduceLeft(_ + _)\n        val isLessThanMaxSumAndFlipped\
    \ = maxSum < maxWeight && maxSum == q.reduceLeft(_ + _) && q.forall(x => x !=\
    \ q(0))\n        val isLessThanMaxSumAndFlippedAndBalanced = maxSum < maxWeight\
    \ && maxSum == q.reduceLeft(_ + _) && q.forall(x => x != q(0)) && q.forall(x =>\
    \ x == q(0))\n        val isLessThanMaxSumAndFlippedAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == q.reduceLeft(_ + _) && q.forall(x => x !=\
    \ q(0)) && q.forall(x => x == q(0)) && q.reverse.forall(x => x == q(0))\n    \
    \    val isLessThanMaxSumAndFlippedAndBalancedAndPalindromicAndFlipped = maxSum\
    \ < maxWeight && maxSum == q.reduceLeft(_ + _) && q.forall(x => x != q(0)) &&\
    \ q.forall(x => x == q(0)) && q.reverse.forall(x => x == q(0)) && q.forall(x =>\
    \ x != q(0))\n        val isLessThanMaxSumAndFlippedAndBalancedAndPalindromicAndFlippedAndBalanced\
    \ = maxSum < maxWeight && maxSum == q.reduceLeft(_ + _) && q.forall(x => x !=\
    \ q(0)) && q.forall(x => x == q(0)) && q.reverse.forall(x => x == q(0)) && q.forall(x\
    \ => x != q(0)) && q.forall(x => x == q(0))\n        val isLessThanMaxSumAndFlippedAndBalancedAndPalindromicAndFlippedAndBalancedAndFlipped\
    \ = maxSum < maxWeight && max\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpter0yhct.scala:29:119 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndFlippedAndBalancedAndPalindromicAndFlippedAndBalancedAndFlipped\e\
    [0m = maxSum < maxWeight && max\n\e[31m\e[31m   |\e[0m                       \
    \                                                                            \
    \                    ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double, y: Double): Double\n\e[31m   |\e[0m\
    \ (x: Float, y: Float): Float\n\e[31m   |\e[0m (x: Long, y: Long): Long\n\e[31m\
    \   |\e[0m (x: Int, y: Int): Int\n\e[31m   |\e[0mmatch expected type Boolean\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpter0yhct.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n     \
    \   val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < w\n        val isLessThanMaxSum = maxSum < q.foldLeft(0)(_ + _)\n        isPalindromic\
    \ && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6qine500.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6qine500.scala:21:54\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSum\e\
    [0m = maxSum < q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                   Found:    Long\n\e[31m   |\e\
    [0m                                                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.reduceRight(_\
    \ + _))\n        val isBalanced = q.forall(x => x <= maxWeight && x >= 0)\n  \
    \      val isLessOrEqual = q.forall(x => x <= maxWeight && x >= 0)\n        isPalindromic\
    \ && isBalanced && isLessOrEqual && maxSum < maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc2xrs6dx.scala:24)\n\tat Problem.main(tmpc2xrs6dx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfQ\
    \ = q.sum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n    \
    \    val isBalanced = q.forall(x => x <= maxSum)\n        val isLessThanMax =\
    \ maxSumOfQ - q.sum < maxSum\n        val isLessThanMaxOfQ = q.sum - maxSumOfQ\
    \ < maxSum\n        isPalindromic && isBalanced && isLessThanMax && isLessThanMaxOfQ\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyst9py_j.scala:25)\n\tat Problem.main(tmpyst9py_j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800790
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        isPalindromic && isBalanced\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8nw5g9co.scala:23)\n\tat Problem.main(tmp8nw5g9co.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800765
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isPalindromic && !isBalanced\n        isFly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjzxcbdqy.scala:25)\n\tat Problem.main(tmpjzxcbdqy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeoi0u8in.scala:17:42\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj4azif20.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n     \
    \   val isBalanced = maxSum - q.sum < maxWeight\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_khz6s8s.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800789
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.isReverse.forall(x => x == q(0))\n     \
    \   val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxWeightAndBalanced = maxSum < maxWeight && isBalanced\n        val\
    \ isLessThanMaxSumAndBalanced = maxSum < maxWeight && isBalanced\n        val\
    \ isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight && isBalanced\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxSum\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSum\n  \
    \      val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxSum = maxSum\
    \ < maxWeight && isBalanced && isPalindromic && isLessThanMaxSum\n        val\
    \ isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeight\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeightAndBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeightAndBalanced\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeightAndBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeightAndBalanced\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpypdrdmxd.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpypdrdmxd.scala:18:30\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = q.isReverse.forall(\e[36mx\e[0m => x == q(\e[31m0\e[0m))\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m value isReverse is not a member of List[Long] - did you mean q.reverse?\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpypdrdmxd.scala:28:149 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxWeightAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeight\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeight\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                        Not found: isLessThanMaxSumAndLessThanMaxWeight\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpypdrdmxd.scala:29:146 -----------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndLessThanMaxSumAndLessThanMaxWeight\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isLessThanMaxSumAndLessThanMaxWeight\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                     Not found: isLessThanMaxSumAndLessThanMaxWeight\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpypdrdmxd.scala:30:160 -----------------------\e\
    [0m\e[0m\n\e[31m30 |"
  stdout: ''
  timestamp: 1659800790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && q.forall(x => x <= maxWeight)\n        val sumLessThanMax =\
    \ q.sum < maxWeight\n        val sumLessThanMaxButNotBalanced = q.sum < maxWeight\
    \ && !balanced\n        val sumLessThanMaxButBalanced = q.sum < maxWeight && balanced\n\
    \        val sumGreaterThanMax = q.sum > maxWeight\n        val sumGreaterThanMaxButNotBalanced\
    \ = q.sum > maxWeight && !balanced\n        val sumGreaterThanMaxButBalanced =\
    \ q.sum > maxWeight && balanced\n        val sumEqualMax = q.sum == maxWeight\n\
    \        val sumEqualMaxButNotBalanced = q.sum == maxWeight && !balanced\n   \
    \     val sumEqualMaxButBalanced = q.sum == maxWeight && balanced\n        val\
    \ sumLessThanMaxButNotBalancedButEqualMax = q.sum < maxWeight && !balanced &&\
    \ q.sum == maxWeight\n        val sumLessThanMaxButBalancedButEqualMax = q.sum\
    \ < maxWeight && balanced && q.sum == maxWeight\n        val sumGreaterThanMaxButNotBalancedButEqualMax\
    \ = q.sum > maxWeight && !balanced && q.sum == maxWeight\n        val sumGreaterThanMaxButBalancedButEqualMax\
    \ = q.sum > maxWeight && balanced && q.sum == maxWeight\n        val sumEqualMaxButNotBalancedButEqualMax\
    \ = q.sum == maxWeight && !balanced && q.sum == maxWeight\n        val sumEqualMaxButBalancedButEqualMax\
    \ = q.sum == maxWeight && balanced && q.sum == maxWeight\n        val sumLessThanMaxButNotBalancedButEqualMaxButNotBalanced\
    \ = q.sum < maxWeight && !balanced && q.sum == maxWeight && !balanced\n      \
    \  val sumLessThanMaxButBalancedButEqualMaxButNotBalanced = q.sum < maxWeight\
    \ && balanced && q.sum == maxWeight && !balanced\n        val sumGreaterThanMaxButNotBalancedButEqualMaxButNotBalanced\
    \ = q.sum > maxWeight && !balanced && q.sum == maxWeight && !balanced\n      \
    \  val sumGreaterThanMaxButBalancedButEqualMaxButNotBalanced = q.sum > maxWeight\
    \ && balanced && q.sum == maxWeight && !balance\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6b1kbm2.scala:38:124 -----------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msumGreaterThanMaxButBalancedButEqualMaxButNotBalanced\e\
    [0m = q.sum > maxWeight && balanced && q.sum == maxWeight && !balance\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                            ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                      Not found:\
    \ balance\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi6b1kbm2.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800795
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x => x == q(0))\n\
    \        val isBalanced = q.reduce(_ + _) <= maxWeight\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n\
    \        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7devaqh4.scala:25)\n\tat Problem.main(tmp7devaqh4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(false)((acc, x) => acc && x <= maxWeight && isPalindromic\
    \ && x == q(q.length - 1))\n        val isLessThanMaxWeight = q.foldLeft(false)((acc,\
    \ x) => acc && x <= maxWeight && isBalanced && x == q(q.length - 1))\n       \
    \ isLessThanMaxWeight\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyptlrj86.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val maxSumOfElements = q.sum\n        val maxSumOfElementsOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromes = q.sum\n  \
    \      val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromes = q.sum\n \
    \       val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ = q.sum\n        val maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpae0n9zo2.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpae0n9zo2.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\e\
    [0m = q.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpae0n9zo2.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\e\
    [0m = q.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumOfElementsOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromesOfPalindromes\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel"
  stdout: ''
  timestamp: 1659800797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.reduceLeft(_\
    \ + _))\n        val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n\
    \        isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj5ae4qlr.scala:24)\n\tat Problem.main(tmpj5ae4qlr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800798
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.reduceRight(_\
    \ + _))\n        val isBalanced = maxSum < maxWeight\n        isPalindromic &&\
    \ isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk7fzihnx.scala:23)\n\tat Problem.main(tmpk7fzihnx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessThanMax = maxSumOfElements < w\n        val isLessThanMaxOfElements\
    \ = q.foldLeft(0)(_ + _) < w\n        isBalanced && isPalindromic && isLessThanMax\
    \ && isLessThanMaxOfElements\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpawb0s0t8.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpawb0s0t8.scala:21:52 --------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxOfElements\e[0m\
    \ = q.foldLeft(\e[31m0\e[0m)(_ + _) < w\n\e[31m\e[31m   |\e[0m               \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                        Found:    Long\n\e[31m   |\e[0m     \
    \                                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659800797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isPalindromic && isBalanced && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_npib3h.scala:24)\n\tat Problem.main(tmpq_npib3h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isPalindromic && isBalanced && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_npib3h.scala:24)\n\tat Problem.main(tmpq_npib3h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n     \
    \   isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9gz2_ykj.scala:25)\n\tat Problem.main(tmp9gz2_ykj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q.head)\n        val balanced\
    \ = palindromic && q.sum < maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q.head)\n        val isBalanced = palindromic && q.sum < maxWeight\n\
    \        val isLessThanMax = q.sum < maxWeight\n        val isLessThanMaxPalindromic\
    \ = q.reverse.forall(x => x == q.head)\n        val isLessThanMaxPalindromicBalanced\
    \ = palindromic && q.sum < maxWeight\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMax\
    \ = q.sum < maxWeight && palindromic\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromic\
    \ = q.reverse.forall(x => x == q.head)\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromicBalanced\
    \ = palindromic && q.sum < maxWeight\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromicBalancedAndIsPalindromic\
    \ = q.sum < maxWeight && palindromic && isPalindromic\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromicBalancedAndIsPalindromicBalanced\
    \ = palindromic && q.sum < maxWeight && palindromic && isPalindromic && isBalanced\n\
    \        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromicBalancedAndIsPalindromicBalancedAndIsPalindromic\
    \ = q.sum < maxWeight && palindromic && isPalindromic && isBalanced && isPalindromic\n\
    \        val isLessThanMaxPalindromicBalancedAndSumLessThanMaxPalindromicBalancedAndIsPalindromicBalancedAndIsPalindromicBalanced\
    \ = palindromic && q.sum < maxWeight && palindromic && isPalindromic && isBalanced\
    \ && isPalindromic && isBalanced\n        val isLessThanMaxPalindromicBalancedAndSumLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxj3hdhz0.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpxj3hdhz0.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.last)\n\
    \        val isFlippable = q.forall(x => x <= maxWeight && x >= maxWeight - q.last)\n\
    \        val isFlippableAndBalanced = isFlippable && isBalanced\n        val isFlippableAndPalindromic\
    \ = isFlippable && isPalindromic\n        val isFlippableAndBalancedPalindromic\
    \ = isFlippableAndPalindromic && isBalanced\n        val isFlippableAndBalancedPalindromicPalindromic\
    \ = isFlippableAndPalindromic && isBalanced && isPalindromic\n        val isFlippableAndBalancedPalindromicPalindromicPalindromic\
    \ = isFlippableAndPalindromic && isBalanced && isPalindromic && isPalindromic\n\
    \        val isFlippableAndBalancedPalindromicPalindromicPalindromicPalindromic\
    \ = isFlippableAndPalindromic && isBalanced && isPalindromic && isPalindromic\
    \ && isPalindromic\n        val isFlippableAndBalancedPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = isFlippableAndPalindromic && isBalanced && isPalindromic && isPalindromic\
    \ && isPalindromic && isPalindromic\n        val isFlippableAndBalancedPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = isFlippableAndPalindromic && isBalanced && isPalindromic && isPalindromic\
    \ && isPalindromic && isPalindromic && isPalindromic\n        val isFlippableAndBalancedPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = isFlippableAndPalindro\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjxmp98go.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjxmp98go.scala:29:114\
    \ -----------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36misFlippableAndBalancedPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = isFlippableAndPalindro\n\e[31m\e[31m   |\e[0m                          \
    \                                                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                   Not found: isFlippableAndPalindro\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjxmp98go.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(false)((acc, x) => acc && x != q(0))\n        val\
    \ isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n\
    \        isLessThanMaxAndBalanced || isLessThanMaxAndPalindromic\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpid48dzqm.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isLessOrEqual = q.forall(x => x <= maxWeight && x >= maxWeight -\
    \ q.length)\n        isPalindromic && isBalanced && isLessOrEqual\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjqc3wmb4.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessThanMax = maxSumOfElements < w\n        isBalanced && isPalindromic\
    \ && isLessThanMax\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaazy2pe4.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum == maxWeight\n        val isFlippable = isPalindromic\
    \ && isBalanced\n        val isFlippable = q.reverse.forall(x => x == q(0))\n\
    \        isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprq94ypsa.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == q(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlippable is already defined as \e[33mvalue\e[0m \e[35misFlippable\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n1 error found\n"
  stdout: ''
  timestamp: 1659800795
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q.head)\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMax = q.sum\
    \ < maxWeight\n        val isLessThanMaxButNotBalanced = q.sum < maxWeight &&\
    \ isBalanced\n        val isLessThanMaxButNotPalindromic = q.sum < maxWeight &&\
    \ !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic = q.sum\
    \ < maxWeight && !isPalindromic && !isBalanced\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !isBalanced && !q.exists(x => x ==\
    \ 0)\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !isBalanced && !q.exists(x => x ==\
    \ 0) && !q.exists(x => x == 0)\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !isBalanced && !q.exists(x => x ==\
    \ 0) && !q.exists(x => x == 0) && !q.exists(x => x == 0)\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !isBalanced && !q.exists(x => x ==\
    \ 0) && !q.exists(x => x == 0) && !q.exists(x => x == 0) && !q.exists(x => x ==\
    \ 0)\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !isBalanced && !q.exists(x => x ==\
    \ 0) && !q.exists(x => x == 0) && !q.exists(x => x == 0) && !q.exists(x => x ==\
    \ 0) && !q.exists(x => x == 0)\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = q.sum < maxWeight && !isPalindromic && !is\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphxrzt4hi.scala:29:159 -----------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\e\
    [0m = q.sum < maxWeight && !isPalindromic && !is\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \                                                                            \
    \ ^^\e[0m\n\e[31m   |\e[0m                                                   \
    \        Not found: is\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphxrzt4hi.scala:30:5\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800798
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum <\
    \ maxWeight\n        val isLessThanMaxSum = maxSum < q.reduceLeft(_ + _)\n   \
    \     val isLessThanMaxSumAndBalanced = isLessThanMaxWeight && isBalanced\n  \
    \      val isLessThanMaxSumAndPalindromic = isLessThanMaxWeight && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = isLessThanMaxWeight &&\
    \ isBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\
    \ && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeight && !isBalanced && !isPalindromic && !isLessThanMaxWeight\
    \ && !isPalindromic && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmcpnwlr7.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpmcpnwlr7.scala:31:5 ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n  \
    \      val isBalanced = sumOfElements <= maxWeight\n        val isFlippable =\
    \ q.tail.forall(x => x <= maxWeight)\n        isPalindromic && isBalanced && isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1axrakbf.scala:24)\n\tat Problem.main(tmp1axrakbf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMax\
    \ = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMaxAndBalanced\
    \ = q.forall(x => x <= maxWeight && x >= 0 && isBalanced)\n        isPalindromic\
    \ && isBalanced && isLessThanMax && isLessThanMaxAndBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiesf49rl.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n  \
    \      isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_abuy27w.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n  \
    \      isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_abuy27w.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.forall(_ < w)\n        val isFlippedAndBalanced\
    \ = isFlipped && isBalanced\n        isPalindromic && isBalanced && isFlippedAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmps5bo1wpp.scala:18:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659800801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.last)\n\
    \        val isLessThanMax = q.forall(x => x <= maxWeight && x >= maxSum)\n  \
    \      isPalindromic && isBalanced && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46gcaly8.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800763
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && maxSum - q.sum <= maxWeight\n        val unbalanced = palindromic\
    \ && maxSum - q.sum > maxWeight\n        balanced && unbalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfzsyq713.scala:24)\n\tat Problem.main(tmpfzsyq713.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800804
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(x =>\
    \ x != q(0))\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isPalindromic && isBalanced && isFlippableAndBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpezh23i14.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800801
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isLessOrEqual = maxSum == maxWeight\n    \
    \    isPalindromic && isBalanced && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz62zp62a.scala:24)\n\tat Problem.main(tmpz62zp62a.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800808
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.reduceLeft(_ + _) <= maxWeight\n        val isLessOrEqual\
    \ = maxSum - q.reduceLeft(_ + _) <= maxWeight\n        isPalindromic && isBalanced\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpitbg1djt.scala:24)\n\tat Problem.main(tmpitbg1djt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < maxWeight)\n        val isFlippable =\
    \ q.forall(_ < maxWeight)\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        val isFlippable = q.forall(_ < \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbb425_kx.scala:48:38 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(_\
    \ < \n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                                      expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb425_kx.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.forall(_ < maxWeight)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misFlippable\
    \ is already defined as \e[33mvalue\e[0m \e[35misFlippable\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb425_kx.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.forall(_ < maxWeight)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misFlippable\
    \ is already defined as \e[33mvalue\e[0m \e[35misFlippable\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb425_kx.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.forall(_ < maxWeight)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misFlippable\
    \ is already defined as \e[33mvalue\e[0m \e[35misFlippable\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb425_kx.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36misFlippable\e[0m = q.forall(_ < maxWeight)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0misFlippabl"
  stdout: ''
  timestamp: 1659800806
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(0)(_ + _) == maxSum\n        val isLessThanMax =\
    \ maxWeight - maxSum < 0\n        val isLessThanMaxAndBalanced = isLessThanMax\
    \ && isBalanced\n        isPalindromic && isLessThanMaxAndBalanced\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ytu2eat.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ytu2eat.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) == maxSum\n\e[31m\e[31m   |\e[0m       \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800808
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isPalindromic\n        val isBalanced\
    \ = isPalindromic && sumOfElements <= maxWeight\n        val isFlipped = !isPalindromic\
    \ && sumOfElements > maxWeight\n        isBalanced && isFlipped\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgfhr8kzj.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800808
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w.toInt\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.reverse.forall(x => x == q.head)\n  \
    \      val isBalanced = sumOfElements <= maxWeight\n        val isFlippable =\
    \ q.tail.forall(x => x == q.head)\n        val isFlippableAndBalanced = isFlippable\
    \ && isBalanced\n        val isFlippableAndBalancedAndPalindromic = isFlippableAndBalanced\
    \ && isPalindromic\n        isFlippableAndBalancedAndPalindromic\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbs0vc7tw.scala:26)\n\tat Problem.main(tmpbs0vc7tw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.foldLeft(0)(_ + _)\n       \
    \ val maxWeight = q.foldLeft(0)(_ + _)\n        val maxSumOfWeight = q.foldLeft(0)(_\
    \ + _)\n        val maxSumOfWeightOfElements = q.foldLeft(0)(_ + _)\n        val\
    \ maxSumOfWeightOfElementsOfElements = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd4r3_hsk.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd4r3_hsk.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumOfWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpd4r3_hsk.scala:16:35 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    Long\n\e[31m\
    \   |\e[0m                                   Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd4r3_hsk.scala:17:38 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m                                      Found:   \
    \ Long\n\e[31m   |\e[0m                                      Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch"
  stdout: ''
  timestamp: 1659800811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q == q.sort\n        val isBalanced = isPalindromic\
    \ && maxSum == maxWeight\n        val isLessOrEqual = maxSum < maxWeight\n   \
    \     isBalanced && isLessOrEqual\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpate1m1ko.scala:18:35 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q ==\
    \ q.sort\n\e[31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\e\
    [31m   |\e[0m       value sort is not a member of List[Long] - did you mean q.sortBy?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sum = 0L\n        for (i <- 0 until q.length) {\n            sum += q(i)\n \
    \       }\n        sum <= maxSum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwolasym6.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            sum += q(i)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1659800809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxPalindromic = q.reverse.forall(x => x <=\
    \ maxWeight)\n        val maxPalindromicSum = maxPalindromic.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = maxPalindromicSum == maxSum\n        val isBalanced\
    \ = q.forall(x => x <= maxWeight)\n        isPalindromic && isBalanced\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfhoypkmc.scala:19:47 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxPalindromicSum\e[0m =\
    \ maxPalindromic.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                        value foldLeft is not a member of Boolean\n1 error found\n"
  stdout: ''
  timestamp: 1659800809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxWeight\
    \ = w.toLong\n        val maxSumOfElements = q.foldLeft(0L) { (sum, element) =>\
    \ sum + element }\n        val isPalindromic = maxSumOfElements == maxSum\n  \
    \      val isBalanced = maxSumOfElements <= maxWeight\n        val isLessThanMaxWeight\
    \ = maxSumOfElements < maxWeight\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements < q.foldLeft(0L)\
    \ { (sum, element) => sum + element }\n        val isLessThanMaxSumOfElementsOrEqualToMaxSum\
    \ = maxSumOfElements <= q.foldLeft(0L) { (sum, element) => sum + element }\n \
    \       val isLessThanMaxSumOfElementsOrEqualToMaxSumOrEqualToMaxWeight = maxSumOfElements\
    \ <= q.foldLeft(0L) { (sum, element) => sum + element } || maxSumOfElements ==\
    \ maxWeight\n        val isLessThanMaxSumOfElementsOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSum\
    \ = maxSumOfElements <= q.foldLeft(0L) { (sum, element) => sum + element } ||\
    \ maxSumOfElements == maxSum || maxSumOfElements == maxWeight\n        val isLessThanMaxSumOfElementsOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSumOrEqualToMaxWeight\
    \ = maxSumOfElements <= q.foldLeft(0L) { (sum, element) => sum + element } ||\
    \ maxSumOfElements == maxSum || maxSumOfElements == maxSum || maxSumOfElements\
    \ == maxWeight\n        val isLessThanMaxSumOfElementsOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSum\
    \ = maxSumOfElements <= q.foldLeft(0L) { (sum, element) => sum + element } ||\
    \ maxSumOfElements == maxSum || maxSumOfElements == maxSum || maxSumOfElements\
    \ == maxSum || maxSumOfElements == maxWeight\n        val isLessThanMaxSumOfElementsOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSumOrEqualToMaxWeightOrEqualToMaxSumOrEqualTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiy28eerd.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpiy28eerd.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800809
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.reduce(_ + _)\n        val maxWeight\
    \ = q.reduce(_ + _)\n        val isPalindromic = q.isEmpty || q.head == q.reverse.head\n\
    \        val isBalanced = maxSum == w\n        val isFlipped = q.tail == q.reverse.tail\n\
    \        val isLessThanMaxWeight = maxWeight < w\n        val isLessThanMaxSum\
    \ = maxSum < w\n        isPalindromic && isBalanced && isFlipped && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjesw8d7y.scala:26)\n\tat Problem.main(tmpjesw8d7y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isReverse.forall(_ == q.head)\n     \
    \   val isBalanced = sumOfElements <= maxWeight\n        val isFly = isPalindromic\
    \ && isBalanced\n        val isNotFly = !isPalindromic && !isBalanced\n      \
    \  isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp61i_10iz.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isReverse.forall(_\
    \ == q.head)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m value isReverse is not a member of List[Long] - did you mean q.reverse?\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(false)((acc, x) => acc && x <= maxWeight && x ==\
    \ q(q.length - 1))\n        val isLessThanMax = q.foldLeft(false)((acc, x) =>\
    \ acc && x <= maxWeight && x == q(q.length - 1))\n        val isLessThanMaxAndBalanced\
    \ = q.foldLeft(false)((acc, x) => acc && x <= maxWeight && x == q(q.length - 1))\n\
    \        val isLessThanMaxAndBalancedAndPalindromic = q.foldLeft(false)((acc,\
    \ x) => acc && x <= maxWeight && x == q(q.length - 1))\n        isPalindromic\
    \ && isBalanced && isLessThanMax && isLessThanMaxAndBalanced && isLessThanMaxAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppa1zv41w.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse == sums\n\
    \        val isBalanced = sums.sum < maxSum\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpauzu105d.scala:28)\n\tat Problem.main(tmpauzu105d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800812
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && q.sum <= maxWeight\n        val unbalanced = palindromic &&\
    \ q.sum > maxWeight\n        val isFlipping = balanced && unbalanced\n       \
    \ val isNotFlipping = !isFlipping\n        isFlipping || isNotFlipping\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptedhgkn2.scala:27)\n\tat Problem.main(tmptedhgkn2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxWeightSum = w.toLong * q.length\n     \
    \   val maxWeightSumOfElements = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgpzkfzp1.scala:31:174 --------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + \n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgpzkfzp1.scala:19:51 --------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElements\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \               ^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \                 Found:    Long\n\e[31m   |\e[0m                            \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpgpzkfzp1.scala:20:61 --------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                                            ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                                     Found:    Long\n\e[31m \
    \  |\e[0m                                                          Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgpzkfzp1.scala:21:71\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfElementsOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                        "
  stdout: ''
  timestamp: 1659800813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxWeightSum = w.toLong * q.length\n     \
    \   val maxWeightSumOfQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5d07pnix.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5d07pnix.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group o"
  stdout: ''
  timestamp: 1659800777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        return maxSumOfElements <=\
    \ maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5imwt11p.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isEmpty\n        val isBalanced = sumOfElements\
    \ <= maxWeight\n        val isFlipped = q.tail == q.init.reverse\n        val\
    \ isLessOrEqual = sumOfElements <= maxWeight && sumOfElements >= sumOfElements.max\n\
    \        val isLessOrEqualAndBalanced = sumOfElements <= maxWeight && sumOfElements\
    \ >= sumOfElements.max && isBalanced\n        val isLessOrEqualAndFlipped = sumOfElements\
    \ <= maxWeight && sumOfElements >= sumOfElements.max && isFlipped\n        val\
    \ isLessOrEqualAndPalindromic = sumOfElements <= maxWeight && sumOfElements >=\
    \ sumOfElements.max && isPalindromic\n        isLessOrEqual || isLessOrEqualAndBalanced\
    \ || isLessOrEqualAndFlipped || isLessOrEqualAndPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5yzdctsk.scala:21:72 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqual\e[0m = sumOfElements\
    \ <= maxWeight && sumOfElements >= sumOfElements.max\n\e[31m\e[31m   |\e[0m  \
    \                                                        ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>=\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments (Long => Long)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5yzdctsk.scala:22:83\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e\
    [0m \e[36misLessOrEqualAndBalanced\e[0m = sumOfElements <= maxWeight && sumOfElements\
    \ >= sumOfElements.max && isBalanced\n\e[31m\e[31m   |\e[0m                  \
    \                                                   ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>=\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments (Long => Long)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5yzdctsk.scala:23:82\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36misLessOrEqualAndFlipped\e[0m = sumOfElements <= maxWeight && sumOfElements\
    \ >= sumOfElements.max && isFlipped\n\e[31m\e[31m   |\e[0m                   \
    \                                                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>=\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): "
  stdout: ''
  timestamp: 1659800810
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.reduce(_ + _)\n        val maxWeight\
    \ = q.reduce(_ + _)\n        val isPalindromic = q.isEmpty || q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = isPalindromic && maxSum < w\n      \
    \  val isLessThanMaxWeight = maxWeight < w\n        val isLessThanMaxSum = maxSum\
    \ < w\n        isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsyyg5ewg.scala:25)\n\tat Problem.main(tmpsyyg5ewg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxWeightPalindromic = maxWeight /\
    \ 2\n        val maxWeightPalindromicPalindromic = maxWeightPalindromic / 2\n\
    \        val maxWeightPalindromicPalindromicPalindromic = maxWeightPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromic = maxWeightPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic / 2\n   \
    \     val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp393hzj0r.scala:24:101 --------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp393hzj0r.scala:25:112 --------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp393hzj0r.scala:26:123 --------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n"
  stdout: ''
  timestamp: 1659800812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sumOfQ = q.foldLeft(0)(_ + _)\n        sumOfQ <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1igrecou.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800811
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessThanMax = maxSumOfElements < w\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        isLessThanMaxAndBalanced || isLessThanMaxAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcl2we3ec.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessThanMaxSum = maxSumOfElements < maxSum\n        isBalanced &&\
    \ isPalindromic && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mkltn5g.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxWeightSum = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumLessOrEqualToMaxSum = maxWeightSum <= maxSum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = isPalindromic && maxWeightSumLessOrEqualToMaxSum\n        val isFlipped =\
    \ q.forall(x => x == q.reverse.head)\n        val isFlippedAndBalanced = isFlipped\
    \ && isBalanced\n        isFlippedAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmu_i40yz.scala:18:52\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSum\e\
    [0m = w.toLong * q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m      \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                 Found:    Long\n\e[31m   |\e\
    [0m                                                    Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800819
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        \n        !isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3n_i10xe.scala:26)\n\tat Problem.main(tmp3n_i10xe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxSumOfWeight = q.sum\n        val\
    \ maxWeightOfSum = q.sum * q.length\n        val maxSumOfWeightOfSum = q.sum *\
    \ q.length\n        val maxWeightOfSumOfWeight = q.sum * q.sum\n        val maxWeightOfSumOfWeightOfSum\
    \ = q.sum * q.sum * q.length\n        val maxWeightOfSumOfWeightOfSumOfWeight\
    \ = q.sum * q.sum * q.sum * q.length\n        val maxWeightOfSumOfWeightOfSumOfWeightOfSum\
    \ = q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightOfSumOfWeightOfSumOfWeightOfSumOfWeight\
    \ = q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSum\
    \ = q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n        val maxWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeight\
    \ = q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.length\n\
    \        val maxWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSum\
    \ = q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum * q.sum\n\
    \        val maxWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeightOfSumOfWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn7990zjg.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpn7990zjg.scala:30:5 ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.length\n        val maxWeightSum = w.toLong * q.length\n\
    \        val maxWeightSumOfQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ2\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ3 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ4 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ5\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ6 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ7 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ8\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ9 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ10 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ11\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ12 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ13 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ14\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ15 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ16 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ17\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ18 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ19 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ20\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ21 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ22 = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ23\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ24 = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQ\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppah9u68u.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmppah9u68u.scala:19:44 --------------------\e[0m\e[0m\n\e[31m19 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxWeightSumOfQ\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                            ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    Long\n\
    \e[31m   |\e[0m                                            Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppah9u68u.scala:20:45 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQ2\e[0m =\
    \ q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                     \
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                    Found:    Long\n\e[31m   |\e[0m                         \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppah9u68u.scala:21:45 --------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQ3\e[0m = q.foldLeft(\e[31m0\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                           \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m                                             Found:\
    \    Long\n\e[31m   |\e[0m                                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppah9u68u.scala:22:45\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQ4\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                    "
  stdout: ''
  timestamp: 1659800823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q.reduceRight(_\
    \ + _))\n        val isBalanced = q.forall(x => x <= maxWeight && x >= maxSum)\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdqhgakjl.scala:23)\n\tat Problem.main(tmpdqhgakjl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w.toInt\n        val maxSum\
    \ = q.reduceLeft(_ + _)\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = maxSum < maxWeight\n        isPalindromic &&\
    \ isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcv3y5h6y.scala:23)\n\tat Problem.main(tmpcv3y5h6y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxSum\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n  \
    \      val isLessOrEqualToMaxWeight = maxSumOfElements <= w\n        val isLessOrEqualToMaxWeightAndBalanced\
    \ = isLessOrEqualToMaxWeight && isBalanced\n        isPalindromic && isLessOrEqualToMaxWeightAndBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2d_r_71e.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= 0)\n        val isLessThanMax\
    \ = q.foldLeft(false)((acc, x) => acc && x <= maxWeight)\n        val isLessThanMaxOrBalanced\
    \ = q.foldLeft(false)((acc, x) => acc && (x <= maxWeight && x >= 0))\n       \
    \ val isLessThanMaxOrBalancedOrPalindromic = q.foldLeft(false)((acc, x) => acc\
    \ && (x <= maxWeight && x >= 0 && x == q(0)))\n        val isLessThanMaxOrBalancedOrPalindromicOrFalse\
    \ = q.foldLeft(false)((acc, x) => acc && (x <= maxWeight && x >= 0 || x == q(0)))\n\
    \        val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalse = q.foldLeft(false)((acc,\
    \ x) => acc && (x <= maxWeight && x >= 0 || x == q(0) || x == q(0)))\n       \
    \ val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalseOrFalse = q.foldLeft(false)((acc,\
    \ x) => acc && (x <= maxWeight && x >= 0 || x == q(0) || x == q(0) || x == q(0)))\n\
    \        val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalseOrFalseOrFalse\
    \ = q.foldLeft(false)((acc, x) => acc && (x <= maxWeight && x >= 0 || x == q(0)\
    \ || x == q(0) || x == q(0) || x == q(0)))\n        val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalseOrFalseOrFalseOrFalse\
    \ = q.foldLeft(false)((acc, x) => acc && (x <= maxWeight && x >= 0 || x == q(0)\
    \ || x == q(0) || x == q(0) || x == q(0) || x == q(0)))\n        val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalseOrFalseOrFalseOrFalseOrFalse\
    \ = q.foldLeft(false)((acc, x) => acc && (x <= maxWeight && x >= 0 || x == q(0)\
    \ || x == q(0) || x == q(0) || x == q(0) || x == q(0) || x == q(0)))\n       \
    \ val isLessThanMaxOrBalancedOrPalindromicOrFalseOrFalseOrFalseOrFalseOrFalse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_gu8zjh8.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_gu8zjh8.scala:17:35 --------------------\e[0m\e[0m\n\e[31m17 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_gu8zjh8.scala:30:5 ---------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessOrEqual = maxSum == maxWeight\n\
    \        val isLessOrEqualPalindromic = maxSum == maxWeight && isPalindromic\n\
    \        val isLessOrEqualBalanced = maxSum == maxWeight && isBalanced\n     \
    \   val isLessOrEqualBalancedPalindromic = maxSum == maxWeight && isBalanced &&\
    \ isPalindromic\n        val isLessOrEqualBalancedPalindromicAndLessOrEqual =\
    \ maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual\n      \
    \  val isLessOrEqualBalancedPalindromicAndLessOrEqualPalindromic = maxSum == maxWeight\
    \ && isBalanced && isPalindromic && isLessOrEqual && isPalindromic\n        val\
    \ isLessOrEqualBalancedPalindromicAndLessOrEqualBalanced = maxSum == maxWeight\
    \ && isBalanced && isPalindromic && isLessOrEqual && isBalanced\n        val isLessOrEqualBalancedPalindromicAndLessOrEqualBalancedPalindromic\
    \ = maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual && isBalanced\
    \ && isPalindromic\n        val isLessOrEqualBalancedPalindromicAndLessOrEqualBalancedPalindromicAndLessOrEqual\
    \ = maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual && isBalanced\
    \ && isPalindromic && isLessOrEqual\n        val isLessOrEqualBalancedPalindromicAndLessOrEqualBalancedPalindromicAndLessOrEqualPalindromic\
    \ = maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual && isBalanced\
    \ && isPalindromic && isLessOrEqual && isPalindromic\n        val isLessOrEqualBalancedPalindromicAndLessOrEqualBalancedPalindromicAndLessOrEqualBalanced\
    \ = maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual && isBalanced\
    \ && \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpciztfxqm.scala:30:186 --------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualBalancedPalindromicAndLessOrEqualBalancedPalindromicAndLessOrEqualBalanced\e\
    [0m = maxSum == maxWeight && isBalanced && isPalindromic && isLessOrEqual && isBalanced\
    \ && \n\e[31m\e[31m   |\e[0m                                                 \
    \                                                                            \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpciztfxqm.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpciztfxqm.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800821
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x <= maxWeight && x >= maxWeight - q.length)\n\
    \        val isFlight = maxSum < maxWeight\n        val isFlightAndBalanced =\
    \ isFlight && isBalanced\n        val isFlightAndPalindromic = isFlight && isPalindromic\n\
    \        val isFlightAndNotBalanced = isFlight && !isBalanced\n        val isFlightAndNotPalindromic\
    \ = isFlight && !isPalindromic\n        val isFlightAndNotBalancedAndNotPalindromic\
    \ = isFlight && !isBalanced && !isPalindromic\n        val isFlightAndNotBalancedAndPalindromic\
    \ = isFlight && !isBalanced && isPalindromic\n        val isFlightAndNotBalancedAndNotPalindromic\
    \ = isFlight && !isBalanced && !isPalindromic\n        val isFlightAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isFlight && !isBalanced && !isPalindromic && !isBalanced\n        val isFlightAndNotBalancedAndNotPalindromicAndBalanced\
    \ = isFlight && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\n\
    \        val isFlightAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isFlight && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isFlightAndNotBalancedAndNotPalindromicAndNotBalancedAndPalindromic\
    \ = isFlight && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && isPalindromic\n        val isFlightAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = isFlight && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced && !isPalindro\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl74h7uhj.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misFlightAndNotBalancedAndNotPalindromic\e\
    [0m = isFlight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misFlightAndNotBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misFlightAndNotBalancedAndNotPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpl74h7uhj.scala:17:35 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                   Found:    Long\n\e[31m   |\e[0m\
    \                                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpl74h7uhj.scala:32:226 -----------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36misFlightAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\e\
    [0m = isFlight && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isBalanced && !isPalindro\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                                            \
    \                                                                            \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \              Not found: isPalindro\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpl74h7uhj.scala:33:5 ---------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659800822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q.head)\n        val isBalanced\
    \ = maxSum - q.sum < maxWeight\n        val isLessThanMaxWeight = maxSum - q.sum\
    \ >= maxWeight\n        val isLessThanMaxSum = maxSum - q.sum < maxWeight\n  \
    \      val isLessThanMaxSumButNotBalanced = maxSum - q.sum < maxWeight && !isBalanced\n\
    \        val isLessThanMaxWeightButNotBalanced = maxSum - q.sum < maxWeight &&\
    \ !isBalanced && !isPalindromic\n        val isLessThanMaxWeightButIsBalanced\
    \ = maxSum - q.sum < maxWeight && isBalanced\n        val isLessThanMaxWeightButIsPalindromic\
    \ = maxSum - q.sum < maxWeight && isPalindromic\n        val isLessThanMaxWeightButIsBalancedAndIsPalindromic\
    \ = maxSum - q.sum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxWeightButIsBalancedAndIsPalindromicButNotAllElementsAreEqual\
    \ = maxSum - q.sum < maxWeight && isBalanced && isPalindromic && !q.forall(x =>\
    \ x == q.head)\n        val isLessThanMaxWeightButIsBalancedAndIsPalindromicButAllElementsAreEqual\
    \ = maxSum - q.sum < maxWeight && isBalanced && isPalindromic && q.forall(x =>\
    \ x == q.head)\n        val isLessThanMaxWeightButIsBalancedAndIsPalindromicButAllElementsAreEqualButNotAllElementsAreEqual\
    \ = maxSum - q.sum < maxWeight && isBalanced && isPalindromic && q.forall(x =>\
    \ x == q.head) && !q.forall(x => x == q.head)\n        val isLessThanMaxWeightButIsBalancedAndIsPalindromicButAllElementsAreEqualButNotAllElementsAreEqualButNotAllElementsAreEqual\
    \ = maxSum - q.sum < maxWeight && isBalanced && isPalindromic && q.forall(x =>\
    \ x == q.head) && !q.forall(x => x == q.head) && !q.forall(x => x == q.head)\n\
    \        val isLessThanMaxWeightButIsBalancedAndIsPalindromicButAllElementsAreEqualButNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpblko_caf.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpblko_caf.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800822
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && maxSum < maxWeight\n        val unbalanced = !palindromic &&\
    \ maxSum > maxWeight\n        balanced && unbalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphsmhqign.scala:24)\n\tat Problem.main(tmphsmhqign.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.reduceLeft(_ + _) == maxSum\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduceLeft(_\
    \ + _)\n        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_h9bu2z.scala:25)\n\tat Problem.main(tmpq_h9bu2z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        \n        return isFly\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc9ppzqjf.scala:25)\n\tat Problem.main(tmpc9ppzqjf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxSumOfElements =\
    \ maxSumOfElements <= maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbz8cddol.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbz8cddol.scala:30:127 -----------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\e\
    [0m = isLessOrEqualToMaxSumOfElementsAndIsLessOr\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: isLessOrEqualToMaxSumOfElementsAndIsLessOr\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbz8cddol.scala:31:5\
    \ ---------------------\e[0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val palindromic = q.reverse.forall(x =>\
    \ x <= maxWeight)\n        val balanced = q.forall(x => x <= maxWeight && x <=\
    \ maxSum)\n        (palindromic && balanced)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqkn7e6rv.scala:24)\n\tat Problem.main(tmpqkn7e6rv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x == q(0) + q(1))\n        val isLessThanMax\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxButNotBalanced = maxSum -\
    \ maxWeight > 0 && !isBalanced\n        isPalindromic && isBalanced && isLessThanMax\
    \ && isLessThanMaxButNotBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp37b1iy7k.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        \n        isFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4mr_7xve.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800823
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFlippable = q.forall(_ < maxWeight)\n\
    \        isPalindromic && isBalanced && isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5h_mgvkl.scala:24)\n\tat Problem.main(tmp5h_mgvkl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800825
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q.isEmpty || q.reverse == q\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isFlipped = q.reverse.head == q.head\n   \
    \     isPalindromic && isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnatl6nv5.scala:29)\n\tat Problem.main(tmpnatl6nv5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800826
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong).sum\n        sums <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpan8out18.scala:22)\n\tat Problem.main(tmpan8out18.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = maxSumOfElements\
    \ == maxSum\n        val isBalanced = isPalindromic && q.size == q.reverse.size\
    \ && maxSumOfElements <= w\n        isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp03gg71a8.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val balanced = maxSum == maxWeight\n        val palindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val sum = q.sum\n        val isLessOrEqual\
    \ = sum <= maxWeight\n        val isBalanced = balanced && palindromic && isLessOrEqual\n\
    \        isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2d6rrile.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong * q.sum\n        val maxWeightSum = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumLessOrEqual = w.toLong * q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumLessOrEqualEqual = w.toLong * q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumLessOrEqualEqualEqual = w.toLong * q.foldLeft(0)(_ +\
    \ _)\n        val maxWeightSumLessOrEqualEqualEqualEqual = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqual = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqual = w.toLong * q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqual = w.toLong\
    \ * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_ + _)\n        val maxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqualEqualEqual\
    \ = w.toLong * q.foldLeft(0)(_\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5vhwpw4z.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5vhwpw4z.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumLessOrEqualEqualEqualEqualEqual\e[0m = w.toLong * q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumLessOrEqualEqualEqualEqualEqual is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxWeightSumLessOrEqualEqualEqualEqualEqual\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5vhwpw4z.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\e\
    [0m = w.toLong * q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5vhwpw4z.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\e\
    [0m = w.toLong * q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumLessOrEqualEqualEqualEqualEqualEqualEqualEqual\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that "
  stdout: ''
  timestamp: 1659800832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.foldLeft(List[Long]())((sums, x) => sums.updated(x, sums(x) + x))\n\
    \        sums.last <= maxSum\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolsam66e.scala:17:70\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msums\e\
    [0m = q.foldLeft(List[\e[35mLong\e[0m]())((\e[36msums\e[0m, \e[36mx\e[0m) => sums.updated(x,\
    \ sums(x) + x))\n\e[31m\e[31m   |\e[0m                                       \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                              Found:    (x : Long)\n\e[31m   |\e[0m         \
    \                                           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolsam66e.scala:17:78 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = q.foldLeft(List[\e\
    [35mLong\e[0m]())((\e[36msums\e[0m, \e[36mx\e[0m) => sums.updated(x, sums(x) +\
    \ x))\n\e[31m\e[31m   |\e[0m                                                 \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                            Found:    (x : Long)\n\e[31m   |\e[0m           \
    \                                         Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800830
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = q.reduce((a, b) => a + b)\n  \
    \      val maxWeight = q.reduce((a, b) => math.max(math.abs(a), math.abs(b)))\n\
    \        val isPalindromic = q.reverse.forall(_ == q(0))\n        val sumOfElements\
    \ = q.sum\n        val isBalanced = sumOfElements <= maxWeight && isPalindromic\n\
    \        val isFlipped = q.forall(_ < 0)\n        val isFlippedBackwards = q.forall(_\
    \ > 0)\n        isBalanced && isFlipped && isFlippedBackwards && maxSum <= w\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdqby6_p_.scala:26)\n\tat Problem.main(tmpdqby6_p_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessThanMax\
    \ = maxSum - q.sum <= maxWeight\n        isPalindromic && isBalanced && isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpajro4hlo.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpajro4hlo.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxWeight\n\e[31m\e[31m   |\e[0m    \
    \                                   ^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFlipped = q.forall(x => x\
    \ == q.reverse.head)\n        isPalindromic && isBalanced && isFlipped\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6nfo3nfa.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced\
    \ = maxSumOfElements <= maxWeight\n        val isFlippable = isPalindromic &&\
    \ isBalanced\n        val isFlippableAndLessThanMaxWeight = isFlippable && maxSumOfElements\
    \ < maxWeight\n        isFlippableAndLessThanMaxWeight\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6yvpjju7.scala:18:45\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum - maxWeight <= 0\n        val isLessThanMax = maxSum - maxWeight\
    \ < 0\n        val isLessThanMaxAndBalanced = maxSum - maxWeight < 0 && maxSum\
    \ - maxWeight > 0\n        val isLessThanMaxAndBalancedAndPalindromic = maxSum\
    \ - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\n        val\
    \ isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum - maxWeight < 0 && maxSum - maxWeight > 0 && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isPalindromic && !isBalanced\n        val isLessThanMaxAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp43mzsgbl.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp43mzsgbl.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isReverse.forall(x => x == q(0))\n  \
    \      val isBalanced = sumOfElements <= maxWeight\n        val isFlippable =\
    \ q.forall(x => x == q(q(q.length - 1)))\n        isPalindromic && isBalanced\
    \ && isFlippable\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3ixagjnx.scala:18:30 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isReverse.forall(\e\
    [36mx\e[0m => x == q(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value isReverse is not a member of\
    \ List[Long] - did you mean q.reverse?\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3ixagjnx.scala:20:48 --------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(\e[36mx\e[0m => x ==\
    \ q(q(q.length - \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                      \
    \                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                 Found:    Long\n\e[31m   |\e[0m            \
    \                                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800833
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n    \
    \    val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = isLessThanMaxAndBalanced && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf_2meigh.scala:26)\n\tat Problem.main(tmpf_2meigh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q.head)\n        val\
    \ isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isPalindromic || !isBalanced\n        isFly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp37b1w2ka.scala:25)\n\tat Problem.main(tmp37b1w2ka.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(_ == q(0))\n        val isBalanced\
    \ = maxSum - q.reduceLeft(_ + _) <= maxWeight\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzkfbmybe.scala:23)\n\tat Problem.main(tmpzkfbmybe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val palindromic\
    \ = q.reverse.forall(x => x != q)\n        val sumOfElements = q.sum\n       \
    \ val isBalanced = sumOfElements <= maxWeight\n        val isFlippable = palindromic\
    \ && isBalanced\n        isFlippable\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5q2dje42.scala:17:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x != q)\n\e[31m\e[31m   |\e[0m                                 \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and List[Long]\
    \ cannot be compared with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1659800834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isLessThanMaxWeight = maxSum\
    \ < maxWeight\n        val isLessThanMaxSum = maxSum < maxWeight\n        val\
    \ isLessThanMaxSumAndBalanced = maxSum < maxWeight && maxWeight < maxSum\n   \
    \     val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight && maxWeight\
    \ < maxSum && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isBalanced\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic && !\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1e_gx1ek.scala:28:337 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\e\
    [0m = maxSum < maxWeight && maxWeight < maxSum && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic && !\n\e[31m\e[31m   |\e[0m            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                            Not found: !\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp1e_gx1ek.scala:29:5 ---------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.sum\n\
    \        val palindromic = q.reverse.forall(x => x == q(0))\n        val balanced\
    \ = palindromic && maxSum < maxWeight\n        val unbalanced = !palindromic &&\
    \ maxSum > maxWeight\n        balanced && unbalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphsmhqign.scala:24)\n\tat Problem.main(tmphsmhqign.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isPalindromic = maxSumOfElements == maxSum\n\
    \        val isBalanced = maxSumOfElements <= w\n        val isFlippable = q.forall(x\
    \ => x == x.reverse)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isPalindromic && isBalanced && isFlippableAndBalanced\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjers96z6.scala:17:45\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpjers96z6.scala:20:47 ------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          value reverse is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduce(_\
    \ + _)\n        val isPalindromic = q == q.reverse\n        val isBalanced = maxSum\
    \ < maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight * 2\n    \
    \    val isLessThanMaxSum = maxSum < maxWeight * 3\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight * 4\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight * 5\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight * 6\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight * 7\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight * 8\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight * 9\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight * 10\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight * 11\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight * 12\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight * 13\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp21fdqz2d.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp21fdqz2d.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ maxWeight = w.toLong\n        val maxWeightSum = w.toLong * q.length\n     \
    \   val maxWeightSumOfQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5d07pnix.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5d07pnix.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5d07pnix.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group o"
  stdout: ''
  timestamp: 1659800777
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum < maxWeight\n        val isFly = isPalindromic && isBalanced\n\
    \        val isNotFly = !isPalindromic || !isBalanced\n        isFly\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzp4zkfc.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800834
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val palindrome =\
    \ q.reverse.forall(x => x == q.last)\n        val sumOfElements = q.sum\n    \
    \    val isBalanced = sumOfElements <= maxWeight\n        val isPalindromic =\
    \ palindrome\n        val isFlippable = isBalanced && isPalindromic\n        isFlippable\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7l4l288s.scala:25)\n\tat Problem.main(tmp7l4l288s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.reduceLeft(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = maxSum - q.sum <= maxWeight\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjgkhr831.scala:23)\n\tat Problem.main(tmpjgkhr831.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val maxSum = q.foldLeft(0)(_\
    \ + _)\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n       \
    \ val isBalanced = q.forall(x => x == q(0))\n        val isLessThanMaxWeight =\
    \ maxSum - maxWeight <= 0\n        val isLessThanMaxSum = maxSum - maxWeight <=\
    \ 0\n        val isLessThanMaxSumAndBalanced = maxSum - maxWeight <= 0 && isBalanced\n\
    \        val isLessThanMaxSumAndPalindromic = maxSum - maxWeight <= 0 && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedPalindromic = maxSum - maxWeight <= 0\
    \ && isPalindromic && isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum - maxWeight <= 0 && isPalindromic && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicPalindromic = maxSum - maxWeight\
    \ <= 0 && isPalindromic && isBalanced && isPalindromic && isPalindromic\n    \
    \    val isLessThanMaxSumAndBalancedAndPalindromicPalindromicPalindromic = maxSum\
    \ - maxWeight <= 0 && isPalindromic && isBalanced && isPalindromic && isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum - maxWeight <= 0 && isPalindromic && isBalanced && isPalindromic &&\
    \ isPalindromic && isPalindromic && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum - maxWeight <= 0 && isPalindromic && isBalanced && isPalindromic &&\
    \ isPalindromic && isPalindromic && isPalindromic && isPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwxewc6l3.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwxewc6l3.scala:17:35 --------------------\e[0m\e[0m\n\e[31m17 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpwxewc6l3.scala:31:5 ---------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w\n        val sumOfElements\
    \ = q.sum\n        val isPalindromic = q.isPalindromic\n        val isBalanced\
    \ = isPalindromic && sumOfElements <= maxWeight\n        val isFlippable = q.tail.isEmpty\
    \ && q.head.isEmpty\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        val isFlippableAndBalancedAndNotPalindromic = isFlippable && isBalanced\
    \ && !isPalindromic\n        val isFlippableAndBalancedAndPalindromic = isFlippable\
    \ && isBalanced && isPalindromic\n        val isFlippableAndBalancedAndNotPalindromicAndNotFlippable\
    \ = isFlippable && isBalanced && !isPalindromic && !isFlippable\n        val isFlippableAndBalancedAndPalindromicAndNotFlippable\
    \ = isFlippable && isBalanced && isPalindromic && !isFlippable\n        val isFlippableAndBalancedAndNotPalindromicAndFlippable\
    \ = isFlippable && isBalanced && !isPalindromic && isFlippable\n        val isFlippableAndBalancedAndPalindromicAndFlippable\
    \ = isFlippable && isBalanced && isPalindromic && isFlippable\n        val isFlippableAndBalancedAndNotPalindromicAndFlippableAndNotFlippable\
    \ = isFlippable && isBalanced && !isPalindromic && isFlippable && !isFlippable\n\
    \        val isFlippableAndBalancedAndPalindromicAndFlippableAndNotFlippable =\
    \ isFlippable && isBalanced && isPalindromic && isFlippable && !isFlippable\n\
    \        val isFlippableAndBalancedAndNotPalindromicAndFlippableAndFlippable =\
    \ isFlippable && isBalanced && !isPalindromic && isFlippable && isFlippable\n\
    \        val isFlippableAndBalancedAndPalindromicAndFlipp\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3t4x0l9r.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3t4x0l9r.scala:18:30\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = q.isPalindromic\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ isPalindromic is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3t4x0l9r.scala:20:51 ------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36misFlippable\e[0m = q.tail.isEmpty && q.head.isEmpty\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value isEmpty is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3t4x0l9r.scala:32:5\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxWeight = w.toInt\n        val palindromic\
    \ = q.reverse.forall(x => x == x.reverse)\n        val sumOfElements = q.sum\n\
    \        val isBalanced = sumOfElements <= maxWeight\n        val isFlippable\
    \ = palindromic && isBalanced\n        isFlippable\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpymmzqhft.scala:17:55 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value reverse is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659800835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sumOfQ = q.foldLeft(0)(_ + _)\n        sumOfQ <= maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1igrecou.scala:17:35\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msumOfQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800811
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // will_it_fly([1, 2], 5) \u279E False \n  \
    \  // # 1+2 is less than the maximum possible weight, but it's unbalanced.\n \
    \   // will_it_fly([3, 2, 3], 1) \u279E False\n    // # it's balanced, but 3+2+3\
    \ is more than the maximum possible weight.\n    // will_it_fly([3, 2, 3], 9)\
    \ \u279E True\n    // # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n    // will_it_fly([3], 5) \u279E True\n    // # 3 is less than the\
    \ maximum possible weight, and it's balanced.\n    def willItFly(q : List[Long],\
    \ w : Long) : Boolean = {\n        val maxSum = w.toLong * q.length\n        val\
    \ sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse == sums\n\
    \        val isBalanced = sums.sum <= maxSum\n        val isFlippable = q.forall(x\
    \ => x > 0 && x < w)\n        val isFlippableAndBalanced = isFlippable && isBalanced\n\
    \        isPalindromic && isFlippableAndBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg1rv95on.scala:30)\n\tat Problem.main(tmpg1rv95on.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800836
