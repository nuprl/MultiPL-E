language: scala
name: HumanEval_76_is_simple_power
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        if (pow ==\
    \ x) {\n            true\n        } else {\n            false\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9t5mkkje.scala:23)\n\tat Problem.main(tmp9t5mkkje.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(x, n)\n        val result\
    \ = math.abs(x - pow) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp750tbxq6.scala:20)\n\tat Problem.main(tmp750tbxq6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(n, 2)\n        val pow3 = math.pow(n, 3)\n        val pow4 = math.pow(n,\
    \ 4)\n        val pow5 = math.pow(n, 5)\n        val pow6 = math.pow(n, 6)\n \
    \       val pow7 = math.pow(n, 7)\n        val pow8 = math.pow(n, 8)\n       \
    \ val pow9 = math.pow(n, 9)\n        val pow10 = math.pow(n, 10)\n        val\
    \ pow11 = math.pow(n, 11)\n        val pow12 = math.pow(n, 12)\n        val pow13\
    \ = math.pow(n, 13)\n        val pow14 = math.pow(n, 14)\n        val pow15 =\
    \ math.pow(n, 15)\n        val pow16 = math.pow(n, 16)\n        val pow17 = math.pow(n,\
    \ 17)\n        val pow18 = math.pow(n, 18)\n        val pow19 = math.pow(n, 19)\n\
    \        val pow20 = math.pow(n, 20)\n        val pow21 = math.pow(n, 21)\n  \
    \      val pow22 = math.pow(n, 22)\n        val pow23 = math.pow(n, 23)\n    \
    \    val pow24 = math.pow(n, 24)\n        val pow25 = math.pow(n, 25)\n      \
    \  val pow26 = math.pow(n, 26)\n        val pow27 = math.pow(n, 27)\n        val\
    \ pow28 = math.pow(n, 28)\n        val pow29 = math.pow(n, 29)\n        val pow30\
    \ = math.pow(n, 30)\n        val pow31 = math.pow(n, 31)\n        val pow32 =\
    \ math.pow(n, 32)\n        val pow33 = math.pow(n, 33)\n        val pow34 = math.pow(n,\
    \ 34)\n        val pow35 = math.pow(n, 35)\n        val pow36 = math.pow(n, 36)\n\
    \        val pow37 = math.pow(n, 37)\n        val pow38 = math.pow(n, 38)\n  \
    \      val pow39 = math.pow(n, 39)\n        val pow40 = math.pow(n, 40)\n    \
    \    val pow41 = math.pow(n, 41)\n        val pow42 = math.pow(n, 42)\n      \
    \  val pow43 = math.pow(n, 43)\n        val pow44 = math.pow(n, 44)\n        val\
    \ pow45 = math.pow(n, 45)\n        val pow46 = math.pow(n, 46)\n        val pow47\
    \ = math.pow(n, 47)\n        val pow48 = math.pow(n, 48)\n        val pow49 =\
    \ math.pow(n, 49)\n        val pow50 = math.pow(n, 50)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_fy26rk3.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fy26rk3.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.pow(power, n) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplnlyaq45.scala:20)\n\tat Problem.main(tmplnlyaq45.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(n, 2)\n        val pow3 = math.pow(n, 3)\n        val pow4 = math.pow(n,\
    \ 4)\n        val pow5 = math.pow(n, 5)\n        val pow6 = math.pow(n, 6)\n \
    \       val pow7 = math.pow(n, 7)\n        val pow8 = math.pow(n, 8)\n       \
    \ val pow9 = math.pow(n, 9)\n        val pow10 = math.pow(n, 10)\n        val\
    \ pow11 = math.pow(n, 11)\n        val pow12 = math.pow(n, 12)\n        val pow13\
    \ = math.pow(n, 13)\n        val pow14 = math.pow(n, 14)\n        val pow15 =\
    \ math.pow(n, 15)\n        val pow16 = math.pow(n, 16)\n        val pow17 = math.pow(n,\
    \ 17)\n        val pow18 = math.pow(n, 18)\n        val pow19 = math.pow(n, 19)\n\
    \        val pow20 = math.pow(n, 20)\n        val pow21 = math.pow(n, 21)\n  \
    \      val pow22 = math.pow(n, 22)\n        val pow23 = math.pow(n, 23)\n    \
    \    val pow24 = math.pow(n, 24)\n        val pow25 = math.pow(n, 25)\n      \
    \  val pow26 = math.pow(n, 26)\n        val pow27 = math.pow(n, 27)\n        val\
    \ pow28 = math.pow(n, 28)\n        val pow29 = math.pow(n, 29)\n        val pow30\
    \ = math.pow(n, 30)\n        val pow31 = math.pow(n, 31)\n        val pow32 =\
    \ math.pow(n, 32)\n        val pow33 = math.pow(n, 33)\n        val pow34 = math.pow(n,\
    \ 34)\n        val pow35 = math.pow(n, 35)\n        val pow36 = math.pow(n, 36)\n\
    \        val pow37 = math.pow(n, 37)\n        val pow38 = math.pow(n, 38)\n  \
    \      val pow39 = math.pow(n, 39)\n        val pow40 = math.pow(n, 40)\n    \
    \    val pow41 = math.pow(n, 41)\n        val pow42 = math.pow(n, 42)\n      \
    \  val pow43 = math.pow(n, 43)\n        val pow44 = math.pow(n, 44)\n        val\
    \ pow45 = math.pow(n, 45)\n        val pow46 = math.pow(n, 46)\n        val pow47\
    \ = math.pow(n, 47)\n        val pow48 = math.pow(n, 48)\n        val pow49 =\
    \ math.pow(n, 49)\n        val pow50 = math.pow(n, 50)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_fy26rk3.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fy26rk3.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power\
    \ = power.toInt\n        val power = power.toLong\n        val power = power.toDouble\n\
    \        val power = power.toFloat\n        val power = power.toInt\n        val\
    \ power = power.toLong\n        val power = power.toDouble\n        val power\
    \ = power.toFloat\n        val power = power.toInt\n        val power = power.toLong\n\
    \        val power = power.toDouble\n        val power = power.toFloat\n     \
    \   val power = power.toInt\n        val power = power.toLong\n        val power\
    \ = power.toDouble\n        val power = power.toFloat\n        val power = power.toInt\n\
    \        val power = power.toLong\n        val power = power.toDouble\n      \
    \  val power = power.toFloat\n        val power = power.toInt\n        val power\
    \ = power.toLong\n        val power = power.toDouble\n        val power = power.toFloat\n\
    \        val power = power.toInt\n        val power = power.toLong\n        val\
    \ power = power.toDouble\n        val power = power.toFloat\n        val power\
    \ = power.toInt\n        val power = power.toLong\n        val power = power.toDouble\n\
    \        val power = power.toFloat\n        val power = power.toInt\n        val\
    \ power = power.toLong\n        val power = power.toDouble\n        val power\
    \ = power.toFloat\n        val power = power.toInt\n        val power = power.toLong\n\
    \        val power = power.toDouble\n        val power = power.toFloat\n     \
    \   val power = power.toInt\n        val power = power.toLong\n        val power\
    \ = power.toDouble\n        val power = power.toFloat\n        val power = power.toInt\n\
    \        val power = power.toLong\n        val power = power.toDouble\n      \
    \  val power = power.toFloat\n        val power = power.toInt\n        val power\
    \ = power.toLong\n        val power = power.toDouble\n        val power = power.toFloat\n\
    \        val power = power.toInt\n        val power = power.toLong\n        val\
    \ power = power.toDouble\n        val power = power.toFloat\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvqa5xuwy.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mpower\e[0m = power.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mpower\
    \ is already defined as \e[33mvalue\e[0m \e[35mpower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvqa5xuwy.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mpower\e[0m = power.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpower is already defined as \e[33mvalue\e[0m \e[35mpower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvqa5xuwy.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mpower\e[0m = power.toDouble\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mpower is\
    \ already defined as \e[33mvalue\e[0m \e[35mpower\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvqa5xuwy.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mpower\e[0m = power.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpower is already defined as \e[33mvalue\e[0m \e[35mpower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvqa5xuwy.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mpower\e[0m = power.toInt\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mpower is already\
    \ defined as \e[33mvalue\e[0m \e[35mpower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7njg8l.scala:19)\n\tat Problem.main(tmp2_7njg8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7njg8l.scala:19)\n\tat Problem.main(tmp2_7njg8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        if (pow ==\
    \ x) {\n            return true\n        }\n        if (pow % x == 0) {\n    \
    \        return true\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpww_eljxd.scala:31)\n\tat Problem.main(tmpww_eljxd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.abs(power - x) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphydgj495.scala:20)\n\tat Problem.main(tmphydgj495.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7njg8l.scala:19)\n\tat Problem.main(tmp2_7njg8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa8iz07cr.scala:58:13 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        pow = \n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpa8iz07cr.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpa8iz07cr.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpa8iz07cr.scala:18:12 -----------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        pow = math.max(pow, Long.MinValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpa8iz07cr.scala:19:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        pow = math.min(pow,\
    \ Long.MaxValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpa8iz07cr.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.max(pow, Long.MinValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-e"
  stdout: ''
  timestamp: 1659793905
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(n, 2)\n        val pow3 = math.pow(n, 3)\n        val pow4 = math.pow(n,\
    \ 4)\n        val pow5 = math.pow(n, 5)\n        val pow6 = math.pow(n, 6)\n \
    \       val pow7 = math.pow(n, 7)\n        val pow8 = math.pow(n, 8)\n       \
    \ val pow9 = math.pow(n, 9)\n        val pow10 = math.pow(n, 10)\n        val\
    \ pow11 = math.pow(n, 11)\n        val pow12 = math.pow(n, 12)\n        val pow13\
    \ = math.pow(n, 13)\n        val pow14 = math.pow(n, 14)\n        val pow15 =\
    \ math.pow(n, 15)\n        val pow16 = math.pow(n, 16)\n        val pow17 = math.pow(n,\
    \ 17)\n        val pow18 = math.pow(n, 18)\n        val pow19 = math.pow(n, 19)\n\
    \        val pow20 = math.pow(n, 20)\n        val pow21 = math.pow(n, 21)\n  \
    \      val pow22 = math.pow(n, 22)\n        val pow23 = math.pow(n, 23)\n    \
    \    val pow24 = math.pow(n, 24)\n        val pow25 = math.pow(n, 25)\n      \
    \  val pow26 = math.pow(n, 26)\n        val pow27 = math.pow(n, 27)\n        val\
    \ pow28 = math.pow(n, 28)\n        val pow29 = math.pow(n, 29)\n        val pow30\
    \ = math.pow(n, 30)\n        val pow31 = math.pow(n, 31)\n        val pow32 =\
    \ math.pow(n, 32)\n        val pow33 = math.pow(n, 33)\n        val pow34 = math.pow(n,\
    \ 34)\n        val pow35 = math.pow(n, 35)\n        val pow36 = math.pow(n, 36)\n\
    \        val pow37 = math.pow(n, 37)\n        val pow38 = math.pow(n, 38)\n  \
    \      val pow39 = math.pow(n, 39)\n        val pow40 = math.pow(n, 40)\n    \
    \    val pow41 = math.pow(n, 41)\n        val pow42 = math.pow(n, 42)\n      \
    \  val pow43 = math.pow(n, 43)\n        val pow44 = math.pow(n, 44)\n        val\
    \ pow45 = math.pow(n, 45)\n        val pow46 = math.pow(n, 46)\n        val pow47\
    \ = math.pow(n, 47)\n        val pow48 = math.pow(n, 48)\n        val pow49 =\
    \ math.pow(n, 49)\n        val pow50 = math.pow(n, 50)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_fy26rk3.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fy26rk3.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-6\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpctnqy6f1.scala:20)\n\tat Problem.main(tmpctnqy6f1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqsand0x6.scala:63:13 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        pow = \n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:18:12 -----------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        pow = math.max(pow, Long.MinValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:19:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:20:12 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Ty"
  stdout: ''
  timestamp: 1659793906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val intPower\
    \ = math.round(power)\n        val intPower2 = math.round(power * 2)\n       \
    \ val intPower3 = math.round(power * 3)\n        val intPower4 = math.round(power\
    \ * 4)\n        val intPower5 = math.round(power * 5)\n        val intPower6 =\
    \ math.round(power * 6)\n        val intPower7 = math.round(power * 7)\n     \
    \   val intPower8 = math.round(power * 8)\n        val intPower9 = math.round(power\
    \ * 9)\n        val intPower10 = math.round(power * 10)\n        val intPower11\
    \ = math.round(power * 11)\n        val intPower12 = math.round(power * 12)\n\
    \        val intPower13 = math.round(power * 13)\n        val intPower14 = math.round(power\
    \ * 14)\n        val intPower15 = math.round(power * 15)\n        val intPower16\
    \ = math.round(power * 16)\n        val intPower17 = math.round(power * 17)\n\
    \        val intPower18 = math.round(power * 18)\n        val intPower19 = math.round(power\
    \ * 19)\n        val intPower20 = math.round(power * 20)\n        val intPower21\
    \ = math.round(power * 21)\n        val intPower22 = math.round(power * 22)\n\
    \        val intPower23 = math.round(power * 23)\n        val intPower24 = math.round(power\
    \ * 24)\n        val intPower25 = math.round(power * 25)\n        val intPower26\
    \ = math.round(power * 26)\n        val intPower27 = math.round(power * 27)\n\
    \        val intPower28 = math.round(power * 28)\n        val intPower29 = math.round(power\
    \ * 29)\n        val intPower30 = math.round(power * 30)\n        val intPower31\
    \ = math.round(power * 31)\n        val intPower32 = math.round(power * 32)\n\
    \        val intPower33 = math.round(power * 33)\n        val intPower34 = math.round(power\
    \ * 34)\n        val intPower35 = math.round(power * 35)\n        val intPower36\
    \ = math.round(power * 36)\n        val intPower37 = math.round(power * 37)\n\
    \        val intPower38 = math.round(power * 38)\n        val intPower39 = math.round(power\
    \ * 39)\n        val intPower40 = math.round(power * 40)\n        val intPower41\
    \ = math.round(power * 41)\n        val intPower42 = math.round(power\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp39tanevw.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp39tanevw.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val intPower\
    \ = math.pow(n, int)\n        val intPower2 = math.pow(n, int/2)\n        val\
    \ intPower3 = math.pow(n, int/3)\n        val intPower4 = math.pow(n, int/4)\n\
    \        val intPower5 = math.pow(n, int/5)\n        val intPower6 = math.pow(n,\
    \ int/6)\n        val intPower7 = math.pow(n, int/7)\n        val intPower8 =\
    \ math.pow(n, int/8)\n        val intPower9 = math.pow(n, int/9)\n        val\
    \ intPower10 = math.pow(n, int/10)\n        val intPower11 = math.pow(n, int/11)\n\
    \        val intPower12 = math.pow(n, int/12)\n        val intPower13 = math.pow(n,\
    \ int/13)\n        val intPower14 = math.pow(n, int/14)\n        val intPower15\
    \ = math.pow(n, int/15)\n        val intPower16 = math.pow(n, int/16)\n      \
    \  val intPower17 = math.pow(n, int/17)\n        val intPower18 = math.pow(n,\
    \ int/18)\n        val intPower19 = math.pow(n, int/19)\n        val intPower20\
    \ = math.pow(n, int/20)\n        val intPower21 = math.pow(n, int/21)\n      \
    \  val intPower22 = math.pow(n, int/22)\n        val intPower23 = math.pow(n,\
    \ int/23)\n        val intPower24 = math.pow(n, int/24)\n        val intPower25\
    \ = math.pow(n, int/25)\n        val intPower26 = math.pow(n, int/26)\n      \
    \  val intPower27 = math.pow(n, int/27)\n        val intPower28 = math.pow(n,\
    \ int/28)\n        val intPower29 = math.pow(n, int/29)\n        val intPower30\
    \ = math.pow(n, int/30)\n        val intPower31 = math.pow(n, int/31)\n      \
    \  val intPower32 = math.pow(n, int/32)\n        val intPower33 = math.pow(n,\
    \ int/33)\n        val intPower34 = math.pow(n, int/34)\n        val intPower35\
    \ = math.pow(n, int/35)\n        val intPower36 = math.pow(n, int/36)\n      \
    \  val intPower37 = math.pow(n, int/37)\n        val intPower38 = math.pow(n,\
    \ int/38)\n        val intPower39 = math.pow(n, int/\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpn90412e5.scala:54:41 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mintPower39\e[0m = math.pow(n,\
    \ int/\n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn90412e5.scala:16:35\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mintPower\e[0m = math.pow(n, int)\n\e[31m\e[31m   |\e[0m                  \
    \                 ^^^\e[0m\n\e[31m   |\e[0m                                  \
    \ Not found: int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn90412e5.scala:17:36\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mintPower2\e[0m = math.pow(n, int/\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                ^^^\e[0m\n\e[31m   |\e[0m                   \
    \                 Not found: int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpn90412e5.scala:18:36 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mintPower3\e[0m = math.pow(n, int/\e[31m3\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^\e[0m\n\e[31m   |\e\
    [0m                                    Not found: int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn90412e5.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mintPower4\e[0m = math.pow(n,\
    \ int/\e[31m4\e[0m)\n\e[31m\e[31m   |\e[0m                                   \
    \ ^^^\e[0m\n\e[31m   |\e[0m                                    Not found: int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn90412e5.scal"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val powerInt\
    \ = math.round(power)\n        if (powerInt == power) {\n            return true\n\
    \        }\n        return false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpftf479a0.scala:28)\n\tat Problem.main(tmpftf479a0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.pow(x, power) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaad6lgtx.scala:20)\n\tat Problem.main(tmpaad6lgtx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.pow(x, power) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaad6lgtx.scala:20)\n\tat Problem.main(tmpaad6lgtx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.abs(power) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphlodujop.scala:20)\n\tat Problem.main(tmphlodujop.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow2, 3)\n        val pow4 =\
    \ math.pow(pow3, 4)\n        val pow5 = math.pow(pow4, 5)\n        val pow6 =\
    \ math.pow(pow5, 6)\n        val pow7 = math.pow(pow6, 7)\n        val pow8 =\
    \ math.pow(pow7, 8)\n        val pow9 = math.pow(pow8, 9)\n        val pow10 =\
    \ math.pow(pow9, 10)\n        val pow11 = math.pow(pow10, 11)\n        val pow12\
    \ = math.pow(pow11, 12)\n        val pow13 = math.pow(pow12, 13)\n        val\
    \ pow14 = math.pow(pow13, 14)\n        val pow15 = math.pow(pow14, 15)\n     \
    \   val pow16 = math.pow(pow15, 16)\n        val pow17 = math.pow(pow16, 17)\n\
    \        val pow18 = math.pow(pow17, 18)\n        val pow19 = math.pow(pow18,\
    \ 19)\n        val pow20 = math.pow(pow19, 20)\n        val pow21 = math.pow(pow20,\
    \ 21)\n        val pow22 = math.pow(pow21, 22)\n        val pow23 = math.pow(pow22,\
    \ 23)\n        val pow24 = math.pow(pow23, 24)\n        val pow25 = math.pow(pow24,\
    \ 25)\n        val pow26 = math.pow(pow25, 26)\n        val pow27 = math.pow(pow26,\
    \ 27)\n        val pow28 = math.pow(pow27, 28)\n        val pow29 = math.pow(pow28,\
    \ 29)\n        val pow30 = math.pow(pow29, 30)\n        val pow31 = math.pow(pow30,\
    \ 31)\n        val pow32 = math.pow(pow31, 32)\n        val pow33 = math.pow(pow32,\
    \ 33)\n        val pow34 = math.pow(pow33, 34)\n        val pow35 = math.pow(pow34,\
    \ 35)\n        val pow36 = math.pow(pow35, 36)\n        val pow37 = math.pow(pow36,\
    \ 37)\n        val pow38 = math.pow(pow37, 38)\n        val pow39 = math.pow(pow38,\
    \ 39)\n        val pow40 = math.pow(pow39, 40)\n        val pow41 = math.pow(pow40,\
    \ 41)\n        val pow42 = math.pow(pow41, 42)\n        val pow43 = math.pow(pow42,\
    \ 43)\n        val pow44 = math.pow(pow43, 44)\n        val pow45 = math.pow(pow44,\
    \ 45)\n        val pow46 = math.pow(pow45, 46)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0di1adhu.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.pow(x, power) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaad6lgtx.scala:20)\n\tat Problem.main(tmpaad6lgtx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7njg8l.scala:19)\n\tat Problem.main(tmp2_7njg8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power5 =\
    \ math.pow(n, 5)\n        val power7 = math.pow(n, 7)\n        val power9 = math.pow(n,\
    \ 9)\n        val power11 = math.pow(n, 11)\n        val power13 = math.pow(n,\
    \ 13)\n        val power17 = math.pow(n, 17)\n        val power19 = math.pow(n,\
    \ 19)\n        val power23 = math.pow(n, 23)\n        val power27 = math.pow(n,\
    \ 27)\n        val power31 = math.pow(n, 31)\n        val power37 = math.pow(n,\
    \ 37)\n        val power43 = math.pow(n, 43)\n        val power47 = math.pow(n,\
    \ 47)\n        val power53 = math.pow(n, 53)\n        val power59 = math.pow(n,\
    \ 59)\n        val power63 = math.pow(n, 63)\n        val power67 = math.pow(n,\
    \ 67)\n        val power73 = math.pow(n, 73)\n        val power79 = math.pow(n,\
    \ 79)\n        val power83 = math.pow(n, 83)\n        val power87 = math.pow(n,\
    \ 87)\n        val power93 = math.pow(n, 93)\n        val power97 = math.pow(n,\
    \ 97)\n        val power103 = math.pow(n, 103)\n        val power107 = math.pow(n,\
    \ 107)\n        val power113 = math.pow(n, 113)\n        val power117 = math.pow(n,\
    \ 117)\n        val power123 = math.pow(n, 123)\n        val power127 = math.pow(n,\
    \ 127)\n        val power133 = math.pow(n, 133)\n        val power137 = math.pow(n,\
    \ 137)\n        val power143 = math.pow(n, 143)\n        val power147 = math.pow(n,\
    \ 147)\n        val power153 = math.pow(n, 153)\n        val power157 = math.pow(n,\
    \ 157)\n        val power163 = math.pow(n, 163)\n        val power167 = math.pow(n,\
    \ 167)\n        val power173 = math.pow(n, 173)\n        val power177 = math.pow(n,\
    \ 177)\n        val power183 = math.pow(n, 183)\n        val power187 = math.pow(n,\
    \ 187)\n        val power193 = math.pow(n, 193)\n        val power197 = math.pow(n,\
    \ 197)\n        val power203 = math.pow(n, 203)\n        val power207 = math.pow(n,\
    \ 207)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpro5cys8h.scala:64:5\
    \ ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val powerInt\
    \ = math.round(power)\n        val powerIntInt = math.round(powerInt)\n      \
    \  val powerIntIntInt = math.round(powerIntInt)\n        val powerIntIntIntInt\
    \ = math.round(powerIntIntIntInt)\n        val powerIntIntIntIntInt = math.round(powerIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \        val powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu430g8l8.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu430g8l8.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e[0m = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt is already\
    \ defined as \e[33mvalue\e[0m \e[35mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu430g8l8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m = math.round(powerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt is already\
    \ defined as \e[33mvalue\e[0m \e[35mpowerIntIntIntIntIntIntIntIntIntIntIntIntIntIntIntInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpu430g8l8.scala:19:43 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mpowerIntIntIntInt\e[0m = math.round(powerIntIntIntInt)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                            Recursive \e[33mvalue\e[0m \e[35mpowerIntIntIntInt\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling wi"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(n, 2)\n        val pow3 = math.pow(n, 3)\n        val pow4 = math.pow(n,\
    \ 4)\n        val pow5 = math.pow(n, 5)\n        val pow6 = math.pow(n, 6)\n \
    \       val pow7 = math.pow(n, 7)\n        val pow8 = math.pow(n, 8)\n       \
    \ val pow9 = math.pow(n, 9)\n        val pow10 = math.pow(n, 10)\n        val\
    \ pow11 = math.pow(n, 11)\n        val pow12 = math.pow(n, 12)\n        val pow13\
    \ = math.pow(n, 13)\n        val pow14 = math.pow(n, 14)\n        val pow15 =\
    \ math.pow(n, 15)\n        val pow16 = math.pow(n, 16)\n        val pow17 = math.pow(n,\
    \ 17)\n        val pow18 = math.pow(n, 18)\n        val pow19 = math.pow(n, 19)\n\
    \        val pow20 = math.pow(n, 20)\n        val pow21 = math.pow(n, 21)\n  \
    \      val pow22 = math.pow(n, 22)\n        val pow23 = math.pow(n, 23)\n    \
    \    val pow24 = math.pow(n, 24)\n        val pow25 = math.pow(n, 25)\n      \
    \  val pow26 = math.pow(n, 26)\n        val pow27 = math.pow(n, 27)\n        val\
    \ pow28 = math.pow(n, 28)\n        val pow29 = math.pow(n, 29)\n        val pow30\
    \ = math.pow(n, 30)\n        val pow31 = math.pow(n, 31)\n        val pow32 =\
    \ math.pow(n, 32)\n        val pow33 = math.pow(n, 33)\n        val pow34 = math.pow(n,\
    \ 34)\n        val pow35 = math.pow(n, 35)\n        val pow36 = math.pow(n, 36)\n\
    \        val pow37 = math.pow(n, 37)\n        val pow38 = math.pow(n, 38)\n  \
    \      val pow39 = math.pow(n, 39)\n        val pow40 = math.pow(n, 40)\n    \
    \    val pow41 = math.pow(n, 41)\n        val pow42 = math.pow(n, 42)\n      \
    \  val pow43 = math.pow(n, 43)\n        val pow44 = math.pow(n, 44)\n        val\
    \ pow45 = math.pow(n, 45)\n        val pow46 = math.pow(n, 46)\n        val pow47\
    \ = math.pow(n, 47)\n        val pow48 = math.pow(n, 48)\n        val pow49 =\
    \ math.pow(n, 49)\n        val pow50 = math.pow(n, 50)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_fy26rk3.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fy26rk3.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.pow(power, n) == x\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppyg2gc4s.scala:20)\n\tat Problem.main(tmppyg2gc4s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        if (pow ==\
    \ x) {\n            true\n        } else {\n            false\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9t5mkkje.scala:23)\n\tat Problem.main(tmp9t5mkkje.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.pow(x, power) == x\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaad6lgtx.scala:20)\n\tat Problem.main(tmpaad6lgtx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(power - x) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpteoayy0z.scala:20)\n\tat Problem.main(tmpteoayy0z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.pow(x, x) == power\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp5u3_82l.scala:20)\n\tat Problem.main(tmpp5u3_82l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(x, n)\n        val pow2\
    \ = math.pow(pow, n)\n        val pow3 = math.pow(pow2, n)\n        val pow4 =\
    \ math.pow(pow3, n)\n        val pow5 = math.pow(pow4, n)\n        val pow6 =\
    \ math.pow(pow5, n)\n        val pow7 = math.pow(pow6, n)\n        val pow8 =\
    \ math.pow(pow7, n)\n        val pow9 = math.pow(pow8, n)\n        val pow10 =\
    \ math.pow(pow9, n)\n        val pow11 = math.pow(pow10, n)\n        val pow12\
    \ = math.pow(pow11, n)\n        val pow13 = math.pow(pow12, n)\n        val pow14\
    \ = math.pow(pow13, n)\n        val pow15 = math.pow(pow14, n)\n        val pow16\
    \ = math.pow(pow15, n)\n        val pow17 = math.pow(pow16, n)\n        val pow18\
    \ = math.pow(pow17, n)\n        val pow19 = math.pow(pow18, n)\n        val pow20\
    \ = math.pow(pow19, n)\n        val pow21 = math.pow(pow20, n)\n        val pow22\
    \ = math.pow(pow21, n)\n        val pow23 = math.pow(pow22, n)\n        val pow24\
    \ = math.pow(pow23, n)\n        val pow25 = math.pow(pow24, n)\n        val pow26\
    \ = math.pow(pow25, n)\n        val pow27 = math.pow(pow26, n)\n        val pow28\
    \ = math.pow(pow27, n)\n        val pow29 = math.pow(pow28, n)\n        val pow30\
    \ = math.pow(pow29, n)\n        val pow31 = math.pow(pow30, n)\n        val pow32\
    \ = math.pow(pow31, n)\n        val pow33 = math.pow(pow32, n)\n        val pow34\
    \ = math.pow(pow33, n)\n        val pow35 = math.pow(pow34, n)\n        val pow36\
    \ = math.pow(pow35, n)\n        val pow37 = math.pow(pow36, n)\n        val pow38\
    \ = math.pow(pow37, n)\n        val pow39 = math.pow(pow38, n)\n        val pow40\
    \ = math.pow(pow39, n)\n        val pow41 = math.pow(pow40, n)\n        val pow42\
    \ = math.pow(pow41, n)\n        val pow43 = math.pow(pow42, n)\n        val pow44\
    \ = math.pow(pow43, n)\n        val pow45 = math.pow(pow44, n)\n        val pow46\
    \ = math.pow(pow\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpajdncf7f.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpajdncf7f.scala:60:28\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m60 |\e[0m       \
    \ \e[33mval\e[0m \e[36mpow46\e[0m = math.pow(pow\n\e[31m\e[31m   |\e[0m      \
    \              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for parameter\
    \ y of \e[33mmethod\e[0m \e[35mpow\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m: (x: Double, y: Double): Double\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpajdncf7f.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2_7njg8l.scala:19)\n\tat Problem.main(tmp2_7njg8l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5xl5ixoy.scala:19)\n\tat Problem.main(tmp5xl5ixoy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = power == x\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmlqmqdfn.scala:20)\n\tat Problem.main(tmpmlqmqdfn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power5 =\
    \ math.pow(n, 5)\n        val power7 = math.pow(n, 7)\n        val power9 = math.pow(n,\
    \ 9)\n        val power13 = math.pow(n, 13)\n        val power17 = math.pow(n,\
    \ 17)\n        val power19 = math.pow(n, 19)\n        val power23 = math.pow(n,\
    \ 23)\n        val power27 = math.pow(n, 27)\n        val power31 = math.pow(n,\
    \ 31)\n        val power37 = math.pow(n, 37)\n        val power41 = math.pow(n,\
    \ 41)\n        val power43 = math.pow(n, 43)\n        val power47 = math.pow(n,\
    \ 47)\n        val power51 = math.pow(n, 51)\n        val power53 = math.pow(n,\
    \ 53)\n        val power57 = math.pow(n, 57)\n        val power61 = math.pow(n,\
    \ 61)\n        val power63 = math.pow(n, 63)\n        val power67 = math.pow(n,\
    \ 67)\n        val power71 = math.pow(n, 71)\n        val power73 = math.pow(n,\
    \ 73)\n        val power77 = math.pow(n, 77)\n        val power81 = math.pow(n,\
    \ 81)\n        val power83 = math.pow(n, 83)\n        val power87 = math.pow(n,\
    \ 87)\n        val power91 = math.pow(n, 91)\n        val power93 = math.pow(n,\
    \ 93)\n        val power97 = math.pow(n, 97)\n        val power101 = math.pow(n,\
    \ 101)\n        val power103 = math.pow(n, 103)\n        val power107 = math.pow(n,\
    \ 107)\n        val power111 = math.pow(n, 111)\n        val power113 = math.pow(n,\
    \ 113)\n        val power117 = math.pow(n, 117)\n        val power121 = math.pow(n,\
    \ 121)\n        val power123 = math.pow(n, 123)\n        val power127 = math.pow(n,\
    \ 127)\n        val power131 = math.pow(n, 131)\n        val power133 = math.pow(n,\
    \ 133)\n        val power137 = math.pow(n, 137)\n        val power141 = math.pow(n,\
    \ 141)\n        val power143 = math.pow(n, 143)\n        val power147 = math.pow(n,\
    \ 147)\n        val power151 = math.pow(n, 151)\n        val power153 = math.pow(n,\
    \ 153)\n\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw3c9a0rj.scala:64:5\
    \ ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        if (pow ==\
    \ x) {\n            return true\n        }\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n\
    \    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc5d6673s.scala:22)\n\tat Problem.main(tmpc5d6673s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.pow(power, n) == power\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvyqqbr2o.scala:20)\n\tat Problem.main(tmpvyqqbr2o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3q13vvi.scala:19)\n\tat Problem.main(tmpf3q13vvi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqsand0x6.scala:63:13 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        pow = \n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:18:12 -----------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        pow = math.max(pow, Long.MinValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:19:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:20:12 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Ty"
  stdout: ''
  timestamp: 1659793906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val result\
    \ = math.abs(x - power) < 1e-10\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnbcdoil.scala:20)\n\tat Problem.main(tmpnnbcdoil.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n        pow = math.abs(pow)\n\
    \        pow = math.abs(pow)\n        pow = math.abs(pow)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:18:12 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:19:12 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:21:12 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmphdutp_hn.scala:22:12 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e["
  stdout: ''
  timestamp: 1659793906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(pow, 2)\n        val pow3 = math.pow(pow, 3)\n        val pow4 =\
    \ math.pow(pow, 4)\n        val pow5 = math.pow(pow, 5)\n        val pow6 = math.pow(pow,\
    \ 6)\n        val pow7 = math.pow(pow, 7)\n        val pow8 = math.pow(pow, 8)\n\
    \        val pow9 = math.pow(pow, 9)\n        val pow10 = math.pow(pow, 10)\n\
    \        val pow11 = math.pow(pow, 11)\n        val pow12 = math.pow(pow, 12)\n\
    \        val pow13 = math.pow(pow, 13)\n        val pow14 = math.pow(pow, 14)\n\
    \        val pow15 = math.pow(pow, 15)\n        val pow16 = math.pow(pow, 16)\n\
    \        val pow17 = math.pow(pow, 17)\n        val pow18 = math.pow(pow, 18)\n\
    \        val pow19 = math.pow(pow, 19)\n        val pow20 = math.pow(pow, 20)\n\
    \        val pow21 = math.pow(pow, 21)\n        val pow22 = math.pow(pow, 22)\n\
    \        val pow23 = math.pow(pow, 23)\n        val pow24 = math.pow(pow, 24)\n\
    \        val pow25 = math.pow(pow, 25)\n        val pow26 = math.pow(pow, 26)\n\
    \        val pow27 = math.pow(pow, 27)\n        val pow28 = math.pow(pow, 28)\n\
    \        val pow29 = math.pow(pow, 29)\n        val pow30 = math.pow(pow, 30)\n\
    \        val pow31 = math.pow(pow, 31)\n        val pow32 = math.pow(pow, 32)\n\
    \        val pow33 = math.pow(pow, 33)\n        val pow34 = math.pow(pow, 34)\n\
    \        val pow35 = math.pow(pow, 35)\n        val pow36 = math.pow(pow, 36)\n\
    \        val pow37 = math.pow(pow, 37)\n        val pow38 = math.pow(pow, 38)\n\
    \        val pow39 = math.pow(pow, 39)\n        val pow40 = math.pow(pow, 40)\n\
    \        val pow41 = math.pow(pow, 41)\n        val pow42 = math.pow(pow, 42)\n\
    \        val pow43 = math.pow(pow, 43)\n        val pow44 = math.pow(pow, 44)\n\
    \        val pow45 = math.pow(pow, 45)\n        val pow46 = math.pow(pow, 46)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvzxkdgv3.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(n, 2)\n        val power3 = math.pow(n, 3)\n        val power4 =\
    \ math.pow(n, 4)\n        val power5 = math.pow(n, 5)\n        val power6 = math.pow(n,\
    \ 6)\n        val power7 = math.pow(n, 7)\n        val power8 = math.pow(n, 8)\n\
    \        val power9 = math.pow(n, 9)\n        val power10 = math.pow(n, 10)\n\
    \        val power11 = math.pow(n, 11)\n        val power12 = math.pow(n, 12)\n\
    \        val power13 = math.pow(n, 13)\n        val power14 = math.pow(n, 14)\n\
    \        val power15 = math.pow(n, 15)\n        val power16 = math.pow(n, 16)\n\
    \        val power17 = math.pow(n, 17)\n        val power18 = math.pow(n, 18)\n\
    \        val power19 = math.pow(n, 19)\n        val power20 = math.pow(n, 20)\n\
    \        val power21 = math.pow(n, 21)\n        val power22 = math.pow(n, 22)\n\
    \        val power23 = math.pow(n, 23)\n        val power24 = math.pow(n, 24)\n\
    \        val power25 = math.pow(n, 25)\n        val power26 = math.pow(n, 26)\n\
    \        val power27 = math.pow(n, 27)\n        val power28 = math.pow(n, 28)\n\
    \        val power29 = math.pow(n, 29)\n        val power30 = math.pow(n, 30)\n\
    \        val power31 = math.pow(n, 31)\n        val power32 = math.pow(n, 32)\n\
    \        val power33 = math.pow(n, 33)\n        val power34 = math.pow(n, 34)\n\
    \        val power35 = math.pow(n, 35)\n        val power36 = math.pow(n, 36)\n\
    \        val power37 = math.pow(n, 37)\n        val power38 = math.pow(n, 38)\n\
    \        val power39 = math.pow(n, 39)\n        val power40 = math.pow(n, 40)\n\
    \        val power41 = math.pow(n, 41)\n        val power42 = math.pow(n, 42)\n\
    \        val power43 = math.pow(n, 43)\n        val power44 = math.pow(n, 44)\n\
    \        val power45 = math.pow(n, 45)\n        val power46 = math.pow(n, 46)\n\
    \        val power47 = math.pow(n, 47)\n        val power48 = math.pow(n, 48)\n\
    \        val power49 = math.pow(n, 49)\n        val power50 = math.pow(n, 50)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmply0afm1w.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmply0afm1w.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = math.max(pow, Long.MinValue)\n        pow = math.abs(pow)\n      \
    \  pow = math.min(pow, Long.MaxValue)\n        pow = math.max(pow, Long.MinValue)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, Long.MaxValue)\n   \
    \     pow = \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqsand0x6.scala:63:13 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        pow = \n\e[31m\e[31m   |\e[0m             ^\e\
    [0m\n\e[31m   |\e[0m             expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:18:12 -----------------------------\e[0m\e[0m\n\e[31m18\
    \ |\e[0m        pow = math.max(pow, Long.MinValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpqsand0x6.scala:19:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        pow = math.abs(pow)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \ Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpqsand0x6.scala:20:12 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        pow = math.min(pow, Long.MaxValue)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E052] Ty"
  stdout: ''
  timestamp: 1659793906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow =\
    \ math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow,\
    \ x)\n        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow\
    \ = math.max(pow, x)\n        pow = math.abs(pow)\n        pow = math.min(pow,\
    \ x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n        pow\
    \ = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow =\
    \ math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow,\
    \ x)\n        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow\
    \ = math.max(pow, x)\n        pow = math.abs(pow)\n        pow = math.min(pow,\
    \ x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n        pow\
    \ = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow =\
    \ math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n\
    \        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow = math.max(pow,\
    \ x)\n        pow = math.abs(pow)\n        pow = math.min(pow, x)\n        pow\
    \ = math.max(pow, x)\n        pow = math.abs(pow)\n        pow = math.min(pow,\
    \ x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n        pow\
    \ = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow = math.abs(pow)\n\
    \        pow = math.min(pow, x)\n        pow = math.max(pow, x)\n        pow =\
    \ math.abs(pow)\n        \n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx8_369hs.scala:16:12 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val pow\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx8_369hs.scala:17:12 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        pow = math.min(pow, x)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val\
    \ pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx8_369hs.scala:18:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        pow = math.max(pow,\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpx8_369hs.scala:19:12 -----------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m        pow = math.abs(pow)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpx8_369hs.scala:20:12 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        pow = math.min(pow, x)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val\
    \ pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpx8_369hs.scala:21:12\
    \ -----------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        pow = math.max(pow,\
    \ x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Reassignment to val pow\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmpx8_369hs.scala:22:12 -------------------------"
  stdout: ''
  timestamp: 1659793914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val pow = math.pow(n, x)\n        val pow2\
    \ = math.pow(n, 2)\n        val pow3 = math.pow(n, 3)\n        val pow4 = math.pow(n,\
    \ 4)\n        val pow5 = math.pow(n, 5)\n        val pow6 = math.pow(n, 6)\n \
    \       val pow7 = math.pow(n, 7)\n        val pow8 = math.pow(n, 8)\n       \
    \ val pow9 = math.pow(n, 9)\n        val pow10 = math.pow(n, 10)\n        val\
    \ pow11 = math.pow(n, 11)\n        val pow12 = math.pow(n, 12)\n        val pow13\
    \ = math.pow(n, 13)\n        val pow14 = math.pow(n, 14)\n        val pow15 =\
    \ math.pow(n, 15)\n        val pow16 = math.pow(n, 16)\n        val pow17 = math.pow(n,\
    \ 17)\n        val pow18 = math.pow(n, 18)\n        val pow19 = math.pow(n, 19)\n\
    \        val pow20 = math.pow(n, 20)\n        val pow21 = math.pow(n, 21)\n  \
    \      val pow22 = math.pow(n, 22)\n        val pow23 = math.pow(n, 23)\n    \
    \    val pow24 = math.pow(n, 24)\n        val pow25 = math.pow(n, 25)\n      \
    \  val pow26 = math.pow(n, 26)\n        val pow27 = math.pow(n, 27)\n        val\
    \ pow28 = math.pow(n, 28)\n        val pow29 = math.pow(n, 29)\n        val pow30\
    \ = math.pow(n, 30)\n        val pow31 = math.pow(n, 31)\n        val pow32 =\
    \ math.pow(n, 32)\n        val pow33 = math.pow(n, 33)\n        val pow34 = math.pow(n,\
    \ 34)\n        val pow35 = math.pow(n, 35)\n        val pow36 = math.pow(n, 36)\n\
    \        val pow37 = math.pow(n, 37)\n        val pow38 = math.pow(n, 38)\n  \
    \      val pow39 = math.pow(n, 39)\n        val pow40 = math.pow(n, 40)\n    \
    \    val pow41 = math.pow(n, 41)\n        val pow42 = math.pow(n, 42)\n      \
    \  val pow43 = math.pow(n, 43)\n        val pow44 = math.pow(n, 44)\n        val\
    \ pow45 = math.pow(n, 45)\n        val pow46 = math.pow(n, 46)\n        val pow47\
    \ = math.pow(n, 47)\n        val pow48 = math.pow(n, 48)\n        val pow49 =\
    \ math.pow(n, 49)\n        val pow50 = math.pow(n, 50)\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(isSimplePower((16l), (2l))\
    \ == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n    assert(isSimplePower((4l),\
    \ (2l)) == (true));\n    assert(isSimplePower((9l), (3l)) == (true));\n    assert(isSimplePower((16l),\
    \ (4l)) == (true));\n    assert(isSimplePower((24l), (2l)) == (false));\n    assert(isSimplePower((128l),\
    \ (4l)) == (false));\n    assert(isSimplePower((12l), (6l)) == (false));\n   \
    \ assert(isSimplePower((1l), (1l)) == (true));\n    assert(isSimplePower((1l),\
    \ (12l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_fy26rk3.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_fy26rk3.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power ==\
    \ x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkaqxpg_2.scala:19)\n\tat Problem.main(tmpkaqxpg_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toDouble\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4j97rwyc.scala:19)\n\tat Problem.main(tmp4j97rwyc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        power.toLong\
    \ == x\n    }\n    def main(args: Array[String]) = {\n    assert(isSimplePower((16l),\
    \ (2l)) == (true));\n    assert(isSimplePower((143214l), (16l)) == (false));\n\
    \    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnfwj_6ak.scala:19)\n\tat Problem.main(tmpnfwj_6ak.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvmt_6igf.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(x, n)\n        val result\
    \ = math.pow(power, n) == x\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppyg2gc4s.scala:20)\n\tat Problem.main(tmppyg2gc4s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Your task is to write a function that returns true if a number x is\
    \ a simple\n    // power of n and false in other cases.\n    // x is a simple\
    \ power of n if n**int=x\n    // For example:\n    // is_simple_power(1, 4) =>\
    \ true\n    // is_simple_power(2, 2) => true\n    // is_simple_power(8, 2) =>\
    \ true\n    // is_simple_power(3, 2) => false\n    // is_simple_power(3, 1) =>\
    \ false\n    // is_simple_power(5, 3) => false\n    def isSimplePower(x : Long,\
    \ n : Long) : Boolean = {\n        val power = math.pow(n, x)\n        val power2\
    \ = math.pow(power, 2)\n        val power3 = math.pow(power, 3)\n        val power4\
    \ = math.pow(power, 4)\n        val power5 = math.pow(power, 5)\n        val power6\
    \ = math.pow(power, 6)\n        val power7 = math.pow(power, 7)\n        val power8\
    \ = math.pow(power, 8)\n        val power9 = math.pow(power, 9)\n        val power10\
    \ = math.pow(power, 10)\n        val power11 = math.pow(power, 11)\n        val\
    \ power12 = math.pow(power, 12)\n        val power13 = math.pow(power, 13)\n \
    \       val power14 = math.pow(power, 14)\n        val power15 = math.pow(power,\
    \ 15)\n        val power16 = math.pow(power, 16)\n        val power17 = math.pow(power,\
    \ 17)\n        val power18 = math.pow(power, 18)\n        val power19 = math.pow(power,\
    \ 19)\n        val power20 = math.pow(power, 20)\n        val power21 = math.pow(power,\
    \ 21)\n        val power22 = math.pow(power, 22)\n        val power23 = math.pow(power,\
    \ 23)\n        val power24 = math.pow(power, 24)\n        val power25 = math.pow(power,\
    \ 25)\n        val power26 = math.pow(power, 26)\n        val power27 = math.pow(power,\
    \ 27)\n        val power28 = math.pow(power, 28)\n        val power29 = math.pow(power,\
    \ 29)\n        val power30 = math.pow(power, 30)\n        val power31 = math.pow(power,\
    \ 31)\n        val power32 = math.pow(power, 32)\n        val power33 = math.pow(power,\
    \ 33)\n        val power34 = math.pow(power, 34)\n        val power35 = math.pow(power,\
    \ 35)\n        val power36 = math.pow(power, 36)\n        val power37 = math.pow(power,\
    \ 37)\n        val power38 = math.pow(power, 38)\n        val power39 = math.pow(power,\
    \ 39)\n        val power40 = math.pow(power, 40)\n        val power41 = math.pow(power,\
    \ 41)\n        val power42 = math.pow(power, 42)\n        val power43 = math.pow(power,\
    \ 43)\n        val power44 = math.pow(power, 44)\n        val power45 = math.pow(power,\
    \ 45)\n        val power46 = math.pow(power, 46)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(isSimplePower((16l), (2l)) == (true));\n    assert(isSimplePower((143214l),\
    \ (16l)) == (false));\n    assert(isSimplePower((4l), (2l)) == (true));\n    assert(isSimplePower((9l),\
    \ (3l)) == (true));\n    assert(isSimplePower((16l), (4l)) == (true));\n    assert(isSimplePower((24l),\
    \ (2l)) == (false));\n    assert(isSimplePower((128l), (4l)) == (false));\n  \
    \  assert(isSimplePower((12l), (6l)) == (false));\n    assert(isSimplePower((1l),\
    \ (1l)) == (true));\n    assert(isSimplePower((1l), (12l)) == (true));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51ayftdj.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793907
