name: HumanEval_21_rescale_to_unit
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n    // such that the smallest number will become 0 and the largest\
  \ will become 1\n    // >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    // [0.0,\
  \ 0.25, 0.5, 0.75, 1.0]\n    def rescaleToUnit(numbers : List[Float]) : List[Float]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](0.0f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](100.0f.toFloat,\
  \ 49.9f.toFloat))).equals((List[Float](1.0f.toFloat, 0.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals((List[Float](0.0f.toFloat,\
  \ 0.25f.toFloat, 0.5f.toFloat, 0.75f.toFloat, 1.0f.toFloat))));\n    assert(rescaleToUnit((List[Float](2.0f.toFloat,\
  \ 1.0f.toFloat, 5.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    assert(rescaleToUnit((List[Float](12.0f.toFloat,\
  \ 11.0f.toFloat, 15.0f.toFloat, 13.0f.toFloat, 14.0f.toFloat))).equals((List[Float](0.25f.toFloat,\
  \ 0.0f.toFloat, 1.0f.toFloat, 0.5f.toFloat, 0.75f.toFloat))));\n    }\n\n}\n"
completions: ["        val min = numbers.min\n        val max = numbers.max\n    \
    \    val range = max - min\n        val scaled: List[Float] = numbers.map(x =>\
    \ (x - min) / range)\n        scaled", "        val minValue = numbers.min\n \
    \       val maxValue = numbers.max\n        val range = maxValue - minValue\n\
    \        val scaledNumbers = numbers.map(x => (x - minValue) / range)\n      \
    \  scaledNumbers", "        val minValue = numbers.min\n        val maxValue =\
    \ numbers.max\n        val scale = (maxValue - minValue) / (numbers.size - 1)\n\
    \        numbers.map(x => x - minValue).map(x => x * scale).toList", "       \
    \ val min = numbers.min\n        val max = numbers.max\n        val range = max\
    \ - min\n        val newRange = range / 2\n        val newMin = min - newRange\n\
    \        val newMax = max + newRange\n        numbers.map(x => (x - min) / (max\
    \ - min))", "        val minValue = numbers.min\n        val maxValue = numbers.max\n\
    \        val range = maxValue - minValue\n        val newNumbers = numbers.map(x\
    \ => (x - minValue) / range)\n        newNumbers", "        val min = numbers.min\n\
    \        val max = numbers.max\n        val range = max - min\n        val newNumbers\
    \ = numbers.map(x => (x - min) / range)\n        newNumbers", "        val min\
    \ = numbers.min\n        val max = numbers.max\n        val range = max - min\n\
    \        val newList = numbers.map(x => (x - min) / range)\n        newList",
  "        val min = numbers.min\n        val max = numbers.max\n        val range\
    \ = max - min\n        val scaled = (numbers - min) / range\n        scaled.map(x\
    \ => x * range + min)", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val range = max - min\n        val scaled: List[Float] = numbers.map(x\
    \ => (x - min) / range)\n        scaled", "        val minValue = numbers.min\n\
    \        val maxValue = numbers.max\n        val range = maxValue - minValue\n\
    \        val newRange = range / 2.0\n        val newMinValue = minValue - newRange\n\
    \        val newMaxValue = maxValue + newRange\n        numbers.map(x => (x -\
    \ newMinValue) / newRange)", "        val min = numbers.min\n        val max =\
    \ numbers.max\n        val range = max - min\n        val newRange = range / 2\n\
    \        numbers.map(x => (x - min) / newRange)", "        val minValue = math.min(numbers)\n\
    \        val maxValue = math.max(numbers)\n        val range = (maxValue - minValue).toFloat\n\
    \        val scaledNumbers = numbers.map(x => (x - minValue) / range)\n      \
    \  scaledNumbers", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val range = max - min\n        val scaledNumbers = numbers.map(x => (x\
    \ - min) / range)\n        scaledNumbers", "        val min = numbers.min\n  \
    \      val max = numbers.max\n        val range = max - min\n        val newList\
    \ = numbers.map(x => (x - min) / range)\n        newList", "        val min =\
    \ numbers.min\n        val max = numbers.max\n        val range = max - min\n\
    \        val newRange = range / 2\n        val newMin = min - newRange\n     \
    \   val newMax = max + newRange\n        numbers.map(x => (x - min) / (max - min))",
  "        val min = numbers.min\n        val max = numbers.max\n        val range\
    \ = max - min\n        val rescaled: List[Float] = numbers.map(x => (x - min)\
    \ / range)\n        rescaled", "        val min = numbers.min\n        val max\
    \ = numbers.max\n        val range = max - min\n        val scale = (range / 2.0).toFloat\n\
    \        numbers.map(x => (x - min) * scale)", "        val minValue = numbers.min\n\
    \        val maxValue = numbers.max\n        val range = maxValue - minValue\n\
    \        val scaledList = numbers.map( x => (x - minValue) / range )\n       \
    \ scaledList", "        val min = numbers.min\n        val max = numbers.max\n\
    \        val range = max - min\n        val scaled = (numbers - min) / range\n\
    \        scaled.map(x => if (x == 0.0) 0.0 else x)", "        val minValue = numbers.min\n\
    \        val maxValue = numbers.max\n        val range = maxValue - minValue\n\
    \        val newNumbers = numbers.map( x => (x - minValue) / range )\n       \
    \ newNumbers"]
stop_tokens:
- "\n    }\n"
