name: HumanEval_6_parse_nested_parens
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Input to this function is a string represented multiple groups\
  \ for nested parentheses separated by spaces.\n    // For each of the group, output\
  \ the deepest level of nesting of parentheses.\n    // E.g. (()()) has maximum two\
  \ levels of nesting while ((())) has three.\n    // >>> ParseNestedParens((\"(()())\
  \ ((())) () ((())()())\"))\n    // (new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))\n    public static List<long> ParseNestedParens(string paren_string)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ParseNestedParens((\"\
  (()()) ((())) () ((())()())\")).Equals((new List<long>(new long[]{(long)2L, (long)3L,\
  \ (long)1L, (long)3L}))));\n    Debug.Assert(ParseNestedParens((\"() (()) ((()))\
  \ (((())))\")).Equals((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n\
  \    Debug.Assert(ParseNestedParens((\"(()(())((())))\")).Equals((new List<long>(new\
  \ long[]{(long)4L}))));\n    }\n\n}\n"
completions: ["        List<long> result = new List<long>();\n        long maximum\
    \ = 0L;\n        long current = 0L;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                current++;\n               \
    \ if (current > maximum) {\n                    maximum = current;\n         \
    \       }\n            }\n            else if (c == ')') {\n                current--;\n\
    \            }\n            else if (c == ' ') {\n                result.Add(maximum);\n\
    \                maximum = 0L;\n                current = 0L;\n            }\n\
    \        }\n        result.Add(maximum);\n        return result;", "        var\
    \ answer = new List<long>();\n        var count = 0L;\n        var max_count =\
    \ 0L;\n        foreach (var ch in paren_string) {\n            if (ch == '(')\
    \ {\n                count += 1L;\n                max_count = Math.Max(max_count,\
    \ count);\n            }\n            else if (ch == ')') {\n                count\
    \ -= 1L;\n            }\n            else if (ch == ' ') {\n                answer.Add(max_count);\n\
    \                max_count = 0L;\n                count = 0L;\n            }\n\
    \        }\n        answer.Add(max_count);\n        return answer;", "       \
    \ if (paren_string == \"\") {\n            return new List<long>();\n        }\n\
    \        else {\n            long max_count = 0L;\n            long count = 0L;\n\
    \            char[] parens = paren_string.ToCharArray();\n            List<long>\
    \ paren_counts = new List<long>();\n            foreach (char c in parens) {\n\
    \                if (c == '(') {\n                    count++;\n             \
    \       if (count > max_count) {\n                        max_count = count;\n\
    \                    }\n                }\n                else if (c == ')')\
    \ {\n                    count--;\n                }\n                else if\
    \ (c == ' ') {\n                    paren_counts.Add(max_count);\n           \
    \         max_count = 0L;\n                    count = 0L;\n                }\n\
    \            }\n            paren_counts.Add(max_count);\n            return paren_counts;\n\
    \        }", "        var groups = paren_string.Split(' ');\n        var depths\
    \ = new List<long>();\n        foreach (var group in groups) {\n            var\
    \ depth = 0L;\n            var max_depth = 0L;\n            foreach (var character\
    \ in group) {\n                if (character == '(') {\n                    depth\
    \ += 1L;\n                } else if (character == ')') {\n                   \
    \ depth -= 1L;\n                }\n                max_depth = Math.Max(max_depth,\
    \ depth);\n            }\n            depths.Add(max_depth);\n        }\n    \
    \    return depths;", "        return paren_string.Split(' ').Select(group =>\n\
    \                group.Aggregate(new Tuple<long, long>(0, 0), (total, c) =>\n\
    \                    c == '(' ? Tuple.Create(total.Item1 + 1, Math.Max(total.Item1\
    \ + 1, total.Item2)) :\n                    Tuple.Create(total.Item1 - 1, total.Item2))).Select(level\
    \ => level.Item2).ToList();", "        List<long> depths = new List<long>();\n\
    \        int depth = 0;\n        int max = 0;\n        for (int i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == '(') {\n                depth++;\n\
    \                if (depth > max) {\n                    max = depth;\n      \
    \          }\n            }\n            else if (paren_string[i] == ')') {\n\
    \                depth--;\n            }\n            else if (paren_string[i]\
    \ == ' ') {\n                depths.Add(max);\n                max = 0;\n    \
    \            depth = 0;\n            }\n        }\n        return depths;", " \
    \       List<long> result = new List<long>();\n        long curr_level = 0L;\n\
    \        long curr_max = 0L;\n        foreach (char c in paren_string) {\n   \
    \         if (c == '(') {\n                curr_level += 1L;\n               \
    \ curr_max = Math.Max(curr_max, curr_level);\n            }\n            else\
    \ if (c == ')') {\n                curr_level -= 1L;\n            }\n        \
    \    else if (c == ' ') {\n                result.Add(curr_max);\n           \
    \     curr_max = 0L;\n                curr_level = 0L;\n            }\n      \
    \  }\n        result.Add(curr_max);\n        return result;", "        // Put\
    \ your code here.\n        return new List<long>();", "        var groups = paren_string.Split(\"\
    \ \");\n        List<long> result = new List<long>();\n        foreach (var group\
    \ in groups) {\n            long depth = 0;\n            long max_depth = 0;\n\
    \            foreach (var c in group) {\n                if (c == '(') {\n   \
    \                 depth += 1;\n                    max_depth = System.Math.Max(max_depth,\
    \ depth);\n                } else if (c == ')') {\n                    depth -=\
    \ 1;\n                }\n            }\n            result.Add(max_depth);\n \
    \       }\n        return result;", "        List<long> groups = new List<long>();\n\
    \        var textArray = paren_string.Split(new char[] { ' ' });\n        foreach\
    \ (var text in textArray) {\n            // Please don't edit this line.\n   \
    \         long lvl = 0;\n            long max_lvl = 0;\n            foreach (var\
    \ c in text) {\n                if (c == '(') {\n                    lvl++;\n\
    \                    if (lvl > max_lvl) {\n                        max_lvl = lvl;\n\
    \                    }\n                } else if (c == ')') {\n             \
    \       lvl--;\n                }\n            }\n            groups.Add(max_lvl);\n\
    \        }\n        return groups;", "        List<long> ret = new List<long>();\n\
    \        // Fill ret with the output data\n        return ret;", "        // Your\
    \ code goes here.\n        // Initialize a list to store the result.\n       \
    \ var result = new List<long>();\n        // Split the input string into multiple\
    \ strings separated by space.\n        var paren_strings = paren_string.Split('\
    \ ');\n        // For each string for parentheses:\n        foreach (var str in\
    \ paren_strings) {\n            // Initialize a long variable named level to represent\
    \ the current level.\n            long level = 0L;\n            // Initialize\
    \ a long variable named max_level to represent the maximum level.\n          \
    \  long max_level = 0L;\n            // Iterate each character in the string:\n\
    \            foreach (var c in str) {\n                // If the character is\
    \ left parenthesis \"(\", increment level by 1.\n                if (c == '(')\
    \ {\n                    level += 1L;\n                }\n                // If\
    \ the character is right parenthesis \")\", decrement level by 1.\n          \
    \      if (c == ')') {\n                    level -= 1L;\n                }\n\
    \                // Update max_level if level is greater than it.\n          \
    \      if (level > max_level) {\n                    max_level = level;\n    \
    \            }\n            }\n            // Add max_level to the result list.\n\
    \            result.Add(max_level);\n        }\n        // Return the result list.\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     foreach (var group in paren_string.Split(' ')) {\n            int nest_depth\
    \ = 0;\n            int max_nest_depth = 0;\n            foreach (var c in group)\
    \ {\n                if (c == '(') {\n                    nest_depth += 1;\n \
    \                   max_nest_depth = Math.Max(max_nest_depth, nest_depth);\n \
    \               } else if (c == ')') {\n                    nest_depth -= 1;\n\
    \                }\n            }\n            result.Add(max_nest_depth);\n \
    \       }\n        return result;", "        List<long> ret = new List<long>();\n\
    \        string[] parens = paren_string.Split(' ');\n        foreach (string paren\
    \ in parens) {\n            ret.Add(parse_paren(paren));\n        }\n        return\
    \ ret;", "        var newList = new List<long>();\n        var groups = paren_string.Split('\
    \ ');\n        foreach (var g in groups) {\n            var left = 0L;\n     \
    \       var max = 0L;\n            foreach (var c in g) {\n                if\
    \ (c == '(') {\n                    left += 1L;\n                    if (left\
    \ > max) {\n                        max = left;\n                    }\n     \
    \           } else {\n                    left -= 1L;\n                }\n   \
    \         }\n            newList.Add(max);\n        }\n        return newList;",
  "        List<long> depth = new List<long>();\n        long nest_level = 0L;\n \
    \       long i = 0L;\n        while (i < paren_string.Length)\n        {\n   \
    \         char c = paren_string[(int)i];\n            i = i + 1L;\n          \
    \  if (c == '(')\n            {\n                nest_level = nest_level + 1L;\n\
    \            }\n            else if (c == ')')\n            {\n              \
    \  depth.Add(nest_level);\n                nest_level = nest_level - 1L;\n   \
    \         }\n            else if (c == ' ')\n            {\n                nest_level\
    \ = 0L;\n            }\n        }\n        return depth;", "        // put your\
    \ code here\n        return null;", "        // Write your code here\n       \
    \ // To print results to the standard output you can use Console.WriteLine()\n\
    \        // Example: Console.WriteLine(\"Hello world!\");\n        return new\
    \ List<long>();", "        List<long> max_nest_levels = new List<long>();\n  \
    \      char[] parens = paren_string.ToCharArray();\n        int current_level\
    \ = 0;\n        int max_level = 0;\n        foreach (char x in parens) {\n   \
    \         if (x == '(') {\n                current_level += 1;\n             \
    \   if (current_level > max_level) {\n                    max_level = current_level;\n\
    \                }\n            } else if (x == ')') {\n                current_level\
    \ -= 1;\n            } else if (x == ' ') {\n                max_nest_levels.Add(max_level);\n\
    \                max_level = 0;\n                current_level = 0;\n        \
    \    }\n        }\n        max_nest_levels.Add(max_level);\n        return max_nest_levels;",
  "        // >>> ParseNestedParens(\"()\")\n        // (new List<long>(new long[]{(long)1L}))\n\
    \        // >>> ParseNestedParens(\"(())\")\n        // (new List<long>(new long[]{(long)2L}))\n\
    \        // >>> ParseNestedParens(\"()()\")\n        // (new List<long>(new long[]{(long)1L,\
    \ (long)1L}))\n        // >>> ParseNestedParens(\"((()))\")\n        // (new List<long>(new\
    \ long[]{(long)3L}))\n        // >>> ParseNestedParens(\"((())())\")\n       \
    \ // (new List<long>(new long[]{(long)3L}))\n        // >>> ParseNestedParens(\"\
    ()(())\")\n        // (new List<long>(new long[]{(long)1L, (long)2L}))\n     \
    \   // >>> ParseNestedParens(\"(()(()))\")\n        // (new List<long>(new long[]{(long)3L}))\n\
    \        // >>> ParseNestedParens(\"((()(())))\")\n        // (new List<long>(new\
    \ long[]{(long)4L}))\n        // >>> ParseNestedParens(\"((())(()))\")\n     \
    \   // (new List<long>(new long[]{(long)3L, (long)3L}))\n        // >>> ParseNestedParens(\"\
    ()((()))\")\n        // (new List<long>(new long[]{(long)1L, (long)3L}))\n   \
    \     // >>> ParseNestedParens(\"(())(())\")\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)2L}))\n        // >>> ParseNestedParens(\"()()()\")\n        // (new List<long>(new\
    \ long[]{(long)1L, (long)1L, (long)1L}))\n        // >>> ParseNestedParens(\"\
    (((())))\")\n        // (new List<long>(new long[]{(long)4", "        List<long>\
    \ depth_list = new List<long>();\n        int current_depth = 0;\n        int\
    \ running_depth = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n\
    \            // If open parentheses, increment current depth and running depth.\n\
    \            if (paren_string[i] == '(') {\n                current_depth++;\n\
    \                running_depth++;\n            }\n            // If close parentheses,\
    \ decrement current depth and keep running depth.\n            if (paren_string[i]\
    \ == ')') {\n                current_depth--;\n            }\n            // If\
    \ we've reached the end of a group of parentheses, append running depth and reset\
    \ to 0.\n            if (paren_string[i] == ' ') {\n                depth_list.Add(running_depth);\n\
    \                running_depth = 0;\n            }\n        }\n        return\
    \ depth_list;", "        var list = new List<long>();\n        var parenStack\
    \ = new Stack<char>();\n        var nestedParenLevel = 0L;\n        var prevParen\
    \ = ' ';\n        foreach (var c in paren_string) {\n            if (c == '(')\
    \ {\n                parenStack.Push(c);\n                if (prevParen == '(')\
    \ {\n                    nestedParenLevel += 1L;\n                } else {\n \
    \                   nestedParenLevel = 1L;\n                }\n            } else\
    \ if (c == ')') {\n                parenStack.Pop();\n                if (parenStack.Count\
    \ == 0) {\n                    list.Add(nestedParenLevel);\n                }\n\
    \            }\n            prevParen = c;\n        }\n        return list;",
  "        List<long> result = new List<long>();\n        // Sample implementation.\n\
    \        // result.Add(0);\n        // if (paren_string[0] == '(') {\n       \
    \ //     result[0]++;\n        // }\n        // return result;\n        int n\
    \ = paren_string.Length;\n        int l = 0;\n        int r = 0;\n        int\
    \ start = 0;\n        int end = 0;\n        while (true) {\n            while\
    \ (paren_string[start] == ' ') start++;\n            if (start >= n) break;\n\
    \            end = start;\n            int h = 0;\n            while (paren_string[end]\
    \ != ' ') {\n                if (paren_string[end] == '(') {\n               \
    \     l++;\n                    h++;\n                } else {\n             \
    \       r++;\n                    h--;\n                }\n                end++;\n\
    \            }\n            result.Add(h);\n            start = end;\n       \
    \ }\n        if (l != r) {\n            Console.WriteLine(\"Wrong Input!\");\n\
    \            return null;\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        int maxDepth = 0;\n        int curDepth\
    \ = 0;\n        int lastDepth = 0;\n        foreach (char ch in paren_string)\
    \ {\n            switch (ch) {\n                case '(':\n                  \
    \  curDepth++;\n                    break;\n                case ')':\n      \
    \              lastDepth = curDepth;\n                    curDepth--;\n      \
    \              break;\n                case ' ':\n                    result.Add(lastDepth);\n\
    \                    lastDepth = 0;\n                    maxDepth = Math.Max(maxDepth,\
    \ lastDepth);\n                    break;\n            }\n        }\n        result.Add(lastDepth);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long paren_count = 0L;\n        foreach (char paren in paren_string) {\n\
    \            if (paren == '(') {\n                paren_count++;\n           \
    \ } else if (paren == ')') {\n                paren_count--;\n            } else\
    \ if (paren == ' ') {\n                result.Add(paren_count);\n            \
    \    paren_count = 0L;\n            } else {\n                throw new Exception(\"\
    Unrecognized character\");\n            }\n        }\n        result.Add(paren_count);\n\
    \        return result;", "        var groups = paren_string.Split(new char[]{'\
    \ '});\n        var result = new List<long>();\n        for (int i = 0; i < groups.Length;\
    \ i++) {\n            result.Add(CountNesting(groups[i]));\n        }\n      \
    \  return result;", "        long __ret;\n        using (StreamReader __input\
    \ = new StreamReader(Console.OpenStandardInput()))\n        using (StreamWriter\
    \ __output = new StreamWriter(Console.OpenStandardOutput())) {\n            Queue<string>\
    \ __inputParts = new Queue<string>(paren_string.Split(' '));\n            long\
    \ __a_size = int.Parse(__inputParts.Dequeue());\n            List<long> __a =\
    \ new List<long>();\n            for (int __i = 0; __i < __a_size; __i++) {\n\
    \                __a.Add(long.Parse(__inputParts.Dequeue()));\n            }\n\
    \            List<long> __result = ParseNestedParens(__a);\n            __output.WriteLine(__result.Count);\n\
    \            foreach (var __num in __result) {\n                __output.WriteLine(__num);\n\
    \            }\n        }\n        return __ret;", "        // >>> ParseNestedParens(\"\
    (()()) ((())) () ((())()())\")\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        List<long> result = new List<long>();\n\
    \        // >>> paren_string = \"(()()) ((())) () ((())()())\"\n        // >>>\
    \ paren_string.Split(new string[]{\" \"}, System.StringSplitOptions.None)\n  \
    \      // (new string[]{\"(()())\", \"((()))\", \"()\", \"((())()())\"})\n   \
    \     // >>> System.StringSplitOptions.None\n        // (System.StringSplitOptions)0\n\
    \        // >>> new string[]{\"(()())\", \"((()))\", \"()\", \"((())()())\"}\n\
    \        // (new string[]{\"(()())\", \"((()))\", \"()\", \"((())()())\"})\n \
    \       foreach (var _ in paren_string.Split(new string[]{\" \"}, System.StringSplitOptions.None))\
    \ {\n            // >>> paren_string.Split(new string[]{\" \"}, System.StringSplitOptions.None)\n\
    \            // (new string[]{\"(()())\", \"((()))\", \"()\", \"((())()())\"})\n\
    \            // >>> _\n            // \"(()())\"\n            // >>> new string[]{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"}\n            // (new string[]{\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"})\n            // >>> paren_string.Split(new\
    \ string[]{\" \"}, System.StringSplitOptions.None)[0]\n            // \"(()())\"\
    \n            // >>> paren_string.Split(new string[]{\" \"}, System.StringSplitOptions.None)[1]\n\
    \            // \"((()))\"\n            // >>> paren_string.Split(new string[]{\"\
    \ \"}, System.StringSplitOptions.None)[2]\n            // \"()\"\n           \
    \ // >>> paren_string.Split(new string[]{\" \"}, System.StringSplitOptions.None)[3]\n\
    \            // \"((())()())\"\n", "        var groups = paren_string.Split('\
    \ ');\n        var result = new List<long>();\n        foreach (var g in groups)\
    \ {\n            var max_depth = 0L;\n            var current_depth = 0L;\n  \
    \          foreach (var c in g) {\n                if (c == '(') {\n         \
    \           current_depth++;\n                    if (current_depth > max_depth)\
    \ {\n                        max_depth = current_depth;\n                    }\n\
    \                } else if (c == ')') {\n                    current_depth--;\n\
    \                }\n            }\n            result.Add(max_depth);\n      \
    \  }\n        return result;", "        var l = new List<long>();\n        long\
    \ depth = 0L;\n        long max_depth = 0L;\n        for (long i = 0L; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[(int)i] == '(') {\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            }\n            else if (paren_string[(int)i] ==\
    \ ')') {\n                if (depth > 0L) {\n                    depth--;\n  \
    \              }\n                else {\n                    max_depth = 0L;\n\
    \                }\n            }\n            else if (paren_string[(int)i] ==\
    \ ' ') {\n                l.Add(max_depth);\n                max_depth = 0L;\n\
    \                depth = 0L;\n            }\n        }\n        if (max_depth\
    \ > 0L) {\n            l.Add(max_depth);\n        }\n        return l;", '        return
    null;', "        List<long> results = new List<long>();\n        List<long> temp\
    \ = new List<long>();\n        long max = 0;\n        char[] paren_char = paren_string.ToCharArray();\n\
    \        for (long i = 0; i < paren_char.Length; i++) {\n            if (paren_char[i]\
    \ == '(') {\n                temp.Add(paren_char[i]);\n            } else if (paren_char[i]\
    \ == ')') {\n                temp.RemoveAt(temp.Count - 1);\n            } else\
    \ if (paren_char[i] == ' ') {\n                max = temp.Count;\n           \
    \     results.Add(max);\n                temp.Clear();\n            }\n      \
    \  }\n        return results;", "        List<long> result = new List<long>();\n\
    \        int cur_cnt = 0;\n        foreach (char c in paren_string) {\n      \
    \      if (c == '(') {\n                cur_cnt += 1;\n            } else if (c\
    \ == ')') {\n                cur_cnt -= 1;\n            } else if (c == ' ') {\n\
    \                result.Add(cur_cnt);\n                cur_cnt = 0;\n        \
    \    }\n        }\n        result.Add(cur_cnt);\n        return result;", "  \
    \      var ans = new List<long>();\n        var cur = \"\";\n        long level\
    \ = 0L;\n        long max_level = 0L;\n        foreach (var r in paren_string)\
    \ {\n            cur = cur + r.ToString();\n            if (r == '(') {\n    \
    \            level++;\n                if (level > max_level) {\n            \
    \        max_level = level;\n                }\n            }\n            else\
    \ if (r == ')') {\n                level--;\n            }\n            else if\
    \ (r == ' ') {\n                ans.Add(max_level);\n                cur = \"\"\
    ;\n                level = 0L;\n                max_level = 0L;\n            }\n\
    \        }\n        ans.Add(max_level);\n        return ans;", "        List<long>\
    \ ret = new List<long>();\n        // Write your code here\n        return ret;",
  "        return (from g in (from _ in paren_string.Split(' ') select _.ToList()).ToList()\
    \ select ((long)DeepestLevelOfNesting(g))).ToList();", "        List<long> paren_levels\
    \ = new List<long>();\n        int cur_level = 0;\n        int max_level = 0;\n\
    \        foreach (var ch in paren_string) {\n            if (ch == '(') {\n  \
    \              cur_level += 1;\n                max_level = Math.Max(max_level,\
    \ cur_level);\n            } else if (ch == ')') {\n                cur_level\
    \ -= 1;\n            } else if (ch == ' ') {\n                paren_levels.Add(max_level);\n\
    \                max_level = 0;\n                cur_level = 0;\n            }\n\
    \        }\n        paren_levels.Add(max_level);\n        return paren_levels;",
  "        List<long> levels = new List<long>();\n        if (paren_string.Length\
    \ == 0) {\n            return levels;\n        }\n        string[] groups = paren_string.Split(new\
    \ char[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n        long level = 0L;\n\
    \        long max_level = 0L;\n        foreach (char @char in groups[0]) {\n \
    \           if (@char == '(') {\n                level++;\n                if\
    \ (level > max_level) {\n                    max_level = level;\n            \
    \    }\n            }\n            else if (@char == ')') {\n                level--;\n\
    \            }\n        }\n        levels.Add(max_level);\n        if (groups.Length\
    \ == 1) {\n            return levels;\n        }\n        for (long i = 1L; i\
    \ < groups.Length; i++) {\n            level = 0L;\n            max_level = 0L;\n\
    \            foreach (char @char in groups[i]) {\n                if (@char ==\
    \ '(') {\n                    level++;\n                    if (level > max_level)\
    \ {\n                        max_level = level;\n                    }\n     \
    \           }\n                else if (@char == ')') {\n                    level--;\n\
    \                }\n            }\n            levels.Add(max_level);\n      \
    \  }\n        return levels;", "        var ret = new List<long>();\n        var\
    \ stk = new Stack<long>();\n        long max_depth = 0;\n        for (long i =\
    \ 0; i < paren_string.Length; i++) {\n            if (paren_string[(int)i] ==\
    \ '(') {\n                stk.Push(i);\n            } else if (paren_string[(int)i]\
    \ == ')') {\n                var idx = stk.Pop();\n                max_depth =\
    \ Math.Max(max_depth, i - idx);\n            } else if (paren_string[(int)i] ==\
    \ ' ') {\n                ret.Add(max_depth);\n                max_depth = 0;\n\
    \            }\n        }\n        ret.Add(max_depth);\n        return ret;",
  "        // Write code here.\n        // >>> ParseNestedParens((\"(()()) ((()))\
    \ () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L, (long)3L,\
    \ (long)1L, (long)3L}))\n        var maxParens = new List<long>();\n        var\
    \ parenStack = new Stack<int>();\n        long maxParen = 0;\n        for (int\
    \ i = 0; i < paren_string.Length; i++) {\n            if (paren_string[i] == '(')\
    \ {\n                parenStack.Push(i);\n            } else if (paren_string[i]\
    \ == ')') {\n                var parenIndex = parenStack.Pop();\n            \
    \    var parenCount = i - parenIndex + 1;\n                if (parenCount > maxParen)\
    \ {\n                    maxParen = parenCount;\n                }\n         \
    \   }\n            if (parenStack.Count == 0) {\n                maxParens.Add(maxParen);\n\
    \                maxParen = 0;\n            }\n        }\n        return maxParens;",
  "        var result = new List<long>();\n        int opening = 0;\n        int max_depth\
    \ = 0;\n        int depth = 0;\n        foreach (char c in paren_string) {\n \
    \           if (c == '(') {\n                opening++;\n                depth++;\n\
    \                if (depth > max_depth) {\n                    max_depth = depth;\n\
    \                }\n            } else if (c == ')') {\n                opening--;\n\
    \                depth--;\n            } else if (c == ' ') {\n              \
    \  if (opening != 0) {\n                    throw new Exception(\"Not all opening\
    \ parentheses are closed!\");\n                }\n                result.Add(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \       }\n        if (opening != 0) {\n            throw new Exception(\"Not\
    \ all opening parentheses are closed!\");\n        }\n        result.Add(max_depth);\n\
    \        return result;", "        List<long> results = new List<long>();\n  \
    \      // TODO implement this\n        return results;", "        List<long> ret\
    \ = new List<long>();\n        int l = 0;\n        int maxn = 0;\n        foreach\
    \ (char ch in paren_string) {\n            if (ch == '(') {\n                l\
    \ += 1;\n                maxn = Math.Max(maxn, l);\n            } else if (ch\
    \ == ')') {\n                l -= 1;\n            } else if (ch == ' ') {\n  \
    \              ret.Add(maxn);\n                maxn = 0;\n                l =\
    \ 0;\n            }\n        }\n        ret.Add(maxn);\n        return ret;",
  "        // todo: implement\n        return new List<long>();", "        var start_paren\
    \ = paren_string.IndexOf('(');\n        var end_paren = paren_string.IndexOf(')');\n\
    \        var res = new List<long>();\n        while(start_paren != -1) {\n   \
    \         var paren_str = paren_string.Substring(start_paren, end_paren - start_paren\
    \ + 1);\n            var depth = 0L;\n            var max_depth = 0L;\n      \
    \      foreach(var c in paren_str) {\n                if(c == '(')\n         \
    \           depth++;\n                else\n                    depth--;\n   \
    \             max_depth = Math.Max(max_depth, depth);\n            }\n       \
    \     res.Add(max_depth);\n            start_paren = paren_string.IndexOf('(',\
    \ end_paren + 1);\n            end_paren = paren_string.IndexOf(')', end_paren\
    \ + 1);\n        }\n        return res;", "        List<long> answer = new List<long>();\n\
    \        int last_idx = 0;\n        int i = 0;\n        for (i = 0; i < paren_string.Length;\
    \ i++) {\n            if (paren_string[i] == ' ') {\n                string this_paren_string\
    \ = paren_string.Substring(last_idx, i - last_idx);\n                answer.Add(GetDeepestParens(this_paren_string));\n\
    \                last_idx = i + 1;\n            }\n        }\n        string last_paren_string\
    \ = paren_string.Substring(last_idx, i - last_idx);\n        answer.Add(GetDeepestParens(last_paren_string));\n\
    \        return answer;", '        return new List<long>();', "        paren_string\
    \ = paren_string.Replace(\"(\", \"( \");\n        paren_string = paren_string.Replace(\"\
    )\", \" )\");\n        List<long> result = new List<long>();\n        string[]\
    \ tokens = paren_string.Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);\n\
    \        long max_count = 0L;\n        long cur_count = 0L;\n        foreach (string\
    \ token in tokens) {\n            if (token == \"(\") {\n                cur_count++;\n\
    \                if (cur_count > max_count) {\n                    max_count =\
    \ cur_count;\n                }\n            } else if (token == \")\") {\n  \
    \              cur_count--;\n            } else {\n                throw new Exception(String.Format(\"\
    Unexpected character in parse string: {0}\", token));\n            }\n       \
    \ }\n        result.Add(max_count);\n        return result;", "        var groups\
    \ = paren_string.Split(\" \".ToCharArray());\n        var result = new List<long>();\n\
    \        foreach (var group in groups) {\n            long level = 0L;\n     \
    \       long max_level = 0L;\n            foreach (var paren in group) {\n   \
    \             if (paren == '(') {\n                    level++;\n            \
    \        if (level > max_level) {\n                        max_level = level;\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           level--;\n                }\n            }\n            result.Add(max_level);\n\
    \        }\n        return result;", "        List<long> out_ = new List<long>();\n\
    \        var v = paren_string.Split(' ');\n        for (int idx = 0; idx < v.Length;\
    \ idx++) {\n            if (v[idx].Length == 0) {\n                out_.Add(0);\n\
    \                continue;\n            }\n            out_.Add(GetMaxDepth(v[idx]));\n\
    \        }\n        return out_;", "        // Start writing code here\n     \
    \   List<long> res = new List<long>();\n        long deepest = 0;\n        int\
    \ counter = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n    \
    \        if (paren_string[i] == '(') {\n                counter++;\n         \
    \       if (counter > deepest) {\n                    deepest = counter;\n   \
    \             }\n            } else if (paren_string[i] == ')') {\n          \
    \      counter--;\n            } else if (paren_string[i] == ' ') {\n        \
    \        res.Add(deepest);\n                deepest = 0;\n                counter\
    \ = 0;\n            }\n        }\n        res.Add(deepest);\n        return res;",
  "        int deep_count = 0;\n        int deep_max = 0;\n        List<long> output\
    \ = new List<long>();\n        for (int i = 0; i < paren_string.Length; i++) {\n\
    \            if (paren_string[i] == '(') {\n                deep_count++;\n  \
    \              if (deep_count > deep_max) {\n                    deep_max = deep_count;\n\
    \                }\n            } else if (paren_string[i] == ')') {\n       \
    \         deep_count--;\n            } else if (paren_string[i] == ' ') {\n  \
    \              output.Add(deep_max);\n                deep_max = 0;\n        \
    \        deep_count = 0;\n            }\n        }\n        output.Add(deep_max);\n\
    \        return output;", "        // We use a stack to keep track of the nesting.\
    \ If a paren is (, we push onto the stack. If it is ), we pop from the stack.\n\
    \        // E.g. (((((((((((())))))))))) has maximum stack size of 12.\n     \
    \   // We use a counter to keep track of the maximum stack size we've seen so\
    \ far.\n        long max_stack_size = 0L;\n        long cur_stack_size = 0L;\n\
    \        var max_stack_sizes = new List<long>();\n\n        foreach (var c in\
    \ paren_string) {\n            if (c == '(') {\n                cur_stack_size\
    \ += 1L;\n                if (cur_stack_size > max_stack_size) {\n           \
    \         max_stack_size = cur_stack_size;\n                }\n            } else\
    \ if (c == ')') {\n                if (cur_stack_size > 0L) {\n              \
    \      cur_stack_size -= 1L;\n                } else {\n                    cur_stack_size\
    \ = 0L;\n                }\n            } else if (c == ' ') {\n             \
    \   // We have reached the end of a group, push the max_stack_size for this group\
    \ to the output list.\n                max_stack_sizes.Add(max_stack_size);\n\
    \                max_stack_size = 0L;\n                cur_stack_size = 0L;\n\
    \            }\n        }\n        // Make sure to handle the last group if there\
    \ is no space at the end.\n        if (max_stack_size > 0L) {\n            max_stack_sizes.Add(max_stack_size);\n\
    \        }\n        return max_stack_sizes;", "        Stack<Tuple<long, long>>\
    \ parens = new Stack<Tuple<long, long>>();\n        List<long> ret = new List<long>();\n\
    \        long max = 0;\n        long count = 0;\n        foreach (char c in paren_string)\
    \ {\n            if (c == '(') {\n                count += 1;\n              \
    \  parens.Push(new Tuple<long, long>(count, max));\n                max = count;\n\
    \            } else if (c == ')') {\n                ret.Add(max);\n         \
    \       Tuple<long, long> p = parens.Pop();\n                count = p.Item1;\n\
    \                max = p.Item2;\n            }\n        }\n        return ret;",
  "        var v = new List<long>();\n        // Var c = paren_string.ToList();\n\
    \        paren_string = paren_string.Replace(\" \", \"\");\n        if (paren_string.Length\
    \ == 0) {\n            return v;\n        }\n        int c = 0;\n        int max\
    \ = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n            if\
    \ (paren_string[i] == '(') {\n                c += 1;\n                if (c >\
    \ max) {\n                    max = c;\n                }\n            } else\
    \ {\n                c -= 1;\n            }\n        }\n        v.Add(max);\n\
    \        int idx = paren_string.LastIndexOf(\"(\");\n        if (idx != -1) {\n\
    \            v.AddRange(ParseNestedParens(paren_string.Substring(idx + 1)));\n\
    \        }\n        return v;", "        List<long> result = new List<long>();\n\
    \        var re = new Regex(@\"\\(\\(([^\\(\\)]*)\\)\\)\");\n        result.Add(paren_string.Count(c\
    \ => c == '('));\n        // The Regex pattern above is capturing the innermost\
    \ layers of parentheses.\n        // For example (abc(abc(abc))) will capture\
    \ 3 times: abc(abc(abc)), abc(abc), abc\n        foreach (Match m in re.Matches(paren_string))\
    \ {\n            result.Add(ParseNestedParens(m.Groups[1].Value).Max());\n   \
    \     }\n        return result;", "        // Write your solution here\n     \
    \   return new List<long>();", "        List<long> results = new List<long>();\n\
    \        long depth = 0L;\n        long max_depth = 0L;\n        foreach (char\
    \ s in paren_string) {\n            if (s == '(') {\n                depth +=\
    \ 1L;\n                if (depth > max_depth) {\n                    max_depth\
    \ = depth;\n                }\n            } else if (s == ')') {\n          \
    \      depth -= 1L;\n            } else if (s == ' ') {\n                results.Add(max_depth);\n\
    \                max_depth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        return results;", "        List<long> result = new List<long>();\n\
    \        List<char> stack = new List<char>();\n        int max_depth = 0;\n  \
    \      int depth = 0;\n        foreach (char c in paren_string) {\n          \
    \  if (c == '(') {\n                stack.Add(c);\n                depth += 1;\n\
    \                max_depth = Math.Max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                stack.RemoveAt(stack.Count - 1);\n           \
    \     depth -= 1;\n            } else if (c == ' ') {\n                result.Add((long)max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \       }\n        result.Add((long)max_depth);\n        return result;", "  \
    \      // code here\n        return new List<long>();", "        var res = new\
    \ List<long>();\n        int paren_count = 0;\n        int max_paren_count = 0;\n\
    \        bool open_paren = false;\n        foreach (var r in paren_string) {\n\
    \            if (r == '(') {\n                open_paren = true;\n           \
    \     paren_count += 1;\n                max_paren_count = Math.Max(max_paren_count,\
    \ paren_count);\n            } else if (r == ')') {\n                open_paren\
    \ = false;\n                paren_count -= 1;\n            } else if (r == ' '\
    \ && !open_paren) {\n                res.Add(max_paren_count);\n             \
    \   max_paren_count = 0;\n                paren_count = 0;\n            }\n  \
    \      }\n        if (paren_count == 0) {\n            res.Add(max_paren_count);\n\
    \        }\n        return res;", "        List<long> res = new List<long>();\n\
    \        foreach (var l in paren_string.Split(' ')) {\n            int cnt = 0;\n\
    \            int max = 0;\n            foreach (var i in l) {\n              \
    \  if (i == '(') {\n                    cnt++;\n                    max = Math.Max(max,\
    \ cnt);\n                } else if (i == ')') {\n                    cnt--;\n\
    \                }\n            }\n            res.Add(max);\n        }\n    \
    \    return res;", "        List<long> result = new List<long>();\n        int\
    \ cnt = 0;\n        int max_level = 0;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                cnt += 1;\n                max_level\
    \ = Math.Max(max_level, cnt);\n            } else if (c == ')') {\n          \
    \      cnt -= 1;\n            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                max_level = 0;\n                cnt = 0;\n            }\n   \
    \     }\n        result.Add(max_level);\n        return result;", "        var\
    \ result = new List<long>();\n        // TODO(you): Write code here\n        return\
    \ result;", "        var ret = new List<long>();\n        var depth = new Stack<long>();\n\
    \        depth.Push(0);\n        var max_depth = 0;\n        foreach (var s in\
    \ paren_string) {\n            if (s == '(') {\n                max_depth += 1;\n\
    \                depth.Push(max_depth);\n            } else if (s == ')') {\n\
    \                ret.Add(depth.Pop());\n                max_depth -= 1;\n    \
    \        }\n        }\n        return ret;", "        List<long> result = new\
    \ List<long>();\n        foreach (string paren_group in paren_string.Split(' '))\
    \ {\n            int depth = 0;\n            int max_depth = 0;\n            foreach\
    \ (char ch in paren_group) {\n                if (ch == '(') {\n             \
    \       depth++;\n                    max_depth = Math.Max(max_depth, depth);\n\
    \                } else if (ch == ')') {\n                    depth--;\n     \
    \           }\n            }\n            result.Add(max_depth);\n        }\n\
    \        return result;", '        throw new NotImplementedException();', '        return
    null;', "        // >>> ParseNestedParens(\"(()()) ((())) () ((())()())\")\n \
    \       // (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n\
    \        if (paren_string == null) {\n            return new List<long>();\n \
    \       }\n        string[] groups = paren_string.Split(' ');\n        var ret\
    \ = new List<long>();\n        foreach (var group in groups) {\n            ret.Add(ParseNestedParens(group));\n\
    \        }\n        return ret;", "        var matches = new List<long>();\n \
    \       var match = new Match();\n        var idx = 0;\n        while (idx < paren_string.Length)\
    \ {\n            while (idx < paren_string.Length && paren_string[idx] == ' ')\
    \ {\n                idx += 1;\n            }\n            if (idx < paren_string.Length)\
    \ {\n                match.Reset();\n                if (paren_string[idx] ==\
    \ '(') {\n                    match.AddOpen();\n                    idx += 1;\n\
    \                }\n                while (idx < paren_string.Length && paren_string[idx]\
    \ != ' ') {\n                    if (paren_string[idx] == '(') {\n           \
    \             match.AddOpen();\n                    } else if (paren_string[idx]\
    \ == ')') {\n                        match.AddClose();\n                    }\n\
    \                    idx += 1;\n                }\n                matches.Add(match.MatchCount());\n\
    \            }\n        }\n        return matches;", '        throw new NotImplementedException();',
  "        List<long> result = new List<long>();\n        string[] groups = paren_string.Split('\
    \ ');\n        for (int i = 0; i < groups.Length; i++) {\n            long depth\
    \ = (long)0L;\n            for (int j = 0; j < groups[i].Length; j++) {\n    \
    \            if (groups[i][j] == '(') {\n                    depth += (long)1L;\n\
    \                }\n                else if (groups[i][j] == ')') {\n        \
    \            depth -= (long)1L;\n                }\n            }\n          \
    \  result.Add(depth);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        foreach (string group in paren_string.Split('\
    \ ')) {\n            int max_nesting = 0;\n            int nesting = 0;\n    \
    \        foreach (char c in group) {\n                if (c == '(') {\n      \
    \              nesting++;\n                    if (nesting > max_nesting) {\n\
    \                        max_nesting = nesting;\n                    }\n     \
    \           } else if (c == ')') {\n                    nesting--;\n         \
    \       }\n            }\n            result.Add(max_nesting);\n        }\n  \
    \      return result;", "        var tokens = paren_string.Split(' ');\n     \
    \   var results = new List<long>();\n        foreach (var group in tokens) {\n\
    \            long level = 0;\n            long max = 0;\n            foreach (var\
    \ ch in group) {\n                if (ch == '(') {\n                    level++;\n\
    \                    if (level > max) {\n                        max = level;\n\
    \                    }\n                } else if (ch == ')') {\n            \
    \        level--;\n                }\n            }\n            results.Add(max);\n\
    \        }\n        return results;", "        var result = new List<long>();\n\
    \        var split = paren_string.Split(' ');\n        foreach (var s in split)\
    \ {\n            var max = 0L;\n            var current = 0L;\n            foreach\
    \ (var c in s) {\n                if (c == '(') {\n                    current\
    \ += 1L;\n                    if (current > max) {\n                        max\
    \ = current;\n                    }\n                }\n                else if\
    \ (c == ')') {\n                    current -= 1L;\n                }\n      \
    \      }\n            result.Add(max);\n        }\n        return result;", " \
    \       var parentheses = paren_string.Split(' ');\n        var ans = new List<long>();\n\
    \        foreach (var paren in parentheses) {\n            var num = 0L;\n   \
    \         foreach (var ch in paren) {\n                if (ch == '(') {\n    \
    \                num++;\n                } else {\n                    num--;\n\
    \                }\n            }\n            ans.Add(num);\n        }\n    \
    \    return ans;", "        if (paren_string.Length == 0L) {\n            return\
    \ new List<long>();\n        }\n\n        var parens = new List<long>();\n   \
    \     long current_level = 0L;\n        for (long i = 0L; i < paren_string.Length;\
    \ i++) {\n            var @char = paren_string[(int)i];\n            if (@char\
    \ == '(') {\n                current_level++;\n            }\n            else\
    \ if (@char == ')') {\n                current_level--;\n            }\n     \
    \       else if (@char == ' ') {\n                parens.Add(current_level);\n\
    \                current_level = 0L;\n            }\n\n        }\n        parens.Add(current_level);\n\
    \        return parens;\n", "        paren_string = paren_string.Trim();\n   \
    \     List<long> depths = new List<long>();\n        int paren_depth = 0;\n  \
    \      int max_depth = 0;\n        for (int i = 0; i < paren_string.Length; i++)\
    \ {\n            if (paren_string[i] == '(') {\n                paren_depth +=\
    \ 1;\n                max_depth = Math.Max(max_depth, paren_depth);\n        \
    \    }\n            else if (paren_string[i] == ')') {\n                paren_depth\
    \ -= 1;\n            }\n            else if (paren_string[i] == ' ') {\n     \
    \           depths.Add(max_depth);\n                max_depth = 0;\n         \
    \       paren_depth = 0;\n            }\n        }\n        return depths;", " \
    \       var result = new List<long>();\n        var number_of_groups = paren_string.Count(c\
    \ => c == ' ') + 1;\n        var groups = paren_string.Split(' ');\n        for\
    \ (int i = 0; i < number_of_groups; i++) {\n            int depth = 0;\n     \
    \       int max_depth = 0;\n            foreach (char c in groups[i]) {\n    \
    \            if (c == '(') {\n                    depth++;\n                 \
    \   if (depth > max_depth) {\n                        max_depth = depth;\n   \
    \                 }\n                } else if (c == ')') {\n                \
    \    depth--;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        // Fill the required code here and\
    \ return the List<long>\n        // You can add more testcases for debugging on\
    \ your local machine.\n        int left_balance = 0;\n        int right_balance\
    \ = 0;\n        long max_depth = 0;\n        List<long> result = new List<long>();\n\
    \        foreach (char c in paren_string) {\n            if (c == '(') {\n   \
    \             left_balance++;\n                max_depth = Math.Max(max_depth,\
    \ left_balance);\n            } else if (c == ')') {\n                right_balance++;\n\
    \                if (right_balance > left_balance) {\n                    max_depth\
    \ = 0;\n                    left_balance = 0;\n                    right_balance\
    \ = 0;\n                }\n            } else if (c == ' ') {\n              \
    \  if (left_balance != right_balance) {\n                    result.Add(max_depth);\n\
    \                    max_depth = 0;\n                    left_balance = 0;\n \
    \                   right_balance = 0;\n                }\n            }\n   \
    \     }\n        if (left_balance == right_balance) {\n            result.Add(max_depth);\n\
    \        }\n        return result;", '        throw new NotImplementedException();',
  "        //implement me\n        List<long> r = new List<long>();\n        int wl\
    \ = 0;\n        int max = 0;\n        int n = paren_string.Length;\n        for\
    \ (int i = 0; i < n; i++) {\n            if (paren_string[i] == '(') {\n     \
    \           wl++;\n                if (wl > max) {\n                    max =\
    \ wl;\n                }\n            } else if (paren_string[i] == ')') {\n \
    \               wl--;\n            } else if (paren_string[i] == ' ') {\n    \
    \            r.Add(max);\n                max = 0;\n                wl = 0;\n\
    \            }\n        }\n        r.Add(max);\n        return r;", '        return
    new List<long>();', "        // Replace the code below\n        return null;",
  "        var l = new List<long>();\n        // Start here.\n        return l;",
  "        int depth = 0;\n        int depthMax = 0;\n        List<long> depths =\
    \ new List<long>();\n        foreach (char _c in paren_string) {\n           \
    \ char c = _c;\n            if (c == '(') {\n                depth += 1;\n   \
    \             if (depth > depthMax) {\n                    depthMax = depth;\n\
    \                }\n            }\n            else if (c == ')') {\n        \
    \        depth -= 1;\n            }\n            else if (c == ' ') {\n      \
    \          depths.Add((long)depthMax);\n                depthMax = 0;\n      \
    \          depth = 0;\n            }\n        }\n        depths.Add((long)depthMax);\n\
    \        return depths;", "        List<long> result = new List<long>();\n   \
    \     // Perform your method of parsing here\n        Stack<long> stk = new Stack<long>();\n\
    \        //long cur_level = 0;\n        long max_level = 0;\n        foreach (char\
    \ c in paren_string.ToCharArray()) {\n            if (c == '(') {\n          \
    \      stk.Push(1);\n                max_level++;\n            } else if (c ==\
    \ ')') {\n                if (stk.Count == 0) {\n                    Console.WriteLine(\"\
    Not a well formed string! Exiting!\");\n                    System.Environment.Exit(1);\n\
    \                }\n                stk.Pop();\n                max_level--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_level);\n\
    \                max_level = 0;\n            }\n        }\n        result.Add(max_level);\n\
    \        return result;", "        List<long> result = new List<long>();\n   \
    \     long current_level = 0L;\n        long deepest_level = 0L;\n        foreach\
    \ (char current_char in paren_string) {\n            switch (current_char) {\n\
    \                case '(':\n                    current_level += 1L;\n       \
    \             break;\n                case ')':\n                    if (current_level\
    \ == 0L) {\n                        throw new Exception(\"Unbalanced parens\"\
    );\n                    }\n                    current_level -= 1L;\n        \
    \            break;\n                case ' ':\n                    result.Add(deepest_level);\n\
    \                    if (current_level != 0L) {\n                        throw\
    \ new Exception(\"Unbalanced parens\");\n                    }\n             \
    \       deepest_level = 0L;\n                    break;\n                default:\n\
    \                    throw new Exception(\"Unknown character in input\");\n  \
    \          }\n            if (current_level > deepest_level) {\n             \
    \   deepest_level = current_level;\n            }\n        }\n        if (current_level\
    \ != 0L) {\n            throw new Exception(\"Unbalanced parens\");\n        }\n\
    \        result.Add(deepest_level);\n        return result;", "        // TODO:\
    \ Write your code here\n        var res = new List<long>();\n        var curMax\
    \ = 0;\n        var cur = 0;\n        foreach (var ch in paren_string) {\n   \
    \         if (ch == '(') {\n                cur++;\n                curMax = Math.Max(curMax,\
    \ cur);\n            } else if (ch == ')') {\n                cur--;\n       \
    \     } else if (ch == ' ') {\n                res.Add(curMax);\n            \
    \    curMax = 0;\n                cur = 0;\n            }\n        }\n       \
    \ res.Add(curMax);\n        return res;", "        List<long> levels = new List<long>();\n\
    \        // Fill here.\n        long count = 0;\n        long level = 0;\n   \
    \     foreach (char ch in paren_string) {\n            if (ch == '(') {\n    \
    \            count++;\n                level++;\n            } else if (ch ==\
    \ ')') {\n                count--;\n                level--;\n            } else\
    \ if (ch == ' ') {\n                levels.Add(level);\n                level\
    \ = 0;\n            }\n        }\n        if (count != 0)\n            throw new\
    \ Exception(\"unbalanced\");\n        return levels;", '        throw new NotImplementedException();',
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   List<long> res = new List<long>();\n        string[] split = paren_string.Split();\n\
    \        foreach (string str in split) {\n            int max = 0;\n         \
    \   int c = 0;\n            for (int i = 0; i < str.Length; i++) {\n         \
    \       if (str[i] == '(') {\n                    c++;\n                    if\
    \ (c > max) {\n                        max = c;\n                    }\n     \
    \           } else {\n                    c--;\n                }\n          \
    \  }\n            res.Add(max);\n        }\n        return res;", "        var\
    \ output = new List<long>();\n        var parts = paren_string.Split(new char[]{'\
    \ '}, StringSplitOptions.RemoveEmptyEntries);\n        foreach (var part in parts)\
    \ {\n            var levels = 0L;\n            var maxLevels = 0L;\n         \
    \   foreach (var c in part) {\n                if (c == '(') {\n             \
    \       levels += 1L;\n                    maxLevels = Math.Max(maxLevels, levels);\n\
    \                } else if (c == ')') {\n                    levels -= 1L;\n \
    \               }\n            }\n            output.Add(maxLevels);\n       \
    \ }\n        return output;", "        var groups = paren_string.Split(\" \");\n\
    \        var result = new List<long>();\n        foreach (var group in groups)\
    \ {\n            if (group.Length == 0) {\n                result.Add(0);\n  \
    \              continue;\n            }\n            else if (group.Length ==\
    \ 1) {\n                result.Add(1);\n                continue;\n          \
    \  }\n            var depth = 1L;\n            var max_depth = 1L;\n         \
    \   foreach (var c in group) {\n                if (c == '(') {\n            \
    \        depth += 1L;\n                    max_depth = Math.Max(max_depth, depth);\n\
    \                }\n                else if (c == ')') {\n                   \
    \ depth -= 1L;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var tokens = paren_string.Split('\
    \ ');\n        // Preprocess list\n        for (int i = 0; i < tokens.Length;\
    \ i++) {\n            tokens[i] = tokens[i].Trim();\n        }\n        var ret\
    \ = new List<long>();\n        foreach (var token in tokens) {\n            long\
    \ current_max = 0;\n            long current_level = 0;\n            foreach (var\
    \ character in token) {\n                if (character == '(') {\n           \
    \         current_level += 1;\n                    current_max = Math.Max(current_max,\
    \ current_level);\n                } else if (character == ')') {\n          \
    \          current_level -= 1;\n                }\n            }\n           \
    \ ret.Add(current_max);\n        }\n        return ret;", "        var result\
    \ = new List<long>();\n        // Your code goes here.\n        var temp = paren_string.Split(new\
    \ char[] { ' ' });\n        foreach (var item in temp)\n        {\n          \
    \  int deep = 0;\n            int max = 0;\n            foreach (var item1 in\
    \ item)\n            {\n                if (item1 == '(')\n                {\n\
    \                    deep++;\n                    if (deep > max)\n          \
    \          {\n                        max = deep;\n                    }\n   \
    \             }\n                else if (item1 == ')')\n                {\n \
    \                   deep--;\n                }\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var maxdepth = new List<long>();\n\
    \        long depth = 0L;\n        long n = 0L;\n        while (n < len(paren_string))\n\
    \        {\n            var @char = paren_string[n..n + 1L];\n            if (@char\
    \ == \"(\")\n            {\n                depth++;\n            }\n        \
    \    else if (@char == \")\")\n            {\n                depth--;\n     \
    \       }\n            else if (@char == \" \")\n            {\n             \
    \   maxdepth.Add(depth);\n                depth = 0L;\n            }\n\n     \
    \       n++;\n\n        }\n\n        maxdepth.Add(depth);\n        return maxdepth;\n",
  "        long count = 0L;\n        long max = 0L;\n        var result = new List<long>();\n\
    \        for (long i = 0L; i < paren_string.Length; i++) {\n            if (paren_string[(int)i]\
    \ == '(') {\n                count++;\n                if (count > max) {\n  \
    \                  max = count;\n                }\n            }\n          \
    \  else if (paren_string[(int)i] == ')') {\n                count--;\n       \
    \     }\n            else if (paren_string[(int)i] == ' ') {\n               \
    \ result.Add(max);\n                max = 0L;\n                count = 0L;\n \
    \           }\n        }\n        result.Add(max);\n        return result;", " \
    \       var A = new List<long>();\n        var B = new List<long>();\n       \
    \ var depth = 0L;\n        foreach (var _ in paren_string) {\n            var\
    \ ch = _;\n            if (ch == '(') {\n                depth++;\n          \
    \  }\n            else if (ch == ')') {\n                A.Add(depth);\n     \
    \           depth--;\n            }\n            else if (ch == ' ') {\n     \
    \           B.Add(A.Max());\n                A.Clear();\n            }\n     \
    \   }\n        B.Add(A.Max());\n        return B;", "        List<long> result\
    \ = new List<long>();\n        long depth = 0L;\n        long max_depth = 0L;\n\
    \        foreach (char paren in paren_string) {\n            switch (paren) {\n\
    \                case '(':\n                    depth++;\n                   \
    \ max_depth = Math.Max(max_depth, depth);\n                    break;\n      \
    \          case ')':\n                    depth--;\n                    break;\n\
    \                case ' ':\n                    result.Add(max_depth);\n     \
    \               max_depth = 0L;\n                    break;\n            }\n \
    \       }\n        result.Add(max_depth);\n        return result;", "        List<long>\
    \ result = new List<long>();\n        foreach (string paren in paren_string.Split('\
    \ ')) {\n            long max_depth = 0;\n            long cur_depth = 0;\n  \
    \          for (int i = 0; i < paren.Length; i++) {\n                if (paren[i]\
    \ == '(') {\n                    cur_depth += 1;\n                    max_depth\
    \ = Math.Max(max_depth, cur_depth);\n                } else if (paren[i] == ')')\
    \ {\n                    cur_depth -= 1;\n                }\n            }\n \
    \           result.Add(max_depth);\n        }\n        return result;", "    \
    \    var stack = new Stack<long>();\n        var maxLevel = new List<long>();\n\
    \        var depth = 0L;\n        for (var i = 0L; i < paren_string.Length; i++)\
    \ {\n            switch (paren_string[(int)i]) {\n                case '(':\n\
    \                    stack.Push(i);\n                    depth++;\n          \
    \          break;\n                case ')':\n                    stack.Pop();\n\
    \                    if (stack.Count == 0) {\n                        maxLevel.Add(depth);\n\
    \                        depth = 0L;\n                    }\n                \
    \    break;\n            }\n        }\n        return maxLevel;", "        return\
    \ Enumerable.ToList(\n            Enumerable.Select(\n                Enumerable.Where(\n\
    \                    Enumerable.Select(\n                        Strings.Split(paren_string,\
    \ \" \"),\n                        (string group) => {\n                     \
    \       return new {\n                                MaxDepth = (long)0L,\n \
    \                               Depth = (long)0L,\n                          \
    \      Level = new List<long>()\n                            };\n            \
    \            }),\n                    (Func<dynamic, bool>)((dynamic group) =>\
    \ {\n                        return group.Level.Count > 0L;\n                \
    \    })),\n                (Func<dynamic, long>)((dynamic group) => {\n      \
    \              return group.MaxDepth;\n                })));", "        // Create\
    \ a stack and set to a dummy value\n        Stack<int> paren_stack = new Stack<int>();\n\
    \        paren_stack.Push(-1);\n        // Create a counter\n        int count\
    \ = 0;\n        // Iterate through the paren_string\n        for (int i = 0; i\
    \ < paren_string.Length; i++) {\n            // Check for any open parentheses\n\
    \            if (paren_string[i] == '(') {\n                // Increment count\n\
    \                count++;\n                // Push the index to the stack\n  \
    \              paren_stack.Push(i);\n            }\n            // Check for any\
    \ closed parentheses\n            else if (paren_string[i] == ')') {\n       \
    \         // Pop the element from the stack\n                paren_stack.Pop();\n\
    \                // Check if the stack is empty\n                if (paren_stack.Count\
    \ == 0) {\n                    // Push the dummy value\n                    paren_stack.Push(-1);\n\
    \                }\n            }\n        }\n        // Create a list to store\
    \ the results\n        List<long> res = new List<long>();\n        // Iterate\
    \ through the stack\n        while (paren_stack.Count > 1) {\n            // Pop\
    \ the element from the stack\n            int temp = paren_stack.Pop();\n    \
    \        // Add the value to the list\n            res.Add(count - temp);\n  \
    \      }\n        // Return the results\n        return res;", "        long longest\
    \ = 0;\n        List<long> lengths = new List<long>();\n        long cur_longest\
    \ = 0;\n        bool match = false;\n        foreach (char cur in paren_string)\
    \ {\n            if (cur == '(') {\n                cur_longest++;\n         \
    \       if (cur_longest > longest) {\n                    longest = cur_longest;\n\
    \                }\n            } else if (cur == ')') {\n                if (cur_longest\
    \ > 0) {\n                    cur_longest--;\n                } else {\n     \
    \               match = false;\n                }\n            } else if (cur\
    \ == ' ') {\n                if (match) {\n                    lengths.Add(longest);\n\
    \                    longest = 0;\n                    cur_longest = 0;\n    \
    \            }\n                match = true;\n            }\n        }\n    \
    \    if (match) {\n            lengths.Add(longest);\n        }\n        return\
    \ lengths;", "        //int level = 0;\n        long maxLevel = 0;\n        long\
    \ currentLevel = 0;\n        bool firstItemFound = false;\n        List<long>\
    \ Levels = new List<long>();\n        if (paren_string.Length == 0)\n        {\n\
    \            Levels.Add(0);\n            return Levels;\n        }\n        else\
    \ if (paren_string.Length == 1)\n        {\n            if (paren_string[0] ==\
    \ '(')\n            {\n                Levels.Add(1);\n                return\
    \ Levels;\n            }\n            else\n            {\n                Levels.Add(0);\n\
    \                return Levels;\n            }\n        }\n        for (int i\
    \ = 0; i < paren_string.Length; i++)\n        {\n            if (paren_string[i]\
    \ == '(')\n            {\n                currentLevel += 1;\n               \
    \ firstItemFound = true;\n            }\n            else if (paren_string[i]\
    \ == ')')\n            {\n                currentLevel -= 1;\n            }\n\
    \            else if (paren_string[i] == ' ')\n            {\n               \
    \ if (currentLevel > maxLevel)\n                {\n                    maxLevel\
    \ = currentLevel;\n                }\n                currentLevel = 0;\n    \
    \            firstItemFound = false;\n            }\n            else\n      \
    \      {\n                continue;\n            }\n        }\n        if (firstItemFound\
    \ == true)\n        {\n            if (currentLevel > maxLevel)\n            {\n\
    \                maxLevel = currentLevel;\n            }\n            Levels.Add(maxLevel);\n\
    \        }\n        return Levels;", "        int string_length = paren_string.Length;\n\
    \        List<long> result = new List<long>();\n        int max_depth = 0;\n \
    \       int cur_depth = 0;\n        int i = 0;\n        while (i < string_length)\
    \ {\n            char c = paren_string[i];\n            if (c == '(') {\n    \
    \            cur_depth++;\n                if (cur_depth > max_depth) {\n    \
    \                max_depth = cur_depth;\n                }\n            } else\
    \ if (c == ')') {\n                cur_depth--;\n            } else if (c == '\
    \ ') {\n                result.Add(max_depth);\n                max_depth = 0;\n\
    \                cur_depth = 0;\n            }\n            i++;\n        }\n\
    \        result.Add(max_depth);\n        return result;", "        var groups\
    \ = paren_string.Split(' ');\n        var depth = 0L;\n        var max_depth =\
    \ 0L;\n        var depths = new List<long>();\n        var current_max = 0L;\n\
    \        foreach (var c in groups) {\n            foreach (var d in c) {\n   \
    \             if (d == '(') {\n                    depth++;\n                \
    \    if (depth > max_depth) {\n                        max_depth = depth;\n  \
    \                  }\n                } else if (d == ')') {\n               \
    \     depth--;\n                }\n            }\n            depths.Add(max_depth);\n\
    \            max_depth = 0L;\n            depth = 0L;\n        }\n        return\
    \ depths;", "        List<long> result = new List<long>();\n        for (int i\
    \ = 0; i < paren_string.Length; i++) {\n            char current = paren_string[i];\n\
    \            if (current == '(') {\n                long depth = 0L;\n       \
    \         while (paren_string[i] != ')') {\n                    if (paren_string[i]\
    \ == '(') {\n                        depth++;\n                    }\n       \
    \             i++;\n                }\n                result.Add(depth);\n  \
    \          }\n        }\n        return result;", '        throw new NotImplementedException();',
  "        var output = new List<long>();\n        var parens = paren_string.Split(\"\
    \ \");\n        foreach (var paren in parens) {\n            var depth = 0L;\n\
    \            var maxDepth = 0L;\n            foreach (var c in paren) {\n    \
    \            if (c == '(') {\n                    depth++;\n                 \
    \   if (depth > maxDepth) {\n                        maxDepth = depth;\n     \
    \               }\n                }\n                else if (c == ')') {\n \
    \                   depth--;\n                }\n            }\n            output.Add(maxDepth);\n\
    \        }\n        return output;", "        List<long> parens = new List<long>();\n\
    \        foreach (string substr in paren_string.Split(' ')) {\n            long\
    \ nesting = 0;\n            foreach (char c in substr) {\n                switch\
    \ (c) {\n                    case '(':\n                        nesting++;\n \
    \                       break;\n                    case ')':\n              \
    \          nesting--;\n                        break;\n                }\n   \
    \         }\n            parens.Add(nesting);\n        }\n        return parens;",
  "        // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        //\
    \ (new List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n     \
    \   var result = new List<long>();\n        var parent_levels = new List<long>();\n\
    \        var paren_groups = paren_string.Split(\" \");\n        for (var i = 0;\
    \ i < paren_groups.Length; i = i + 1) {\n            var curr_parent_level = 0L;\n\
    \            var parent_group = paren_groups[i];\n            var j = 0;\n   \
    \         while (j < parent_group.Length) {\n                var curr_paren =\
    \ parent_group[j];\n                if (curr_paren == '(') {\n               \
    \     curr_parent_level = curr_parent_level + 1L;\n                } else {\n\
    \                    curr_parent_level = curr_parent_level - 1L;\n           \
    \     }\n                j = j + 1;\n            }\n            result.Add(curr_parent_level);\n\
    \        }\n        return result;", "        List<long> group_deepest_nesting\
    \ = new List<long>();\n        // Parsing the given paren_string into a list of\
    \ strings, each of which is one group.\n        List<string> groups = paren_string.Split('\
    \ ').ToList();\n        int i;\n        int parens = 0;\n        long max_nesting\
    \ = 0;\n        for (i = 0; i < groups.Count; i++) {\n            parens = 0;\n\
    \            max_nesting = 0;\n            for (int j = 0; j < groups[i].Length;\
    \ j++) {\n                if (groups[i][j] == '(') {\n                    parens++;\n\
    \                    if (parens > max_nesting) {\n                        max_nesting\
    \ = parens;\n                    }\n                } else if (groups[i][j] ==\
    \ ')') {\n                    parens--;\n                }\n            }\n  \
    \          group_deepest_nesting.Add(max_nesting);\n        }\n        return\
    \ group_deepest_nesting;", "        List<long> results = new List<long>();\n \
    \       long score = 0L;\n        long max_score = 0L;\n        foreach (char\
    \ c in paren_string) {\n            if (c == '(') {\n                score +=\
    \ 1L;\n                max_score = Math.Max(max_score, score);\n            }\
    \ else if (c == ')') {\n                score -= 1L;\n            } else if (c\
    \ == ' ') {\n                results.Add(max_score);\n                max_score\
    \ = 0L;\n                score = 0L;\n            }\n        }\n        return\
    \ results;", "        var output = new List<long>();\n        var depth = 0L;\n\
    \        var maxDepth = 0L;\n        foreach (var c in paren_string) {\n     \
    \       if (c == '(') {\n                depth += 1L;\n                maxDepth\
    \ = Math.Max(maxDepth, depth);\n            } else if (c == ')') {\n         \
    \       depth -= 1L;\n            } else if (c == ' ') {\n                output.Add(maxDepth);\n\
    \                maxDepth = 0L;\n                depth = 0L;\n            }\n\
    \        }\n        output.Add(maxDepth);\n        return output;", "        List<long>\
    \ result = new List<long>();\n        for (long i = 0L; i < paren_string.Length;\
    \ i++) {\n            long max_depth = 0L;\n            for (long k = i; k < paren_string.Length;\
    \ k++) {\n                if (paren_string[(int)k] == '(') {\n               \
    \     max_depth += 1L;\n                }\n                else if (paren_string[(int)k]\
    \ == ')') {\n                    max_depth -= 1L;\n                }\n       \
    \         else if (paren_string[(int)k] == ' ') {\n                    i = k;\n\
    \                    break;\n                }\n            }\n            result.Add(max_depth);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var groups = paren_string.Split(\" \");\n        for (var i = 0; i <\
    \ groups.Length; i++) {\n            var group = groups[i];\n            var level\
    \ = 0L;\n            var max_level = 0L;\n            var start = 0L;\n      \
    \      var end = group.Length - 1;\n            var j = 0L;\n            while\
    \ (true) {\n                if (group[j] == '(') {\n                    level\
    \ += 1L;\n                    if (level > max_level) {\n                     \
    \   max_level = level;\n                    }\n                }\n           \
    \     else if (group[j] == ')') {\n                    level -= 1L;\n        \
    \        }\n                j += 1L;\n                if (j > end) {\n       \
    \             break;\n                }\n            }\n            result.Add(max_level);\n\
    \        }\n        return result;", "        var groups = paren_string.Split('\
    \ ');\n        var depth = new List<long>();\n        foreach (var group in groups)\
    \ {\n            depth.Add(ParseNestedParens(group, 0));\n        }\n        return\
    \ depth;", "        // Initialize the list which we will fill and return\n   \
    \     List<long> max_depth_list = new List<long>();\n        // For each substring\
    \ of the form \"(....)\" with no spaces, compute its maximum nesting depth\n \
    \       for (long substring_start = 0L; substring_start < len(paren_string);)\
    \ {\n            var paren_start = paren_string.IndexOf('(', (int)substring_start);\n\
    \            if (paren_start == -1) {\n                // No more substrings to\
    \ process; we are done!\n                break;\n            }\n            else\
    \ {\n                // Find the matching right paren to the left paren at index\
    \ \"paren_start\"\n                var paren_end = MatchingRightParen(paren_string,\
    \ paren_start);\n                // Compute the maximum depth of this string\n\
    \                max_depth_list.Add(NestedParenDepth(paren_string.Substring((int)paren_start,\
    \ (int)(paren_end - paren_start + 1))));\n                // Update the substring\
    \ start\n                substring_start = paren_end + 1L;\n            }\n  \
    \      }\n        return max_depth_list;", "        var tokens = paren_string.Split(new\
    \ char[] {' '});\n        var max_depth = new List<long>();\n        for (var\
    \ i = 0; i < tokens.Length; i++) {\n            var max_depth_in_paren = 0L;\n\
    \            var depth = 0L;\n            var paren = tokens[i];\n           \
    \ for (var j = 0; j < paren.Length; j++) {\n                if (paren[j] == '(')\
    \ {\n                    depth += 1L;\n                    if (depth > max_depth_in_paren)\
    \ {\n                        max_depth_in_paren = depth;\n                   \
    \ }\n                } else {\n                    depth -= 1L;\n            \
    \    }\n            }\n            max_depth.Add(max_depth_in_paren);\n      \
    \  }\n        return max_depth;", "        // Write your code here\n        throw\
    \ new NotImplementedException();", "        List<long> ans = new List<long>();\n\
    \        long count = 0L;\n        foreach (char c in paren_string) {\n      \
    \      if (c == '(') {\n                count += 1L;\n            }\n        \
    \    else if (c == ')') {\n                ans.Add(count);\n                count\
    \ -= 1L;\n            }\n        }\n        return ans;", "        List<long>\
    \ max_depths = new List<long>();\n        long current_max_depth = 0L;\n     \
    \   int current_start_index = 0;\n        bool reading_group = false;\n      \
    \  char current_char;\n        for (int i = 0; i < paren_string.Length; i++) {\n\
    \            current_char = paren_string[i];\n            if (current_char ==\
    \ '(') {\n                if (!reading_group) {\n                    reading_group\
    \ = true;\n                    current_start_index = i;\n                }\n \
    \               current_max_depth += 1L;\n            } else if (current_char\
    \ == ')') {\n                if (reading_group) {\n                    current_max_depth\
    \ -= 1L;\n                    if (current_max_depth == 0L) {\n               \
    \         reading_group = false;\n                        max_depths.Add(current_max_depth);\n\
    \                    }\n                }\n            } else if (current_char\
    \ == ' ') {\n                if (reading_group) {\n                    reading_group\
    \ = false;\n                    max_depths.Add(current_max_depth);\n         \
    \           current_max_depth = 0L;\n                }\n            }\n      \
    \  }\n        return max_depths;", "        var result = new List<long>();\n \
    \       // Implement using \"Stack\" and \"for-loop\".\n        var stack = new\
    \ Stack<Tuple<char, int>>();\n        var max_depth = 0;\n        foreach (var\
    \ ch in paren_string) {\n            if (ch == '(') {\n                stack.Push(Tuple.Create('(',\
    \ max_depth + 1));\n                max_depth += 1;\n            } else if (ch\
    \ == ')') {\n                stack.Pop();\n                max_depth -= 1;\n \
    \           } else if (ch == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0;\n            }\n        }\n        return result;",
  "        var charArray = paren_string.ToCharArray();\n        var groups = new List<List<char>>();\n\
    \        var group = new List<char>();\n        int flag = 0;\n        foreach\
    \ (var item in charArray) {\n            if (item == '(') {\n                flag\
    \ = 1;\n            }\n            if (flag == 1) {\n                group.Add(item);\n\
    \            }\n            if (item == ')') {\n                groups.Add(group);\n\
    \                group = new List<char>();\n                flag = 0;\n      \
    \      }\n        }\n        List<long> depth = new List<long>();\n        foreach\
    \ (var item in groups) {\n            depth.Add(ParseNestedParensHelper(item));\n\
    \        }\n        return depth;", "        // Construct the output variable.\n\
    \        var ret_val = new List<long>();\n        // Construct the stack of parens.\n\
    \        var paren_stack = new Stack<char>();\n        // Stores the current nesting\
    \ level.\n        var cur_nesting_level = 0L;\n        // Stores the maximum nesting\
    \ level.\n        var max_nesting_level = 0L;\n        // Add a space to the end\
    \ of the string to ensure that the last group of parentheses gets counted.\n \
    \       paren_string += \" \";\n        // Loop through the paren string and parse.\n\
    \        for (long idx = 0L; idx < (long)paren_string.Length; idx++) {\n     \
    \       if ((paren_string[(int)idx] == '(')) {\n                paren_stack.Push(paren_string[(int)idx]);\n\
    \                cur_nesting_level += 1L;\n                if ((cur_nesting_level\
    \ > max_nesting_level)) {\n                    max_nesting_level = cur_nesting_level;\n\
    \                }\n            } else if ((paren_string[(int)idx] == ')')) {\n\
    \                if ((paren_stack.Count == 0L)) {\n                    throw new\
    \ Exception(\"Too many closing parens in nested parens string.\");\n         \
    \       }\n                paren_stack.Pop();\n                cur_nesting_level\
    \ -= 1L;\n            } else if ((paren_string[(int)idx] == ' ')) {\n        \
    \        ret_val.Add(max_nesting_level);\n                cur_nesting_level =\
    \ 0L;\n                max_nesting_level = 0L;\n            }\n        }\n   \
    \     // Return the output variable.\n        return ret_val;", "        var stack\
    \ = new Stack<long>();\n        var result = new List<long>();\n        var current_depth\
    \ = (long)0L;\n        var i = (long)0L;\n        for (i = (long)0L; i < len(paren_string);\
    \ i++)\n        {\n            switch (paren_string[i])\n            {\n     \
    \           case '(': \n                    current_depth++;\n               \
    \     stack.Push(current_depth);\n                    break;\n               \
    \ case ')': \n                    stack.Pop();\n                    break;\n \
    \               case ' ': \n                    result.Add(stack.Peek());\n  \
    \                  break;\n            }\n\n        }\n\n        result.Add(stack.Peek());\n\
    \        return result;\n", "        var depth_stack = new Stack<long>();\n  \
    \      long cur_depth = 0L;\n        var result = new List<long>();\n        foreach\
    \ (var c in paren_string) {\n            if (c == '(') {\n                cur_depth\
    \ += 1L;\n                depth_stack.Push(cur_depth);\n            }\n      \
    \      else if (c == ')') {\n                result.Add(depth_stack.Pop());\n\
    \                cur_depth -= 1L;\n            }\n        }\n        return result;",
  "        List<long> depth_list = new List<long>();\n        foreach (string paren_group\
    \ in paren_string.Split(' ')) {\n            depth_list.Add(ComputeDepth(paren_group));\n\
    \        }\n        return depth_list;", "        paren_string = paren_string.Trim();\n\
    \        if (paren_string == string.Empty) {\n            return new List<long>();\n\
    \        }\n        var a = paren_string.Split(' ');\n        var b = a.Select(x\
    \ => new Stack<char>()).ToList();\n        var c = a.Select(x => (long)0L).ToList();\n\
    \        foreach (var i in Enumerable.Range(0, a.Count())) {\n            foreach\
    \ (var j in Enumerable.Range(0, a[i].Length)) {\n                if (a[i][j] ==\
    \ '(') {\n                    b[i].Push('(');\n                }\n           \
    \     else if (a[i][j] == ')') {\n                    if (b[i].Count() == 0) {\n\
    \                        throw new Exception(string.Format(\"Mismatched parenthesis\
    \ at offset {0} in group {1}.\", (long)j, (long)i));\n                    }\n\
    \                    b[i].Pop();\n                }\n                else {\n\
    \                    throw new Exception(string.Format(\"Invalid character at\
    \ offset {0} in group {1}.\", (long)j, (long)i));\n                }\n       \
    \         c[i] = Math.Max(c[i], b[i].Count());\n            }\n            if\
    \ (b[i].Count() != 0) {\n                throw new Exception(string.Format(\"\
    Mismatched parenthesis in group {0}.\", (long)i));\n            }\n        }\n\
    \        return c;", "        List<long> result = new List<long>();\n        List<char>\
    \ cur_chars = new List<char>();\n        long max_depth = 0L;\n        foreach\
    \ (char c in paren_string) {\n            if (c == ' ') {\n                if\
    \ (max_depth > 0L) {\n                    result.Add(max_depth);\n           \
    \     } else {\n                    result.Add(1L);\n                }\n     \
    \           max_depth = 0L;\n                cur_chars = new List<char>();\n \
    \           } else {\n                cur_chars.Add(c);\n                max_depth\
    \ = Math.Max(max_depth, ProcessChar(cur_chars));\n            }\n        }\n \
    \       if (max_depth > 0L) {\n            result.Add(max_depth);\n        } else\
    \ {\n            result.Add(1L);\n        }\n        return result;", "      \
    \  // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ depth = 0L;\n        var max_depth = 0L;\n        var res = new List<long>();\n\
    \        foreach (var ch in paren_string) {\n            switch (ch) {\n     \
    \           case '(': {\n                    depth++;\n                    if\
    \ (depth > max_depth) {\n                        max_depth = depth;\n        \
    \            }\n                    break;\n                }\n              \
    \  case ')': {\n                    depth--;\n                    break;\n   \
    \             }\n                case ' ': {\n                    res.Add(max_depth);\n\
    \                    max_depth = 0L;\n                    break;\n           \
    \     }\n            }\n        }\n        res.Add(max_depth);\n        return\
    \ res;", "        List<long> result = new List<long>();\n        int startIndex\
    \ = 0;\n        // Write code here to calculate the result.\n        return result;",
  "        var result = new List<long>();\n        // >>> Add your code here.\n  \
    \      var inputs = paren_string.Split(' ');\n        foreach (var input in inputs)\
    \ {\n            var left = 0;\n            var right = 0;\n            var currentLevel\
    \ = 0;\n            var maxLevel = 0;\n            foreach (var character in input)\
    \ {\n                if (character == '(') {\n                    left++;\n  \
    \                  currentLevel++;\n                    if (currentLevel > maxLevel)\
    \ {\n                        maxLevel = currentLevel;\n                    }\n\
    \                } else if (character == ')') {\n                    right++;\n\
    \                    currentLevel--;\n                }\n            }\n     \
    \       if (left != right) {\n                result.Add(-1);\n            } else\
    \ {\n                result.Add(maxLevel);\n            }\n        }\n       \
    \ return result;", "        var ans = new List<long>();\n        var count = 0L;\n\
    \        var groups = paren_string.Split(new char[]{' '});\n        foreach (var\
    \ group in groups) {\n            foreach (var c in group) {\n               \
    \ if (c == '(') {\n                    count++;\n                } else if (c\
    \ == ')') {\n                    count--;\n                }\n            }\n\
    \            ans.Add(count);\n        }\n        return ans;", "        var paren_list\
    \ = new List<long>();\n        for (long i = 0; i < paren_string.Length; i++)\
    \ {\n            var paren_counter = 0L;\n            while (paren_string[(int)i]\
    \ != ' ') {\n                if (paren_string[(int)i] == '(') {\n            \
    \        paren_counter += 1L;\n                }\n                else if (paren_string[(int)i]\
    \ == ')') {\n                    paren_counter -= 1L;\n                }\n   \
    \             i += 1L;\n            }\n            paren_list.Add(paren_counter);\n\
    \        }\n        return paren_list;", "        var groups = paren_string.Split(new\
    \ char[]{' '});\n        List<long> ans = new List<long>();\n        foreach (var\
    \ group in groups) {\n            long level = 0;\n            long max_level\
    \ = 0;\n            foreach (var c in group) {\n                if (c == '(')\
    \ {\n                    level++;\n                    max_level = Math.Max(max_level,\
    \ level);\n                } else if (c == ')') {\n                    level--;\n\
    \                }\n            }\n            ans.Add(max_level);\n        }\n\
    \        return ans;", "        List<long> nest_levels = new List<long>();\n \
    \       long nest_level = 0L;\n        foreach (char @char in paren_string) {\n\
    \            if (@char == '(') {\n                nest_level += 1L;\n        \
    \    } else if (@char == ')') {\n                nest_level -= 1L;\n         \
    \   } else if (@char == ' ') {\n                nest_levels.Add(nest_level);\n\
    \                nest_level = 0L;\n            }\n        }\n        return nest_levels;",
  "        // your code goes here\n        List<long> numbers = new List<long>();\n\
    \        foreach (var item in paren_string.Split(' '))\n        {\n          \
    \  numbers.Add(DeepestLevelOfNesting(item));\n        }\n        return numbers;",
  "        // Write your code here\n        List<long> ret_list = new List<long>();\n\
    \        string[] s = paren_string.Split(new char[] { ' ' });\n        for (int\
    \ i = 0; i < s.Length; i++) {\n            ret_list.Add(ParseNestedParens(s[i]));\n\
    \        }\n        return ret_list;", "        List<long> output = new List<long>();\n\
    \        List<long> curr = new List<long>();\n        int deepest = 0;\n     \
    \   int currDeepest = 0;\n        char[] input = paren_string.ToCharArray();\n\
    \        foreach (char c in input) {\n            if (c == '(') {\n          \
    \      currDeepest++;\n                if (currDeepest > deepest) {\n        \
    \            deepest = currDeepest;\n                }\n            } else if\
    \ (c == ')') {\n                currDeepest--;\n            } else if (c == '\
    \ ') {\n                curr.Add((long)deepest);\n                deepest = 0;\n\
    \                currDeepest = 0;\n            }\n        }\n        output =\
    \ curr;\n        return output;", "        var ret = new List<long>();\n     \
    \   // >>> ParseNestedParens((\"(()()) ((())) () ((())()())\"))\n        // (new\
    \ List<long>(new long[]{(long)2L, (long)3L, (long)1L, (long)3L}))\n        var\
    \ paren = paren_string.Split(\" \".ToCharArray());\n        foreach (var p in\
    \ paren) {\n            var stk = new Stack<int>();\n            var max = 0;\n\
    \            foreach (var c in p) {\n                if (c == '(') {\n       \
    \             stk.Push(1);\n                } else if (c == ')') {\n         \
    \           stk.Pop();\n                }\n                max = Math.Max(max,\
    \ stk.Count);\n            }\n            ret.Add(max);\n        }\n        return\
    \ ret;", "        // TODO: Implement this function\n        long depth = 0;\n\
    \        List<long> result = new List<long>();\n        long max = 0;\n      \
    \  foreach (char c in paren_string)\n        {\n            if (c == '(')\n  \
    \          {\n                depth++;\n                if (depth > max)\n   \
    \             {\n                    max = depth;\n                }\n       \
    \     }\n            else if (c == ')')\n            {\n                depth--;\n\
    \            }\n            else if (c == ' ')\n            {\n              \
    \  result.Add(max);\n                max = 0;\n            }\n        }\n    \
    \    result.Add(max);\n        return result;", "        var result = new List<long>();\n\
    \        foreach (var group in paren_string.Split(' ')) {\n            long num_open\
    \ = 0;\n            long max_nesting = 0;\n            foreach (var c in group)\
    \ {\n                if (c == '(') {\n                    num_open += 1;\n   \
    \                 max_nesting = Math.Max(max_nesting, num_open);\n           \
    \     } else if (c == ')') {\n                    num_open -= 1;\n           \
    \     }\n            }\n            result.Add(max_nesting);\n        }\n    \
    \    return result;", "        List<long> ans = new List<long>();\n        var\
    \ a = paren_string.Split(' ');\n        foreach (var s in a) {\n            var\
    \ l = 0;\n            var r = 0;\n            var depth = 0;\n            var\
    \ max_depth = 0;\n            for (var i = 0; i < s.Length; i++) {\n         \
    \       if (s[i] == '(') {\n                    l++;\n                    if (l\
    \ == r + 1)\n                        depth++;\n                    max_depth =\
    \ Math.Max(max_depth, depth);\n                }\n                else {\n   \
    \                 r++;\n                    if (l == r)\n                    \
    \    depth--;\n                }\n            }\n            ans.Add(max_depth);\n\
    \        }\n        return ans;", "        List<long> result = new List<long>();\n\
    \        // >>> Write your solution here\n        return result;", "        return\
    \ paren_string.Split(\" \").Select(group => {\n            long max_level = 0L;\n\
    \            long level = 0L;\n            foreach (char c in group) {\n     \
    \           if (c == '(') {\n                    level += 1L;\n              \
    \      max_level = Math.Max(max_level, level);\n                } else {\n   \
    \                 level -= 1L;\n                }\n            }\n           \
    \ return max_level;\n        }).ToList();", "        // >>> ParseNestedParens((\"\
    (()()) ((())) () ((())()())\"))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)3L, (long)1L, (long)3L}))\n        long max_count = (long)0L;\n      \
    \  List<long> max_counts = new List<long>();\n        long cur_count = (long)0L;\n\
    \        bool seen_paren = false;\n        bool has_paren = false;\n        char\
    \ paren = ')';\n        foreach (var @char in paren_string)\n        {\n     \
    \       if ((@char == ' '))\n            {\n                if (seen_paren)\n\
    \                {\n                    max_counts.Add(max_count);\n         \
    \           cur_count = (long)0L;\n                    max_count = (long)0L;\n\
    \                    seen_paren = false;\n                    has_paren = false;\n\
    \                }\n\n            }\n            else if ((@char == '('))\n  \
    \          {\n                if (seen_paren)\n                {\n           \
    \         cur_count = (long)1L;\n                }\n                else\n   \
    \             {\n                    cur_count = (long)1L;\n                 \
    \   seen_paren = true;\n                }\n\n                if ((max_count <\
    \ cur_count))\n                {\n                    max_count = cur_count;\n\
    \                }\n\n                has_paren = true;\n                paren\
    \ = ')';\n\n            }\n            else if ((@char == ')'))\n            {\n\
    \                if (has_paren)\n                {\n                    if ((paren\
    \ == ')'))\n                    {\n                        cur_count = (long)1L;\n\
    \                    }\n                    else\n                    {\n    \
    \                    cur_count = (long)1L;\n                    }\n\n        \
    \            if ((max_count < cur_count))\n                    {\n           \
    \             max_count = cur_count;\n                    }\n\n              \
    \      has_paren = true;\n                    paren = '(';\n\n               \
    \ }\n\n            }\n\n        }\n        if (seen_paren)\n        {\n      \
    \      max_counts.Add(max_count);\n        }\n\n        return max_counts;\n\n",
  "        // REPLACE WITH YOUR SOLUTION\n        return null;", "        return paren_string.Split('\
    \ ').Select(g => 0L).ToList();", "        var result = new List<long>();\n   \
    \     foreach (var group in paren_string.Split(' ')) {\n            var group_result\
    \ = new List<long>();\n            var num_open = 0;\n            var num_close\
    \ = 0;\n            var paren_max = 0;\n            foreach (var paren in group)\
    \ {\n                switch (paren) {\n                    case '(':\n       \
    \                 num_open++;\n                        paren_max = Math.Max(paren_max,\
    \ num_open);\n                        break;\n                    case ')':\n\
    \                        num_close++;\n                        paren_max = Math.Max(paren_max,\
    \ num_close);\n                        break;\n                }\n           \
    \ }\n            if (num_open != num_close) {\n                throw new Exception(\"\
    Mismatched parenthesis\");\n            }\n            result.Add(paren_max);\n\
    \        }\n        return result;", "        List<long> ret = new List<long>();\n\
    \        string[] grps = paren_string.Split(' ');\n        foreach (string grp\
    \ in grps) {\n            ret.Add(ParseNestedParensHelper(grp));\n        }\n\
    \        return ret;", "        //Fill in your solution here.\n        char[]\
    \ charArr = paren_string.ToCharArray();\n        List<long> maxDepth = new List<long>();\n\
    \        long d = 0;\n        long max = 0;\n        //long i = 0;\n        foreach\
    \ (char x in charArr)\n        {\n            if (x == '(')\n            {\n \
    \               d++;\n                if (d > max)\n                {\n      \
    \              max = d;\n                }\n            }\n            else if\
    \ (x == ')')\n            {\n                d--;\n            }\n           \
    \ else if (x == ' ')\n            {\n                maxDepth.Add(max);\n    \
    \            max = 0;\n                d = 0;\n            }\n        }\n    \
    \    maxDepth.Add(max);\n        return maxDepth;", "        var result = new\
    \ List<long>();\n        var count = 0L;\n        var max = 0L;\n        for (var\
    \ i = 0L; i < paren_string.Length; i++) {\n            if (paren_string[(int)i]\
    \ == '(') {\n                count++;\n                if (count > max) {\n  \
    \                  max = count;\n                }\n            }\n          \
    \  else if (paren_string[(int)i] == ')') {\n                count--;\n       \
    \     }\n            else if (paren_string[(int)i] == ' ') {\n               \
    \ result.Add(max);\n                max = 0L;\n                count = 0L;\n \
    \           }\n        }\n        result.Add(max);\n        return result;", " \
    \       int n = paren_string.Length;\n        List<long> parenthesis_levels =\
    \ new List<long>();\n        long level = (long)0L;\n        for (long i = (long)0L;\
    \ i < n; i++) {\n            if (paren_string[(int)i] == '(') {\n            \
    \    level++;\n            }\n            else if (paren_string[(int)i] == ')')\
    \ {\n                level--;\n            }\n            else if (paren_string[(int)i]\
    \ == ' ') {\n                parenthesis_levels.Add(level);\n            }\n \
    \       }\n        return parenthesis_levels;", "        var stk = new Stack<long>();\n\
    \        var res = new List<long>();\n        var currParenCount = 0L;\n     \
    \   var currMaxParenCount = 0L;\n        for (var (__i, __x) = (0L, paren_string);\
    \ __i < len(__x); __i++) {\n            i = __i;\n            x = __x[__i];\n\
    \            if (x == '(') {\n                currParenCount++;\n            \
    \    currMaxParenCount = Math.Max(currMaxParenCount, currParenCount);\n      \
    \      }\n\n            if (x == ')') {\n                currParenCount--;\n \
    \           }\n\n            if (x == ' ') {\n                res.append(currMaxParenCount);\n\
    \                currMaxParenCount = 0L;\n                currParenCount = 0L;\n\
    \            }\n\n        }\n        res.append(currMaxParenCount);\n\n      \
    \  return res;\n", "        // List<long> to be returned\n        var result =\
    \ new List<long>();\n        // Current deepest level of nesting of parentheses\n\
    \        long nest_level = 0;\n        // Current deepest level of nesting of\
    \ parentheses for the current group of parentheses\n        long local_nest_level\
    \ = 0;\n        foreach (var paren in paren_string) {\n            if (paren ==\
    \ '(') {\n                // Start of a new group of parentheses\n           \
    \     if (local_nest_level == 0) {\n                    local_nest_level++;\n\
    \                }\n                else {\n                    local_nest_level++;\n\
    \                    if (local_nest_level > nest_level) {\n                  \
    \      nest_level = local_nest_level;\n                    }\n               \
    \ }\n            }\n            else if (paren == ')') {\n                // End\
    \ of a group of parentheses\n                if (local_nest_level == 1) {\n  \
    \                  result.Add(nest_level);\n                    nest_level = 0;\n\
    \                    local_nest_level = 0;\n                }\n              \
    \  else {\n                    local_nest_level--;\n                }\n      \
    \      }\n        }\n        return result;", "        // >>> ord('(')\n     \
    \   // (long)40L\n        // >>> ord(')')\n        // (long)41L\n        // >>>\
    \ chr(40)\n        // '('\n        // >>> chr(41)\n        // ')'\n        //\
    \ >>> dec_str = \"10\"\n        // \"10\"\n        // >>> int(dec_str)\n     \
    \   // (long)10L\n        // >>> dec_str = \"10\"\n        // \"10\"\n       \
    \ // >>> int(dec_str, 2)\n        // (long)2L\n        // >>> dec_str = \"10\"\
    \n        // \"10\"\n        // >>> int(dec_str, 10)\n        // (long)10L\n \
    \       // >>> dec_str = \"10\"\n        // \"10\"\n        // >>> int(dec_str,\
    \ 16)\n        // (long)16L\n        // >>> bin_str = \"1111\"\n        // \"\
    1111\"\n        // >>> int(bin_str, 2)\n        // (long)15L\n        // >>> bin_str\
    \ = \"1111\"\n        // \"1111\"\n        // >>> int(bin_str, 10)\n        //\
    \ (long)1111L\n        // >>> bin_str = \"1111\"\n        // \"1111\"\n      \
    \  // >>> int(bin_str, 16)\n        // (long)3855L\n        // >>> hex_str = \"\
    ff\"\n        // \"ff\"\n        // >>> int(hex_str, 2)\n        // (long)255L\n\
    \        // >>> hex_str = \"ff\"\n        // \"ff\"\n        // >>> int(hex_str,\
    \ 10)\n        // (long)255L\n        // >>> hex_str = \"ff\"\n        // \"ff\"\
    \n        // >>> int(hex_str, 16)\n        // (long)255L\n        // >>> even_str\
    \ = \"even\"\n        // \"even\"\n        // >>> ord(even_str[0])\n        //\
    \ (long)101L\n        // >>> ord(even_str[1])\n        // (long)118L\n       \
    \ // >>> ord(even_str[2])\n        // (long)101L\n        // >>> ord(", "    \
    \    long n = paren_string.Length;\n        long i = (long)0L;\n        List<long>\
    \ result = new List<long>();\n        while (i < n)\n        {\n            long\
    \ x = (long)0L;\n            i = i + (long)1L;\n            while (paren_string[(int)(i)]\
    \ != ' ')\n            {\n                if (paren_string[(int)(i)] == '(')\n\
    \                {\n                    x = x + (long)1L;\n                }\n\
    \                else\n                {\n                    x = x - (long)1L;\n\
    \                }\n                if (x < (long)0L)\n                {\n   \
    \                 break;\n                }\n                i = i + (long)1L;\n\
    \            }\n            if (x >= (long)0L)\n            {\n              \
    \  result.Add(x);\n            }\n            else\n            {\n          \
    \      result.Add((long)0L);\n            }\n        }\n        return result;",
  "        // >>> paren_string = \"(()()) ((())) () ((())()())\"\n        var paren_groups\
    \ = paren_string.Split(\" \");\n        // >>> paren_groups = (\"(()())\", \"\
    (()))\", \"()\", \"((())()())\")\n        var result = new List<long>();\n   \
    \     foreach (var group in paren_groups) {\n            // >>> group = \"(()())\"\
    \n            var stack = new Stack<char>();\n            var max_depth = 0L;\n\
    \            foreach (var c in group) {\n                // >>> c = \"(\"\n  \
    \              if (c == '(') {\n                    stack.Push(c);\n         \
    \           max_depth = stack.Count > max_depth ? stack.Count : max_depth;\n \
    \               } else if (c == ')') {\n                    if (stack.Count >\
    \ 0) {\n                        stack.Pop();\n                    }\n        \
    \        }\n            }\n            result.Add(max_depth);\n        }\n   \
    \     return result;", "        long __retval = 0;\n        try {\n          \
    \  if (paren_string.Length < 2) {\n                __retval = 0;\n           \
    \ } else {\n                List<long> groups = new List<long>();\n          \
    \      int group_start = 0;\n                int group_end = 0;\n            \
    \    for (int i = 0; i < paren_string.Length; i++) {\n                    if (paren_string[i]\
    \ == '(') {\n                        if (group_start == 0) {\n               \
    \             group_start = i;\n                        }\n                  \
    \      int depth = 0;\n                        int max_depth = 0;\n          \
    \              while (paren_string[i] != ')') {\n                            if\
    \ (paren_string[i] == '(') {\n                                depth++;\n     \
    \                       }\n                            if (depth > max_depth)\
    \ {\n                                max_depth = depth;\n                    \
    \        }\n                            i++;\n                        }\n    \
    \                    group_end = i;\n                        groups.Add(max_depth);\n\
    \                        group_start = 0;\n                        group_end =\
    \ 0;\n                    }\n                }\n                if (group_start\
    \ > 0) {\n                    group_end = paren_string.Length - 1;\n         \
    \           int depth = 0;\n                    int max_depth = 0;\n         \
    \           for (int i = group_start; i <= group_end; i++) {\n               \
    \         if (paren_string[i] == '(') {\n                            depth++;\n\
    \                        }\n                        if (depth > max_depth) {\n\
    \                            max_depth = depth;\n                        }\n \
    \                   }\n                    groups.Add(max_depth);\n          \
    \      }\n                __retval = groups;\n            }\n        } catch (Exception\
    \ e) {\n            Debug.WriteLine(e.Message);\n        }\n        return __retval;",
  '        return null;', '        return Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEnumerable<long>)Enumerable.ToList(new
    List<long>(((IEnumerable<long>)Enumerable.ToList(new List<long>(((IEn', '        throw
    new NotImplementedException();', "        // \n        // YOUR CODE GOES HERE\n\
    \        // \n        char[] all = paren_string.ToCharArray();\n        List<long>\
    \ rst = new List<long>();\n        long maxlevel = 0;\n        long level = 0;\n\
    \        for (int i = 0; i < all.Length; i++) {\n            if (all[i] == '(')\
    \ {\n                level++;\n                if (level > maxlevel) {\n     \
    \               maxlevel = level;\n                }\n            } else if (all[i]\
    \ == ')') {\n                level--;\n            } else if (all[i] == ' ') {\n\
    \                rst.Add(maxlevel);\n                maxlevel = 0;\n         \
    \       level = 0;\n            }\n        }\n        return rst;", '        throw
    new NotImplementedException();', "        // Auto-generated code below aims at\
    \ helping you parse\n        // the standard input according to the problem statement.\n\
    \        List<long> res = new List<long>();\n        foreach (var group in paren_string.Split(new\
    \ char[] { ' ' })) {\n            res.Add(ParseNestedParens(group));\n       \
    \ }\n        return res;", "        List<long> result = new List<long>();\n  \
    \      // TODO(qwang): Implement this function\n        return result;", "   \
    \     List<long> depths = new List<long>();\n        long depth = 0L;\n      \
    \  long start = 0L;\n        long index = 0L;\n        while (true) {\n      \
    \      index = index;\n            if (index >= len(paren_string)) {\n       \
    \         break;\n            }\n            {\n                var i__prev1 =\
    \ i;\n\n                var i = paren_string[index];\n\n                if (i\
    \ == '(') {\n                    if (depth == 0L) {\n                        start\
    \ = index;\n                    }\n                    depth++;\n\n          \
    \      } else if (i == ')') {\n                    depth--;\n                \
    \    if (depth == 0L) {\n                        depths.Add(index - start + 1L);\n\
    \                    }\n\n                } else if (i == ' ') {\n           \
    \         if (depth == 0L) {\n                        depths.Add(0L);\n      \
    \              }\n\n                }\n\n                i = i__prev1;\n     \
    \       }\n            index++;\n        }\n        if (depth > 0L) {\n      \
    \      return null;\n        }\n        return depths;", "        var groups =\
    \ paren_string.Split(new char[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\
    \        return groups.Select(group => ParseNestedParensHelper(group)).ToList();",
  "        var gg = paren_string.Split(' ');\n        var rr = new List<long>();\n\
    \        foreach (var group in gg) {\n            var r = 0L;\n            var\
    \ maxr = 0L;\n            foreach (var c in group) {\n                if (c ==\
    \ '(') {\n                    r += 1L;\n                }\n                else\
    \ if (c == ')') {\n                    r -= 1L;\n                }\n         \
    \       else {\n                    throw new Exception(\"Unexpected character\"\
    );\n                }\n                if (r > maxr) {\n                    maxr\
    \ = r;\n                }\n            }\n            rr.Add(maxr);\n        }\n\
    \        return rr;", "        return paren_string.Split(new string[] {\" \"},\
    \ StringSplitOptions.RemoveEmptyEntries).Select(s => {\n            var stack\
    \ = new Stack<char>();\n            int max = 0;\n            foreach (var c in\
    \ s) {\n                if (c == '(') {\n                    stack.Push(c);\n\
    \                    max = Math.Max(max, stack.Count);\n                } else\
    \ if (c == ')') {\n                    stack.Pop();\n                }\n     \
    \       }\n            return max;\n        }).ToList();", "        // Populate\
    \ the following list with the maximum depths of each group.\n        List<long>\
    \ nesting_depth = new List<long>();\n        // Start your code here\n       \
    \ return nesting_depth;", "        var ret = new List<long>();\n        var cnt\
    \ = 0L;\n        var max = 0L;\n        var sum = 0L;\n        for (var i = 0L;\
    \ i < paren_string.Length; i++) {\n            if (paren_string[(int)i] == '(')\
    \ {\n                cnt++;\n                max = cnt > max ? cnt : max;\n  \
    \          } else if (paren_string[(int)i] == ')') {\n                cnt--;\n\
    \            } else if (paren_string[(int)i] == ' ') {\n                sum +=\
    \ max;\n                ret.Add(max);\n                max = 0L;\n           \
    \     cnt = 0L;\n            }\n        }\n        sum += max;\n        ret.Add(max);\n\
    \        if (cnt != 0L) {\n            throw new Exception(new string(new char[]{(char)('0'\
    \ + sum)}));\n        }\n        return ret;", "        List<long> deepest_levels\
    \ = new List<long>();\n        Stack<int> open_paren_levels = new Stack<int>();\n\
    \        int open_paren_count = 0;\n        int current_deepest_level = 0;\n \
    \       for (long i__prev1 = 0; i__prev1 < (long)paren_string.Length; i__prev1++)\
    \ {\n            long i = i__prev1;\n            if (paren_string[(int)i] == '(')\
    \ {\n                open_paren_count++;\n                open_paren_levels.Push(open_paren_count);\n\
    \                current_deepest_level = Math.Max(current_deepest_level, open_paren_count);\n\
    \            }\n            else if (paren_string[(int)i] == ')') {\n        \
    \        open_paren_levels.Pop();\n                if (open_paren_levels.Count\
    \ == 0) {\n                    deepest_levels.Add(current_deepest_level);\n  \
    \                  current_deepest_level = 0;\n                }\n           \
    \ }\n        }\n        return deepest_levels;", "        var result = new List<long>();\n\
    \        //var s = new Stack<long>();\n        long depth = 0;\n        long max_depth\
    \ = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n            if\
    \ (paren_string[i] == '(') {\n                depth++;\n                if (depth\
    \ > max_depth) {\n                    max_depth = depth;\n                }\n\
    \            } else if (paren_string[i] == ')') {\n                depth--;\n\
    \            } else if (paren_string[i] == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0;\n                depth = 0;\n            }\n \
    \       }\n        result.Add(max_depth);\n        return result;", "        //\
    \ TODO: Implement this function.\n        var result = new List<long>();\n   \
    \     var arr = paren_string.Split(' ');\n        for (var i = 0; i < arr.Length;\
    \ i++) {\n            var count = 0;\n            var max = 0;\n            for\
    \ (var j = 0; j < arr[i].Length; j++) {\n                if (arr[i][j] == '(')\
    \ {\n                    count++;\n                    if (count > max) {\n  \
    \                      max = count;\n                    }\n                }\
    \ else if (arr[i][j] == ')') {\n                    count--;\n               \
    \ }\n            }\n            result.Add(max);\n        }\n        return result;",
  "        List<long> solution = new List<long>();\n        // >>> len(paren_string)\n\
    \        // (long)34L\n        // >>> len(paren_string) * 3\n        // (long)102L\n\
    \        long[] temp = new long[len(paren_string) * 3];\n        // >>> len(temp)\n\
    \        // (long)102L\n        // >>> temp[0]\n        // (long)0L\n        //\
    \ >>> temp[1]\n        // (long)0L\n        // >>> temp[2]\n        // (long)0L\n\
    \        // >>> temp[3]\n        // (long)0L\n        temp[0] = (long)1L;\n  \
    \      // >>> temp[0]\n        // (long)1L\n        // >>> temp[1]\n        //\
    \ (long)0L\n        // >>> temp[2]\n        // (long)0L\n        // >>> temp[3]\n\
    \        // (long)0L\n        // >>> temp[3]\n        // (long)0L\n        //\
    \ >>> temp[4]\n        // (long)0L\n        // >>> temp[5]\n        // (long)0L\n\
    \        // >>> temp[6]\n        // (long)0L\n        temp[1] = (long)0L;\n  \
    \      // >>> temp[0]\n        // (long)1L\n        // >>> temp[1]\n        //\
    \ (long)0L\n        // >>> temp[2]\n        // (long)0L\n        // >>> temp[3]\n\
    \        // (long)0L\n        // >>> temp[3]\n        // (long)0L\n        //\
    \ >>> temp[4]\n        // (long)0L\n        // >>> temp[5]\n        // (long)0L\n\
    \        // >>> temp[6]\n        // (long)0L\n        long ptr = (long)0L;\n \
    \       // >>> ptr\n        // (long)0L\n        // >>> temp[0]\n        // (long)1L\n\
    \        // >>> temp[1]\n        // (long)0L\n        // >>> temp[2]\n       \
    \ // (long)0L\n        // >>> temp[3]", "        var levels = new List<long>();\n\
    \        foreach (var paren_group in paren_string.Split(new char[]{' '})) {\n\
    \            var level = 0L;\n            var max_level = 0L;\n            foreach\
    \ (var paren in paren_group) {\n                if (paren == '(') {\n        \
    \            level++;\n                } else if (paren == ')') {\n          \
    \          level--;\n                }\n                max_level = Math.Max(max_level,\
    \ level);\n            }\n            levels.Add(max_level);\n        }\n    \
    \    return levels;", '        return new List<long>();', "        long max_level\
    \ = 0L;\n        long cur_level = 0L;\n        long idx = 0L;\n        long __temp\
    \ = 0L;\n        List<long> output = new List<long>();\n        if (((paren_string\
    \ == null) || (paren_string == \"\"))) {\n            return output;\n       \
    \ }\n        foreach (char c in paren_string) {\n            if ((c == '(')) {\n\
    \                cur_level++;\n                if ((cur_level > max_level)) {\n\
    \                    max_level = cur_level;\n                }\n            }\n\
    \            else if ((c == ')')) {\n                cur_level--;\n          \
    \  }\n            else if ((c == ' ')) {\n                __temp = max_level;\n\
    \                output.Add(__temp);\n                max_level = 0L;\n      \
    \          cur_level = 0L;\n            }\n            else {\n              \
    \  throw new Exception(\"invalid input\");\n            }\n        }\n       \
    \ output.Add(max_level);\n        return output;", "        List<long> result\
    \ = new List<long>();\n        var current_string = \"\";\n        var current_depth\
    \ = 0L;\n        var max_depth = 0L;\n        foreach (var c in paren_string)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       if (current_depth > max_depth) {\n                    max_depth = current_depth;\n\
    \                }\n            } else if (c == ')') {\n                current_depth--;\n\
    \            } else if (c == ' ') {\n                result.Add(max_depth);\n\
    \                max_depth = 0L;\n                current_depth = 0L;\n      \
    \      }\n        }\n        result.Add(max_depth);\n        return result;",
  "        List<long> result = new List<long>();\n        long max_depth = 0L;\n \
    \       long cur_depth = 0L;\n        bool started = false;\n        for (long\
    \ i = 0L; i < paren_string.Length; i++) {\n            char c = paren_string[(int)i];\n\
    \            if (c == '(') {\n                if (!started) {\n              \
    \      started = true;\n                }\n                cur_depth++;\n    \
    \            if (cur_depth > max_depth) {\n                    max_depth = cur_depth;\n\
    \                }\n            }\n            else if (c == ')') {\n        \
    \        cur_depth--;\n            }\n            else if (c == ' ') {\n     \
    \           if (started) {\n                    result.Add(max_depth);\n     \
    \               started = false;\n                    max_depth = 0L;\n      \
    \              cur_depth = 0L;\n                }\n            }\n        }\n\
    \        if (started) {\n            result.Add(max_depth);\n        }\n     \
    \   return result;", "        // Write your code here.\n        var result = new\
    \ List<long>();\n        var stack = new Stack<long>();\n        var max = long.MinValue;\n\
    \        for (var i = 0; i < paren_string.Length; i++) {\n            if (paren_string[i]\
    \ == '(') {\n                stack.Push(i);\n            } else if (paren_string[i]\
    \ == ')') {\n                stack.Pop();\n                if (stack.Count > 0)\
    \ {\n                    max = Math.Max(max, i - stack.Peek());\n            \
    \    } else {\n                    result.Add(max);\n                    max =\
    \ long.MinValue;\n                }\n            }\n        }\n        if (stack.Count\
    \ > 0) {\n            throw new Exception(\"paranthesis not closed properly\"\
    );\n        }\n        return result;", '        throw new NotImplementedException();',
  "        // Your code goes here.\n        // var is considered to be a keyword in\
    \ C#, but is allowed as a variable name.\n        // The 'var' keyword allows\
    \ the compiler to infer the type of the variable.\n        // In this case, the\
    \ expression new List<long>() returns a List<long>, so the compiler infers that\
    \ result should be List<long>.\n        var result = new List<long>();\n     \
    \   // Each of the group is separated by a space, so split by space and iterate\
    \ over the result.\n        // The String.Split method returns a String array,\
    \ which is enumerable, so we can iterate over each String in the String array\
    \ with foreach.\n        foreach (var nested_parens in paren_string.Split(new\
    \ char[] {' '})) {\n            // for loop and while loop are both supported\
    \ in C#, but for loop is more commonly used.\n            var left_parens = 0;\n\
    \            var right_parens = 0;\n            var max_parans = 0;\n        \
    \    foreach (var paren in nested_parens) {\n                if (paren == '(')\
    \ {\n                    left_parens += 1;\n                    if (left_parens\
    \ > max_parans) {\n                        max_parans = left_parens;\n       \
    \             }\n                } else if (paren == ')') {\n                \
    \    right_parens += 1;\n                    if (right_parens > left_parens) {\n\
    \                        throw new ArgumentException(\"Mismatched parens\");\n\
    \                    }\n                } else {\n                    throw new\
    \ ArgumentException(\"Invalid parens\");\n                }\n            }\n \
    \           if (left_parens != right_parens) {\n                throw new ArgumentException(\"\
    Mismatched parens\");\n            }\n            result.Add(max_parans);\n  \
    \      }\n        return result;", "        var pos = 0;\n        var result =\
    \ new List<long>();\n        while (pos < paren_string.Length) {\n           \
    \ if (paren_string[pos] == ' ') {\n                pos++;\n                continue;\n\
    \            }\n            var maxDepth = 0L;\n            var depth = 0L;\n\
    \            var finished = false;\n            while (!finished) {\n        \
    \        if (paren_string[pos] == '(') {\n                    depth++;\n     \
    \               if (depth > maxDepth) {\n                        maxDepth = depth;\n\
    \                    }\n                }\n                else if (paren_string[pos]\
    \ == ')') {\n                    depth--;\n                }\n               \
    \ else {\n                    finished = true;\n                }\n          \
    \      pos++;\n            }\n            result.Add(maxDepth);\n        }\n \
    \       return result;", "        var result = new List<long>();\n        var\
    \ cur_level = 0L;\n        var max_level = 0L;\n        var chars = paren_string.ToArray();\n\
    \        for (var i = 0L; i < chars.Length; i++) {\n            if (chars[i] ==\
    \ '(') {\n                cur_level++;\n                if (cur_level > max_level)\
    \ {\n                    max_level = cur_level;\n                }\n         \
    \   } else if (chars[i] == ')') {\n                cur_level--;\n            }\
    \ else if (chars[i] == ' ') {\n                result.Add(max_level);\n      \
    \          max_level = 0L;\n                cur_level = 0L;\n            }\n \
    \       }\n        result.Add(max_level);\n        return result;", "        var\
    \ Nesting = new List<long>();\n        var Record = new List<string>();\n    \
    \    for (long i = 0L; i < len(paren_string); i++) {\n            if (paren_string[i..i\
    \ + 1L] == \" \") {\n                Nesting.append(len(Record));\n          \
    \      Record = new List<string>();\n            }\n            else {\n     \
    \           Record.append(paren_string[i..i + 1L]);\n            }\n\n       \
    \ }\n        Nesting.append(len(Record));\n\n        return Nesting;\n", "   \
    \     List<long> result = new List<long>();\n        int currentNesting = 0;\n\
    \        int maxNesting = 0;\n        foreach (var c in paren_string) {\n    \
    \        if (c == '(') {\n                currentNesting++;\n                if\
    \ (currentNesting > maxNesting) {\n                    maxNesting = currentNesting;\n\
    \                }\n            } else if (c == ')') {\n                currentNesting--;\n\
    \            } else if (c == ' ') {\n                result.Add(maxNesting);\n\
    \                maxNesting = 0;\n                currentNesting = 0;\n      \
    \      }\n        }\n        result.Add(maxNesting);\n        return result;",
  "        // Your code here...\n        return null;", "        // could use stack\
    \ here, but instead let's just keep track of the current level\n        // if\
    \ we see a ')' and we are not in any parens, fail immediately\n        long current_level\
    \ = 0L;\n        long max_level = 0L;\n        bool inside_parens = false;\n \
    \       List<long> results = new List<long>();\n        foreach (char paren in\
    \ paren_string) {\n            if (paren == '(') {\n                inside_parens\
    \ = true;\n                current_level += 1L;\n                max_level = Math.Max(max_level,\
    \ current_level);\n            } else if (paren == ')') {\n                current_level\
    \ -= 1L;\n                if (current_level < 0L) {\n                    return\
    \ new List<long>();\n                }\n            } else if (paren == ' ') {\n\
    \                if (inside_parens) {\n                    results.Add(max_level);\n\
    \                    max_level = 0L;\n                    current_level = 0L;\n\
    \                    inside_parens = false;\n                }\n            }\
    \ else {\n                return new List<long>();\n            }\n        }\n\
    \        results.Add(max_level);\n        return results;", "        // Your code\
    \ goes here.\n        return new List<long>();", "        List<long> res = new\
    \ List<long>();\n        long curr_depth = 0L;\n        long max_depth = 0L;\n\
    \        foreach (var @char in paren_string) {\n            if (@char == '(')\
    \ {\n                curr_depth++;\n                max_depth = Math.Max(max_depth,\
    \ curr_depth);\n            }\n            else if (@char == ')') {\n        \
    \        curr_depth--;\n            }\n            else if (@char == ' ') {\n\
    \                res.Add(max_depth);\n                max_depth = 0L;\n      \
    \          curr_depth = 0L;\n            }\n        }\n        res.Add(max_depth);\n\
    \        return res;", "        var result = new List<long>();\n        var iter\
    \ = 0;\n        while (iter < paren_string.Length) {\n            // Find the\
    \ end of the current group\n            var end = paren_string.IndexOf(' ', iter);\n\
    \            if (end == -1) {\n                end = paren_string.Length;\n  \
    \          }\n            result.Add(NestedParenDepth(paren_string.Substring(iter,\
    \ end - iter)));\n            iter = end + 1;\n        }\n        return result;",
  "        // Compute the number of nested parentheses for each group\n        //\
    \ Extract the parens data\n        var paren_data = paren_string.Split(' ');\n\
    \        // Hold the result\n        var result = new List<long>();\n        //\
    \ Iterate over paren data\n        foreach (var paren_group in paren_data) {\n\
    \            // Compute the number of nested parentheses\n            var result_group\
    \ = 0L;\n            // Track the current level of nesting\n            var current_level\
    \ = 0L;\n            // Iterate over paren group\n            foreach (var paren\
    \ in paren_group) {\n                // Check if we're opening or closing\n  \
    \              if (paren == '(') {\n                    // We're opening a new\
    \ level of nesting\n                    current_level += 1L;\n               \
    \ } else {\n                    // We're closing a level of nesting\n        \
    \            current_level -= 1L;\n                }\n                // Update\
    \ the max level for this group\n                result_group = Math.Max(result_group,\
    \ current_level);\n            }\n            // Add group result to list\n  \
    \          result.Add(result_group);\n        }\n        // Return result\n  \
    \      return result;", "        List<long> ans = new List<long>();\n        //\
    \ Find the opening parenthesis\n        // when you find the closing parenthesis,\
    \ push the depth into the list\n        // and reset the depth count to zero.\n\
    \        // loop through the rest of the string and repeat\n        int depth\
    \ = 0;\n        for (int i = 0; i < paren_string.Length; i++) {\n            char\
    \ paren = paren_string[i];\n            if (paren == '(') {\n                depth++;\n\
    \            } else if (paren == ')') {\n                ans.Add(depth);\n   \
    \             depth = 0;\n            }\n        }\n        return ans;", "  \
    \      return paren_string.Split(' ').Select(s => {\n            var depth = 0L;\n\
    \            var best_depth = 0L;\n            foreach (var c in s) {\n      \
    \          if (c == '(') {\n                    depth++;\n                   \
    \ best_depth = Math.Max(best_depth, depth);\n                } else if (c == ')')\
    \ {\n                    depth--;\n                }\n            }\n        \
    \    return best_depth;\n        }).ToList();", "        var nested_parens = new\
    \ List<long>();\n        var tokens = paren_string.Split(new string[] { \" \"\
    \ }, StringSplitOptions.RemoveEmptyEntries);\n        var i = 0L;\n        while\
    \ (i < tokens.Length) {\n            var current_tokens = tokens[i];\n       \
    \     var stack = new Stack<long>();\n            var max_nested_level = 0L;\n\
    \            var j = 0L;\n            while (j < current_tokens.Length) {\n  \
    \              if (current_tokens[(int)j] == '(') {\n                    stack.Push(j);\n\
    \                } else {\n                    var popped_index = stack.Pop();\n\
    \                    var nested_level = (j - popped_index) + 1L;\n           \
    \         if (nested_level > max_nested_level) {\n                        max_nested_level\
    \ = nested_level;\n                    }\n                }\n                j\
    \ = j + 1L;\n            }\n            nested_parens.Add(max_nested_level);\n\
    \            i = i + 1L;\n        }\n        return nested_parens;"]
stop_tokens:
- "\n    }\n"
