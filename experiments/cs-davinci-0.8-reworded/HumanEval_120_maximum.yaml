name: HumanEval_120_maximum
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Given a list arr of integers and a positive integer k, return\
  \ a sorted list \n    // of length k with the maximum k numbers in arr.\n    //\
  \ Example 1:\n    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L,\
  \ (long)5L})), (3L))\n    // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))\n\
  \    // Example 2:\n    // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L,\
  \ (long)4L})), (2L))\n    // (new List<long>(new long[]{(long)4L, (long)4L}))\n\
  \    // Example 3:\n    // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L,\
  \ (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))\n    // (new List<long>(new\
  \ long[]{(long)2L}))\n    // Note:\n    // 1. The length of the list will be in\
  \ the range of [1, 1000].\n    // 2. The elements in the list will be in the range\
  \ of [-1000, 1000].\n    // 3. 0 <= k <= len(arr)\n    public static List<long>\
  \ Maximum(List<long> arr, long k) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Maximum((new\
  \ List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})), (3L)).Equals((new List<long>(new\
  \ long[]{(long)-4L, (long)-3L, (long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)4L, (long)-4L, (long)4L})), (2L)).Equals((new List<long>(new long[]{(long)4L,\
  \ (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-3L,\
  \ (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L)).Equals((new\
  \ List<long>(new long[]{(long)2L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)123L, (long)-123L, (long)20L, (long)0L, (long)1L, (long)2L, (long)-3L})),\
  \ (3L)).Equals((new List<long>(new long[]{(long)2L, (long)20L, (long)123L}))));\n\
  \    Debug.Assert(Maximum((new List<long>(new long[]{(long)-123L, (long)20L, (long)0L,\
  \ (long)1L, (long)2L, (long)-3L})), (4L)).Equals((new List<long>(new long[]{(long)0L,\
  \ (long)1L, (long)2L, (long)20L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)5L, (long)15L, (long)0L, (long)3L, (long)-13L, (long)-8L, (long)0L})),\
  \ (7L)).Equals((new List<long>(new long[]{(long)-13L, (long)-8L, (long)0L, (long)0L,\
  \ (long)3L, (long)5L, (long)15L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)-1L, (long)0L, (long)2L, (long)5L, (long)3L, (long)-10L})), (2L)).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)5L}))));\n    Debug.Assert(Maximum((new\
  \ List<long>(new long[]{(long)1L, (long)0L, (long)5L, (long)-7L})), (1L)).Equals((new\
  \ List<long>(new long[]{(long)5L}))));\n    Debug.Assert(Maximum((new List<long>(new\
  \ long[]{(long)4L, (long)-4L})), (2L)).Equals((new List<long>(new long[]{(long)-4L,\
  \ (long)4L}))));\n    Debug.Assert(Maximum((new List<long>(new long[]{(long)-10L,\
  \ (long)10L})), (2L)).Equals((new List<long>(new long[]{(long)-10L, (long)10L}))));\n\
  \    Debug.Assert(Maximum((new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
  \ (long)-23L, (long)243L, (long)-400L, (long)0L})), (0L)).Equals((new List<long>())));\n\
  \    }\n\n}\n"
completions: ['        throw new NotImplementedException();', "        arr.Sort();\n\
    \        arr.Reverse();\n        return arr.GetRange(0, (int)k);", "        var\
    \ sorted = arr.OrderByDescending(x => x).ToList();\n        return sorted.Take((int)k).ToList();",
  "        if(arr.Count == 0) {\n            return arr;\n        }\n        arr.Sort();\n\
    \        arr.Reverse();\n        return arr.GetRange(0, (int)k);", "        //\
    \ Write your code here\n        List<long> a = arr;\n        List<long> b = new\
    \ List<long>();\n        long i = 0;\n        while (i < k) {\n            i =\
    \ i + 1;\n            long x = a[0];\n            long j = 0;\n            while\
    \ (j < a.Count) {\n                if (a[j] > x) {\n                    x = a[j];\n\
    \                }\n                j = j + 1;\n            }\n            a.Remove(x);\n\
    \            b.Add(x);\n        }\n        return b;", "        if (k > arr.Count)\
    \ throw new Exception(\"k must be less than or equal to the number of elements\
    \ in arr.\");\n        var result = arr.OrderByDescending(x => x).Take((int)k).ToList();\n\
    \        return result;", "        if (arr.Count == 0) {\n            throw new\
    \ ArgumentException(\"arr must not be empty\");\n        }\n        if (k > arr.Count)\
    \ {\n            throw new ArgumentException(\"k must be less than or equal to\
    \ the length of arr\");\n        }\n        if (k < 0) {\n            throw new\
    \ ArgumentException(\"k must be non-negative\");\n        }\n        var maxHeap\
    \ = new Heap<long>(HeapType.Max);\n        for (int i = 0; i < arr.Count; i++)\
    \ {\n            if (maxHeap.Count < k) {\n                maxHeap.Insert(arr[i]);\n\
    \            } else {\n                if (arr[i] > maxHeap.GetRoot()) {\n   \
    \                 maxHeap.PopRoot();\n                    maxHeap.Insert(arr[i]);\n\
    \                }\n            }\n        }\n        var result = new List<long>();\n\
    \        while (maxHeap.Count > 0) {\n            result.Add(maxHeap.PopRoot());\n\
    \        }\n        result.Reverse();\n        return result;", "        if (k\
    \ <= 0L) {\n            return (new List<long>(new long[]{}));\n        }\n  \
    \      if (k >= arr.Count) {\n            return (new List<long>(arr));\n    \
    \    }\n        List<long> ans = new List<long>();\n        for (long i = 0L;\
    \ i < k; i++) {\n            long idx = 0L;\n            long val = long.MinValue;\n\
    \            for (long j = 0L; j < arr.Count; j++) {\n                if (arr[(int)j]\
    \ > val) {\n                    idx = j;\n                    val = arr[(int)j];\n\
    \                }\n            }\n            ans.Add(val);\n            arr.RemoveAt((int)idx);\n\
    \        }\n        return (ans);", "        // Your code goes here\n        return\
    \ new List<long>();", "        var sorted = arr.OrderByDescending(x => x).ToList();\n\
    \        return sorted.Take((int)k).ToList();", "        List<long> res = new\
    \ List<long>();\n        if (k > arr.Count) {\n            res = new List<long>(arr);\n\
    \            res.Sort();\n            return res;\n        }\n        foreach\
    \ (long a in arr) {\n            if (res.Count < k) {\n                res.Add(a);\n\
    \                res.Sort();\n            } else {\n                if (a > res[0])\
    \ {\n                    res.RemoveAt(0);\n                    res.Add(a);\n \
    \                   res.Sort();\n                }\n            }\n        }\n\
    \        return res;", "        var s = new SortedSet<long>();\n        s.Add(0);\n\
    \        var result = new List<long>();\n        foreach (var elem in arr) {\n\
    \            var t = new SortedSet<long>();\n            foreach (var e in s)\
    \ {\n                t.Add(e + elem);\n            }\n            foreach (var\
    \ e in t) {\n                s.Add(e);\n            }\n        }\n        foreach\
    \ (var elem in s) {\n            result.Add(elem);\n        }\n        var m =\
    \ new List<long>();\n        for (int i = 0; i < k; i += 1) {\n            m.Add(result[result.Count\
    \ - i - 1]);\n        }\n        return m;", "        var s = new List<long>();\n\
    \        var max = arr.Max();\n        var min = arr.Min();\n        while (s.Count()\
    \ < k) {\n            var c = arr.Where(x => x == max).Count();\n            if\
    \ (c > 0) {\n                s.Add(max);\n                arr.RemoveAll(x => x\
    \ == max);\n            }\n            max = arr.Max();\n        }\n        return\
    \ s;", "        // return a sorted list with the maximum k numbers in arr.\n \
    \       return new List<long>();", "        // arr (list of int)\n        // k\
    \ (int)\n        // return (list of int)\n        // max heap\n        List<long>\
    \ heap = new List<long>();\n        int i = 0;\n        for (i = 0; i < k; i++)\
    \ {\n            HeapPush(ref heap, arr[i]);\n        }\n        for (i = k; i\
    \ < arr.Count; i++) {\n            long temp = HeapPeek(heap);\n            if\
    \ (arr[i] > temp) {\n                HeapPop(ref heap);\n                HeapPush(ref\
    \ heap, arr[i]);\n            }\n        }\n        heap.Sort();\n        heap.Reverse();\n\
    \        return heap;", '        return arr.OrderByDescending(e => e).Take((int)k).ToList();',
  "        long i;\n        List<long> karr = new List<long>();\n        long s =\
    \ 0L;\n        long e = (long)arr.Count;\n        long m = (long)0L;\n       \
    \ long pos = (long)0L;\n        for (i = (long)0L; i < k; i++) {\n           \
    \ m = (long)((e - s) / 2L);\n            pos = (long)(s + m);\n            if\
    \ (m == (long)0L) {\n                pos = s;\n            }\n            karr.Add(arr[(int)pos]);\n\
    \            s = (long)(pos + 1L);\n        }\n        return karr;", "      \
    \  // IMPLEMENT ME\n        List<long> result = new List<long>();\n        if\
    \ (k > arr.Count) {\n            return arr;\n        }\n        for (int i =\
    \ 0; i < k; i++) {\n            result.Add(0);\n        }\n        for (int i\
    \ = 0; i < arr.Count; i++) {\n            for (int j = k - 1; j >= 0; j--) {\n\
    \                if (result[j] < arr[i]) {\n                    if (j == k - 1)\
    \ {\n                        result[j] = arr[i];\n                    } else {\n\
    \                        result[j + 1] = result[j];\n                        result[j]\
    \ = arr[i];\n                    }\n                }\n            }\n       \
    \ }\n        return result;", '        return arr.OrderByDescending(x => x).Take((int)k).ToList();',
  "        var list = new List<long>();\n        if (k == 0) {\n            return\
    \ list;\n        }\n        long n = arr.Count;\n        long i = 1;\n       \
    \ long j = k;\n        while (j <= n) {\n            var max = FindMax(arr, i,\
    \ j);\n            list.Add(max);\n            i = i + 1;\n            j = j +\
    \ 1;\n        }\n        return list;", "        var r = new List<long>();\n \
    \       var s = arr.OrderByDescending(x => x).Take((int)k).ToList();\n       \
    \ for (var i = 0; i < k; i++) {\n            r.Add(s[i]);\n        }\n       \
    \ return r;", "        List<long> max = new List<long>();\n        for (int i\
    \ = 0; i < k; i++) {\n            max.Add(arr[i]);\n        }\n        return\
    \ max;", "        List<long> result = new List<long>();\n        return result;",
  '        return default(List<long>);', "        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        var lookup = new Dictionary<long,\
    \ int>();\n        var maxLookup = new Dictionary<long, int>();\n        var result\
    \ = new List<long>();\n        foreach (var n in arr) {\n            if (lookup.ContainsKey(n))\
    \ {\n                lookup[n]++;\n            } else {\n                lookup[n]\
    \ = 1;\n            }\n        }\n        for (int i = 0; i < k; i++) {\n    \
    \        var max = (long)-1e9;\n            foreach (var key in lookup.Keys) {\n\
    \                if (key > max) {\n                    max = key;\n          \
    \      }\n            }\n            result.Add(max);\n            lookup[max]--;\n\
    \            if (lookup[max] == 0) {\n                lookup.Remove(max);\n  \
    \          }\n        }\n        return result;", '        return new List<long>();',
  "        long len = arr.Count;\n        var arrr = arr.OrderByDescending(x => x).ToList();\n\
    \        return arrr.GetRange(0, (int)k);", '        return arr;', "        var\
    \ heap = new List<long>();\n        foreach (var item in arr) {\n            if\
    \ (heap.Count < k) {\n                heap.Add(item);\n                var cur\
    \ = heap.Count - 1;\n                while (cur > 0) {\n                    var\
    \ parent = (cur - 1) / 2;\n                    if (heap[parent] > heap[cur]) {\n\
    \                        break;\n                    }\n                    var\
    \ temp = heap[parent];\n                    heap[parent] = heap[cur];\n      \
    \              heap[cur] = temp;\n                    cur = parent;\n        \
    \        }\n            } else {\n                if (item <= heap[0]) {\n   \
    \                 continue;\n                }\n                heap[0] = item;\n\
    \                var cur = 0;\n                while (true) {\n              \
    \      var left = 2 * cur + 1;\n                    var right = 2 * cur + 2;\n\
    \                    var newcur = cur;\n                    if (left < heap.Count\
    \ && heap[left] > heap[newcur]) {\n                        newcur = left;\n  \
    \                  }\n                    if (right < heap.Count && heap[right]\
    \ > heap[newcur]) {\n                        newcur = right;\n               \
    \     }\n                    if (newcur == cur) {\n                        break;\n\
    \                    }\n                    var temp = heap[newcur];\n       \
    \             heap[newcur] = heap[cur];\n                    heap[cur] = temp;\n\
    \                    cur = newcur;\n                }\n            }\n       \
    \ }\n        return heap;", "        // Return the sorted list of length k with\
    \ the maximum k numbers in arr.\n        if ((k) > (arr.Count)) {\n          \
    \  throw new ArgumentException();\n        }\n        return arr.OrderByDescending((i)\
    \ => (i)).Take((int)(k)).ToList();", '        return null;', "        var result\
    \ = new List<long>();\n        result.AddRange(arr.OrderByDescending(x => x).Take((int)k));\n\
    \        return result;", "        // Write your code here\n        return arr;",
  '        return new List<long>();', "        // >>> arr.Sort()\n        // >>> arr[-k:]\n\
    \        arr.Sort();\n        return arr.GetRange((int)(arr.Count - k), (int)k);",
  '        throw new NotImplementedException();', "        var sz = arr.Count;\n \
    \       var pq = new PriorityQueue<long>();\n        for (var i = 0; i < sz; i++)\
    \ {\n            pq.Push(arr[i]);\n        }\n        arr.Clear();\n        for\
    \ (var i = 0; i < k; i++) {\n            var v = pq.Pop();\n            arr.Add(v);\n\
    \        }\n        return arr;", '        return new List<long>();', "      \
    \  // Implement your solution here\n        return arr;", "        // Insert your\
    \ solution here!\n        return arr;", '        return arr.OrderByDescending(x
    => x).Take((int)k).ToList();', "        // TODO: Implement this function and return\
    \ the correct output.\n        return new List<long>();", "        // *** INSERT\
    \ YOUR CODE HERE ***\n        if (k == 0)\n            return new List<long>();\n\
    \        if (k == arr.Count)\n            return arr;\n        arr.Sort();\n \
    \       arr.Reverse();\n        return arr.GetRange(0, (int)k);", '        return
    Maximum(arr, k, new List<long>());', "        if (k > arr.Count) {\n         \
    \   throw new ArgumentException();\n        }\n        return arr.OrderByDescending(x\
    \ => x).Take((int)k).ToList();", "        if (k < 0) throw new ArgumentException(nameof(k));\n\
    \        if (k > arr.Count) k = arr.Count;\n        List<long> result = new List<long>();\n\
    \        if (k == 0) return result;\n        int arrCount = arr.Count;\n     \
    \   int[] arrInts = new int[arrCount];\n        for (int i = 0; i < arrCount;\
    \ i++) {\n            arrInts[i] = (int)arr[i];\n        }\n        result = MaxK(arrInts,\
    \ (int)k);\n        return result;", "        List<long> res = new List<long>();\n\
    \        for (long i = 0; i < k; i++) {\n            long max = arr[0];\n    \
    \        long maxindex = 0;\n            for (long j = 0; j < arr.Count; j++)\
    \ {\n                if (arr[(int)j] > max) {\n                    max = arr[(int)j];\n\
    \                    maxindex = j;\n                }\n            }\n       \
    \     res.Add(max);\n            arr.RemoveAt((int)maxindex);\n        }\n   \
    \     return res;", "        if (k > arr.Count) return arr;\n        var result\
    \ = new List<long>();\n        //Console.WriteLine(arr);\n        for (int i =\
    \ 0; i < k; i++) {\n            var max = arr.Max();\n            result.Add(max);\n\
    \            arr.Remove(max);\n        }\n        return result;", "        //\
    \ If k is negative, then return an empty list.\n        if (k < 0) {\n       \
    \     return new List<long>();\n        }\n        // If k is zero, then return\
    \ an empty list.\n        if (k == 0) {\n            return new List<long>();\n\
    \        }\n        // Sort arr in increasing order.\n        arr.Sort();\n  \
    \      // If k is larger than the length of arr, then return arr.\n        if\
    \ (k >= arr.Count) {\n            return arr;\n        }\n        // Otherwise,\
    \ return the last k elements of arr.\n        return arr.GetRange((int)(arr.Count\
    \ - k), (int)k);", "        // Time: O(log(n) * n), Space: O(n)\n        // Since\
    \ we are returning an element in the middle of the list, we need to sort it first.\n\
    \        // There are various algorithms to do this. We implemented the one based\
    \ on max heap.\n        // We start by placing all the elements in the max heap.\n\
    \        // We then pop the largest element and put it in the result list.\n \
    \       // We pop the remaining elements and put them back in the heap.\n    \
    \    // We do this until we get all elements sorted.\n        // We can use a\
    \ sorted array instead of a max heap. We can insert elements in the right spot.\n\
    \        // But the cost of insertion is O(log(n)) and we have n elements to insert\
    \ so it is O(n * log(n)).\n        // After all elements are sorted, we return\
    \ the first k of them.\n        if (k <= 0) return new List<long>();\n       \
    \ if (k >= arr.Count) return arr;\n        // Build max heap.\n        List<long>\
    \ heap = BuildMaxHeap(arr);\n        // Pop the largest element and put it in\
    \ the result list.\n        List<long> res = new List<long>();\n        for (int\
    \ i = 0; i < k; i++) {\n            res.Add(heap[0]);\n            heap[0] = heap[heap.Count\
    \ - 1];\n            heap.RemoveAt(heap.Count - 1);\n            MaxHeapify(heap,\
    \ 0);\n        }\n        return res;", "        // Write your code here\n   \
    \     // return new List<long>();\n        var queue = new SortedSet<int>();\n\
    \        var max = new HashSet<int>();\n        var result = new List<long>();\n\
    \        for (var i = 0; i < arr.Count; i++) {\n            queue.Add(i);\n  \
    \          max.Add(i);\n        }\n        for (var i = 0; i < k; i++) {\n   \
    \         var m = queue.Max;\n            result.Add(arr[m]);\n            queue.Remove(m);\n\
    \            if (max.Contains(m)) {\n                var order = new Dictionary<int,\
    \ long>();\n                foreach (var x in queue) {\n                    order[x]\
    \ = arr[x];\n                }\n                queue.Clear();\n             \
    \   foreach (var x in order.OrderByDescending(x => x.Value)) {\n             \
    \       queue.Add(x.Key);\n                }\n                max.Clear();\n \
    \               max.Add(queue.Max);\n            }\n        }\n        return\
    \ result;", "        var result = new List<long>();\n        for (int i = 0; i\
    \ < k; i++) {\n            var max = -1L;\n            for (int j = 0; j < arr.Count;\
    \ j++) {\n                if (arr[j] > max) {\n                    max = arr[j];\n\
    \                }\n            }\n            result.Add(max);\n            arr.Remove(max);\n\
    \        }\n        return result;", "        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        // Sort the list in ascending\
    \ order\n        arr.Sort();\n        // Reverse the first k elements\n      \
    \  arr.Reverse(0, (int)k);\n        // Return the entire list\n        return\
    \ arr;", "        var res = new List<long>();\n        while (k > 0) {\n     \
    \       var max = 0L;\n            var idx = 0;\n            for (int i = 0; i\
    \ < arr.Count; i++) {\n                if (arr[i] > max) {\n                 \
    \   max = arr[i];\n                    idx = i;\n                }\n         \
    \   }\n            res.Add(max);\n            arr.RemoveAt(idx);\n           \
    \ k -= 1;\n        }\n        return res;", '        throw new NotImplementedException();',
  "        List<long> max = new List<long>();\n        max.AddRange(arr.GetRange(0,(int)k));\n\
    \        for (long i = k; i < arr.Count; i++) {\n            for (long j = 0;\
    \ j < k; j++) {\n                if (arr[(int)i] > max[(int)j]) {\n          \
    \          max.Insert((int)j, arr[(int)i]);\n                    max.RemoveAt((int)k);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return max;", "        var maxValues = new List<long>();\n        for (int\
    \ i = 0; i < k; i++) {\n            maxValues.Add(arr.Max());\n            arr.Remove(arr.Max());\n\
    \        }\n        return maxValues;", "        var result = new List<long>();\n\
    \        for (var i = 0; i < k; i++) {\n            var maxIndex = arr.IndexOf(arr.Max());\n\
    \            result.Add(arr[maxIndex]);\n            arr.RemoveAt(maxIndex);\n\
    \        }\n        return result;", "        if (k == 0) {\n            return\
    \ new List<long>();\n        }\n        if (k == arr.Count) {\n            arr.Sort();\n\
    \            return arr;\n        }\n        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        var s = new HashSet<long>();\n\
    \        for (var i = 0; i < arr.Count; i++) {\n            s.Add(arr[i]);\n \
    \       }\n        var t = new List<long>(s);\n        var r = new List<long>();\n\
    \        for (var i = 0; i < k; i++) {\n            var m = t[0];\n          \
    \  var p = 0;\n            for (var j = 1; j < t.Count; j++) {\n             \
    \   if (t[j] > m) {\n                    m = t[j];\n                    p = j;\n\
    \                }\n            }\n            r.Add(m);\n            t.RemoveAt(p);\n\
    \        }\n        return r;", '        throw new NotImplementedException();',
  '        return arr.OrderByDescending(x => x).Take((int)k).ToList();', "       \
    \ var r = new List<long>();\n        var h = new Heap();\n        for (int i =\
    \ 0; i < arr.Count; i++) {\n            h.Push(arr[i]);\n        }\n        for\
    \ (int i = 0; i < k; i++) {\n            r.Add(h.Pop());\n        }\n        return\
    \ r;", "        if (k == 0L) {\n            return new List<long>();\n       \
    \ }\n        // *** start code here ***\n        var result = new List<long>();\n\
    \        var heap = new Heap<long>();\n        foreach (var item in arr) {\n \
    \           heap.Push(item);\n        }\n        while (k > 0L) {\n          \
    \  result.Add(heap.Pop());\n            k--;\n        }\n        return result;\n\
    \        // *** end code here ***", "        // Your code goes here.\n       \
    \ return arr;", '        return arr.OrderByDescending(num => num).Take((int)k).ToList();',
  "        var result = new List<long>();\n        // Iterate through arr until we've\
    \ placed k numbers into result\n        var i = 0;\n        while(i < arr.Count\
    \ && result.Count < k) {\n            // Start by placing the maximum numbers\
    \ from arr into result\n            result.Add(arr[i]);\n            i++;\n  \
    \      }\n        // Sort result in ascending order\n        result.Sort();\n\
    \        // Iterate through the rest of arr, comparing it to result[0]\n     \
    \   while(i < arr.Count) {\n            // If a[i] is greater than result[0],\
    \ swap it into result, then sort result again\n            if(arr[i] > result[0])\
    \ {\n                result[0] = arr[i];\n                result.Sort();\n   \
    \         }\n            i++;\n        }\n        return result;", '        return
    arr.OrderByDescending(e => e).Take((int)k).ToList();', "        List<long> maxarr\
    \ = new List<long>();\n        arr.Sort();\n        arr.Reverse();\n        for\
    \ (long i = 0; i < k; i++) {\n            maxarr.Add(arr[(int)i]);\n        }\n\
    \        return maxarr;", "        for (long i = 0; i < k; i++) {\n          \
    \  long max = 0;\n            long idx = 0;\n            for (long j = 0; j <\
    \ (arr.Count - i); j++) {\n                if (arr[(int)j] > max) {\n        \
    \            max = arr[(int)j];\n                    idx = j;\n              \
    \  }\n            }\n            arr.Add(arr[(int)idx]);\n            arr.RemoveAt((int)idx);\n\
    \        }\n        arr.RemoveRange((int)k, (int)(arr.Count - k));\n        return\
    \ arr;", "        List<long> result = new List<long>();\n        arr.Sort();\n\
    \        result = arr.GetRange((int)(arr.Count - k), (int)k);\n        return\
    \ result;", "        var res = new List<long>();\n        for (var i = 0; i <\
    \ k; i++) {\n            var maxIndex = -1;\n            for (var j = 0; j < arr.Count;\
    \ j++) {\n                if (maxIndex == -1 || arr[j] > arr[maxIndex]) {\n  \
    \                  maxIndex = j;\n                }\n            }\n         \
    \   res.Add(arr[maxIndex]);\n            arr.RemoveAt(maxIndex);\n        }\n\
    \        return res;", "        var temp = new List<long>();\n        for (var\
    \ i = (long)0L; i < k; i++) {\n            var max = (long)-1001L;\n         \
    \   var maxIndex = (long)-1L;\n            for (var j = (long)0L; j < arr.Count;\
    \ j++) {\n                if (arr[(int)j] > max) {\n                    max =\
    \ arr[(int)j];\n                    maxIndex = j;\n                }\n       \
    \     }\n            temp.Add(max);\n            arr.RemoveAt((int)maxIndex);\n\
    \        }\n        return temp;", '        return Enumerable.Range(0, (int)k).Select(i
    => arr.OrderByDescending(l => l).ElementAt(i)).ToList();', "        // We want\
    \ to get the maximum k elements of arr. One way to do this is to \n        //\
    \ put the elements of arr into a min-heap and pop from the heap until we \n  \
    \      // have k elements remaining. This takes O(nlgk) time.\n        //\n  \
    \      // Another approach is to sort the elements of arr. This takes O(nlgn)\
    \ time \n        // but is faster than the heap approach if n >> k.\n        //\n\
    \        // But we can do better. In this problem, we are given a k which is small\
    \ \n        // relative to n (the length of arr). Therefore, we should find a\
    \ sorting \n        // algorithm that is faster than O(nlgn) if the input size\
    \ is much larger \n        // than the output size. One such algorithm is the\
    \ quicksort algorithm.\n        //\n        // Our quicksort algorithm is particularly\
    \ simple since we only need to \n        // sort the last k elements. We can avoid\
    \ sorting elements before the kth \n        // element. This would be slow for\
    \ large k values, but not for small k \n        // values.\n        //\n     \
    \   // The quicksort algorithm for this problem takes O(n) time.\n        //\n\
    \        // This problem is related to the Kth Largest Element in an Array problem\
    \ \n        // on LeetCode.\n        Debug.Assert(arr.Count > 0);\n        Debug.Assert(k\
    \ > 0);\n        // The algorithm is simple enough that we can implement it without\
    \ any \n        // helper functions.\n        // The space complexity of the algorithm\
    \ is O(1).\n        long i = k - 1;\n        long j = arr.Count - 1;\n       \
    \ long pivot = arr[k - 1];\n        while (true) {\n            while (arr[i]\
    \ < pivot) {\n                // Skip elements that are less than the pivot.\n\
    \                i += 1;\n            }\n            while (arr[j] > pivot) {\n\
    \                // Skip elements that are greater than the pivot.\n         \
    \       j -= 1;\n            }\n            if (i >= j) {\n                //\
    \ We found the pivot element.\n                break;\n            }\n       \
    \     // Swap the elements.\n            long temp = arr[i];\n            arr[i",
  "        List<long> result = new List<long>();\n        // Put your code here\n\
    \        return result;", "        //if (k > arr.Count) {\n        //    throw\
    \ new System.ArgumentException(\"Input must have at least k elements\");\n   \
    \     //}\n        //if (k <= 0) {\n        //    throw new System.ArgumentException(\"\
    Input must have at least 1 element\");\n        //}\n        //if (arr.Count <=\
    \ 0) {\n        //    throw new System.ArgumentException(\"Input must have at\
    \ least 1 element\");\n        //}\n        List<long> maxk = new List<long>();\n\
    \        for (long i = 0; i < k; i++) {\n            maxk.Add(arr[0]);\n     \
    \   }\n        foreach (long a in arr) {\n            long min = min(maxk);\n\
    \            if (a > min) {\n                maxk.Remove(min);\n             \
    \   maxk.Add(a);\n            }\n        }\n        maxk.Sort();\n        return\
    \ maxk;", "        if(arr.Count <= k) return arr;\n        var ans = new List<long>();\n\
    \        var pq = new PriorityQueue();\n        for(var i = 0; i < arr.Count;\
    \ i++) pq.Insert(new Item(arr[i], i));\n        for(var i = 0; i < k; i++) ans.Add(pq.Pop().key);\n\
    \        return ans;", "        List<long> result = new List<long>();\n      \
    \  long m = arr.Max();\n        long i = 1;\n        while (m > 0 && k > 0) {\n\
    \            foreach (long a in arr) {\n                if (a / i % 10 > 0) {\n\
    \                    result.Add(a);\n                    k -= 1;\n           \
    \     }\n            }\n            i *= 10;\n        }\n        return result;",
  "        //   arr: given list of integers\n        //     k: length of list to return\n\
    \        // return: sorted list of length k with the maximum k numbers in arr\n\
    \        // Your code here\n        return arr;", "        List<long> negs = new\
    \ List<long>();\n        foreach (long x in arr) {\n            if (x < 0) {\n\
    \                negs.Add(x);\n            }\n        }\n        negs.Sort();\n\
    \        negs.Reverse();\n        List<long> res = new List<long>();\n       \
    \ long v = k;\n        for (long i = 0; i < v; i++) {\n            long max =\
    \ 0;\n            foreach (long x in arr) {\n                if (x > max) {\n\
    \                    max = x;\n                }\n            }\n            if\
    \ (max < 0) {\n                max = negs[0];\n                negs.RemoveAt(0);\n\
    \            }\n            res.Add(max);\n            arr.Remove(max);\n    \
    \    }\n        return res;", "        // >>> Maximum((new List<long>(new long[]{(long)-3L,\
    \ (long)-4L, (long)5L})), (3L))\n        // (new List<long>(new long[]{(long)-4L,\
    \ (long)-3L, (long)5L}))\n        // >>> Maximum((new List<long>(new long[]{(long)4L,\
    \ (long)-4L, (long)4L})), (2L))\n        // (new List<long>(new long[]{(long)4L,\
    \ (long)4L}))\n        // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L,\
    \ (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))\n        // (new\
    \ List<long>(new long[]{(long)2L}))\n        // >>> Maximum((new List<long>(new\
    \ long[]{(long)-3L, (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})),\
    \ (2L))\n        // (new List<long>(new long[]{(long)2L, (long)2L}))\n       \
    \ // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L,\
    \ (long)-1L, (long)-2L, (long)1L})), (3L))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)2L, (long)1L}))\n        // >>> Maximum((new List<long>(new long[]{(long)-3L,\
    \ (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (4L))\n   \
    \     // (new List<long>(new long[]{(long)2L, (long)2L, (long)1L, (long)1L}))\n\
    \        // >>> Maximum((new List<long>(new long[]", "        if (k == 0) {\n\
    \            return new List<long>();\n        }\n        List<long> result =\
    \ new List<long>();\n        for (long i = 0; i < k; i++) {\n            result.Add(arr[(int)i]);\n\
    \        }\n        result.Sort();\n        for (long i = k; i < arr.Count; i++)\
    \ {\n            for (long j = 0; j < k; j++) {\n                if (arr[(int)i]\
    \ > result[(int)j]) {\n                    result.RemoveAt((int)j);\n        \
    \            result.Add(arr[(int)i]);\n                    result.Sort();\n  \
    \                  break;\n                }\n            }\n        }\n     \
    \   return result;", "        // Given a list arr of integers and a positive integer\
    \ k, return a sorted list \n        // of length k with the maximum k numbers\
    \ in arr.\n        return Maximum_MaxHeap(arr, k);", '        return arr.OrderByDescending(x
    => x).Take((int)k).ToList();', "        // We use a max-heap to store the values.\
    \ This way, the top element will\n        // always be the largest number. In\
    \ order to find the k largest numbers\n        // we can just pop the top element\
    \ k times.\n        List<long> heap = new List<long>();\n        for (int i =\
    \ 0; i < arr.Count; i++) {\n            heap.Add(arr[i]);\n            SiftUp(heap,\
    \ i);\n        }\n        List<long> max = new List<long>();\n        for (int\
    \ i = 0; i < k; i++) {\n            max.Add(heap[0]);\n            heap[0] = heap[heap.Count\
    \ - 1];\n            heap.RemoveAt(heap.Count - 1);\n            SiftDown(heap,\
    \ 0);\n        }\n        return max;", "        // public static List<long> Maximum(List<long>\
    \ arr, long k) {\n        //   var r = arr.OrderByDescending(x => x).Take((int)k).ToList();\n\
    \        //   return r;\n        // }\n        // public static List<long> Maximum(List<long>\
    \ arr, long k) {\n        //   arr.Sort();\n        //   arr.Reverse();\n    \
    \    //   return arr.Take((int)k).ToList();\n        // }\n        // public static\
    \ List<long> Maximum(List<long> arr, long k) {\n        //   var maxArr = new\
    \ List<long>();\n        //   while (k > 0) {\n        //     var indexOfMax =\
    \ arr.IndexOf(arr.Max());\n        //     maxArr.Add(arr[indexOfMax]);\n     \
    \   //     arr.RemoveAt(indexOfMax);\n        //     k--;\n        //   }\n  \
    \      //   return maxArr;\n        // }\n        // public static List<long>\
    \ Maximum(List<long> arr, long k) {\n        //   return Enumerable.Range(0, (int)k).Select(x\
    \ => arr.Max()).ToList();\n        // }\n        // public static List<long> Maximum(List<long>\
    \ arr, long k) {\n        //   List<long> biggestElements = new List<long>();\n\
    \        //   while (k > 0) {\n        //     long currentMax = long.MinValue;\n\
    \        //     foreach (long num in arr) {\n        //       if (num > currentMax)\
    \ {\n        //         currentMax = num;\n        //       }\n        //    \
    \ }\n        //     biggestElements.Add(currentMax);\n        //     arr.Remove(currentMax);\n\
    \        //     k--;\n        //   }\n        //   return biggestElements;\n \
    \       // }\n        public static List<long> Maximum(List<long> arr, long k)\
    \ {\n          // return arr.OrderByDescending(x => x).Take((int)k).ToList();\n\
    \          List<long> biggestElements = new List<long>();\n          for (int",
  "        var result = arr.OrderByDescending(item => item).Take((int)k).ToList();\n\
    \        return result;", "        // TODO: Implement your solution here!\n  \
    \      return arr;", '        return (List<long>)arr.OrderByDescending(x => x).Take((int)k);',
  "        // TODO: Complete this function.\n        return new List<long>();", " \
    \       var minHeap = new MinHeap(arr.GetRange(0, (int)k));\n        for (var\
    \ i = k; i < arr.Count; i++) {\n            if (arr[(int)i] > minHeap.Peek())\
    \ {\n                minHeap.Replace(arr[(int)i]);\n            }\n        }\n\
    \        return minHeap.GetItems();", "        var res = new List<long>();\n \
    \       var heap = new System.Collections.Generic.SortedSet<long>();\n       \
    \ foreach (var elem in arr) {\n            heap.Add(elem);\n            if (heap.Count\
    \ > k) {\n                heap.Remove(heap.Min);\n            }\n        }\n \
    \       return new List<long>(heap);", "        if(arr.Count == 0) {\n       \
    \     return arr;\n        }\n        arr.Sort();\n        arr.Reverse();\n  \
    \      return arr.GetRange(0, (int)Math.Min(k, arr.Count));", '        return
    arr.OrderByDescending(a => a).Take((int)k).ToList();', "        if (k <= 0) {\n\
    \            return new List<long>();\n        }\n        if (k == 1) {\n    \
    \        return new List<long> { arr.Max() };\n        }\n        if (k == arr.Count)\
    \ {\n            return arr.OrderByDescending(x => x).ToList();\n        }\n \
    \       // arr.Sort((x, y) => x.CompareTo(y));\n        // return arr.Reverse().Take((int)k).ToList();\n\
    \        return Maximum(arr, k, 0, arr.Count - 1);", "        List<long> maxs\
    \ = new List<long>();\n        // Loop invariant: maxs contains the k largest\
    \ elements in arr[0 .. i-1]\n        for (int i = 0; i < arr.Count; i++) {\n \
    \           // Add the element if possible\n            bool added = false;\n\
    \            for (int j = 0; j < maxs.Count; j++) {\n                if (maxs[j]\
    \ < arr[i]) {\n                    maxs.Insert(j, arr[i]);\n                 \
    \   added = true;\n                    break;\n                }\n           \
    \ }\n            if (!added && maxs.Count < k) {\n                maxs.Add(arr[i]);\n\
    \            }\n            // Remove the smallest element if necessary\n    \
    \        if (maxs.Count > k) {\n                maxs.RemoveAt(maxs.Count - 1);\n\
    \            }\n        }\n        return maxs;", "        if (k < 1 || k > arr.Count)\
    \ {\n            throw new Exception(\"Invalid parameter\");\n        }\n    \
    \    arr.Sort();\n        arr.Reverse();\n        List<long> res = new List<long>();\n\
    \        foreach (long x in arr) {\n            res.Add(x);\n            if (res.Count\
    \ == k) {\n                break;\n            }\n        }\n        return res;",
  "        //  ***** Bad Solution *****\n        // \n        // var l = new List<long>();\n\
    \        // while (k > 0) {\n        //     long max = arr.Min();\n        //\
    \     foreach (var a in arr) {\n        //         if (a > max) {\n        //\
    \             max = a;\n        //         }\n        //     }\n        //   \
    \  l.Add(max);\n        //     arr.Remove(max);\n        //     k -= 1;\n    \
    \    // }\n        // return l;\n        \n        //  ***** Bad Solution *****\n\
    \        // \n        // var l = new List<long>();\n        // while (k > 0) {\n\
    \        //     l.Add(arr.Max());\n        //     arr.Remove(arr.Max());\n   \
    \     //     k -= 1;\n        // }\n        // return l;\n        \n        //\
    \  ***** Correct Solution *****\n        // \n        // return arr.OrderByDescending(a\
    \ => a).Take((int)k).ToList();\n        \n        //  ***** Correct Solution *****\n\
    \        // \n        var sortedList = arr.OrderByDescending(a => a).ToList();\n\
    \        return sortedList.GetRange(0, (int)k);", "        //////////////////////////////////////////////////////////\n\
    \        List<long> result = new List<long>();\n        //////////////////////////////////////////////////////////\n\
    \        if ((k == 0L)) {\n            return (result);\n        }\n        if\
    \ ((k == arr.Count)) {\n            return (arr);\n        }\n        int n =\
    \ (int) k;\n        List<long> r = new List<long>();\n        r.AddRange(arr);\n\
    \        r.Sort();\n        r.Reverse();\n        result.AddRange(r.GetRange(0,\
    \ n));\n        return (result);", "        List<long> result = new List<long>();\n\
    \        for (int i = 0; i < k; i++) {\n            result.Add(long.MinValue);\n\
    \        }\n        foreach (long x in arr) {\n            long i = 0;\n     \
    \       while (i < k && result[(int)i] > x) {\n                i++;\n        \
    \    }\n            result.Insert((int)i, x);\n            result.RemoveAt((int)k);\n\
    \        }\n        return result;", '        return arr.OrderByDescending(x =>
    x).Take((int)k).ToList();', "        var n = arr.Count;\n        var stack = new\
    \ Stack<long>();\n        var res = new List<long>();\n        var i = 0;\n  \
    \      while (i < n) {\n            while (stack.Count != 0 && arr[i] > stack.Peek()\
    \ && stack.Count + n - i > k) {\n                stack.Pop();\n            }\n\
    \            if (stack.Count < k) {\n                stack.Push(arr[i]);\n   \
    \         }\n            i += 1;\n        }\n        while (stack.Count != 0)\
    \ {\n            res.Add(stack.Pop());\n        }\n        res.Reverse();\n  \
    \      return res;", "        // your code here\n        return (new List<long>(new\
    \ long[]{}));", "        ////////////////////////////////////\n        // initial\
    \ solution, slow.\n        ////////////////////////////////////\n        // takes\
    \ too long\n        // return arr.OrderByDescending(x => x).Take((int)k).ToList();\n\
    \        ////////////////////////////////////\n        // Improved\n        ////////////////////////////////////\n\
    \        // take the first k elements, sort them, then go through the rest of\
    \ the list\n        // and if we find an element > than the minimum of the current\
    \ k, remove that\n        // element and insert it.\n        var l = new List<long>();\n\
    \        // take the first k elements.\n        l.AddRange(arr.Take((int)k));\n\
    \        // sort those elements.\n        l.Sort();\n        // the minimum element\
    \ in the sorted k.\n        var min = l[0];\n        for (var i = k; i < arr.Count;\
    \ i++) {\n            var e = arr[(int)i];\n            if (e > min) {\n     \
    \           // remove the minimum, then insert the new element.\n            \
    \    l.RemoveAt(0);\n                l.Add(e);\n                // resort.\n \
    \               l.Sort();\n                // and update the minimum.\n      \
    \          min = l[0];\n            }\n        }\n        // sort the list.\n\
    \        l.Sort();\n        // return it.\n        return l;", "        // We\
    \ can do this with a heap...\n        var heap = new MaxHeap<long>(k);\n     \
    \   foreach (var el in arr) {\n            heap.Insert(el);\n        }\n     \
    \   return heap.GetValues();", "        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        Debug.Assert(k >= 0L);\n \
    \       Debug.Assert(k <= arr.Count);\n        Debug.Assert(k <= 1000L);\n   \
    \     Debug.Assert(arr.All(v => v >= -1000L && v <= 1000L));\n        Debug.Assert(arr.Count\
    \ <= 1000L);\n        var result = new List<long>();\n        if (k > 0L) {\n\
    \            var heap = new BinaryHeap<long>();\n            for (var i = 0L;\
    \ i < k; i++) {\n                heap.Add(arr[(int)i]);\n            }\n     \
    \       for (var i = k; i < arr.Count; i++) {\n                if (arr[(int)i]\
    \ > heap.Peek()) {\n                    heap.Replace(arr[(int)i]);\n         \
    \       }\n            }\n            result = heap.GetElements();\n        }\n\
    \        return result;", '        return arr.OrderByDescending(x => x).Take((int)k).ToList();',
  "        if (k < 1 || k > arr.Count) {\n            return new List<long>();\n \
    \       }\n        // Heapify\n        long lastParentIndex = (k - 2) / 2;\n \
    \       for (long i = lastParentIndex; i >= 0; i--) {\n            Heapify(arr,\
    \ i, k);\n        }\n        // Replace min with arr[i] and heapify\n        for\
    \ (long i = k; i < arr.Count; i++) {\n            if (arr[i] > arr[0]) {\n   \
    \             arr[0] = arr[i];\n                Heapify(arr, 0, k);\n        \
    \    }\n        }\n        return arr.GetRange(0, (int)k);", "        var sort\
    \ = from x in arr orderby x descending select x;\n        return sort.Take((int)k).ToList();",
  "        arr.Sort();\n        List<long> result = new List<long>();\n        for\
    \ (long i = (long)(arr.Count() - k); i < arr.Count(); i++) {\n            result.Add(arr[(int)i]);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        int n = arr.Count;\n        if (k <= n) {\n            result = arr.OrderByDescending(i\
    \ => i).Take((int)k).ToList();\n        }\n        return result;", "        if\
    \ (k == 0) return new List<long>();\n        if (k == arr.Count) return arr;\n\
    \        var kth = kth_Largest(arr, k);\n        var res = new List<long>();\n\
    \        foreach (var i in arr) {\n            if (i >= kth) res.Add(i);\n   \
    \     }\n        return res;", "        SortedSet<long> s = new SortedSet<long>();\n\
    \        for (int i = 0; i < arr.Count; i++) {\n            s.Add(arr[i]);\n \
    \       }\n        List<long> result = new List<long>();\n        while (k > 0)\
    \ {\n            result.Add(s.Max);\n            s.Remove(s.Max);\n          \
    \  k--;\n        }\n        return result;", "        List<long> copy = new List<long>(arr);\n\
    \        copy.Sort();\n        copy.Reverse();\n        return copy.GetRange(0,\
    \ (int)k);", "        arr.Sort();\n        arr.Reverse();\n        return arr.GetRange(0,\
    \ Convert.ToInt32(k));", "        var result = new List<long>();\n        var\
    \ heap = new SortedList<long, List<long>>();\n        foreach (var element in\
    \ arr) {\n            if (heap.Count < k) {\n                if (!heap.ContainsKey(element))\
    \ {\n                    heap.Add(element, new List<long>());\n              \
    \  }\n                heap[element].Add(element);\n            } else {\n    \
    \            if (element >= heap.Keys[0]) {\n                    if (!heap.ContainsKey(element))\
    \ {\n                        heap.Add(element, new List<long>());\n          \
    \          }\n                    heap[element].Add(element);\n              \
    \      var last = heap.Keys[0];\n                    heap.RemoveAt(0);\n     \
    \               if (heap.Count != 0 && heap.Keys[0] == last) {\n             \
    \           heap.RemoveAt(0);\n                    }\n                }\n    \
    \        }\n        }\n        for (var i = heap.Count - 1; i >= 0; i--) {\n \
    \           var l = heap.Values[i];\n            foreach (var element in l) {\n\
    \                result.Add(element);\n            }\n        }\n        return\
    \ result;", "        if (arr.Count == k) {\n            return arr;\n        }\n\
    \        long[] sorted = (arr.OrderByDescending(x => x).ToArray());\n        return\
    \ (new List<long>(sorted)).GetRange(0, (int)k);", "        // Put your code here\n\
    \        return new List<long>();", "        var maxKHeap = new Heap<long>(k,\
    \ (a, b) => b.CompareTo(a));\n        foreach (var i in arr) {\n            maxKHeap.Insert(i);\n\
    \        }\n        return maxKHeap.GetAll();", '        // Your code goes here',
  '        return arr.OrderByDescending(x => x).Take((int)k).ToList();', "       \
    \ var l = new List<long>();\n        for (int i = 0; i < k; i++) {\n         \
    \   long maxValue = long.MinValue;\n            int maxIndex = -1;\n         \
    \   for (int j = 0; j < arr.Count; j++) {\n                if (maxValue < arr[j])\
    \ {\n                    maxValue = arr[j];\n                    maxIndex = j;\n\
    \                }\n            }\n            l.Add(maxValue);\n            arr.RemoveAt(maxIndex);\n\
    \        }\n        return l;", '        return null;', "        // return Maximum_Teacher(arr,\
    \ k);\n        return Maximum_Mine(arr, k);", "        // There are two methods\
    \ to solve this problem. \n        // The first method is to use a max-heap data\
    \ structure to get the maximum\n        // k elements. This would be very close\
    \ to linear time complexity.\n        // The second method uses a min-heap data\
    \ structure. First, create a min-heap \n        // with the first k elements of\
    \ the array. Then, iterate through the rest of \n        // the array, if the\
    \ value is larger than the min of the heap, pop the min of \n        // the heap\
    \ and push the value on to the heap. After the heap is populated, \n        //\
    \ pop each element and add it to the result list. This is more complex, but \n\
    \        // it's linear time complexity.\n        // We will use the second method\
    \ here.\n        List<long> max = new List<long>();\n        // If k is 0 or the\
    \ array is empty, return the empty list.\n        if (k == 0 || arr.Count == 0)\
    \ {\n            return max;\n        }\n        // Create a min-heap.\n     \
    \   BinaryHeap<long> heap = new BinaryHeap<long>(arr.Take((int)k).ToList(), new\
    \ MinHeapComparer<long>());\n        // Iterate through the rest of the array.\n\
    \        for (int i = (int)k; i < arr.Count; i++) {\n            if (arr[i] >\
    \ heap.Peek()) {\n                heap.Pop();\n                heap.Push(arr[i]);\n\
    \            }\n        }\n        // Add all elements to the result list.\n \
    \       while (heap.Count > 0) {\n            max.Add(heap.Pop());\n        }\n\
    \        // Sort the result list.\n        max.Sort();\n        // Return the\
    \ result list.\n        return max;", "        // >>> Maximum((new List<long>(new\
    \ long[]{(long)-3L, (long)-4L, (long)5L})), (3L))\n        // (new List<long>(new\
    \ long[]{(long)-4L, (long)-3L, (long)5L}))\n        // >>> Maximum((new List<long>(new\
    \ long[]{(long)4L, (long)-4L, (long)4L})), (2L))\n        // (new List<long>(new\
    \ long[]{(long)4L, (long)4L}))\n        // >>> Maximum((new List<long>(new long[]{(long)-3L,\
    \ (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (1L))\n   \
    \     // (new List<long>(new long[]{(long)2L}))\n        // Note:\n        //\
    \ 1. The length of the list will be in the range of [1, 1000].\n        // 2.\
    \ The elements in the list will be in the range of [-1000, 1000].\n        //\
    \ 3. 0 <= k <= len(arr)\n        List<long> res = new List<long>();\n        long[]\
    \ a = arr.ToArray();\n        Sorting.TopK(a, a.Length, k);\n        for (int\
    \ i = 0; i < k; i++) {\n            res.Add(a[i]);\n        }\n        return\
    \ res;", '        return new List<long>();', "        var ls = arr.GetRange(0,\
    \ (int)k);\n        ls.Sort();\n        for (int i = (int)k; i < arr.Count; i++)\
    \ {\n            if (arr[i] > ls[0]) {\n                ls.RemoveAt(0);\n    \
    \            ls.Add(arr[i]);\n                ls.Sort();\n            }\n    \
    \    }\n        return ls;", "        // Your code here\n        // iterate over\
    \ the list and use priority queue to find the max k\n        // O(n * k * log\
    \ k)\n        // HeapSort() for O(n * log n)\n        // QuickSelect for O(n)\n\
    \        return null;", "        if (k == 0) {\n            return new List<long>();\n\
    \        }\n        var heap = new BinaryHeap<long>();\n        foreach (var item\
    \ in arr) {\n            heap.Push(item);\n        }\n        var res = new List<long>();\n\
    \        for (int i = 0; i < k; i++) {\n            res.Add(heap.Pop());\n   \
    \     }\n        return res;", "        var result = new List<long>();\n     \
    \   var arrlen = arr.Count;\n        for (long index = 0; index < k; index++)\
    \ {\n            var max = (long)-1000000000L;\n            var max_index = (long)-1L;\n\
    \            for (long i = 0; i < arrlen; i++) {\n                if (arr[(int)i]\
    \ > max) {\n                    max = arr[(int)i];\n                    max_index\
    \ = i;\n                }\n            }\n            result.Add(max);\n     \
    \       arr[(int)max_index] = (long)-1000000000L;\n        }\n        return result;",
  "        // Build max heap\n        for (int i = arr.Count / 2; i >= 0; i--) {\n\
    \            Heapify(arr, i, arr.Count);\n        }\n        // Remove all elements\
    \ greater than k\n        for (int i = arr.Count - 1; i >= k; i--) {\n       \
    \     Swap(arr, 0, i);\n            Heapify(arr, 0, i);\n        }\n        return\
    \ arr.GetRange(0, (int)k);", "        SortedSet<long> set = new SortedSet<long>();\n\
    \        foreach (long el in arr) {\n            set.Add(el);\n        }\n   \
    \     List<long> result = new List<long>();\n        for (int i = 0; i < k; i++)\
    \ {\n            result.Add(set.Max);\n            set.Remove(set.Max);\n    \
    \    }\n        return result;", "        // *** Need to account for duplicates.\
    \ ***\n        // *** Need to account for k > len(arr). ***\n        // *** Need\
    \ to account for k = 0. ***\n        // Take the k largest elements.\n       \
    \ // Sort them in descending order.\n        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        // Convert the array to a\
    \ priority queue.\n        PriorityQueue<long> pq = new PriorityQueue<long>();\n\
    \        foreach (long num in arr) {\n            pq.Insert(num);\n        }\n\
    \        // Build the output.\n        List<long> output = new List<long>();\n\
    \        for (long i = 0; i < k; i++) {\n            output.Add(pq.Pop());\n \
    \       }\n        return output;", "        // Your code goes here.\n       \
    \ return arr;", "        // Time: O(n lg n), Space: O(n)\n        return arr.OrderByDescending(x\
    \ => x).Take((int)k).ToList();", '        return arr;', "        List<long> maxHeap\
    \ = arr.GetRange(0, (int)k);\n        for (int i = (int)k; i < arr.Count; i++)\
    \ {\n            long m = maxHeap[0];\n            if (arr[i] > m) {\n       \
    \         maxHeap[0] = arr[i];\n                AdjustMaxHeap(maxHeap, 0);\n \
    \           }\n        }\n        maxHeap.Sort();\n        return maxHeap;", " \
    \       // Step 1: We define a function that returns a list of length k.\n   \
    \     //         The function takes in a list and a k.\n        //         The\
    \ function is tail recursive.\n        // Step 2: We create a helper function\
    \ whose type is \n        //         ((List<long>, long) => long) => (List<long>,\
    \ long) => List<long>.\n        //         The helper function takes in a list,\
    \ a k, and a function that takes in a list and a k and returns a long.\n     \
    \   //         The function is tail recursive.\n        // Step 3: We create a\
    \ function called max_comparator.\n        //         max_comparator has type\
    \ (List<long>, long) => long.\n        //         max_comparator takes in a list\
    \ and a k and returns a long.\n        //         max_comparator returns the maximum\
    \ value from the list.\n        // Step 4: We create a function called min_comparator.\n\
    \        //         min_comparator has type (List<long>, long) => long.\n    \
    \    //         min_comparator takes in a list and a k and returns a long.\n \
    \       //         min_comparator returns the minimum value from the list.\n \
    \       // Step 5: We create a variable called new_arr and set it equal to the\
    \ \n        //         the result of calling the helper function with inputs arr,\
    \ k, and max_comparator.\n        // Step 6: We return new_arr.\n        //  \
    \       This is the end of our function.\n        long len = (long)arr.Count;\n\
    \        long max_comparator(List<long> arr, long k) {\n            long max =\
    \ arr[0];\n            for (long i = 1; i < len; i++) {\n                if (arr[(int)i]\
    \ > max) {\n                    max = arr[(int)i];\n                }\n      \
    \      }\n            return max;\n        }\n        long min_comparator(List<long>\
    \ arr, long k) {\n            long min = arr[0];\n            for (long i = 1;\
    \ i < len; i++) {\n                if (arr[(int)i] < min) {\n                \
    \    min = arr[(int)i];", "        // Insert the C# code here \n        long[]\
    \ heap = new long[k];\n        for (int i = 0; i < k; i++) {\n            heap[i]\
    \ = long.MinValue;\n        }\n        foreach (long e in arr) {\n           \
    \ if (e <= heap[0]) {\n                continue;\n            }\n            heap[0]\
    \ = e;\n            int p = 0;\n            while (true) {\n                int\
    \ l = 2 * p + 1;\n                int r = 2 * p + 2;\n                int c =\
    \ p;\n                if (l < k && heap[l] < heap[c]) {\n                    c\
    \ = l;\n                }\n                if (r < k && heap[r] < heap[c]) {\n\
    \                    c = r;\n                }\n                if (c == p) {\n\
    \                    break;\n                }\n                long t = heap[c];\n\
    \                heap[c] = heap[p];\n                heap[p] = t;\n          \
    \      p = c;\n            }\n        }\n        return new List<long>(heap);",
  "        if (k < 1)\n            return new List<long>();\n        if (k > arr.Count)\n\
    \            return arr;\n        if (k == arr.Count)\n            return arr.OrderByDescending(x\
    \ => x).ToList();\n        var minVal = arr.Min();\n        var maxVal = arr.Max();\n\
    \        var minValAbs = Math.Abs(minVal);\n        arr = arr.Select(x => x +\
    \ minValAbs).ToList();\n        var result = new long[k];\n        for (var i\
    \ = 0; i < k; i++)\n            result[i] = arr[i];\n        for (var i = k; i\
    \ < arr.Count; i++) {\n            var m = FindMin(result);\n            if (arr[i]\
    \ > result[m])\n                result[m] = arr[i];\n        }\n        return\
    \ result.Select(x => x - minValAbs).OrderByDescending(x => x).ToList();", '        return
    new List<long>();', "        if (k == 0) return new List<long>();\n        if\
    \ (k == arr.Count) return arr;\n        List<long> ans = new List<long>();\n \
    \       long current_min = Math.Min(arr[0], arr[1]);\n        long next_min =\
    \ current_min;\n        int to_remove = -1;\n        for (int i = 2; i < arr.Count;\
    \ i++) {\n            long elem = arr[i];\n            if (current_min < elem)\
    \ {\n                // add the element\n                arr.RemoveAt(i);\n  \
    \              arr.Add(current_min);\n                current_min = elem;\n  \
    \              to_remove = i;\n            } else if (next_min < elem) {\n   \
    \             // add the element\n                arr.RemoveAt(i);\n         \
    \       arr.Add(next_min);\n                next_min = elem;\n               \
    \ to_remove = i;\n            }\n        }\n        if (to_remove == -1) {\n \
    \           arr.Reverse();\n            ans.AddRange(arr.GetRange(0, (int)k));\n\
    \        } else {\n            ans.AddRange(arr.GetRange(to_remove + 1, (int)k));\n\
    \        }\n        return ans;", "        int n = arr.Count;\n        if (k >\
    \ n) k = n;\n        return arr.OrderByDescending(x => x).Take((int)k).ToList();",
  "        // Python code:\n        // def maximum(arr, k):\n        //     return\
    \ sorted(arr)[-k:]\n        return arr.OrderByDescending(x => x).Take((int)k).ToList();",
  "        // TODO: Implement your solution here.\n        return arr;", "       \
    \ Func<List<long>, long, List<long>> MaximumHelper = null;\n        MaximumHelper\
    \ = (a, n) => {\n            if (n == 0) {\n                return new List<long>();\n\
    \            }\n            if (a.Count == 1) {\n                return a;\n \
    \           }\n            long pivot = a[0];\n            List<long> left = new\
    \ List<long>();\n            List<long> right = new List<long>();\n          \
    \  for (long i = 1; i < a.Count; i++) {\n                if (a[(int)i] > pivot)\
    \ {\n                    left.Add(a[(int)i]);\n                } else {\n    \
    \                right.Add(a[(int)i]);\n                }\n            }\n   \
    \         if (left.Count >= n) {\n                return MaximumHelper(left, n);\n\
    \            } else {\n                List<long> left_res = MaximumHelper(left,\
    \ left.Count);\n                List<long> right_res = MaximumHelper(right, n\
    \ - left.Count);\n                left_res.Add(pivot);\n                left_res.AddRange(right_res);\n\
    \                return left_res;\n            }\n        };\n        return MaximumHelper(arr,\
    \ k);", "        // TODO: Implement this function.\n        return null;", " \
    \       if(arr.Count == 0) {\n            throw new ArgumentException(\"Empty\
    \ list.\");\n        }\n        if(k < 0 || k > arr.Count) {\n            throw\
    \ new ArgumentException(\"Expected 0 <= k <= len(arr).\");\n        }\n      \
    \  return arr.Take((int)k).OrderByDescending(n => n).ToList();", "        // return\
    \ arr.OrderByDescending(x => x).Take((int)k).ToList();\n        // return arr.OrderByDescending(x\
    \ => x).Take((int)k).ToList();\n        if (k == 0) {\n            return (new\
    \ List<long>(new long[] {}));\n        }\n        long[] subarr = arr.GetRange(0,\
    \ (int)k).ToArray();\n        Array.Sort(subarr);\n        foreach (long v in\
    \ arr.GetRange((int)k, arr.Count - (int)k)) {\n            int ind = (int)k -\
    \ 1;\n            while (ind >= 0 && subarr[ind] < v) {\n                if (ind\
    \ == (int)k - 1) {\n                    subarr[ind] = v;\n                } else\
    \ {\n                    subarr[ind + 1] = subarr[ind];\n                    subarr[ind]\
    \ = v;\n                }\n                ind -= 1;\n            }\n        }\n\
    \        return subarr.ToList();", "        if(arr.Count == 0) {\n           \
    \ return new List<long>();\n        } else if(arr.Count == 1) {\n            return\
    \ arr;\n        } else {\n            // Maximum() should be running in O(k*log(n))\
    \ time, where n is the length of the array.\n            //\n            // This\
    \ is a classic problem which can be solved with a heap.\n            // Since\
    \ we just want the largest k elements we can use a max heap.\n            //\n\
    \            // In C#'s System.Collections.Generic.Heap there is no MaxHeap,\n\
    \            // however we can use a MinHeap with the negative values instead\
    \ of the positive ones.\n            //\n            // For example, if the input\
    \ is [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n            // then the MinHeap will be\
    \ [-0, -1, -2, -3, -4, -5, -6, -7, -8, -9].\n            //\n            // To\
    \ keep track of the items in the MinHeap we use the List arr2.\n            //\n\
    \            // If we then want to get the Max of the first k items from the input,\n\
    \            // then we sort the first k items from arr2 and negate the values.\n\
    \            //\n            // To prove that this runs in O(k*log(n)) time we\
    \ need to show that\n            // O(k + (n-k) + k*log(k)) = O(k*log(n))\n  \
    \          //\n            // O(k + (n-k) + k*log(k))\n            // = O(k) +\
    \ O(n-k) + O(k*log(k))\n            // = O(k) + O(n) + O(k*log(k)) (since O(n-k)\
    \ = O(n))\n            // = O(k) + O(n) + O(k*log(k)) (since O(n) is a constant)\n\
    \            // = O(k*log(k)) + O(n) + O(k*log(k))\n            // = O(k*log(k))\
    \ + O(k*log(k)) + O(", '        return arr.OrderByDescending(x => x).Take((int)k).ToList();',
  "        // Your code here\n        throw new NotImplementedException();", "   \
    \     // we use a max-heap to store the maximum k numbers in arr.\n        //\
    \ this is O(N + K*logK) in time and O(K) in space.\n        // if we don't care\
    \ about maintaining order, we can use a map to keep track\n        // of the maximum\
    \ k elements, which is O(N) in time and O(K) in space.\n        // that would\
    \ be a cool way to write the solution and then compare the\n        // performance.\n\
    \        var heap = new SortedSet<long>();\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            heap.Add(arr[i]);\n            if (heap.Count > k) {\n \
    \               heap.Remove(heap.Min);\n            }\n        }\n        var\
    \ res = new List<long>();\n        foreach (var item in heap) {\n            res.Add(item);\n\
    \        }\n        return res;", '        return null;', "        List<long>\
    \ ret = new List<long>();\n        if (k == 0) {\n            return ret;\n  \
    \      }\n        if (k > arr.Count) {\n            ret.AddRange(arr);\n     \
    \       return ret;\n        }\n        arr.Sort();\n        return arr.GetRange((int)(arr.Count\
    \ - k), (int)k);", "        List<long> maximum = new List<long>();\n        for\
    \ (long i = 0; i < k; i++) {\n            maximum.Add(arr[i]);\n        }\n  \
    \      maximum.Sort();\n        long maximumSize = maximum.Count;\n        for\
    \ (long i = k; i < arr.Count; i++) {\n            long insertIndex = 0;\n    \
    \        while (insertIndex < maximumSize && arr[i] > maximum[insertIndex]) {\n\
    \                insertIndex += 1;\n            }\n            if (insertIndex\
    \ < maximumSize) {\n                maximum.Insert(Convert.ToInt32(insertIndex),\
    \ arr[i]);\n                maximum.RemoveAt(Convert.ToInt32(maximumSize));\n\
    \            }\n        }\n        return maximum;", "        IEnumerable<long>\
    \ l = arr.OrderByDescending(x => x).Take((int)k);\n        return l.ToList();",
  "        List<long> ret = new List<long>();\n        // Create a priority queue\
    \ that pops out the smallest element each time\n        // Initialize it with\
    \ the first k elements\n        PriorityQueue<long> max_pq = new PriorityQueue<long>();\n\
    \        for (int i = 0; i < k; i++) {\n            max_pq.Push(arr[i]);\n   \
    \     }\n        // For each element after the first k elements, add it to the\
    \ priority queue\n        // and remove the smallest element\n        for (int\
    \ i = k; i < arr.Count; i++) {\n            max_pq.Push(arr[i]);\n           \
    \ max_pq.Pop();\n        }\n        // Pop the elements out of the priority queue,\
    \ which are the k largest elements\n        for (int i = 0; i < k; i++) {\n  \
    \          ret.Add(max_pq.Pop());\n        }\n        return ret;", "        //\
    \ FIND MAXIMUM K INTEGERS IN ARR\n        arr.Sort();\n        arr.Reverse();\n\
    \        arr = arr.GetRange(0, (int)k);\n        return arr;", "        int n\
    \ = arr.Count;\n        // create a max heap and insert k elements from arr\n\
    \        var heap = new SortedSet<long>();\n        for (int i = 0; i < k; i++)\
    \ {\n            heap.Add(arr[i]);\n        }\n        // for each remaining element\
    \ in arr, insert it into the heap if it's larger than\n        // the current\
    \ smallest element\n        for (int i = k; i < n; i++) {\n            if (arr[i]\
    \ > heap.Min) {\n                heap.Remove(heap.Min);\n                heap.Add(arr[i]);\n\
    \            }\n        }\n        return heap.ToList();", '        throw new
    NotImplementedException();', "        Func<long, long, bool> compare = delegate(long\
    \ a, long b) {\n            return a < b;\n        };\n        HeapSort<long>\
    \ sorter = new HeapSort<long>(arr, compare);\n        arr = sorter.Sort().Take((int)k).ToList();\n\
    \        arr.Reverse();\n        return arr;", "        // Declare a variable\
    \ called 't' to store the length of the input list.\n        long t = arr.Count;\n\
    \        // If the length of the input list is larger than the given length k,\n\
    \        // set the length of the input list to the given length k.\n        if\
    \ (arr.Count > k) {\n            t = k;\n        }\n        // Declare a variable\
    \ called 'list' to store the list of maximum numbers.\n        List<long> list\
    \ = new List<long>();\n        // Declare a variable called 'x' to store the index\
    \ of the maximum number in the input list.\n        long x = 0;\n        // Declare\
    \ a variable called 'temp' to store the maximum number in the input list.\n  \
    \      long temp = 0;\n        // Iterate from 0 to the length of the input list.\n\
    \        for (long i = 0; i < t; i++) {\n            // Initialize the maximum\
    \ number to the first element in the input list.\n            temp = arr[0];\n\
    \            // Iterate from 0 to the length of the input list.\n            for\
    \ (long j = 0; j < arr.Count; j++) {\n                // If the current element\
    \ is larger than the temporary maximum number,\n                // set the maximum\
    \ number to the current element.\n                if (arr[(int)j] > temp) {\n\
    \                    temp = arr[(int)j];\n                    // Set the index\
    \ of the maximum number to the current index.\n                    x = j;\n  \
    \              }\n            }\n            // Append the maximum number to the\
    \ list of maximum numbers.\n            list.Add(temp);\n            // Remove\
    \ the maximum number from the input list.\n            arr.RemoveAt((int)x);\n\
    \        }\n        // Return the list of maximum numbers.\n        return list;",
  '        throw new NotImplementedException();', "        List<long> result = new\
    \ List<long>();\n        if (arr.Count < k) {\n            return result;\n  \
    \      }\n        for (long i = 0; i < k; i++) {\n            long max = arr[0];\n\
    \            for (long j = 1; j < arr.Count; j++) {\n                if (arr[(int)j]\
    \ > max) {\n                    max = arr[(int)j];\n                }\n      \
    \      }\n            result.Add(max);\n            arr.Remove(max);\n       \
    \ }\n        return result;", "        // Fill in the code here\n        return\
    \ arr;", "        var result = new List<long>();\n        var maxHeap = new MaxHeap<long>(arr.Count);\n\
    \        foreach (var a in arr) {\n            maxHeap.Add(a);\n        }\n  \
    \      for (int i = 0; i < k; i++) {\n            result.Add(maxHeap.DeleteMax());\n\
    \        }\n        return result;", "        arr.Sort();\n        arr.Reverse();\n\
    \        return arr.GetRange(0, (int)k);", "        Debug.Assert(arr.Count > 0);\n\
    \        Debug.Assert(k > 0);\n        Debug.Assert(k <= arr.Count);\n       \
    \ List<long> a = new List<long>(arr);\n        a.Sort();\n        a.Reverse();\n\
    \        return a.GetRange(0, (int)k);", "        // 1. Sort array.\n        //\
    \ 2. Take elements from end of array.\n        arr.Sort();\n        return arr.GetRange((int)(arr.Count\
    \ - k), (int)k);", "        // We can just sort the array with \n        // C#\
    \ List<T>.Sort() method, which is a stable sort.\n        arr.Sort();\n      \
    \  // This will take O(n*log(n)) time.\n        // Now we only want the last k\
    \ elements.\n        // They will be at index arr.Count - k to arr.Count - 1.\n\
    \        // So we create a new list in that range.\n        // This will take\
    \ O(k) time.\n        return new List<long>(arr.GetRange((int)(arr.Count - k),\
    \ (int)k));", "        // === IMPLEMENTATION ===\n        return arr;", "    \
    \    List<long> d = new List<long>();\n        foreach (long x in arr) {\n   \
    \         if (d.Count == 0) {\n                d.Add(x);\n            } else {\n\
    \                int i = d.Count - 1;\n                while (i >= 0 && x > d[i])\
    \ {\n                    i -= 1;\n                }\n                d.Insert(i\
    \ + 1, x);\n                if (d.Count > k) {\n                    d.RemoveAt(d.Count\
    \ - 1);\n                }\n            }\n        }\n        return d;", "  \
    \      if (k == 0L) {\n            return new List<long>();\n        }\n     \
    \   else if (k >= ((long)arr.Count)) {\n            return arr.OrderByDescending(x\
    \ => x).ToList();\n        }\n        else {\n            var max = arr.OrderByDescending(x\
    \ => x).Take((int)k).ToList();\n            foreach (var item in arr) {\n    \
    \            if (item < max.Last()) {\n                    max.Add(item);\n  \
    \                  max = max.OrderByDescending(x => x).Take((int)k).ToList();\n\
    \                }\n            }\n            return max;\n        }", "    \
    \    if(k < 1)\n            return new List<long>();\n        if(k > arr.Count)\n\
    \            k = arr.Count;\n        return arr.OrderByDescending(x => x).Take((int)k).ToList();",
  "        // Let's define a mergeSort procedure, with the property that for a given\n\
    \        // pivot, it partitions the array into exactly two parts: those\n   \
    \     // in front of the pivot and those equal to or after the pivot.\n      \
    \  // The mergeSort procedure will return the index of the pivot.\n        //\n\
    \        // We can then recursively apply mergeSort to the first part of the list\n\
    \        // until we get a segment of the list of size k. If the returned index\n\
    \        // is less than k, it means that the kth element was in that segment\
    \ and\n        // we recurse down the segment. If the returned index is greater\
    \ than or\n        // equal to k, it means that the kth element was in the second\
    \ segment and\n        // we recurse down the second segment. This process ends\
    \ after log(n)\n        // iterations.\n        // \n        // Asymptotic complexity:\
    \ O(n log(n))\n        // Space complexity: O(1)\n        Func<List<long>, long,\
    \ long, long> mergeSort = null;\n        mergeSort = (List<long> list, long left,\
    \ long right) => {\n            if (left < right) {\n                // Arbitrarily\
    \ choose the leftmost element as the pivot\n                long pivot = list[left];\n\
    \                // Put each element that is greater than the pivot in front\n\
    \                // of the pivot, and each element that is less than or equal\n\
    \                // to the pivot in the back of the pivot\n                long\
    \ slow = left;\n                for (long fast = left + 1; fast <= right; fast++)\
    \ {\n                    if (list[fast] > pivot) {\n                        slow++;\n\
    \                        if (slow != fast) {\n                            long\
    \ temp = list[slow];\n                            list[slow] = list[fast];\n \
    \                           list[fast] = temp;\n                        }\n  \
    \                  }\n                }\n                // Swap the pivot with\
    \ the first element after the pivot\n                if (slow != left) {\n   \
    \                 list[left] = list[slow];\n                    list[slow] = pivot;\n\
    \                }\n                // Return the index of the pivot\n       \
    \         return slow;\n            }\n            return left;\n        };\n\
    \        // Define a function that recursively uses mergeSort to find the kth\
    \ element", "        List<long> res = new List<long>();\n        for (int i =\
    \ 0; i < k; i++) {\n            long curr = arr[0];\n            for (int j =\
    \ 1; j < arr.Count; j++) {\n                if (arr[j] > curr) {\n           \
    \         curr = arr[j];\n                }\n            }\n            res.Add(curr);\n\
    \            arr.Remove(curr);\n        }\n        return res;", "        // Insert\
    \ arr[0] into a max heap.\n        // Push the rest of the elements into the heap,\
    \ one at a time.\n        // When the heap has k elements, remove the max.\n \
    \       // Heapify.\n        // Return the heap.\n        if ((k < 1L) || (k >\
    \ arr.Count)) {\n            throw new System.Exception(\"Invalid k\");\n    \
    \    }\n        if (k == 1L) {\n            long max = arr[0];\n            foreach\
    \ (long x in arr) {\n                if (x > max) {\n                    max =\
    \ x;\n                }\n            }\n            return new List<long>(new\
    \ long[]{max});\n        }\n        List<long> heap = new List<long>(new long[]{arr[0]});\n\
    \        for (int i = 1; i < arr.Count; i++) {\n            heap.Add(arr[i]);\n\
    \            int j = heap.Count - 1;\n            while (true) {\n           \
    \     int parent_idx = (j - 1) / 2;\n                if (parent_idx < 0) {\n \
    \                   break;\n                }\n                if (heap[j] > heap[parent_idx])\
    \ {\n                    long tmp = heap[j];\n                    heap[j] = heap[parent_idx];\n\
    \                    heap[parent_idx] = tmp;\n                    j = parent_idx;\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if (heap.Count > k) {\n                heap[0] = heap[heap.Count\
    \ - 1];\n                heap.RemoveAt(heap.Count - 1);\n                j = 0;\n\
    \                while (true) {\n                    int left_idx = 2 * j + 1;\n\
    \                    int right_idx = 2 * j + 2;\n                    if (left_idx\
    \ >= heap.Count) {\n                        break;\n                    }\n  \
    \                  if (right_idx >= heap.Count) {\n                        if\
    \ (heap[left_idx] > heap[j]) {\n                            long tmp = heap[left_idx];\n\
    \                            heap[left_idx] = heap[j];\n                     \
    \       heap[j] = tmp", "        // TODO\n        List<long> result = new List<long>();\n\
    \        arr.Sort();\n        for (int i = arr.Count - 1; i >= 0; i--) {\n   \
    \         if (result.Count < k) {\n                result.Add(arr[i]);\n     \
    \       }\n        }\n        return result;", '        return null;', '        return
    arr.OrderByDescending(e => e).Take((int)k).ToList();', '        return MaximumSolution(arr,
    k);', "        var ans = new List<long>();\n        if (k > arr.Count) {\n   \
    \         return arr;\n        }\n        for (var i = 0; i < k; i++) {\n    \
    \        var max = long.MinValue;\n            for (var j = 0; j < arr.Count;\
    \ j++) {\n                var e = arr[j];\n                if (e > max) {\n  \
    \                  max = e;\n                }\n            }\n            ans.Add(max);\n\
    \            arr.Remove(max);\n        }\n        return ans;", "        var n\
    \ = arr.Count;\n        var soln = new List<long>();\n        var partarr = new\
    \ List<long>();\n        for (int i = 0; i < n; i++) {\n            partarr.Add(arr[i]);\n\
    \            for (int j = partarr.Count - 1; j > 0; j--) {\n                if\
    \ (partarr[j] > partarr[j - 1]) {\n                    var t = partarr[j];\n \
    \                   partarr[j] = partarr[j - 1];\n                    partarr[j\
    \ - 1] = t;\n                }\n            }\n            if (i >= k - 1) {\n\
    \                soln.Add(partarr[k - 1]);\n                partarr.RemoveAt(0);\n\
    \            }\n        }\n        return soln;", '        throw new NotImplementedException();',
  "        arr.Sort();\n        arr.Reverse();\n        return arr.GetRange(0,(int)k);",
  "        List<long> l = new List<long>();\n        arr.Sort();\n        arr.Reverse();\n\
    \        for (int i = 0; i < k; i++) {\n            l.Add(arr[i]);\n        }\n\
    \        return l;", "        List<long> answer = new List<long>();\n        var\
    \ tempList = new List<long>(arr);\n        tempList.Sort();\n        tempList.Reverse();\n\
    \        for (int i = 0; i < k; i++) {\n            answer.Add(tempList[i]);\n\
    \        }\n        return answer;", "        // Fill this in.\n        List<long>\
    \ arr1 = new List<long>();\n        long j = 1;\n        while (arr1.Count < k)\
    \ {\n            foreach (long i in arr) {\n                if (i > j) {\n   \
    \                 arr1.Add(i);\n                }\n            }\n           \
    \ j += 1;\n        }\n        return arr1;", '        return null;', "       \
    \ List<long> result = new List<long>();\n        if (arr.Count == 0) {\n     \
    \       return result;\n        }\n        if (arr.Count == 1) {\n           \
    \ result.Add(arr[0]);\n            return result;\n        }\n        if (arr.Count\
    \ == 2) {\n            long a = arr[0];\n            long b = arr[1];\n      \
    \      if (a >= b) {\n                result.Add(a);\n                result.Add(b);\n\
    \            } else {\n                result.Add(b);\n                result.Add(a);\n\
    \            }\n            return result;\n        }\n        Dictionary<long,\
    \ int> visited = new Dictionary<long, int>();\n        long idx = (long)0L;\n\
    \        long size = (long)arr.Count;\n        while (result.Count < k) {\n  \
    \          int add = 1;\n            if (visited.ContainsKey(idx)) {\n       \
    \         add = visited[idx];\n            }\n            visited[idx] = add +\
    \ 1;\n            result.Add(arr[(int)idx]);\n            idx = idx + (long)1L;\n\
    \            if (idx >= size) {\n                idx = (long)0L;\n           \
    \ }\n        }\n        return result;", "        int ik = (int)k;\n        arr.Sort();\n\
    \        arr.Reverse();\n        return arr.GetRange(0, ik);", "        if (k\
    \ < 1 || k > arr.Count) throw new System.ArgumentException(\"k must be between\
    \ 1 and arr.Count\");\n        if (k == arr.Count) return arr;\n        var res\
    \ = arr.OrderByDescending(c => c).Take((int)k).ToList();\n        return res;",
  "        // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)-4L, (long)5L})),\
    \ (3L))\n        // (new List<long>(new long[]{(long)-4L, (long)-3L, (long)5L}))\n\
    \        // >>> Maximum((new List<long>(new long[]{(long)4L, (long)-4L, (long)4L})),\
    \ (2L))\n        // (new List<long>(new long[]{(long)4L, (long)4L}))\n       \
    \ // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L,\
    \ (long)-1L, (long)-2L, (long)1L})), (1L))\n        // (new List<long>(new long[]{(long)2L}))\n\
    \        // >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L,\
    \ (long)2L, (long)-1L, (long)-2L, (long)1L})), (2L))\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)2L}))\n        // >>> Maximum((new List<long>(new long[]{(long)-3L,\
    \ (long)2L, (long)1L, (long)2L, (long)-1L, (long)-2L, (long)1L})), (3L))\n   \
    \     // (new List<long>(new long[]{(long)2L, (long)2L, (long)1L}))\n        //\
    \ >>> Maximum((new List<long>(new long[]{(long)-3L, (long)2L, (long)1L, (long)2L,\
    \ (long)-1L, (long)-2L, (long)1L})), (4L))\n        // (new List<long>(new long[]{(long)2L,\
    \ (long)2L, (long)1L, (long)1L}))\n        // >>> Maximum((new List<long>(new\
    \ long[]"]
stop_tokens:
- "\n    }\n"
