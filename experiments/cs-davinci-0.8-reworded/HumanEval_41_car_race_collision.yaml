name: HumanEval_41_car_race_collision
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Imagine a road that's a perfectly straight infinitely long line.\n\
  \    // n cars are driving left to right;  simultaneously, a different set of n\
  \ cars\n    // are driving right to left.   The two sets of cars start out being\
  \ very far from\n    // each other.  All cars move in the same speed.  Two cars\
  \ are said to collide\n    // when a car that's moving left to right hits a car\
  \ that's moving right to left.\n    // However, the cars are infinitely sturdy and\
  \ strong; as a result, they continue moving\n    // in their trajectory as if they\
  \ did not collide.\n    // This function outputs the number of such collisions.\n\
  \    public static long CarRaceCollision(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(CarRaceCollision((2L))\
  \ == (4L));\n    Debug.Assert(CarRaceCollision((3L)) == (9L));\n    Debug.Assert(CarRaceCollision((4L))\
  \ == (16L));\n    Debug.Assert(CarRaceCollision((8L)) == (64L));\n    Debug.Assert(CarRaceCollision((10L))\
  \ == (100L));\n    }\n\n}\n"
completions: ["        // This function returns the number of collisions.\n      \
    \  // You must fill this in.  The default implementation is just to return 0;\n\
    \        // that is not what you want.\n        long[] a = new long[n];\n    \
    \    long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n        \
    \    a[i] = i;\n            b[i] = n - i - 1;\n        }\n        int ans = 0;\n\
    \        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++)\
    \ {\n                if (a[i] == b[j]) ans++;\n            }\n        }\n    \
    \    return ans;", "        // I'm pretty sure I'm right but this is an O(n^2)\
    \ solution that times out.\n        // The O(n log n) solution is nontrivial.\n\
    \n        // If a car #i (1 <= i <= n) moving left to right hits a car moving\
    \ right to left,\n        // then it hits the car that has number k, where k =\
    \ n - i + 1.\n        // For example, car #1 from the left to right set collides\
    \ with car #n from the right to left set.\n        // From this observation, we\
    \ get the following algorithm:\n        // Sort the left to right cars and the\
    \ right to left cars by their positions.\n        // We then start at the first\
    \ left to right car, and look for its partner right to left car.\n        // When\
    \ we find that car, we count the number of left to right cars (that have not yet\
    \ been paired)\n        // between the car we're looking at and the partner car\
    \ we just found.\n        // For example, suppose n = 5 and the cars are positioned\
    \ as follows:\n        //\n        //        RTRTR\n        // LTLTL\n       \
    \ //\n        // The left to right cars are ordered as 4, 1, 5 and the right to\
    \ left cars are ordered as 2, 3.\n        // We begin with the left to right car\
    \ #4, and we count the number of left to right cars between it\n        // and\
    \ the car #3 that it will collide with.  In this case, there are 2 such cars (1\
    \ and 5).\n        // We then move on to the left to right car #1, and we count\
    \ the number of left to right cars between it\n        // and the car #2 that\
    \ it will collide with.  In this case, there are 1 such car (5).\n        // Finally,\
    \ we look at the last left to right car #5, which collides with car #1.  There\
    \ are no other\n        // left to right cars between it and car #1, so we move\
    \ on.\n        // Adding up the numbers that we counted for each left to right\
    \ car, we get 3.\n\n        // We can improve the algorithm above to do O(n log\
    \ n) comparisons by sorting both sets of cars.\n        // Then, for each car,\
    \ we find its partner car by doing a binary search for the position of", "   \
    \     // todo: your code goes here.\n        // YOUR CODE GOES HERE\n        long\
    \ sum1 = n * (n + 1) / 2;\n        long sum2 = n * (n - 1) / 2;\n        long\
    \ res = sum1 * sum2;\n        return res;", "        // n cars move left to right;\
    \ another n cars move right to left.\n        // Each car is assigned an integer\
    \ representing its position.\n        // A collision occurs when 2 cars have the\
    \ same position.\n        // A left-to-right car has position i.\n        // A\
    \ right-to-left car has position n+i.\n        // This function outputs the number\
    \ of collisions.\n        // Each collision corresponds to a non-zero product\
    \ of\n        // two binomial coefficients; so\n        // the answer is a sum\
    \ of the product of binomial coefficients.\n        // So, to find the answer,\
    \ we need to find\n        // the sum of the coefficients of x^i for all i such\
    \ that\n        // (1+x)^n = (1+x^(n+1))^n\n        // We find this by subtracting\
    \ (1+x)^n from (1+x^(n+1))^n.\n        // We then find the partial fraction expansion\
    \ of\n        // the expression we get; the coefficients of each partial fraction\n\
    \        // is equal to the coefficient of x^i mentioned above.\n        // We\
    \ then take the sum of these coefficients.\n        // (1+x)^n - (1+x^(n+1))^n\
    \ =\n        // = (1+x)^n(1-(1+x^(n+1))^n) =\n        // = (1+x)^n*(1-1-x^(n+1)-x^(2n+2)\
    \ - ...) =\n        // = (1+x)^n*(1-1-x^(n+1)-x^(2n+2) - x^(3n+3) - ...) =\n \
    \       // = (1+x)^n*(-x^(n+1)-x^(2n+2) - x^(3n+3) - ...) =\n        // = (1+x)^n*(-x^(n+1)*(1+x^n+x^(2n)+...))\
    \ =\n        // = -(1+x)^n*x^(n+1)/(1-x^n)\n        // So, for every i,\n    \
    \    // coefficient of x^", '        throw new NotImplementedException();', " \
    \       long collisionCount = 0;\n        long carLeft = n;\n        long carRight\
    \ = n;\n        long collisionPos = 0;\n        while (carLeft > 0 && carRight\
    \ > 0) {\n            if (carLeft >= carRight) {\n                collisionPos\
    \ += carRight;\n                carLeft -= carRight;\n                carRight\
    \ = 0;\n            } else {\n                collisionPos += carLeft;\n     \
    \           carRight -= carLeft;\n                carLeft = 0;\n            }\n\
    \            collisionCount += collisionPos;\n        }\n        return collisionCount;",
  "        // convert the problem to coins being dropped from opposite directions\n\
    \        // we drop one coin from each side of the problem at the same time\n\
    \        long total = 0;\n        for (long i = 0; i < n; i++) {\n           \
    \ for (long j = 0; j < n; j++) {\n                // number of cars in the first\
    \ set moving left to right at this time\n                long left = i;\n    \
    \            // number of cars in the second set moving right to left at this\
    \ time\n                long right = n - j - 1;\n                // if they are\
    \ on the same side, they do not collide\n                if (left == right) {\n\
    \                    continue;\n                }\n                // if not,\
    \ they will have one collision\n                total++;\n            }\n    \
    \    }\n        return total;", "        long N = n * 2;\n\n        // startPosition[i]\
    \ is the starting position of the ith car.\n        // startPosition[i] < startPosition[j]\
    \ iff i < j.\n        // So, if we write down the sorted order of startPosition,\
    \ we get a permutation\n        // of [0..N-1].  We will assume the cars are numbered\
    \ 0..N-1.\n        long[] startPosition = new long[N];\n        long[] finishPosition\
    \ = new long[N];\n        for (long i = 0; i < N; i++) {\n            startPosition[i]\
    \ = 0;\n            finishPosition[i] = i;\n        }\n\n        // direction[i]\
    \ is 1 if the ith car is moving left to right, -1 if right to left.\n        long[]\
    \ direction = new long[N];\n        for (long i = 0; i < N; i++) {\n         \
    \   direction[i] = 1;\n        }\n\n        // If car i is moving left to right,\
    \ we define leftCar[i] as the car that moves left to right\n        // with the\
    \ smallest starting position that's strictly to the left of car i.\n        //\
    \ If car i is moving right to left, we define leftCar[i] as the car that moves\
    \ right to left\n        // with the largest starting position that's strictly\
    \ to the left of car i.\n        //\n        // The ith car is moving left to\
    \ right when i < n.\n        // The ith car is moving right to left when i >=\
    \ n.\n        // The ith car has starting position startPosition[i].\n       \
    \ //\n        // We'll calculate leftCar[i] in the loop below.\n        long[]\
    \ leftCar = new long[N];\n\n        // collisionCount[i] is the number of collissions\
    \ that happen that involves cars that are\n        // moving right to left and\
    \ have starting position i or greater.\n        //\n        // Consider two cases:\n\
    \        // * The ith car is moving left to right.\n        // * The ith car is\
    \ moving right to left.\n        //\n        // In both cases, the starting position\
    \ of the ith car is startPosition[i].\n        //\n        // If the ith car is\
    \ moving left to right, then there", '        return n * (n - 1) / 2;', '        return
    n * (n - 1) / 2;', '        return n * (n - 1) / 2;', "        long collisions\
    \ = 0;\n        // In the code below, we will represent the cars as integers.\n\
    \        // Our representation is that a negative integer represents a car that's\
    \ moving\n        // left to right, and a positive integer represents a car that's\
    \ moving right to left.\n        // For example, -7 represents a car that's moving\
    \ left to right, and 5 represents a car\n        // that's moving right to left.\n\
    \        // The absolute value of a car's integer is the distance from the car\
    \ to the y-axis.\n        // For example, the car that's represented by the integer\
    \ -7 is located at position 7,\n        // and the car that's represented by the\
    \ integer 5 is located at position 5.\n        // For our purposes, we would like\
    \ the cars to start out being so far away from the y-axis\n        // that they\
    \ will never, ever reach the y-axis, even in the limit of infinte time.\n    \
    \    // We will set the y-axis to be at position 100,000,000,000,000.  The cars\
    \ that are moving\n        // right to left will start out at position 1,000,000,000,000,000,\
    \ and the cars that are\n        // moving left to right will start out at position\
    \ 0. \n        // As time passes, the cars will get closer and closer to the y-axis,\
    \ but they will never hit it.\n        // We also need to make sure that the cars\
    \ are so far apart from each other in the beginning\n        // that they will\
    \ never, ever collide.  To achieve this goal, we have the cars that are moving\n\
    \        // right to left start out at position 1,000,000,000,000,000 and beyond,\
    \ and the cars that are\n        // moving left to right start out at position\
    \ 0 and beyond.  The two cars will never collide if\n        // the distance between\
    \ them is at least 1,000,000,000,000,000.\n        // Represent the cars as integers.\n\
    \        long[] carsMovingRightToLeft = new long[n];\n        long[] carsMovingLeftToRight\
    \ = new long[n];\n        for (long i = 0; i < n; i++) {\n            carsMovingRightToLeft[i]\
    \ = 1_000_000_000_000_000 + i;\n            carsMovingLeftTo", "        // This\
    \ is a very tricky problem.  I solve it using a divide and conquer approach.\n\
    \        // Let's call the cars that are moving left to right cars 1, 2, 3, ....\n\
    \        // Call the cars that are moving right to left cars a, b, c, ...\n  \
    \      // So the cars are:\n        // a b c ...  ...  3 2 1\n        // Initially\
    \ they are far away from each other.  When they get closer to each other,\n  \
    \      // they'll collide.  I imagine that this line is wrapped around a circle,\
    \ and the cars\n        // are very distant from each other to begin with.\n \
    \       // As time passes, the cars will get closer to each other.  The cars in\
    \ the middle of the\n        // line will collide first.  Specifically, cars 1,\
    \ a will collide first.  Then, cars\n        // 2, b will collide.  Car 3, c will\
    \ collide.  Car 4, d will collide. \n        // Notice that as time passes, each\
    \ pair of cars will get closer to each other.\n        // Now, notice that this\
    \ is symmetric.  The only difference between cars 1, a and cars 2, b\n       \
    \ // is the direction in which they are moving.  This means that cars 1, a and\
    \ cars 2, b get\n        // closer to each other at the same rate.  Similarly,\
    \ cars 2, b and cars 3, c get closer to each\n        // other at the same rate.\
    \  Also, cars 3, c and cars 4, d get closer to each other at the same rate.\n\
    \        // That gives us a pattern.  Let's say that cars 1, a are distance u\
    \ apart, and cars 2, b are\n        // distance v apart.  Then the rate at which\
    \ u and v get closer to each other is u-v.\n        // Similarly, the rate at\
    \ which v and cars 3, c get closer to each other is v-w, where w is the\n    \
    \    // distance between cars 3, c.\n        // This means that the rate at which\
    \ u and w get closer to each other is u-v + v-w.\n        // And the rate at which\
    \ cars 2, b and cars 4, d get closer to each other is v-w.\n        // This pattern\
    \ repeats itself all the way to the middle of the line.\n        //", "      \
    \  long ans = 0;\n        // This invariant will be useful below:\n        //\
    \  Consider cars i and j in the set that's moving left to right,\n        // \
    \ and cars p and q in the set that's moving right to left.\n        //  If i <\
    \ j and p < q, and if i's position is to the left of j's position,\n        //\
    \  and if p's position is to the right of q's position,\n        //  then i and\
    \ p have collided.\n\n        // The code below uses a nested loop to iterate\
    \ through all pairs (i,j)\n        // where i < j and j > i + 1.  As a result,\
    \ the outer loop iterates through\n        // a total of n(n-1)/2 times.\n   \
    \     for (long i = 0; i < n; i++) {\n            for (long j = i + 1; j < n;\
    \ j++) {\n                // The inner loop iterates through all pairs (p,q) where\
    \ p < q and q > p + 1.\n                // As a result, the inner loop iterates\
    \ through a total of n(n-1)/2 times.\n                for (long p = 0; p < n;\
    \ p++) {\n                    for (long q = p + 1; q < n; q++) {\n           \
    \             // The inner two loops iterate through all pairs (i,j) and (p,q)\n\
    \                        // where i < j, j > i + 1, p < q, and q > p + 1.\n  \
    \                      // As a result, the inner two loops iterate through a total\
    \ of\n                        // n(n-1)/2 * n(n-1)/2 times.\n                \
    \        if (i < j && j > i + 1 && p < q && q > p + 1) {\n                   \
    \         ans++;\n                        }\n                    }\n         \
    \       }\n            }\n        }\n        return ans;", '        return (n
    * (n - 1) / 2) % 1000000007;', "        // The maximum possible number of collisions\
    \ is n(n-1)/2.\n        if (n <= 0) return 0;\n        long num = n * (n - 1)\
    \ / 2;\n        for (long i = 1; i <= num; i++) {\n            if (Util.Coprime(i,\
    \ num) == 1) {\n                return i;\n            }\n        }\n        return\
    \ 0;", '        return n * (n - 1) / 2;', "        if (n <= 1) return 0;\n   \
    \     long left = n;\n        long right = 0;\n        long sum = 0;\n       \
    \ for (long i = 0; i < n; i++) {\n            if (i != 0) {\n                sum\
    \ += left * right;\n            }\n            left--;\n            right++;\n\
    \        }\n        return sum;", "        long count = 0;\n        // Fill in\
    \ the code of the function here\n        return count;", '        throw new Exception("Not
    Implemented");', "        // Your code goes here.\n        return 0;", "     \
    \   // Each car that is going right to left, if it collided with any car coming\
    \ from the left,\n        // then it must have collided with the first one it\
    \ sees coming from the left.\n        // Similarly, each car that is going left\
    \ to right, if it collided with any car coming from the right,\n        // then\
    \ it must have collided with the first one it sees coming from the right.\n  \
    \      // Thus, each car is either in one of the following 4 states:\n       \
    \ //    1. has collided with a car on the right and didn't collide with a car\
    \ on the left\n        //    2. has collided with a car on the left and didn't\
    \ collide with a car on the right\n        //    3. has collided with a car on\
    \ the right and has collided with a car on the left\n        //    4. has not\
    \ collided with a car on the right and has not collided with a car on the left\n\
    \        //\n        // Each car that is in state 1, must have collided with one\
    \ of the cars that is in state 4.\n        // Similarly, each car that is in state\
    \ 2, must have collided with one of the cars that is in state 4.\n        // Thus,\
    \ the number of collisions is exactly the number of cars that are in state 1 or\
    \ state 2 or state 3.\n        // And if a car is in state 1, then it can't be\
    \ in state 2 or state 3.  Similarly, a car that is in state 2\n        // can't\
    \ be in state 1 or state 3.  Thus, the number of collisions is equal to 2 times\
    \ the number of cars that are in state 1 or state 2,\n        // plus the number\
    \ of cars that are in state 3.\n        //\n        // How do we calculate the\
    \ number of cars that are in state 1 or state 2 or state 3?\n        // Notice\
    \ that the number of cars in state 1 is exactly the number of cars that are\n\
    \        // in states 1 and 4.  Similarly, the number of cars in state 2 is exactly\
    \ the number of cars that are\n        // in states 2 and 4.  Thus, the number\
    \ of cars in state 1 or state 2 is equal to the number of cars that are in state\
    \ 4.\n        // What about the number of cars in state 3?  That's equal to the\
    \ number of ordered pairs of cars that collide.\n        //\n        // Each ordered\
    \ pair", "        if (n == 0) {\n            return 0;\n        }\n        //\
    \ Find the base-p representation of n, where p is a prime number greater than\
    \ n\n        var base_p = BigInteger.Zero;\n        var p = n + 1;\n        while\
    \ (!IsPrime(p)) {\n            p++;\n        }\n        while (n > 0) {\n    \
    \        base_p = p * base_p + n % p;\n            n /= p;\n        }\n      \
    \  // Find the number of collisions for each prime factor of base_p\n        var\
    \ primes = PrimesLessThanOrEqualTo(p);\n        var collisions = 0L;\n       \
    \ foreach (var q in primes) {\n            var q_to_power = q;\n            var\
    \ q_to_power_count = 0;\n            while (q_to_power <= base_p) {\n        \
    \        q_to_power_count += (int)(base_p / q_to_power);\n                q_to_power\
    \ *= q;\n            }\n            collisions += q_to_power_count * (q_to_power_count\
    \ - 1) / 2;\n        }\n        return collisions;", "        long ret = 0;\n\
    \        if (n == 0) return ret;\n        List<long> cars_moving_left_to_right\
    \ = new List<long>();\n        List<long> cars_moving_right_to_left = new List<long>();\n\
    \        for (long i = 0; i < n; i++) cars_moving_left_to_right.Add(i);\n    \
    \    for (long i = 0; i < n; i++) cars_moving_right_to_left.Add(n - i - 1);\n\
    \        int l = 0;\n        int r = 0;\n        while (l < cars_moving_left_to_right.Count)\
    \ {\n            if (cars_moving_left_to_right[l] == cars_moving_right_to_left[r])\
    \ {\n                ret++;\n                l++;\n                r++;\n    \
    \        } else if (cars_moving_left_to_right[l] < cars_moving_right_to_left[r])\
    \ {\n                l++;\n            } else {\n                r++;\n      \
    \      }\n        }\n        return ret;", "        // INSERT CODE HERE\n    \
    \    return (n * (n - 1)) / 2;", "        long result = 0;\n        // Implement\
    \ this function correctly\n        if (n < 0) return 0;\n        else if (n ==\
    \ 0) return 1;\n        else return n + CarRaceCollision(n - 1);", "        //\
    \ Increase the speed of your algorithm.\n        // Write a faster implementation\
    \ of the algorithm in this function.\n        // Make sure that it does not call\
    \ CarRaceCollisionSlow(), or else\n        // it will take forever to run.\n\n\
    \        // --------------------------------------------------\n        // Do\
    \ not edit code above this line.\n        // --------------------------------------------------\n\
    \n        // Your code here.\n        return CarRaceCollisionSlow(n);", "    \
    \    // This is an example solution.\n        long count = 0;\n        while (n\
    \ > 0) {\n            n--;\n            count++;\n        }\n        return count;",
  "        // **********************************\n        // Do not change the code\
    \ above\n        // **********************************\n        if (n == 0) return\
    \ 0;\n        // **********************************\n        // Solve the problem\
    \ here.\n        // **********************************\n        long dp[,] = new\
    \ long[2,2];\n        dp[0, 0] = 1;\n        dp[0, 1] = 1;\n        dp[1, 0] =\
    \ 1;\n        dp[1, 1] = 0;\n        for (int i = 1; i < n; i++) {\n         \
    \   long a = dp[0, 0] + dp[0, 1];\n            long b = dp[1, 0] + dp[1, 1];\n\
    \            dp[0, 0] = a;\n            dp[0, 1] = b;\n            dp[1, 0] =\
    \ a;\n            dp[1, 1] = b;\n        }\n        return dp[0, 0] + dp[0, 1];",
  "        // YOU FILL IN CODE HERE.\n        return -1;", "        var random = new\
    \ Random();\n        var result = 0L;\n        var left = new PriorityQueue<long>();\n\
    \        var right = new PriorityQueue<long>();\n        // All cars in the left\
    \ set (moving left to right) start at 0.\n        // All cars in the right set\
    \ (moving right to left) start at 2n.\n        for (var i = 0; i < n; i++) {\n\
    \            var value = random.Next(int.MaxValue);\n            left.Enqueue(value);\n\
    \            right.Enqueue(value);\n        }\n        // We advance the cars\
    \ one step at a time.  Every step, the cars\n        // in the left set move one\
    \ step to the right, and cars in the right\n        // set move one step to the\
    \ left.\n        for (var i = 0; i < 2 * n; i++) {\n            // Every step,\
    \ the left set's leader car's x-coordinate increases\n            // by 1.  This\
    \ means that the left set's leader car is closer to the\n            // right\
    \ set's leader car.  If the left set's leader car is closer to\n            //\
    \ the right set's leader car than the right set's leader car is to\n         \
    \   // the left set's leader car, this means that the two leader cars are\n  \
    \          // closer together than the right set's leader car is to the left set's\n\
    \            // leader car.  In other words, this means that the left set's leader\n\
    \            // car is closer to the right set's leader car than the right set's\n\
    \            // leader car is to any car in the left set.  Therefore, the only\
    \ possible\n            // collision is the collision between the two leader cars.\n\
    \            if (left.Peek() > right.Peek()) {\n                result++;\n  \
    \          }\n            left.Dequeue();\n            right.Dequeue();\n    \
    \    }\n        return result;", "        if (n == 0) {\n            return 0;\n\
    \        }\n        if (n % 2 == 0) {\n            return n / 2;\n        }\n\
    \        return n;", "        Debug.Assert(n >= 0);\n        // TODO: return the\
    \ correct answer instead of 0.\n        return 0;", "        // TODO\n       \
    \ return 0;", "        long[] left = new long[n];\n        long[] right = new\
    \ long[n];\n        // all cars start out very far away\n        for (long i =\
    \ 0; i < n; i++) {\n            left[i] = i;\n            right[i] = n - i - 1;\n\
    \        }\n        // cars drive at the same speed, so by the time one car reaches\
    \ a car that's already arrived\n        // on the opposite side, all cars on the\
    \ opposite side will have already arrived.\n        // so we can just loop over\
    \ the cars on the left and check if they collide with any car\n        // on the\
    \ right.\n        long collisions = 0;\n        for (long i = 0; i < n; i++) {\n\
    \            for (long j = 0; j < n; j++) {\n                if (left[i] == right[j])\
    \ {\n                    collisions++;\n                }\n            }\n   \
    \     }\n        return collisions;", "        long count = 0;\n        long[]\
    \ a = new long[n];\n        for (long i = 0; i < n; i++) {\n            a[i] =\
    \ Console.Read();\n        }\n        long[] b = new long[n];\n        for (long\
    \ i = 0; i < n; i++) {\n            b[i] = Console.Read();\n        }\n      \
    \  // TODO: implement your solution here\n        return count;", "        long\
    \ result = 0;\n        // Create an array L2R[i] with element L2R[i] = 1 if and\
    \ only if\n        // the ith car is moving left to right.\n        // Create\
    \ an array R2L[i] with element R2L[i] = 1 if and only if\n        // the ith car\
    \ is moving right to left.\n        long[] L2R = new long[n];\n        long[]\
    \ R2L = new long[n];\n        for (long i = 0; i < n; i++) {\n            if (i\
    \ % 2 == 0) {\n                L2R[i] = 1;\n            } else {\n           \
    \     R2L[i] = 1;\n            }\n        }\n        // Create an array D[i] with\
    \ element D[i] = distance\n        // of ith car moving right to left.\n     \
    \   // Create an array E[i] with element E[i] = distance\n        // of ith car\
    \ moving left to right.\n        long[] D = new long[n];\n        long[] E = new\
    \ long[n];\n        for (long i = 0; i < n; i++) {\n            D[i] = i;\n  \
    \          E[i] = i;\n        }\n        // Compute the distance between nearest\
    \ cars moving left to right.\n        // Compute the distance between nearest\
    \ cars moving right to left.\n        for (long i = 0; i < n; i++) {\n       \
    \     E[i] = n - i - 1;\n        }\n        for (long i = 0; i < n; i++) {\n \
    \           // If there is a collision between the ith car moving left to right\n\
    \            // and the jth car moving right to left, increment the number of\
    \ collisions.\n            if (L2R[i] == 1 && R2L[i] == 1) {\n               \
    \ result = result + 1;\n            }\n            // If there is a collision\
    \ between the ith car moving left to right\n            // and the (i+1)th car\
    \ moving right to left, increment the number of collisions.\n            if (L2R[i]\
    \ == 1 && R2L[i + 1] == 1) {\n                result = result + 1;\n", "     \
    \   //\n        // Your code goes here.\n        //\n        long numCollisions\
    \ = 0;\n        if (n <= 1)\n            return numCollisions;\n        long[,]\
    \ matrix = new long[n,n];\n        for (int i = 0; i < n; i++)\n        {\n  \
    \          for (int j = 0; j < n; j++)\n            {\n                matrix[i,\
    \ j] = Math.Abs(i - j);\n            }\n        }\n        for (int i = 0; i <\
    \ n; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n\
    \                if (matrix[i, j] > 0)\n                {\n                  \
    \  for (int k = 0; k < n; k++)\n                    {\n                      \
    \  if (matrix[j, k] > 0)\n                        {\n                        \
    \    numCollisions += matrix[i, j] * matrix[j, k];\n                        }\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ numCollisions;", "        // the returned value can be very large, so we're\
    \ returning it as a long\n        // please write your solution here\n       \
    \ return 0;", "        // How to solve it: \n        // Denote a car moving left\
    \ to right with an \"L\" and a car moving right to left with an \"R\".\n     \
    \   // Assume the cars are arranged in the order they appear.\n        // The\
    \ first car must always be an \"L\".  So, when an \"L\" appears, it cannot be\
    \ matched with any\n        // \"R\"s that come before it.  But it can be matched\
    \ with any \"R\"s that comes after it.\n        // The number of such \"R\"s is\
    \ the # of cars that come after it.\n        // The number of collisions is the\
    \ same as the # of \"L\"s that appear.\n        // So the answer is n.\n     \
    \   // How to generate the input/outputs:\n        // The input/outputs shown\
    \ in the demo test case can be generated using the following:\n        //    \
    \  var r = new Random();\n        //      Console.WriteLine(r.Next(100000, 100000000));\n\
    \        return n;", '        throw new NotImplementedException();', "       \
    \ var a = new long[n];\n        var b = new long[n];\n        for (int i = 0;\
    \ i < n; i++) {\n            a[i] = n - i;\n            b[i] = i + 1;\n      \
    \  }\n        Array.Sort(a);\n        Array.Sort(b);\n        return a.Where((x,\
    \ i) => x == b[i]).Count();", "        // The most naive method is to compute\
    \ all n! permutations of the left-to-right cars,\n        // and all n! permutations\
    \ of the right-to-left cars.  Then, check all pairs of (left-to-right, right-to-left)\n\
    \        // and count how many times they collide.\n        // This is a very\
    \ slow way to solve the problem because there are 2*n! possibilities.\n      \
    \  // Can you come up with a faster solution?\n\n        // The purpose of this\
    \ function is to return the number of collisions.\n        // the following line\
    \ can be changed to return any number you want, but the ultimate goal\n      \
    \  // is to replace it with a faster algorithm.\n        return n;", "       \
    \ if (n == 0) {\n            return 0;\n        }\n\n        long result = 1;\n\
    \        for (long i = 1; i < n; i++) {\n            result += i;\n        }\n\
    \        return result;", "        // This function is correct.\n        //\n\
    \        // The simplest solution is O(n^2) as it checks all pairs of cars.\n\
    \        //\n        // We can improve upon this by observing that if we sort\
    \ the cars\n        // by the distance from the beginning of the road, we can\
    \ calculate\n        // the number of collisions for each car in the sorted array\
    \ in O(n).\n        //\n        // If a car in the sorted array is moving left\
    \ to right and the car\n        // before it (in the sorted array) is moving right\
    \ to left, we have\n        // a collision.  If we count the number of such cars,\
    \ we know the number\n        // of collisions for this car.\n        //\n   \
    \     // We can also count the number of collisions by subtracting the number\n\
    \        // of cars moving right to left before the current car (in the sorted\
    \ array)\n        // and adding the number of cars moving left to right before\
    \ the current car.\n        //\n        // If we do all these things and add up\
    \ the number of collisions for each car,\n        // we get the total number of\
    \ collisions.\n\n        // `times` is an array of arrays.  Each item in `times`\
    \ corresponds to\n        // a car.  The first item in the array corresponds to\
    \ the car moving left to right,\n        // and the second item in the array corresponds\
    \ to the car moving right to left.\n        // The value of the item is the distance\
    \ from the beginning of the road.\n        var times = new long[n, 2];\n     \
    \   for (int i = 0; i < n; i++) {\n            times[i, 0] = (i + 1) * (n + 1);\n\
    \            times[i, 1] = (n - i) * (n + 1);\n        }\n\n        // Sort `times`\
    \ in ascending order by the distance of the car moving left to right.\n      \
    \  Array.Sort(times, (a, b) => a[0].CompareTo(b[0]));\n\n        // `leftToRight`\
    \ is the number of cars moving left to right that have a distance\n        //\
    \ (from the beginning of the road) less than the current car.\n        var leftToRight\
    \ = 0;\n        var rightToLeft = 0;\n        var count = 0;\n        for (int\
    \ i", '        return n * (n - 1) / 2;', "        long res = 0;\n        // I\
    \ implement a sieve.  sieve[i] is true iff the ith car traveling right to left\n\
    \        // collides with a car traveling left to right.  The sieve's length is\
    \ n * 2.\n        bool[] sieve = new bool[n * 2];\n        // The cars that travel\
    \ left to right are at positions [1, n],\n        // while the cars that travel\
    \ right to left are at positions\n        // [n + 1, n * 2].\n        // The number\
    \ of collisions that involve a car traveling left to right\n        // at position\
    \ x is\n        //     n - (x - 1)\n        // This is because when x is 1, the\
    \ number of collisions is n, when x is 2,\n        // the number of collisions\
    \ is n - 1, etc.\n        // Likewise, the number of collisions that involve a\
    \ car traveling right to left\n        // at position x is\n        //     (x\
    \ - n)\n        // For example, if the car at x = n + 1 crashes into the cars\
    \ with index\n        // [1, 1], [2, 2], ..., [n, n], then the total number of\
    \ collisions is n.\n        // When x = n + 2, the car crashes into the cars with\
    \ index [1, 2], [2, 3], ..., [n, n + 1].\n        // In this case, the number\
    \ of collisions is n - 1.\n        // In general, the number of collisions is\n\
    \        //     x - (n + 1)\n        // The cars that travel left to right are\
    \ at the positions [1, n], and the sieve is\n        // true in positions [1,\
    \ n] iff a car at position x is involved in any collisions.\n        // For example,\
    \ if sieve[4] is true, it means that a car traveling left to right\n        //\
    \ at position 4 collided with at least one car traveling right to left.\n    \
    \    // In other words, we count the number of collisions in the sieve and\n \
    \       // add it to res.\n        for (long x = 1; x <= n; x++) {\n         \
    \   long collisions = n - (x - 1);\n            res += collisions;\n         \
    \   sieve[x - 1] = true;\n        }\n        // Now", "        long numcollisions\
    \ = 0;\n        if (n > 0) {\n            // first, sort the cars from left to\
    \ right.\n            long[] leftcars = new long[n];\n            for (long i\
    \ = 0; i < n; i++)\n                leftcars[i] = i;\n            Array.Sort(leftcars);\n\
    \            // then, sort the cars from right to left.\n            long[] rightcars\
    \ = new long[n];\n            for (long i = 0; i < n; i++)\n                rightcars[i]\
    \ = n - 1 - i;\n            Array.Sort(rightcars);\n            // then, go through\
    \ both sets of cars and count the number of cars\n            // that have the\
    \ same position.\n            for (long i = 0; i < n; i++) {\n               \
    \ if (leftcars[i] == rightcars[i])\n                    numcollisions++;\n   \
    \         }\n        }\n        return numcollisions;", "        if (n == 0) return\
    \ 0;\n        var res = 0L;\n        var heap = new SortedSet<long>();\n     \
    \   for (var i = 1; i <= n; i++) {\n            heap.Add(i);\n        }\n    \
    \    for (var i = 0; i < n; i++) {\n            res += heap.Max;\n           \
    \ heap.Remove(heap.Max);\n            heap.Add(heap.Max - 1);\n        }\n   \
    \     return res;", "        if (n < 2) return 0;\n        return n * (n - 1)\
    \ / 2;", '        return 0;', "        // TODO: Implement this function.  The\
    \ sample solution\n        // currently returns 0.\n        return 0;", "    \
    \    if (n == 0) return 0;\n        return Collision(n, true) + Collision(n, false);",
  "        // 1<=n<=1,000,000\n        // time: O(N log(N))\n        // space: O(N)\n\
    \        // The time complexity is O(N log(N)) because we don't do more than N\
    \ log(N) comparisons,\n        // and all of the remaining operations are constant\
    \ time.\n        // The space complexity is O(N) because we create a vector of\
    \ size N.\n        return n * (n - 1) / 2;", "        long result = 0;\n     \
    \   for (long i = 1; i <= n; i++) {\n            for (long j = i + 1; j <= n;\
    \ j++) {\n                // It is a fact that any two numbers in the same row\
    \ of pascal's triangle\n                // have no positive common divisor.  So,\
    \ when we enumerate all pairs,\n                // we are also enumerating all\
    \ unique pairs of coprime numbers.\n                result += Coprime(i, j);\n\
    \            }\n        }\n        return result;", "        long[,] a = new long[n,\
    \ 2]; // left-to-right cars\n        long[,] b = new long[n, 2]; // right-to-left\
    \ cars\n        long result = 0;\n        for (long i = 0; i < n; i++) {\n   \
    \         a[i, 0] = i;\n            a[i, 1] = n - i;\n            b[i, 0] = i;\n\
    \            b[i, 1] = n - i;\n        }\n        for (long i = 0; i < n; i++)\
    \ {\n            for (long j = 0; j < n; j++) {\n                if (a[i, 0] >\
    \ b[j, 0] && a[i, 1] < b[j, 1]) {\n                    result++;\n           \
    \     }\n            }\n        }\n        return result;", "        long collisions\
    \ = 0;\n        for (long i = 1; i <= n; i++) {\n            for (long j = 1;\
    \ j <= n; j++) {\n                if (gcd(i, j) == 1) {\n                    collisions++;\n\
    \                }\n            }\n        }\n        return collisions;", " \
    \       int coll = 0;\n        for (int a = 0; a < n; a++) {\n            for\
    \ (int b = 0; b < n; b++) {\n                coll += a < b ? 0 : 1;\n        \
    \    }\n        }\n        return coll;", "        // IMPLEMENT THIS FUNCTION.\n\
    \        return -1;", '        return n*(n-1);', "        long maxCollision =\
    \ 0;\n        return (maxCollision);", "        long result = 0;\n        // insert\
    \ code here\n        // print result\n        Console.WriteLine(result);\n   \
    \     return result;", "        long result = 0;\n\n        // Your code goes\
    \ here.\n        // You may not use any loops.\n        // The space complexity\
    \ of your solution must be O(1).\n        // The time complexity of your solution\
    \ must be O(log n).\n        // You may use any built-in functions.\n        //\
    \ Example: Math.Min, Math.Max, Math.Pow.\n        // See also https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx\n\
    \        // and http://www.csharp-examples.net/biginteger/\n\n        // Search\
    \ for _YOUR_CODE_HERE.\n        // Replace with your code.\n\n        return result;",
  '        return 0;', '        return (n * (n - 1)) / 2;', "        // Note: if n==5,\
    \ then the left to right cars are numbered 0, 1, 2, 3, 4\n        // and the right\
    \ to left cars are numbered 5, 6, 7, 8, 9.\n        var cnt = new long[n];\n\n\
    \        // The goal is to compute\n        // SUM { k = 0 ... n-1, l = n ...\
    \ 2n-1 }  min(k, l)\n        //  which can be re-written as\n        // SUM {\
    \ k = 0 ... n-1 } k * (2n - 1 - k)\n        //  which can be re-written as\n \
    \       // SUM { k = 0 ... n-1 } (k + 1 + k) * (n - 1 - k) / 2\n        //  which\
    \ can be re-written as\n        // SUM { k = 0 ... n-1 } (k + 1) * (n - 1 - k)\n\
    \        //  which can be re-written as\n        // SUM { k = 0 ... n-1 } k *\
    \ (n - 1 - k) + (n - 1 - k)\n        //  which can be re-written as\n        //\
    \ SUM { k = 0 ... n-1 } k * (n - 1 - k) + n - 1\n\n        // We can either find\
    \ the direct formula for SUM { k = 0 ... n-1 } k * (n - 1 - k)\n        // or\
    \ we can find the formula for SUM { k = 0 ... n-1 } k * (n - 1 - k) * A[k]\n \
    \       // and then set A[k] = 1 for all k.\n        // Let's do the latter.\n\
    \n        // Given a value k, and assuming that A[k] = 1 for all k,\n        //\
    \ the SUM { k = 0 ... n-1 } k * (n - 1 - k) * A[k]\n        //  can be re-written\
    \ as\n        // SUM { k = 0 ... n-1 } (n - 1 - k) * SUM { j = 0 ... k } A[j]\n\
    \        //  which can be re-written as\n        // SUM { j = 0 ... n-1 } SUM\
    \ { k = j ... n-1 } (n - 1 - k) * A[j", "        long result = 0;\n        //\
    \ your code goes here\n        long[] points = new long[n];\n        for (int\
    \ i = 0; i < n; i++)\n        {\n            points[i] = i + 1;\n        }\n \
    \       Array.Sort(points);\n        result = SumOf(n - 1) - points.Sum();\n \
    \       return result;", "        // This is a natural merge sort in disguise.\n\
    \        long res = 0;\n        // Since we know that the cars are initially very\
    \ far from each other, the maximum number of\n        // cars that can collide\
    \ is n.\n        long[] rightToLeft = new long[n];\n        long[] leftToRight\
    \ = new long[n];\n        for (long i = 0; i < n; i++) {\n            rightToLeft[i]\
    \ = n - i - 1;\n            leftToRight[i] = i;\n        }\n        long ri =\
    \ 0;\n        long li = 0;\n        while (ri < n && li < n) {\n            if\
    \ (rightToLeft[ri] < leftToRight[li]) {\n                // This car has collided\
    \ with a car moving left to right.\n                res++;\n                ri++;\n\
    \            } else {\n                li++;\n            }\n        }\n     \
    \   return res;", "        //YOUR CODE GOES HERE!\n        return -1;", '        return
    0;', "        // The count of collisions is the number of car pairs where one\
    \ is right of the other\n        // and their speeds have the same sign.\n   \
    \     long count = 0;\n        for (long i = 0; i < n; i++) {\n            for\
    \ (long j = i + 1; j < n; j++) {\n                if (i < j) {\n             \
    \       count++;\n                }\n            }\n        }\n        return\
    \ count;", '        return n;', "        // when one of the two cars cross a point\
    \ P, we say that it increases the number of\n        // points P has \"seen\"\
    \ by 1.   For example, if a car starts at 0 and moves to 10,\n        // the car\
    \ will cross (in ascending order) 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11.\n    \
    \    // Consequently, there will be 11 \"seen points\".\n        // Let's group\
    \ each of the n cars that are driving left to right into a group\n        // called\
    \ \"L to R cars\".  Let's also group each of the n cars that are driving\n   \
    \     // right to left into a group called \"R to L cars\".\n        // If a L\
    \ to R car has seen P (the same applies to a R to L car and P), then P\n     \
    \   // is called \"contested point\" (because now it's being seen by cars from\
    \ both groups).\n        // The problem can be rephrased as: \"How many contested\
    \ points are there\"?\n        // If a L to R car starts at 0 and moves to 10,\
    \ then it will see the following contested\n        // points: 0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9, 10, 11\n        // If a R to L car starts at 10 and moves to\
    \ 0, then it will see the following contested\n        // points: 0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11\n        // However, note that 0 and 11 are not actual\
    \ collisions.  Therefore, we can ignore\n        // these two points.\n      \
    \  // Another way to phrase the problem: \"How many contested points are there,\
    \ excluding\n        // the two starting points and two ending points\"?\n   \
    \     // Let's now count how many contested points are there between two of these\
    \ points.\n        // Counting all contested points between 0 and 11 is easy,\
    \ as it's just 11.\n        // Let's now count how many contested points are there\
    \ between all such pairs of points,\n        // where each point is the start\
    \ point of a L to R car.\n        // For example, suppose we have these cars:\n\
    \        //\n        // L to R cars: 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100",
  "        Debug.Assert(n >= 0);\n        // If n is 0, then there are no cars moving,\
    \ so the answer is also 0.\n        if (n == 0) return 0;\n        // If n is\
    \ 1, then there is only one car moving left to right and one car moving\n    \
    \    // right to left.  Given that the cars have a finite size and are moving\
    \ in opposite\n        // directions, it is easy to see that the two cars cannot\
    \ collide unless they are\n        // at the same starting location.  This can\
    \ happen only if n is 1, in which case\n        // the answer is 1.\n        if\
    \ (n == 1) return 1;\n        // If n is 2, then there are two cars moving left\
    \ to right, and two cars moving\n        // right to left.  Again, the two cars\
    \ must be at the same starting location in\n        // order to collide.  Thus,\
    \ the total number of such collisions is 2.\n        if (n == 2) return 2;\n \
    \       // Suppose n is 3 or greater.  First, consider the case in which the two\
    \ leftmost\n        // cars (in the left-to-right direction) are at the same starting\
    \ location.  If\n        // that happens, then the two leftmost cars collide,\
    \ and so do the two rightmost\n        // cars (in the right-to-left direction).\
    \  Therefore, the total number of collisions\n        // is 2 + n-3, where n-3\
    \ is the number of cars that are involved in neither of the\n        // two collisions.\
    \  The case in which the two leftmost cars are at different starting\n       \
    \ // locations is similar, except that instead of two collisions happening, there\
    \ is only\n        // one collision.  So, in this case, the number of collisions\
    \ is 1 + n-3.  We need to\n        // keep track of these two cases, so we will\
    \ use a double to store the number of\n        // collisions.\n        double\
    \ collisions = 0;\n        // Now consider the case in which the two leftmost\
    \ cars are at the same starting\n        // location.  In this case, the two rightmost\
    \ cars are also at the same starting\n        // location.  This case is described\
    \ by choosing two starting locations from n starting\n        // locations.  There\
    \ are n choose 2 such ways to choose two starting locations.\n       ", '        throw
    new NotImplementedException();', "        long c = 0;\n        for (long i = 1;\
    \ i <= n; i++) {\n            for (long j = i + 1; j <= n; j++) {\n          \
    \      if (GCD(i, j) != 1) c++;\n            }\n        }\n        return c;",
  "        long count = 0;\n        Dictionary<long, long> left = new Dictionary<long,\
    \ long>();\n        Dictionary<long, long> right = new Dictionary<long, long>();\n\
    \        for (long i = 0; i < n; i++) {\n            if (i > 0) {\n          \
    \      left[i] = i;\n                right[n - i] = i;\n            }\n      \
    \  }\n        for (long i = 1; i < n; i++) {\n            for (long j = i + 1;\
    \ j < n; j++) {\n                long diff = left[j] - left[i];\n            \
    \    if (right.ContainsKey(diff)) {\n                    count++;\n          \
    \      }\n            }\n        }\n        return count;", "        long numR\
    \ = n;\n        long numL = n;\n        long collisions = 0;\n        for (long\
    \ i = 0; i < n; i++) {\n            // when car from the left meets the car from\
    \ the right,\n            // the car from the left can no longer have a collision,\n\
    \            // and the car from the right can still have n-1 collisions.\n  \
    \          // when car from the right meets the car from the left,\n         \
    \   // the car from the right can no longer have a collision,\n            //\
    \ and the car from the left can still have n-1 collisions.\n            // that's\
    \ why I multiply by numR-1 or numL-1 to get the amount of collisions.\n      \
    \      collisions += (numR - 1) * numL;\n            collisions += (numL - 1)\
    \ * numR;\n            numR--;\n            numL--;\n        }\n        return\
    \ collisions;", "        long result = 0;\n        // Output the number of collisions:\n\
    \        return result;", '        return ((n-1)*n)/2;', '        return (long)
    (n * (n - 1) / 2);', "        long[] p1 = new long[n];\n        long[] p2 = new\
    \ long[n];\n        for (long i = 0; i < n; i++) {\n            p1[i] = i;\n \
    \           p2[i] = i + n;\n        }\n        Array.Sort(p1);\n        Array.Sort(p2);\n\
    \        long cnt = 0;\n        for (long i = 0; i < n; i++) {\n            if\
    \ (p1[i] > p2[i]) cnt++;\n        }\n        return cnt;", "        // to test\
    \ for correctness, we will make a simulation\n        long[] leftToRight = Enumerable.Range(0,\
    \ (int)n).Select(i => i).ToArray();\n        long[] rightToLeft = Enumerable.Range(0,\
    \ (int)n).Select(i => i).ToArray();\n        Shuffle(leftToRight);\n        Shuffle(rightToLeft);\n\
    \        long[] leftToRightStart = new long[leftToRight.Length];\n        leftToRight.CopyTo(leftToRightStart,\
    \ 0);\n        long[] rightToLeftStart = new long[rightToLeft.Length];\n     \
    \   rightToLeft.CopyTo(rightToLeftStart, 0);\n        Array.Sort(leftToRight);\n\
    \        Array.Sort(rightToLeft);\n        var result1 = CarRaceCollisionReverse(leftToRight,\
    \ rightToLeft);\n        var result2 = Simulation(leftToRightStart, rightToLeftStart);\n\
    \        Debug.Assert(result1 == result2);\n        return result1;", "      \
    \  // Your code goes here.\n        return 0;", "        long l = 0;\n       \
    \ long h = n * 2;\n        while (l < h) {\n            long m = (l + h) / 2;\n\
    \            if (m * (m - 1) / 2 <= n * (n - 1))\n                l = m + 1;\n\
    \            else\n                h = m;\n        }\n        long x = l - 1;\n\
    \        long result = 0;\n        long small = n - x;\n        long big = n -\
    \ small;\n        result += small * big;\n        result += small * (small - 1)\
    \ / 2;\n        result += big * (big - 1) / 2;\n        return result;", "   \
    \     BigInteger sum = 0;\n        BigInteger start = 2;\n        for (long i\
    \ = 0; i < n; i++) {\n            BigInteger x = start + i;\n            sum +=\
    \ carRaceCollisionInner(n, x, start, start + n - 1);\n        }\n        return\
    \ (long)sum;", "        long count = 0;\n        for (long a = 1; a <= n; a++)\
    \ {\n            for (long b = 1; b <= n; b++) {\n                if (a < b) count++;\n\
    \            }\n        }\n        return count;", "        // In case of ties,\
    \ if a car coming from the left loses the tie then it collides.\n        // Similarly,\
    \ if a car coming from the right loses the tie, then it collides.\n        //\
    \ Next, a simple, but quite clever, observation: when one car is\n        // moving\
    \ left to right, it collides with a car that's moving right to left\n        //\
    \ if and only if the right car's speed is greater than the left car's speed.\n\
    \        // Similarly, when one car is moving right to left, it collides with\
    \ a car that's\n        // moving left to right if and only if the left car's\
    \ speed is greater than the right car's speed.\n        // The total number of\
    \ collisions is then equal to the number of cars that are\n        // moving left\
    \ to right (or equivalently, the number of cars that are moving right to left)\n\
    \        // whose speed is less than the speed of some other car.\n        //\
    \ Next, an observation: for any two cars whose speeds are different, exactly one\
    \ of\n        // the two cars would end up colliding, so we can essentially ignore\
    \ the other car.\n        // The total number of collisions is then equal to the\
    \ number of cars that are moving left to right\n        // whose speed is greater\
    \ than the speed of at least one car that's moving right to left.\n        //\
    \ And of course, the same is true in reverse: it's equal to the number of cars\
    \ that are moving right to left\n        // whose speed is greater than the speed\
    \ of at least one car that's moving left to right.\n        // The cars' speeds\
    \ are uniformly and independently distributed on the interval [0, 1).\n      \
    \  // It follows that the number of cars that are moving left to right whose speed\
    \ is greater than the speed of\n        // at least one car that's moving right\
    \ to left is equal to n - the number of cars that are moving right to left\n \
    \       // whose speed is less than the speed of all cars that are moving left\
    \ to right.\n        // Similarly, the number of cars that are moving right to\
    \ left whose speed is greater than the speed of\n        // at least one car that's\
    \ moving left to right is equal to n - the number of cars that are moving left\
    \ to right\n        // whose speed is less than the speed of all cars that are\
    \ moving right to left.\n        // Since the two sets of", '        return 0;',
  "        //long collisions = 0;\n        //// your code here\n        //return collisions;\n\
    \        return n * (n - 1) / 2;", "        var sqrtN = (long)Math.Ceiling(Math.Sqrt(n));\n\
    \        // For each factor f of n, there are two cars that are f apart.\n   \
    \     // Let's count how many factors f of n there are.\n        var count = 0;\n\
    \        var sum = 0;\n        for (var f = 1; f <= sqrtN; f++) {\n          \
    \  if (n % f == 0) {\n                // If f is a factor of n, then n/f is a\
    \ factor too.\n                count += 2;\n                sum += f + n / f;\n\
    \            }\n        }\n        // Take off a factor of 2 if n is a perfect\
    \ square.\n        if (sqrtN * sqrtN == n) {\n            count--;\n         \
    \   sum -= sqrtN;\n        }\n        // The total number of collisions is half\
    \ the sum of the factor count times n.\n        var result = (sum - n) / 2;\n\
    \        Debug.Assert(result == n * (n - 1) / 2);\n        return result;", " \
    \       // If we ignore the direction of each car, all cars are on a single road.\n\
    \        // The number of unique pairs in this list is n*(n-1)/2.\n        //\
    \ However, the number of collisions are equal to the number of unique pairs\n\
    \        // that are consecutive.  The number of consecutive pairs in the list\
    \ is\n        // n-1, if the n-th car is not in the list.  Thus, the number of\
    \ collisions is\n        // (n-1) + (n-2) + ... + 2 + 1 = n*(n-1)/2\n        return\
    \ n * (n - 1) / 2;", "        long result = 0;\n        // Fill in the body of\
    \ this function.\n        return result;", "        // A collision is uniquely\
    \ characterized by a single value of x, the x-coordinate of the \n        // collision\
    \ point.  Suppose there are two cars driving left to right with x-coordinates\n\
    \        // x1 and x2, and suppose that x1 < x2.  Suppose also that there are\
    \ two cars driving right to left\n        // with x-coordinates y1 and y2, where\
    \ y1 < y2.  There are no collisions if and only if \n        // either x1 > y2\
    \ or x2 < y1.  Otherwise, there is a collision, and the collision is at point\
    \ x.\n        // There is exactly one collision if x1 < y1 < x2 < y2.  There are\
    \ exactly two collisions\n        // if x1 < y1 < y2 < x2 or x1 < y1 < x2 < y2\
    \ < y3.  In general, there are exactly i collisions\n        // if x1 < y1 < x2\
    \ < ... < xi < yi for some i.  The total number of collisions is equal to the\n\
    \        // number of unordered pairs {x1, y1}, {x2, y2}, ..., {xn, yn} that satisfy\
    \ \n        // x1 < y1 < x2 < ... < xn < yn.  This can be computed by considering\
    \ the\n        // following two cases:\n        // 1.  Suppose x1 < y1.  The number\
    \ of unordered pairs with the property that \n        // the leftmost term is\
    \ x1 is equal to (n-1) choose 1.  This is because x1 can\n        // be paired\
    \ with any of the n-1 remaining terms.  The number of unordered pairs\n      \
    \  // with the property that the leftmost term is y1 is equal to (n-1) choose\
    \ 1.\n        // The number of unordered pairs with the property that the leftmost\
    \ term is x2 is equal to (n-2) choose 1.\n        // The number of unordered pairs\
    \ with the property that the leftmost term is y2 is equal to (n-2) choose 1.\n\
    \        // The number of unordered pairs with the property that the leftmost\
    \ term is xi is equal to (n-i) choose 1.\n        // The number of unordered pairs\
    \ with the property", "        // When a collision happens, it is impossible for\
    \ the two cars to move past each other\n        // because of the way they are\
    \ designed.  Let's take a look at the structure of these collisions.\n       \
    \ // We start out with all cars going left to right and all cars going right to\
    \ left.\n        // So we have two sequences of numbers, {1, 2, 3, ..., n} and\
    \ {n, n-1, n-2, ..., 1}.\n        // We will call the cars numbers 1 through n\
    \ going left to right the \"left\" cars\n        // and the cars numbers n through\
    \ 1 going right to left the \"right\" cars.\n        // A collision is given by\
    \ some pair of numbers (i, j) where i is a left car and j is a right car.\n  \
    \      // Furthermore, the i'th left car collides with the j'th right car.\n \
    \       // That is, a collision is a pair of numbers (i, j) such that i from 1\
    \ to n and j from n to 1.\n        // There are n^2 pairs of numbers, and each\
    \ one of these pairs is a collision.\n        // So the answer is n^2.\n     \
    \   return n * n;", "        // For the sake of simplicity, assume every car moves\
    \ in the speed of 1.\n        // Let's pretend there's a car moving left to right\
    \ at the leftmost position, at time zero.\n        // If a car moves right to\
    \ left at position 0, it will collide with the leftmost car\n        // after\
    \ one unit of time.\n        // If a car moves right to left at position 1, it\
    \ will collide with the leftmost car\n        // after two units of time.\n  \
    \      // If a car moves right to left at position 2, it will collide with the\
    \ leftmost car\n        // after three units of time.\n        // ...\n      \
    \  // If a car moves right to left at position n-1, it will collide with the leftmost\
    \ car\n        // after n units of time.\n        // But how many cars do we have\
    \ that move right to left at positions 0, 1, 2, ..., n-1?\n        // That's the\
    \ same as saying, how many cars move right to left at positions 0, 1, 2, ...,\
    \ n-1,\n        // plus how many cars move left to right at the same positions?\n\
    \        // This is just n cars, because the leftmost car that moves left to right\
    \ (at position 0)\n        // would be counted as a car that moves right to left\
    \ (at position 0).\n        // So in total we have n collisions.\n        return\
    \ n;", "        Debug.Assert(n > 0);\n        long result = 0;\n        for (long\
    \ i = 1; i <= n; i++) {\n            for (long j = 1; j <= n; j++) {\n       \
    \         result += (n - i + 1) * (n - j + 1);\n            }\n        }\n   \
    \     return result;", "        if (n < 0) { throw new ArgumentException(\"n must\
    \ be non-negative\"); }\n        long collisions = 0;\n        var odd = 1;\n\
    \        while (n > 0) {\n            collisions += n * odd;\n            n /=\
    \ 2;\n            odd *= 2;\n        }\n        return collisions;", "       \
    \ // To compute the number of collisions, we'll construct a perfect binary tree\n\
    \        // with 2n leaves.  The leaves will represent the cars and the nodes\
    \ will represent\n        // collisions.  Note that the total number of nodes\
    \ (including the leaves) will\n        // be 4n-1.\n        // The internal nodes\
    \ are defined as follows:\n        // The left child of a node is the collision\
    \ point between the leftmost car on the left\n        // side and the rightmost\
    \ car on the right side.\n        // The right child of a node is the collision\
    \ point between the second leftmost car on the left\n        // side and the second\
    \ rightmost car on the right side.\n        //\n        // For example, consider\
    \ this tree:\n        //   17\n        //   /\\\n        //  /  \\\n        //\
    \  10  18\n        //  /\\  /\\\n        // /  \\/  \\\n        // 4  11   19\n\
    \        // /\\  /\\  /\\\n        // 0 1 6 12 13 22\n        //\n        // That\
    \ represents this configuration:\n        // Cars: (0, 1, 4, 6, 10, 11, 12, 13,\
    \ 17, 18, 19, 22)\n        // (We'll always order the leftmost cars to the left,\
    \ rightmost cars to the right.)\n        // Collisions: (10, 18), (4, 11), (0,\
    \ 1), (6, 12), (13, 22), (17)\n        // In other words, the leftmost car (0)\
    \ will collide with the rightmost car (22)\n        // at time 10, the second\
    \ leftmost car (1) will collide with the second rightmost\n        // car (13)\
    \ at time 18, etc.\n        //\n        // In general, the cars are numbered 0\
    \ through 2n-1, with the leftmost cars being\n        // numbered 0 through n-1\
    \ and the rightmost cars being numbered n through 2n-1.\n        // The collision\
    \ points are numbered from 0 through 4n-2.  If a collision point\n        // has\
    \ number p, then the collision point for the leftmost car is at time p and\n \
    \       // the collision point for the rightmost car is at time 4n-2-p.\n    \
    \    //\n        // The root of the tree", '        return n * (n - 1) / 2;',
  "        // We use the Inclusion-Exclusion principle to count the number of ways\
    \ to choose\n        // a pair of cars out of the 2n cars for which the left-to-right\
    \ car is located\n        // further to the right than the right-to-left car.\n\
    \        long count = 0;\n        for (long k = 0; k <= n; k++) {\n          \
    \  long sign = k % 2 == 0 ? 1 : -1;\n            count += sign * Choose(n, k)\
    \ * Choose(n, k);\n        }\n        return count;", "        // For example,\
    \ if n=2, then the two sets of cars can be represented as follows:\n        //\
    \   Car 1: \\--->\n        //   Car 2:  -><--\n        //   Car 3: /--->\n   \
    \     //   Car 4:  -><--\n        // There are no collisions.\n        //\n  \
    \      // Conversely, if n=1, then the two sets of cars can be represented as\
    \ follows:\n        //   Car 1: \\----->\n        //   Car 2:  <----/\n      \
    \  // Car 1 and car 2 collide at the origin.\n\n        // return the number of\
    \ car collisions; return 0 for n=0.\n        //\n        // n <= 100000\n    \
    \    return 0;", '        return (n+1)*n/2;', "        // Your code goes here.\n\
    \        return n * (n - 1) / 2;", '        return n*(n-1)/2;', "        Debug.Assert(n\
    \ >= 1);\n        return (n * (n - 1)) / 2;", "        long m = 2 * n;\n     \
    \   long distance = m;\n        long[] dx = new long[m];\n        long[] dxLeft\
    \ = new long[m];\n        long[] dxRight = new long[m];\n        long[] pos =\
    \ new long[m];\n        long[] posLeft = new long[m];\n        long[] posRight\
    \ = new long[m];\n        for (long i = 0; i < m; i++) {\n            pos[i] =\
    \ i;\n            posLeft[i] = i;\n            posRight[i] = i;\n            dx[i]\
    \ = i;\n            dxLeft[i] = i;\n            dxRight[i] = i;\n        }\n \
    \       long count = 0;\n        for (long i = 0; i < n; i++) {\n            for\
    \ (long j = 0; j < m; j++) {\n                dx[j] = pos[j] * (n - i) - (j +\
    \ 1) * (n - i) * (n - i);\n                dxLeft[j] = posLeft[j] * (n - i) -\
    \ (j + 1) * (n - i) * (n - i);\n                dxRight[j] = posRight[j] * (n\
    \ - i) - (j + 1) * (n - i) * (n - i);\n            }\n            dx.OrderBy(x\
    \ => x);\n            dxLeft.OrderBy(x => x);\n            dxRight.OrderBy(x =>\
    \ x);\n            for (long j = 0; j < m; j++) {\n                pos[j] = j;\n\
    \                posLeft[j] = j;\n                posRight[j] = j;\n         \
    \   }\n            for (long j = 0; j < m; j++) {\n                pos[dx[j]]\
    \ = j;\n                posLeft[dxLeft[j]] = j;\n                posRight[dxRight[j]]\
    \ = j;\n            }\n            // at this point, pos[0], ..., pos[m-1] denote\
    \ the position\n            // of each car after the ith second.\n           \
    \ // The car at pos[j] is moving right to left.\n            // The car at posLeft[",
  "        // Fill in the code here.\n        return 42;", "        // todo\n    \
    \    // Hint 1:\n        // If car 1 moves from a to b, and car 2 moves from c\
    \ to d, then the two cars collide if and only if\n        // a is between c and\
    \ d (inclusive), and b is between c and d (inclusive).\n        // Hint 2:\n \
    \       // n==1 is a special case.  Can you handle it?  What about n==2?\n   \
    \     // Hint 3:\n        // A solution that runs in time O(n lg n) is possible.\
    \  The O(n^2) solution is trickier.\n        // Hint 4:\n        // Think of it\
    \ as an excercise in sorting.\n        if (n == 1) return 0;\n        long[] left\
    \ = new long[n];\n        long[] right = new long[n];\n        for (int i = 0;\
    \ i < n; i++) {\n            left[i] = i;\n            right[i] = n + i;\n   \
    \     }\n        int l = 0;\n        int r = 0;\n        long res = 0;\n     \
    \   while (l < n && r < n) {\n            if (left[l] <= right[r]) {\n       \
    \         res += (n - r);\n                l++;\n            } else {\n      \
    \          r++;\n            }\n        }\n        return res;", "        // In\
    \ short:\n        // Look at the intersection points of each car going left and\
    \ each car going right.\n        // Calculate the distances between each of these\
    \ intersection points.\n        // Sort these distances (for n cars going left\
    \ and n cars going right, this is a total of 2n distances).\n        // The answer\
    \ is the sum of these distances (by adding the distances from left to right,\n\
    \        // and then from right to left).\n        //\n        // Here's the detailed\
    \ explanation:\n        // Let's say I have 2 cars moving in opposite directions,\
    \ as follows:\n        //      L1\n        //       |\n        // --R1--|--R2--\n\
    \        //      --L2--\n        // Where:\n        //   * L1 is the first car\
    \ moving left.\n        //   * L2 is the second car moving left.\n        // \
    \  * R1 is the first car moving right.\n        //   * R2 is the second car moving\
    \ right.\n        // Let's also assume:\n        //   * The speed of L1 is the\
    \ same as the speed of L2.\n        //   * The speed of R1 is the same as the\
    \ speed of R2.\n        //\n        // Theoretically, the number of collisions\
    \ is the integral of \n        //   ((time at which L1 reaches R1) - (time at\
    \ which L2 reaches R2))\n        // This can be rewritten as:\n        //   ((distance\
    \ from L1 to R1) - (distance from L2 to R2))\n        // Note that this is the\
    \ same as the distance between the collision of L1 and R1,\n        // and the\
    \ collision of L2 and R2.\n        //\n        // (1) Let's assume the speeds\
    \ of L1 and L2 are the same, and the speeds of R1 and R2 are the same, and they\
    \ are equal to each other.\n        //     Then the number of collisions is (R1\
    \ - L1) + (R2 - L2).\n        //\n        //     Why?\n        //     (R1 - L1)\
    \ is the time for L1 to reach R1.\n        //     (R2 - L2) is the time for L2\
    \ to reach R2.\n        //     (R1 - L1)", "        long colls = 0;\n        long[]\
    \ L = new long[n];\n        long[] R = new long[n];\n        for (long i = 0;\
    \ i < n; i++)\n            L[i] = i;\n        for (long i = 0; i < n; i++)\n \
    \           R[i] = n - i - 1;\n        for (long i = 0; i < n; i++)\n        \
    \    for (long j = 0; j < n; j++)\n                if (L[i] == R[j])\n       \
    \             colls++;\n        return colls;", "        // Write your code here\n\
    \        throw new NotImplementedException();", '        return n * (n - 1) /
    2;', "        var factorials = new long[n + 1];\n        factorials[0] = 1;\n\
    \        for (int i = 1; i <= n; i++) {\n            factorials[i] = i * factorials[i\
    \ - 1];\n        }\n        // Use stars and bars.\n        return factorials[2\
    \ * n] / (factorials[n] * factorials[n] * (n + 1));", "        long left_to_right\
    \ = n * (n - 1) / 2;\n        long right_to_left = n * (n - 1) / 2;\n        return\
    \ left_to_right * right_to_left;", "        // We first calculate the result for\
    \ the special case that n=0.\n        // This is done using simple brute force,\
    \ by keeping track of the\n        // current positions of all the cars moving\
    \ in the left to right\n        // direction, and the current positions of all\
    \ the cars moving in\n        // the right to left direction.  We then advance\
    \ the time by\n        // a small amount and check whether any cars are on the\
    \ same position.\n        var collisionPoints = new SortedSet<double>();\n   \
    \     var startingPositions = Enumerable.Range(0, (int)n).Select(x => 1e9 + n\
    \ + (2 * x)).ToList();\n        var leftToRightCars = startingPositions.Select(x\
    \ => new Car(x, 1)).ToList();\n        var rightToLeftCars = startingPositions.Select(x\
    \ => new Car(x, -1)).ToList();\n        for (var t = 0.0; t < 1e9; t += 1e-12)\
    \ {\n            var currentPositions = new HashSet<double>();\n            foreach\
    \ (var car in leftToRightCars) {\n                currentPositions.Add(car.PositionAtTime(t));\n\
    \            }\n            foreach (var car in rightToLeftCars) {\n         \
    \       if (currentPositions.Contains(car.PositionAtTime(t))) {\n            \
    \        collisionPoints.Add(t);\n                }\n            }\n        }\n\
    \        // We now split all intervals between consecutive collision points\n\
    \        // into a number of smaller intervals, so that the width of each interval\n\
    \        // is (1e-9).  The reason for this is that if a collision occurs in\n\
    \        // an interval between two consecutive collision points, then it will\n\
    \        // be recorded at one of the endpoints of that interval.\n        var\
    \ collisionPointsList = collisionPoints.ToList();\n        var splitPoints = new\
    \ SortedSet<double>();\n        foreach (var t in collisionPointsList) {\n   \
    \         splitPoints.Add(t);\n            var lo = t;\n            var hi = t\
    \ + 1e-9;\n            while (hi < collisionPointsList[0]) {\n               \
    \ splitPoints.Add(hi);\n                lo = hi;\n                hi = lo + 1e",
  "        long total = 0;\n        var carl = new long[n];\n        var carr = new\
    \ long[n];\n        // First stage, initialize cars, and sort them by arrival\
    \ time.\n        for (int i = 0; i < n; i++) {\n            carl[i] = i;\n   \
    \         carr[i] = 2 * n - i - 1;\n        }\n        Array.Sort(carl);\n   \
    \     Array.Sort(carr);\n        // Second stage, do an O(n) sweep from left to\
    \ right and count collisions.\n        // At each point, the number of collisions\
    \ is simply the number of cars that\n        // started moving left that arrive\
    \ here, times the number of cars that started\n        // moving right that arrive\
    \ here.\n        int p = 0;\n        for (int i = 0; i < n; i++) {\n         \
    \   while (p < n && carr[p] < carl[i]) p++;\n            total += p;\n       \
    \ }\n        return total;", "        // replace this code with your own...\n\
    \        Random r = new Random();\n        return (long)r.Next();", "        //\
    \ Your code goes here.\n        return 0;", '        return n * (n - 1) / 2;',
  "        // Let's say that n cars drive left to right, and n cars drive right to\
    \ left.\n        // Let's say the the left-to-right cars are numbered from 1 to\
    \ n in order of their starting location,\n        // and the right-to-left cars\
    \ are numbered from 1 to n in order of their starting location.\n        // This\
    \ function computes the number of collisions.\n        // For example, if n =\
    \ 3, then the left-to-right cars are numbered 1, 2, 3 in order of their start\
    \ location.\n        // The right-to-left cars are also numbered 1, 2, 3 in order\
    \ of their start location.\n        // There will be 4 collisions because:\n \
    \       // 1. The car that starts at location 1 and moves right to left collides\
    \ with the car that starts at location 1 and moves left to right.\n        //\
    \ 2. The car that starts at location 2 and moves right to left collides with the\
    \ car that starts at location 2 and moves left to right.\n        // 3. The car\
    \ that starts at location 3 and moves right to left collides with the car that\
    \ starts at location 3 and moves left to right.\n        // 4. The car that starts\
    \ at location 3 and moves right to left collides with the car that starts at location\
    \ 2 and moves left to right.\n        // Note that the 4th collision does not\
    \ involve the car that starts at location 1 and moves left to right;  that's because\
    \ the 4th collision\n        // happens after the first two cars have already\
    \ collided.\n        //\n        // To compute the number of collisions, we need\
    \ to compute the number of pairs of cars that collide;\n        // the number\
    \ of pairs of cars that collide is the same as the number of collisions.\n   \
    \     // For example, in the case of n = 3, there are four pairs of cars that\
    \ collide:\n        // 1) the pair of cars that starts at location 1, both left-to-right\
    \ and right-to-left.\n        // 2) the pair of cars that starts at location 2,\
    \ both left-to-right and right-to-left.\n        // 3) the pair of cars that starts\
    \ at location 3, both left-to-right and right-to-left.\n        // 4) the pair\
    \ of cars that starts at location 2 and 3, left-to-right and right-to-left", " \
    \       long ret = 0;\n        foreach (var q in Enumerable.Range(1, (int)n))\
    \ {\n            foreach (var p in Enumerable.Range(1, (int)n)) {\n          \
    \      ret += p * q;\n            }\n        }\n        return ret;", "      \
    \  long[] posl = new long[n];\n        long[] posr = new long[n];\n        long[]\
    \ speedl = new long[n];\n        long[] speedr = new long[n];\n        for (long\
    \ i = 0; i < n; i++) {\n            posl[i] = i;\n            posr[i] = n + i;\n\
    \            speedl[i] = 1;\n            speedr[i] = 1;\n        }\n        long\
    \ time = 0;\n        long collision = 0;\n        for (long i = 0; i < n; i++)\
    \ {\n            for (long j = 0; j < n; j++) {\n                if (posl[i] ==\
    \ posr[j]) {\n                    collision++;\n                }\n          \
    \  }\n            time++;\n            for (long j = 0; j < n; j++) {\n      \
    \          posl[j] += speedl[j];\n                posr[j] -= speedr[j];\n    \
    \        }\n        }\n        return collision;", "        // your code here\n\
    \        return 0;", "        long collisions = 0;\n        // Implement a solution\
    \ here.  The sample solution is just a placeholder.\n        return collisions;",
  "        var a = new long[n];\n        var b = new long[n];\n        long answer\
    \ = 0;\n        for (long i = 0; i < n; i++) {\n            for (long j = 0; j\
    \ < n; j++) {\n                var x = i - j;\n                var y = Math.Abs(x);\n\
    \                if (x > 0) {\n                    answer += y;\n            \
    \    }\n            }\n        }\n        return answer;", "        var rnd =\
    \ new Random();\n        var left = Enumerable.Range(0, (int)n).Select(x => rnd.Next(1,\
    \ 100)).ToArray();\n        var right = Enumerable.Range(0, (int)n).Select(x =>\
    \ rnd.Next(1, 100)).ToArray();\n        Array.Sort(left);\n        Array.Sort(right);\n\
    \        var collisions = 0;\n        var i = 0;\n        var j = 0;\n       \
    \ while (i < n && j < n) {\n            if (left[i] < right[j]) {\n          \
    \      collisions++;\n                i++;\n            } else {\n           \
    \     j++;\n            }\n        }\n        return collisions;", "        //\
    \ It is a very simple observation that the left-to-right car #i\n        // and\
    \ the right-to-left car #i will never collide.\n        // For every other pair\
    \ of cars, the left-to-right car and the right-to-left car\n        // will collide,\
    \ because both cars are moving towards each other.\n        // The left-to-right\
    \ car i can collide with the right-to-left car j\n        // iff i != j.\n   \
    \     // Therefore, there are n * (n - 1) collisions.\n        return n * (n -\
    \ 1);", "        // Assume that the left to right cars are numbered 1 to n, and\n\
    \        // the right to left cars are numbered n+1 to 2n\n        // We compute\
    \ a vector of pairs (x, y),\n        // where x is the x-coordinate of car x,\
    \ and\n        // y is the y-coordinate of car y,\n        // for all cars x and\
    \ y.\n        // The x-coordinate of car x is equal to x;\n        // the y-coordinate\
    \ of car x is equal to x^2 - n^2.\n        // The x-coordinate of car y is equal\
    \ to 2n - y;\n        // the y-coordinate of car y is equal to y^2 - n^2.\n  \
    \      // We then sort this vector by x-coordinate,\n        // and then by y-coordinate.\n\
    \        var Car = new List<Tuple<long, long>>();\n        for (long x = 1; x\
    \ <= n; x++) {\n            Car.Add(Tuple.Create(x, x * x - n * n));\n       \
    \ }\n        for (long y = n + 1; y <= 2 * n; y++) {\n            Car.Add(Tuple.Create(2\
    \ * n - y, y * y - n * n));\n        }\n        Car.Sort((x, y) => {\n       \
    \     var compareX = x.Item1.CompareTo(y.Item1);\n            if (compareX !=\
    \ 0) {\n                return compareX;\n            }\n            return x.Item2.CompareTo(y.Item2);\n\
    \        });\n        // We now go over the sequence of cars in\n        // sorted\
    \ order and count the number of collisions.\n        long collisions = 0;\n  \
    \      for (long i = 0; i < 2 * n; i++) {\n            long x = Car[i].Item1;\n\
    \            long y = Car[i].Item2;\n            if (x < y) {\n              \
    \  // The car moving right to left will collide with each car to its left.\n \
    \               collisions += i;\n            } else {\n                // The\
    \ car moving left to right will collide with each car to its right.\n        \
    \        collisions += 2 * n - i - 1;\n            }\n       ", "        var a\
    \ = -1 * (n + 1);\n        var a2 = a * a;\n        var b = n * n;\n        var\
    \ c = b - a2;\n        return c;", "        if (n == 0) return 0;\n        return\
    \ (n * (n - 1)) / 2;", "        // Algorithm:\n        // Sort the two sets of\
    \ car positions from left to right;\n        // Then, the two cars that will hit\
    \ each other next are the two cars that are closest to each other.\n        //\
    \ The car on the left is the one moving left to right, and the car on the right\
    \ is the one moving right to left.\n        // Therefore, count the number of\
    \ such pairs of cars, and also keep track of their distances;\n        // The\
    \ total number of collisions is the sum of those distances.\n        long[] a\
    \ = new long[n];\n        long[] b = new long[n];\n        for (long i = 0; i\
    \ < n; i++) {\n            a[i] = 100000000000L - i;\n            b[i] = 100000000000L\
    \ + i;\n        }\n        Array.Sort(a);\n        Array.Sort(b);\n        long\
    \ ans = 0;\n        for (long i = 0; i < n; i++) {\n            ans += a[i] -\
    \ b[i];\n        }\n        return ans;", "        long collisions = 0;\n\n  \
    \      // If a car at index k of the right to left cars is\n        // the right\
    \ most right to left car that collides with\n        // the left to right car\
    \ at index k, then sum up all the\n        // distances between the right to left\
    \ cars and the \n        // left to right cars.  Those are the collisions.\n \
    \       for (long k = 0; k < n; k++) {\n            long sum = 0;\n          \
    \  for (long i = 0; i < k; i++) {\n                sum += (n - 1 - i) - i;\n \
    \           }\n            for (long i = k + 1; i < n; i++) {\n              \
    \  sum += (n - 1 - i) - i;\n            }\n            collisions += sum;\n  \
    \      }\n        return collisions;", "        if (n < 0)\n            throw\
    \ new ArgumentException(\"n should be non-negative\");\n        long count = 0;\n\
    \        for (long i = 0; i < n; i++) {\n            for (long j = 0; j < n; j++)\
    \ {\n                if (i - j > 0)\n                    count++;\n          \
    \  }\n        }\n        return count;", "        // return (long)BigInteger.ModPow(2,\
    \ n, 1000000007);\n        return 0;", "        if (n == 0) {\n            return\
    \ 0;\n        }\n        else if (n == 1) {\n            return 1;\n        }\n\
    \        else {\n            return 2 * n - 1;\n        }", "        // Your solution\
    \ here\n        return n*(n-1)/2;", "        long res = 0;\n        // First,\
    \ we make an invariant argument.\n        // We will show that the number of collisions\
    \ is always odd.\n        // We can then just return that number.\n        //\
    \ Base case: n = 1.\n        // The number of collisions is 1.\n        // Inductive\
    \ step:\n        // Now, suppose the number of collisions is always odd for all\
    \ n < N.\n        // We need to show that it's also odd for n = N.\n        //\
    \ Fix a value of n = N.\n        // There are two cases to consider.\n       \
    \ // Case A.  The Nth car from the left that's moving right to left collides with\n\
    \        // the Nth car from the right that's moving left to right.\n        //\
    \ This case is easy.\n        // The number of collisions in this case is 1 +\
    \ the number of collisions for n = N - 1.\n        // (By an argument similar\
    \ to the inductive step, the number of collisions for n = N - 1\n        // is\
    \ odd).  Since 1 is an odd number, 1 + an odd number is still odd.\n        //\
    \ Case B.  The Nth car from the left that's moving right to left collides with\n\
    \        // the (N - 1)th car from the right that's moving left to right.\n  \
    \      // This case is also easy.\n        // The number of collisions in this\
    \ case is 1 + the number of collisions for n = N - 2.\n        // (By an argument\
    \ similar to the inductive step, the number of collisions for n = N - 2\n    \
    \    // is odd).  Since 1 is an odd number, 1 + an odd number is still odd.\n\
    \        // Since Case A and Case B cover all possible collisions for n = N, the\
    \ number of collisions\n        // for n = N is odd.\n        // Therefore, by\
    \ mathematical induction, the number of collisions is always odd.\n        //\
    \ QED.\n        // Finally, we implement the algorithm in the inductive step.\n\
    \        // For each value of n, we just count the number of collisions.\n   \
    \     // We do this by checking each pair of cars, one that's going left to right,\n\
    \        // and one that's going right to left.\n        // We sum all the results.\n\
    \        long i, j;\n        for (", '        return 0;', "        // Your code\
    \ here. \n        // (Needless to say, your code must be more efficient than just\
    \ doing a brute force calculation.)\n        // Another important note:  your\
    \ code has to work for n = 18446744073709551615.\n        // Please describe your\
    \ algorithm on paper, then write your answer here.\n\n        // Even cars are\
    \ moving to the right\n        // Odd cars are moving to the left\n        //\
    \ The path of each car is linear\n        // Collision point will be the intersection\
    \ of the path of the two cars\n        // Speed is constant, so the time at which\
    \ two cars will meet will be the same for any two cars\n        // because the\
    \ time taken to reach intersection will be the same for any two cars\n       \
    \ // So, only one intersection point is possible\n        // Finding that intersection\
    \ point and using this point as reference, you can find\n        // the number\
    \ of collisions. \n        if (n == 0) return 0;\n        long[] even = new long[n];\n\
    \        long[] odd = new long[n];\n        for (long i = 0; i < n; i++)\n   \
    \     {\n            even[i] = 2 * i;\n            odd[i] = 2 * i + 1;\n     \
    \   }\n        double time = -1;\n        for (long i = 0; i < n; i++)\n     \
    \   {\n            if (odd[i] == even[i])\n            {\n                time\
    \ = (double)even[i] / 2;\n                break;\n            }\n        }\n \
    \       if (time == -1)\n        {\n            time = n;\n        }\n       \
    \ //Console.WriteLine(time);\n        long num_collisions = 0;\n        for (long\
    \ i = 0; i < n; i++)\n        {\n            if (even[i] <= time)\n          \
    \  {\n                num_collisions++;\n            }\n            if (odd[i]\
    \ <= time)\n            {\n                num_collisions++;\n            }\n\
    \        }\n        //Console.WriteLine(num_collisions);\n        return num_collisions;",
  "        long ret = 0;\n        Debug.Assert(n >= 0);\n        // Your code goes\
    \ here\n        return ret;", "        long r = 0;\n        for (long k = 1; k\
    \ <= n; k++) {\n            r += k - 1;\n        }\n        return r;", "    \
    \    // Implement this function.  You can add additional methods and classes if\
    \ you want.\n        //\n        // Note that the input n is a long, so be sure\
    \ to represent it using a BigInteger\n        // internally.\n        //\n   \
    \     // If you can, try to find a solution that runs in logarithmic time or better\n\
    \        // (O(log n) or better).\n        var left = GetLeft(n);\n        var\
    \ right = GetRight(n);\n        var count = 0;\n        var leftIndex = 0;\n \
    \       var rightIndex = 0;\n        while (leftIndex < left.Count && rightIndex\
    \ < right.Count) {\n            if (left[leftIndex] <= right[rightIndex]) {\n\
    \                count += leftIndex;\n                leftIndex++;\n         \
    \   } else {\n                count += left.Count - leftIndex - 1;\n         \
    \       rightIndex++;\n            }\n        }\n        return count;", "   \
    \     // TODO, implement this method.\n        // Note that the method signature\
    \ must be \n        // public static long CarRaceCollision(long n)\n\n       \
    \ // Note also that this algorithm is not optimized for big numbers.\n       \
    \ // So for big numbers, it will be inefficient and your machine may run\n   \
    \     // out of memory.\n        return 0;", "        // ...\n        return 0;",
  '        return n;', '        return n;', "        long x = 0;\n\n        long n_minus_x\
    \ = n - x;\n        long y = n_minus_x;\n        long n_minus_y = n - y;\n   \
    \     long n_minus_x_minus_y = n_minus_x - y;\n\n        long collisions = x *\
    \ y + x * n_minus_y + n_minus_x * y + (n_minus_x_minus_y) * (n_minus_x_minus_y\
    \ - 1) / 2;\n        return collisions;", "        long a = 0;\n        long b\
    \ = 0;\n        long collisions = 0;\n        long nexta = 0;\n        long nextb\
    \ = 0;\n        long i = 0;\n        while (i < n) {\n            if (i == nexta)\
    \ {\n                a++;\n                nexta = a + b + 1;\n            }\n\
    \            if (i == nextb) {\n                b++;\n                nextb =\
    \ a + b + 1;\n            }\n            if (nexta == nextb) {\n             \
    \   collisions++;\n                nexta++;\n                nextb++;\n      \
    \      }\n            else if (nexta < nextb) {\n                nexta++;\n  \
    \          }\n            else {\n                nextb++;\n            }\n  \
    \          i++;\n        }\n        return collisions;", "        // !! Fill in\
    \ your implementation here.\n        if (n == 0)\n            return 0;\n    \
    \    long count = 0;\n        long L = 1;\n        long R = n;\n        while\
    \ (R > L)\n        {\n            long mid = (L + R) / 2;\n            if (mid\
    \ * mid == n)\n            {\n                count = mid;\n                break;\n\
    \            }\n            else if (mid * mid > n)\n            {\n         \
    \       R = mid - 1;\n            }\n            else\n            {\n       \
    \         count = mid;\n                L = mid + 1;\n            }\n        }\n\
    \        return count * count;", '        return (n * (n - 1)) / 2;', "      \
    \  if (n < 1)\n            throw new ArgumentOutOfRangeException(\"Input must\
    \ be positive.\");\n        if (n == 1)\n            return 0;\n        long result\
    \ = 0;\n        // brute force\n        for (long i = 1; i < n; i++) {\n     \
    \       for (long j = n + 1; j <= 2 * n; j++) {\n                if (i < j) {\n\
    \                    long gcd = GCD(i, j);\n                    result += (2 *\
    \ n) / gcd - 1;\n                }\n            }\n        }\n        return result;",
  "        long count = 0;\n        var left = new Stack<long>();\n        var right\
    \ = new Stack<long>();\n        for (long i = 0; i < n; i++) {\n            left.Push(n\
    \ - i);\n            right.Push(i + 1);\n        }\n        while (left.Count\
    \ > 0) {\n            var x = left.Pop();\n            var y = right.Pop();\n\
    \            if (x > y) {\n                count += x - y;\n                left.Push(x);\n\
    \            } else {\n                count += y - x;\n                right.Push(y);\n\
    \            }\n        }\n        return count;", "        // The answer is ((n\
    \ * (n-1)) / 2)\n        long x = 1;\n        for (long i = 2; i <= n; i++) {\n\
    \            x = checked(x * i);\n        }\n        return (x * (x - 1)) / 2;",
  "        long count = 0;\n        // A car moving right to left is at position -(i+1),\
    \ with i ranging from 0 to n-1\n        // A car moving left to right is at position\
    \ (i+1), with i ranging from 0 to n-1\n        // A collision happens when -(i+1)\
    \ == (j+1) or i == j\n        // number of such collisions is n-1 + n-2 + n-3\
    \ + ... + 1 == n(n-1)/2\n        count = n * (n - 1) / 2;\n        return count;",
  "        // Your code goes here.\n        int count = 0;\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if\
    \ (i + j == n) {\n                    if (i == j) {\n                        count\
    \ += 1;\n                    } else {\n                        count += 2;\n \
    \                   }\n                }\n            }\n        }\n        return\
    \ count;", '        return n * (n - 1) / 2;', '        return 6;', "        //TODO:\
    \ implement your solution here\n        return -1;", "        // Solution 1: brute\
    \ force.  Each of the n cars going left to right will collide with\n        //\
    \ one of the cars going right to left.  So we'll loop through them and check.\n\
    \        // To avoid double counting, we'll only loop through the \"left-to-right\"\
    \ cars\n        // with larger positions (pos_1) than the \"right-to-left\" cars\
    \ with smaller positions\n        // (pos_2).  For each pair (pos_1, pos_2), we\
    \ count a collision iff pos_1 >= pos_2.\n        // This way, each collision is\
    \ counted exactly once.\n        long numCollisions = 0;\n        for (long pos_1\
    \ = n; pos_1 >= 1; pos_1--) {\n            for (long pos_2 = 1; pos_2 <= n; pos_2++)\
    \ {\n                if (pos_1 >= pos_2) {\n                    numCollisions++;\n\
    \                }\n            }\n        }\n        return numCollisions;",
  "        long answer = 1;\n        for (long i = 1; i <= n; i++) {\n           \
    \ answer += i;\n        }\n        return answer;", "        var exp = (long)Math.Floor(Math.Log(n,2));\n\
    \        var result = 0L;\n        for (var i = exp; i >= 0; i--) {\n        \
    \    var pow = (long)Math.Pow(2,i);\n            var r = (long)Math.Floor((double)n/pow);\n\
    \            if (r % 2 == 1)\n                result = result | pow;\n       \
    \     n = n - (r-1)*pow;\n        }\n        return result;", "        // TODO:\
    \ Find out what the answer is.  You're not allowed to run the code, or measure\n\
    \        // times, or anything like that.  However, you are allowed to come up\
    \ with clever\n        // ideas to find the answer.\n        return 0;", "   \
    \     // To solve this problem, we'll use the Sieve of Eratosthenes.\n       \
    \ // Say that we want to count the number of left-to-right cars that are\n   \
    \     // collision with right-to-left cars.  Suppose we have a car k moving right\
    \ to left.\n        // If any left-to-right car collides with k, then the left-to-right\
    \ car must have\n        // already traveled some distance, and hence must be\
    \ at least k units to the left of k.\n        // Hence, k must have collided with\
    \ every left-to-right car from 1 to k-1.\n        // Hence, we'll have a state\
    \ for each left-to-right car, and whether k has collided with it.\n        //\
    \ Then, we'll check each car moving right to left, and increment the answer by\
    \ the\n        // number of left-to-right cars that k has not collided with yet.\n\
    \        bool[] state = new bool[n + 1];\n        long answer = 0;\n        for\
    \ (long k = n; k >= 1; k--) {\n            long collisionCount = 0;\n        \
    \    // Check how many left-to-right cars have not collided with k.\n        \
    \    for (long i = 1; i < k; i++) {\n                if (!state[i]) {\n      \
    \              collisionCount++;\n                }\n            }\n         \
    \   // Then, mark them all as collided.\n            for (long i = 1; i < k; i++)\
    \ {\n                state[i] = true;\n            }\n            // Then, increment\
    \ the answer by the number of collisions.\n            answer += collisionCount;\n\
    \        }\n        return answer;", "        // Define \"s(m,n)\" to be the number\
    \ of collisions where there are m cars moving\n        // left to right and n\
    \ cars moving right to left.  The problem is to compute s(n,n).\n        // We'll\
    \ use the following facts:\n        //\n        // Fact 1: s(m,n) = 0 if m or\
    \ n is negative or zero.\n        // Fact 2: s(m,n) = s(m-1,n) + s(m,n-1) + (m-1)*(n-1)\n\
    \        // Fact 3: s(n,n) = s(n-1,n) + s(n,n-1) + (n-1)*(n-1)\n        //\n \
    \       // We'll use dynamic programming to compute s(n,n).\n        //\n    \
    \    // First, let's check the feasibility of the algorithm; namely, we'll need\n\
    \        // that s(m,n) fits in a long.  This can be done by showing that s(m,n)\
    \ is\n        // upper-bounded by the function f(m,n) = (m+n)^2.\n        // Here's\
    \ the proof:\n        //\n        // s(m,n) = s(m-1,n) + s(m,n-1) + (m-1)*(n-1)\n\
    \        //       <= s(m-1,n) + s(m,n-1) + (m+n-2)^2\n        //       <= s(m-1,n)\
    \ + s(m,n-1) + (m+n-1)^2\n        //       <= s(m-1,n) + s(m,n-1) + (m+n)^2\n\
    \        //       <= f(m-1,n) + f(m,n-1) + (m+n)^2\n        //       <= f(m,n)\n\
    \        //\n        // That concludes the proof.\n        //\n        // So the\
    \ DP algorithm fits in a long.  It'll take O(n^2) time.\n        // Let's implement\
    \ it.\n        long[,] s = new long[n+1,n+1", "        long result = 0;\n    \
    \    for (long i = 0; i < n; i++) {\n            for (long j = 0; j < n; j++)\
    \ {\n                if (i < j) {\n                    result++;\n           \
    \     }\n            }\n        }\n        return result;", '        return n
    * (n - 1) / 2;', "        long res = n;\n        long p = 5;\n        while (p\
    \ <= n) {\n            res = (res * p) % 1000000007;\n            p += 4;\n  \
    \      }\n        return res;", '        return n * (n - 1) / 2;', "        long\
    \ sum = 0;\n        //\n        // YOUR CODE GOES HERE\n        //\n        sum\
    \ = n * (n - 1) / 2;\n        return sum;", "        long collision = 0;\n   \
    \     // CHALLENGE\n        // Implement the algorithm in this function to efficiently\
    \ compute the\n        // number of car race collisions.\n        // \n      \
    \  // HINT\n        //\n        //  * You do not need to write an \"if\" statement\
    \ in this function.\n        //  * You do not need to use recursion in this function.\n\
    \        //  * You do not need to write a \"for\" loop in this function.\n   \
    \     //  * You do not need to write a \"while\" loop in this function.\n    \
    \    //  * You can write any additional functions you want.\n        //  * You\
    \ may use the built-in sorting algorithm of your choice.\n        //  * You may\
    \ use the built-in timing function of your choice.\n        //  * If you're using\
    \ LINQ, there is a built-in algorithm you can use\n        //    that runs in\
    \ linear time.\n        //  * This can be solved with less than 10 lines of code.\n\
    \        //  * You can call this function and the test runner in the main function\
    \ below.\n        //\n        return collision;", "        // Your code goes here.\n\
    \        return 0;", "        // This is O(n^2).  Can you find something faster?\n\
    \        // REPLACE THIS LINE WITH YOUR CODE\n        return -1;", "        //TODO:\
    \  write your code here\n        return 0;", "        //\n        // Your code\
    \ here.\n        //", "        // The total number of collisions is the sum of\
    \ number of collisions for each position,\n        // where the car is numbered\
    \ from 0 to n-1.\n        // For each car, the other cars are numbered -(n-1),\
    \ ..., -1, 1, ..., n-1.\n        // The number of collisions is the number of\
    \ cars with a negative index\n        // that have a smaller value than the car\
    \ at the given position,\n        // and the number of cars with a positive index\
    \ that have a larger value\n        // than the car at the given position.\n \
    \       // These equal the number of cars with negative index and positive index,\
    \ respectively,\n        // minus the number of cars with negative index and larger\
    \ value,\n        // and the number of cars with positive index and smaller value.\n\
    \        // The former is (n-1) - the car's value, and the latter is the car's\
    \ value - 1.\n        // So the number of collisions is (n-1) - car's value -\
    \ car's value + 1 = n-2.\n        return n * (n - 1) / 2;", '        return n
    * (n - 1) / 2;', "        // Define \"event\" to be a tuple of x, t, and type,\
    \ where:\n        // - x is the position of the event;\n        // - t is the\
    \ time of the event;\n        // - type is either \"left to right\" or \"right\
    \ to left\".\n        var events = new List<Tuple<double, double, string>>();\n\
    \        for (long i = 0; i < n; i++) {\n            // For convenience, define\
    \ s[i] to be the position of the ith car\n            // that's moving left to\
    \ right, and r[i] to be the position of the ith car\n            // that's moving\
    \ right to left.  Each car starts out moving in the same\n            // direction\
    \ from a very far distance (1 billion miles) away.\n            // Define v[i]\
    \ to be the velocity of the ith car.  By design, all v[i]\n            // are\
    \ the same.\n            double s = 1e9 + i, r = 1e9 - i;\n            double\
    \ v = 1;\n            // Initially, the position of the ith car that's moving\
    \ left to right is s[i],\n            // and the position of the ith car that's\
    \ moving right to left is r[i].\n            // The time of this event is 0.\n\
    \            events.Add(Tuple.Create(s, 0.0, \"left to right\"));\n          \
    \  events.Add(Tuple.Create(r, 0.0, \"right to left\"));\n            // The next\
    \ time an event occurs is when the ith car that's moving left to right\n     \
    \       // changes its position to s[i] + v[i].  This happens at time (s[i] -\
    \ (s[i] + v[i])) / v[i].\n            // Similarly, the next time an event occurs\
    \ is when the ith car that's moving right to left\n            // changes its\
    \ position to r[i] - v[i].  This happens at time (r[i] - (r[i] - v[i])) / v[i].\n\
    \            events.Add(Tuple.Create(s + v, (s - (s + v)) / v, \"left to right\"\
    ));\n            events.Add(Tuple.Create", "        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // We want to count the number of collisions here.  If a car moving left\
    \ to right\n        // hits a car moving right to left, we'll call that a collision.\
    \  But if a car moving\n        // left to right hits a car moving left to right,\
    \ or a car moving right to left hits\n        // a car moving right to left, we\
    \ won't call that a collision.\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // First we'll sort the left to right cars by their starting positions.\n\
    \        // Then we'll sort the right to left cars by their starting positions.\n\
    \        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // Consider the left to right cars as a function of their starting positions.\n\
    \        // The function takes a starting position and returns the ending position.\n\
    \        // (The ending position is the starting position plus the car's length.)\n\
    \        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // Here is the set of right to left cars as a function of their starting\
    \ positions.\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // Observe that a collision occurs between a left to right car and a\
    \ right to left car\n        // if and only if the right to left car's ending\
    \ position is less than the left to right\n        // car's ending position.\n\
    \        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // We could potentially count the number of collisions in n^2 time.\n\
    \        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // But there is a linear time algorithm here.\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // It's a generalization of the merge operation from mergesort.\n   \
    \     // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // Let's start with a small example to see how it works.\n        //\
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // For example, suppose there are 10 left to right cars, each of length\
    \ 3.\n        // So their ending positions are 3, 6, 9, 12, 15, 18, 21, 24, 27,\
    \ 30.\n        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \        // Suppose there are 10 right to left cars, each of length 5.\n     \
    \   // So their ending positions are 5, 10, 15, 20, 25, 30, 35, 40, 45", "   \
    \     if (n < 1) throw new Exception(\"n must be positive\");\n        if (n ==\
    \ 1) return 0;\n        return n * (n - 1) / 2;", "        var a = new long[3000001];\n\
    \        var b = new long[3000001];\n        for (long i = 0; i < n; i++) {\n\
    \            a[i] = i * n + 1;\n            b[i] = i * n + 1;\n        }\n   \
    \     return MergeSort(a, b, 0, n - 1, 0, n - 1);", "        //TODO: Solve this\
    \ problem\n        return 0;", "        // This is an example of how to use an\
    \ array as a stack.  It's not necessary\n        // to use this method to solve\
    \ the problem but it's interesting.\n        //\n        // Imagine that our \"\
    array\" is a stack of plates.  The following loop\n        // is pushing (n+1)\
    \ plates onto the stack, one at a time.\n        // The \"top plate\" is the plate\
    \ at the top of the stack.\n        // The \"bottom plate\" is the plate at the\
    \ bottom of the stack.\n        // The top plate is at position 0, and the bottom\
    \ plate is at position n.\n        // The variable \"top plate index\" is the\
    \ index of the top plate.\n        // The variable \"bottom plate index\" is the\
    \ index of the bottom plate.\n        // The variable \"top plate index\" starts\
    \ at -1, which means that we haven't\n        // put any plates on the stack yet.\n\
    \        // The variable \"bottom plate index\" starts at n+1, which means that\
    \ we haven't\n        // taken any plates off the stack yet.\n        long collisionCount\
    \ = 0;\n        long[] leftToRightCarPositions = new long[n];\n        long[]\
    \ rightToLeftCarPositions = new long[n];\n        long topPlateIndex = -1;\n \
    \       long bottomPlateIndex = n + 1;\n        for (long i = 0; i < n; i++) {\n\
    \            // We're pushing a new plate onto the stack.\n            topPlateIndex++;\n\
    \            leftToRightCarPositions[topPlateIndex] = i;\n            // The following\
    \ loop is popping plates off the stack, one at a time.\n            //\n     \
    \       // The plate that we're popping off is the top plate.\n            //\
    \ The plate that we're putting back on top of the stack is the one\n         \
    \   // that's underneath the one that we're popping off.\n            //\n   \
    \         // The loop is repeating until we pop off the bottom plate.\n      \
    \      // Then we stop.\n            while (topPlateIndex >= bottomPlateIndex)\
    \ {\n                // We're popping a plate off the stack.\n               \
    \ topPlateIndex--;\n                // We're pushing a plate back onto the stack.\n\
    \                bottomPlateIndex--;\n                rightToLeftCarPositions[bottom",
  "        // calculate the sum of the integers 1 to n, and square it.\n        long\
    \ sum = n * (n + 1) / 2;\n        return sum * sum;", '        return n*(n-1);',
  "        if (n == 0) return 0;\n        if (n == 1) return 1;\n        if (n ==\
    \ 2) return 5;\n        if (n == 3) return 13;\n        // Binary search for the\
    \ answer.\n        // n is in the range of [4, 20000].\n        long start = 4;\n\
    \        long end = 20000;\n        while (start < end) {\n            long mid\
    \ = (start + end) / 2;\n            long numCollisions = CountCollisions(mid);\n\
    \            if (numCollisions > n) {\n                end = mid;\n          \
    \  } else {\n                start = mid + 1;\n            }\n        }\n    \
    \    return CountCollisions(start);", "        // This solution is computed in\
    \ the manner of https://leetcode.com/problems/battleships-in-a-board/\n      \
    \  // except that every car has a +1 or -1 weight.  The collision count is then\
    \ the sum of the\n        // weights of battleships that are vertically aligned;\
    \ this is easily proven.\n        long[,] weights = new long[n, n];\n        for\
    \ (long i = 0; i < n; i++) {\n            for (long j = 0; j < n; j++) {\n   \
    \             weights[i, j] = (i == j) ? 1 : 0;\n            }\n        }\n  \
    \      long collisions = 0;\n        for (long i = 0; i < n; i++) {\n        \
    \    for (long j = 0; j < n; j++) {\n                if (weights[i, j] == 0) continue;\n\
    \                for (long k = i + 1; k < n; k++) {\n                    if (weights[k,\
    \ j] == 0) continue;\n                    collisions += weights[i, j] * weights[k,\
    \ j];\n                    weights[k, j] = 0;\n                }\n           \
    \ }\n        }\n        return collisions;", '        return n*(n-1)/2;', "  \
    \      // constraint\n        if (n < 1) return 0;\n        // generate start\
    \ positions for n cars moving left to right\n        long[][] CarsMovingLeftToRight\
    \ = GenerateCarsMovingLeftToRight(n);\n        // generate start positions for\
    \ n cars moving right to left\n        long[][] CarsMovingRightToLeft = GenerateCarsMovingRightToLeft(n);\n\
    \        // multiply the number of cars by 2\n        // this will ensure that\
    \ we have enough cars to get the number of collisions\n        long[][] Cars =\
    \ MultiplyCars(CarsMovingLeftToRight, CarsMovingRightToLeft);\n        // calculate\
    \ the number of collisions between each pair of cars\n        long collisions\
    \ = NumberOfCollisions(Cars);\n        // output\n        return collisions;",
  "        long nOver2 = n / 2;\n        long result = (nOver2 + 1) * nOver2;\n\n\
    \        if (n % 2 == 0) {\n            result -= nOver2;\n        }\n\n     \
    \   return result;", "        // If n is 1, then there is no collision.\n    \
    \    if (n <= 1) return 0;\n        // If n is more than 1, than the number of\
    \ collisions is n-1.\n        // For example, if n is 3, then (1,3), (2,3) collide.\n\
    \        return n - 1;", "        if (n <= 0) {\n            return 0;\n     \
    \   }\n        long sum = 0;\n        for (long i = 1; i <= n; i++) {\n      \
    \      sum += i;\n        }\n        return sum;", "        // TODO:  Implement\
    \ this method.\n        return 0;", "        // Your code goes here.\n       \
    \ // Note that the return value is of type long.\n        return 0;", "      \
    \  long ret = 0;\n        // Your Solution Here\n        return ret;", "     \
    \   long totalCollisions = 0;\n        // Each car has an integer speed.   The\
    \ speed is the number of units\n        // this car moves in 1 second.  Positive\
    \ speeds mean that the car is\n        // moving right to left.  Negative speeds\
    \ mean that the car is moving\n        // left to right.\n        // The cars\
    \ will be represented by their speeds.  The sign of the speed\n        // indicates\
    \ which direction the car is going, and the value of the speed\n        // indicates\
    \ how fast the car is moving.\n        long[] speeds = new long[n];\n        //\
    \ Initialize speeds for the cars.\n        for (long i = 0; i < n; i++) {\n  \
    \          speeds[i] = i + 1;\n        }\n        // Now, let's run a simulation.\n\
    \        // Each car will move in the respective speed.\n        // A simulation\
    \ consists of a lot of steps.\n        // In each step, each car moves one position\
    \ to the right.\n        // If we are at the end of the simulation, that means\
    \ that we stopped moving.\n        // If we stopped moving and we have not yet\
    \ found a collision, that means that there are no collisions.\n        long[]\
    \ carPositions = new long[n];\n        // Initialize the car positions.\n    \
    \    for (long i = 0; i < n; i++) {\n            carPositions[i] = -i;\n     \
    \   }\n        // At each point in time, the cars will be moving in their respective\
    \ speeds.\n        // Therefore, after one step, we need to recalculate the car\
    \ positions.\n        // Running the simulation by recalculating the car positions\
    \ until there are no more collisions.\n        while (true) {\n            //\
    \ By default, assume that we did not find a collision.\n            bool collisionFound\
    \ = false;\n            // Check for collisions.\n            for (long i = 0;\
    \ i < n; i++) {\n                // A collision happens if this car is moving\
    \ to the right, \n                // and there is another car that's moving to\
    \ the left\n                // and are in the same position as this car.\n   \
    \             // if(carPositions[i] >= 0 && carPositions[n - i - 1] <= 0 && carPositions[i]\
    \ == -carPositions[n - i - 1", "        // Your code goes here.\n        return\
    \ 0;", '        return (n * (n - 1) / 2);', "        // Fill in this function.\n\
    \        return 0;", "        // We assume there are no collisions between cars\
    \ on the same side.\n        // Additionally, there is no collision for a car\
    \ with itself.\n        // Suppose we consider only the cars on the left to right\
    \ side of the road.\n        // This means that we are counting how many pairs\
    \ (a,b) of cars there are\n        // such that a < b and a and b drive from left\
    \ to right.\n        // Order those pairs from left to right.  The first pair\
    \ is (1,2).\n        // The second pair is (1,3), and so on.  The last pair is\
    \ (n-1,n).\n        // So, the number of such pairs is (n-1)*n/2.  We do the same\
    \ thing\n        // with the right to left set of cars.  Since the total number\
    \ of cars\n        // is 2n, the answer is n*(2n-1).\n        return n * (2 *\
    \ n - 1);"]
stop_tokens:
- "\n    }\n"
