name: HumanEval_136_largest_smallest_integers
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that returns a tuple (a, b), where 'a' is\n\
  \    // the largest of negative integers, and 'b' is the smallest\n    // of positive\
  \ integers in a list.\n    // If there is no negative or positive integers, return\
  \ them as null.\n    // Examples:\n    // >>> LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L})))\n    //\
  \ Tuple.Create((Nullable<long>)null, 1L)\n    // >>> LargestSmallestIntegers((new\
  \ List<long>()))\n    // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n\
  \    // >>> LargestSmallestIntegers((new List<long>(new long[]{(long)0L})))\n  \
  \  // Tuple.Create((Nullable<long>)null, (Nullable<long>)null)\n    public static\
  \ Tuple<Nullable<long>, Nullable<long>> LargestSmallestIntegers(List<long> lst)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestSmallestIntegers((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)1L, (long)3L, (long)5L, (long)7L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)2L,\
  \ (long)4L, (long)1L, (long)3L, (long)5L, (long)7L, (long)0L}))).Equals(Tuple.Create((Nullable<long>)null,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)1L,\
  \ (long)3L, (long)2L, (long)4L, (long)5L, (long)6L, (long)-2L}))).Equals(Tuple.Create(-2L,\
  \ 1L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)4L,\
  \ (long)5L, (long)3L, (long)6L, (long)2L, (long)7L, (long)-7L}))).Equals(Tuple.Create(-7L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)7L,\
  \ (long)3L, (long)8L, (long)4L, (long)9L, (long)2L, (long)5L, (long)-9L}))).Equals(Tuple.Create(-9L,\
  \ 2L)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>())).Equals(Tuple.Create((Nullable<long>)null,\
  \ (Nullable<long>)null)));\n    Debug.Assert(LargestSmallestIntegers((new List<long>(new\
  \ long[]{(long)0L}))).Equals(Tuple.Create((Nullable<long>)null, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-1L,\
  \ (long)-3L, (long)-5L, (long)-6L, (long)0L}))).Equals(Tuple.Create(-1L, (Nullable<long>)null)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)1L}))).Equals(Tuple.Create(-3L, 1L)));\n\
  \    Debug.Assert(LargestSmallestIntegers((new List<long>(new long[]{(long)-6L,\
  \ (long)-4L, (long)-4L, (long)-3L, (long)-100L, (long)1L}))).Equals(Tuple.Create(-3L,\
  \ 1L)));\n    }\n\n}\n"
completions: ["        long a = 0;\n        long b = 0;\n        foreach (var item\
    \ in lst) {\n            if (item < 0) {\n                if (item > a) {\n  \
    \                  a = item;\n                }\n            } else {\n      \
    \          if (item < b) {\n                    b = item;\n                }\n\
    \            }\n        }\n        if (a == 0 && b == 0) {\n            return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        } else if\
    \ (a == 0) {\n            return Tuple.Create((Nullable<long>)null, b);\n    \
    \    } else if (b == 0) {\n            return Tuple.Create(a, (Nullable<long>)null);\n\
    \        } else {\n            return Tuple.Create(a, b);\n        }", "     \
    \   List<long> positives = new List<long>();\n        List<long> negatives = new\
    \ List<long>();\n        foreach (long i in lst) {\n            if (i > 0) {\n\
    \                positives.Add(i);\n            } else if (i < 0) {\n        \
    \        negatives.Add(i);\n            }\n        }\n        Nullable<long> largestNegative\
    \ = null;\n        Nullable<long> smallestPositive = null;\n        if (negatives.Count\
    \ != 0) {\n            largestNegative = negatives.Max();\n        }\n       \
    \ if (positives.Count != 0) {\n            smallestPositive = positives.Min();\n\
    \        }\n        return Tuple.Create(largestNegative, smallestPositive);",
  "        // Insert code here!\n        long neg = long.MinValue;\n        long pos\
    \ = long.MaxValue;\n        foreach (long item in lst)\n        {\n          \
    \  if (item > 0 && item < pos)\n            {\n                pos = item;\n \
    \           }\n            if (item < 0 && item > neg)\n            {\n      \
    \          neg = item;\n            }\n        }\n        if (neg == long.MinValue)\n\
    \        {\n            neg = (Nullable<long>)null;\n        }\n        if (pos\
    \ == long.MaxValue)\n        {\n            pos = (Nullable<long>)null;\n    \
    \    }\n        return Tuple.Create(neg, pos);", "        Tuple<Nullable<long>,\
    \ Nullable<long>> y = Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        foreach (long i in lst) {\n            if (i < 0) {\n               \
    \ if (y.Item1 == null || i > y.Item1)\n                    y = Tuple.Create(i,\
    \ y.Item2);\n            } else if (i > 0) {\n                if (y.Item2 == null\
    \ || i < y.Item2)\n                    y = Tuple.Create(y.Item1, i);\n       \
    \     }\n        }\n        return y;", '        return null;', "        long\
    \ a, b;\n        a = b = 0;\n        foreach (var i in lst) {\n            if\
    \ (i > 0) {\n                if (i < b || b == 0) {\n                    b = i;\n\
    \                }\n            } else if (i < 0) {\n                if (i > a)\
    \ {\n                    a = i;\n                }\n            }\n        }\n\
    \        if (a == 0) {\n            a = (Nullable<long>)null;\n        }\n   \
    \     if (b == 0) {\n            b = (Nullable<long>)null;\n        }\n      \
    \  return Tuple.Create(a, b);", "        long largestNeg = long.MinValue;\n  \
    \      long smallestPos = long.MaxValue;\n        foreach (long item in lst) {\n\
    \            if (item < 0 && item > largestNeg) {\n                largestNeg\
    \ = item;\n            }\n            if (item > 0 && item < smallestPos) {\n\
    \                smallestPos = item;\n            }\n        }\n        return\
    \ Tuple.Create((Nullable<long>)largestNeg, (Nullable<long>)smallestPos);", " \
    \       var tuples = lst.Select(x => (long?)x);\n        var maxOfNegative = tuples.Where(x\
    \ => x < 0).Max();\n        var minOfPositive = tuples.Where(x => x > 0).Min();\n\
    \        return Tuple.Create(maxOfNegative, minOfPositive);", "        if (lst.Count\
    \ == 0) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        Nullable<long> a = null;\n        Nullable<long> b = null;\n\
    \        foreach (long i in lst) {\n            if (i >= 0) {\n              \
    \  if (b == null || i < b) {\n                    b = i;\n                }\n\
    \            } else {\n                if (a == null || i > a) {\n           \
    \         a = i;\n                }\n            }\n        }\n        return\
    \ Tuple.Create(a, b);", "        // write your code here\n        long? maxPositiveValue\
    \ = lst.Max();\n        long? minNegativeValue = lst.Min();\n        return Tuple.Create(minNegativeValue,\
    \ maxPositiveValue);", "        var biggestNegativeNumber = new Nullable<long>();\n\
    \        var smallestPositiveNumber = new Nullable<long>();\n        foreach (var\
    \ item in lst) {\n            if (item < 0) {\n                if (biggestNegativeNumber.HasValue)\
    \ {\n                    if (item > biggestNegativeNumber) {\n               \
    \         biggestNegativeNumber = item;\n                    }\n             \
    \   } else {\n                    biggestNegativeNumber = item;\n            \
    \    }\n            } else if (item > 0) {\n                if (smallestPositiveNumber.HasValue)\
    \ {\n                    if (item < smallestPositiveNumber) {\n              \
    \          smallestPositiveNumber = item;\n                    }\n           \
    \     } else {\n                    smallestPositiveNumber = item;\n         \
    \       }\n            }\n        }\n        return Tuple.Create(biggestNegativeNumber,\
    \ smallestPositiveNumber);", "        long? lgst = lst.Max();\n        long? smlst\
    \ = lst.Min();\n        if (lgst > 0)\n            lgst = null;\n        if (smlst\
    \ < 0)\n            smlst = null;\n        return Tuple.Create(lgst, smlst);",
  "      int i;\n      long maximum = 0, minimum = 0;\n      bool minFound = false,\
    \ maxFound = false;\n      for (i = 0; i < lst.Count; i++) {\n        if (lst[i]\
    \ < 0) {\n          if (maxFound == false) {\n            maximum = lst[i];\n\
    \            maxFound = true;\n          }\n          else if (lst[i] > maximum)\
    \ {\n            maximum = lst[i];\n          }\n        }\n        else if (lst[i]\
    \ > 0) {\n          if (minFound == false) {\n            minimum = lst[i];\n\
    \            minFound = true;\n          }\n          else if (lst[i] < minimum)\
    \ {\n            minimum = lst[i];\n          }\n        }\n      }\n      if\
    \ (maxFound == false) {\n        maximum = (Nullable<long>)null;\n      }\n  \
    \    if (minFound == false) {\n        minimum = (Nullable<long>)null;\n     \
    \ }\n      return Tuple.Create((Nullable<long>)maximum, (Nullable<long>)minimum);",
  "        var positive = lst.Where(v => v > 0);\n        var negative = lst.Where(v\
    \ => v < 0);\n        return Tuple.Create(\n            negative.Count() == 0\
    \ ? (Nullable<long>)null : negative.Max(),\n            positive.Count() == 0\
    \ ? (Nullable<long>)null : positive.Min());", "        // Fill in the missing\
    \ code.\n        Nullable<long> maxNeg = null;\n        Nullable<long> minPos\
    \ = null;\n        foreach (long n in lst) {\n            if (n < 0) {\n     \
    \           if (maxNeg == null || n > maxNeg) {\n                    maxNeg =\
    \ n;\n                }\n            } else if (n > 0) {\n                if (minPos\
    \ == null || n < minPos) {\n                    minPos = n;\n                }\n\
    \            }\n        }\n        return Tuple.Create(maxNeg, minPos);", "  \
    \      Nullable<long> _largest = null;\n        Nullable<long> _smallest = null;\n\
    \        long largest = (long)0L;\n        long smallest = (long)0L;\n       \
    \ bool f_lst_empty = false;\n        bool f_found_l = false;\n        bool f_found_s\
    \ = false;\n        // string error = \"\";\n        try {\n            if (lst.Count\
    \ == 0) {\n                f_lst_empty = true;\n            }\n            if\
    \ (f_lst_empty) {\n                _largest = null;\n                _smallest\
    \ = null;\n            } else {\n                for (int i = 0; i < lst.Count;\
    \ i++) {\n                    if (f_found_l == false) {\n                    \
    \    if (lst[i] < 0) {\n                            if (_largest == null) {\n\
    \                                _largest = lst[i];\n                        \
    \        largest = lst[i];\n                                f_found_l = true;\n\
    \                            } else {\n                                if (lst[i]\
    \ > largest) {\n                                    _largest = lst[i];\n     \
    \                               largest = lst[i];\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                    if (f_found_s == false) {\n               \
    \         if (lst[i] > 0) {\n                            if (_smallest == null)\
    \ {\n                                _smallest = lst[i];\n                   \
    \             smallest = lst[i];\n                                f_found_s =\
    \ true;\n                            } else {\n                              \
    \  if (lst[i] < smallest) {\n                                    _smallest = lst[i];\n\
    \                                    smallest = lst[i];\n                    \
    \            }\n                            }\n                        }\n   \
    \                 }\n                }\n            }\n        } catch (Exception\
    \ e) {\n            Console.WriteLine(e.Message);\n        }\n        return Tuple.Create(_largest,\
    \ _smallest);", "        Nullable<long> neg = null;\n        Nullable<long> pos\
    \ = null;\n        foreach (long val in lst) {\n            if (val < 0) {\n \
    \               if (neg == null || val > neg) {\n                    neg = val;\n\
    \                }\n            } else if (val > 0) {\n                if (pos\
    \ == null || val < pos) {\n                    pos = val;\n                }\n\
    \            }\n        }\n        return Tuple.Create(neg, pos);", "        var\
    \ min = (Nullable<long>)null;\n        var max = (Nullable<long>)null;\n     \
    \   foreach (var i in lst) {\n            if (i > 0) {\n                if (min\
    \ == null || i < min) {\n                    min = i;\n                }\n   \
    \         } else if (i < 0) {\n                if (max == null || i > max) {\n\
    \                    max = i;\n                }\n            }\n        }\n \
    \       return Tuple.Create(max, min);", "        //return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        return null;", "        long min = 0;\n    \
    \    long max = 0;\n        long min_idx = 0;\n        long max_idx = 0;\n   \
    \     long start = 0;\n        long end = lst.Count - 1;\n        // if (lst.Count\
    \ == 0) {\n        //     return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        // }\n        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i]\
    \ < 0) {\n                if (lst[i] > max) {\n                    max = lst[i];\n\
    \                    max_idx = i;\n                }\n            }\n        \
    \    else if (lst[i] > 0) {\n                if (lst[i] < min) {\n           \
    \         min = lst[i];\n                    min_idx = i;\n                }\n\
    \            }\n        }\n        if (min == 0 && max == 0) {\n            return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        }\n     \
    \   if (min_idx < max_idx) {\n            return Tuple.Create((Nullable<long>)max,\
    \ (Nullable<long>)min);\n        }\n        else {\n            return Tuple.Create((Nullable<long>)max,\
    \ (Nullable<long>)min);\n        }", "        // Replace with correct code\n \
    \       lst.Sort();\n        Nullable<long> a = null;\n        Nullable<long>\
    \ b = null;\n        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i]\
    \ < 0) {\n                a = lst[i];\n            }\n            if (lst[i] >\
    \ 0) {\n                b = lst[i];\n                break;\n            }\n \
    \       }\n        return Tuple.Create(a, b);", "        // write a function that\
    \ takes a list of integers,\n        // then returns tuple(a, b) where\n     \
    \   // a is the largest negative integer\n        // b is the smallest positive\
    \ integer\n\n        // return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        Nullable<long> small = null;\n        Nullable<long> large = null;\n\
    \        foreach (var item in lst)\n        {\n            if (small == null &&\
    \ item > 0)\n            {\n                small = item;\n            }\n   \
    \         if (small != null && item > 0 && item < small)\n            {\n    \
    \            small = item;\n            }\n            if (large == null && item\
    \ < 0)\n            {\n                large = item;\n            }\n        \
    \    if (large != null && item < 0 && item > large)\n            {\n         \
    \       large = item;\n            }\n        }\n        return Tuple.Create(large,\
    \ small);", "        long max = long.MinValue;\n        long min = long.MaxValue;\n\
    \        bool minOk = false;\n        bool maxOk = false;\n        foreach (long\
    \ x in lst) {\n            if (x >= 0 && x < min) {\n                min = x;\n\
    \                minOk = true;\n            }\n            if (x < 0 && x > max)\
    \ {\n                max = x;\n                maxOk = true;\n            }\n\
    \        }\n        return Tuple.Create(maxOk ? (Nullable<long>)max : (Nullable<long>)null,\
    \ minOk ? (Nullable<long>)min : (Nullable<long>)null);", '        return (lst.Any())
    ? Tuple.Create(lst.Where(e => e < 0).Max(), lst.Where(e => e > 0).Min()) : Tuple.Create((Nullable<long>)null,
    (Nullable<long>)null);', '        throw new NotImplementedException();', '        return
    null;', "        Nullable<long> largestNegative = null;\n        Nullable<long>\
    \ smallestPositive = null;\n        for (int i = 0; i < lst.Count; i++) {\n  \
    \          long value = lst[i];\n            if (value >= 0) {\n             \
    \   if (smallestPositive == null || value < smallestPositive) {\n            \
    \        smallestPositive = value;\n                }\n            } else {\n\
    \                if (largestNegative == null || value > largestNegative) {\n \
    \                   largestNegative = value;\n                }\n            }\n\
    \        }\n        return Tuple.Create(largestNegative, smallestPositive);",
  "        long? maxNeg = null;\n        long? minPos = null;\n        for (int i\
    \ = 0; i < lst.Count; i++) {\n            if (lst[i] > 0 && (minPos == null ||\
    \ lst[i] < minPos)) {\n                minPos = lst[i];\n            }\n     \
    \       if (lst[i] < 0 && (maxNeg == null || lst[i] > maxNeg)) {\n           \
    \     maxNeg = lst[i];\n            }\n        }\n        return Tuple.Create(maxNeg,\
    \ minPos);", "        Nullable<long> smallest = null;\n        Nullable<long>\
    \ largest = null;\n        foreach (long i in lst) {\n            if (i < 0) {\n\
    \                if (largest == null || i > largest) {\n                    largest\
    \ = i;\n                }\n            } else if (i > 0) {\n                if\
    \ (smallest == null || i < smallest) {\n                    smallest = i;\n  \
    \              }\n            }\n        }\n        return Tuple.Create(largest,\
    \ smallest);", '        // Your code here.', "        Nullable<long> x = null;\n\
    \        Nullable<long> y = null;\n        for (int i = 0; i < lst.Count; i++)\
    \ {\n            if (lst[i] < 0) {\n                if (x == null || lst[i] >\
    \ x) {\n                    x = lst[i];\n                }\n            } else\
    \ if (lst[i] > 0) {\n                if (y == null || lst[i] < y) {\n        \
    \            y = lst[i];\n                }\n            }\n        }\n      \
    \  return Tuple.Create(x, y);", "        // Type your code here\n        long?\
    \ biggestNeg = null;\n        long? smallestPos = null;\n        for (int i =\
    \ 0; i < lst.Count; i++) {\n            if (lst[i] < 0) {\n                if\
    \ (biggestNeg == null || lst[i] > biggestNeg) {\n                    biggestNeg\
    \ = lst[i];\n                }\n            } else if (lst[i] > 0) {\n       \
    \         if (smallestPos == null || lst[i] < smallestPos) {\n               \
    \     smallestPos = lst[i];\n                }\n            }\n        }\n   \
    \     return Tuple.Create(biggestNeg, smallestPos);", '        // Your code here',
  '        return null;', "        long largestNeg = 0;\n        long smallestPos\
    \ = 0;\n        bool foundLargestNeg = false;\n        bool foundSmallestPos =\
    \ false;\n        foreach (var item in lst) {\n            if (item < 0) {\n \
    \               if (!foundLargestNeg) {\n                    largestNeg = item;\n\
    \                    foundLargestNeg = true;\n                } else {\n     \
    \               if (item > largestNeg)\n                        largestNeg = item;\n\
    \                }\n            } else if (item > 0) {\n                if (!foundSmallestPos)\
    \ {\n                    smallestPos = item;\n                    foundSmallestPos\
    \ = true;\n                } else {\n                    if (item < smallestPos)\n\
    \                        smallestPos = item;\n                }\n            }\n\
    \        }\n        if (!foundLargestNeg)\n            largestNeg = (Nullable<long>)null;\n\
    \        if (!foundSmallestPos)\n            smallestPos = (Nullable<long>)null;\n\
    \        return Tuple.Create(largestNeg, smallestPos);", "        Nullable<long>\
    \ a = null;\n        Nullable<long> b = null;\n        foreach (long elem in lst)\
    \ {\n            if (a == null && elem < 0) {\n                a = elem;\n   \
    \         }\n            if (b == null && elem > 0) {\n                b = elem;\n\
    \            }\n            if (a != null && elem < 0 && elem > a) {\n       \
    \         a = elem;\n            }\n            if (b != null && elem > 0 && elem\
    \ < b) {\n                b = elem;\n            }\n        }\n        return\
    \ Tuple.Create(a, b);", "        // find largest of negative numbers\n       \
    \ // find smallest of positive numbers\n        // return tuple\n        long\
    \ min_val = 0;\n        long max_val = 0;\n        long min_count = 0;\n     \
    \   long max_count = 0;\n        long num_neg = 0;\n        long num_pos = 0;\n\
    \        // get numbers\n        foreach (long n in lst) {\n            if (n\
    \ > 0) {\n                if (min_count == 0) {\n                    min_val =\
    \ n;\n                    min_count = 1;\n                } else if (n < min_val)\
    \ {\n                    min_val = n;\n                }\n                num_pos++;\n\
    \            } else if (n < 0) {\n                if (max_count == 0) {\n    \
    \                max_val = n;\n                    max_count = 1;\n          \
    \      } else if (n > max_val) {\n                    max_val = n;\n         \
    \       }\n                num_neg++;\n            }\n        }\n        Nullable<long>\
    \ min_val_null = min_val;\n        Nullable<long> max_val_null = max_val;\n  \
    \      if (num_pos == 0) {\n            min_val_null = null;\n        }\n    \
    \    if (num_neg == 0) {\n            max_val_null = null;\n        }\n      \
    \  return Tuple.Create(max_val_null, min_val_null);", "        if (lst.Count <\
    \ 1) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        var negs = new List<long>();\n        var poss = new List<long>();\n\
    \        foreach (var i in lst) {\n            if (i < 0) {\n                negs.Add(i);\n\
    \            } else if (i > 0) {\n                poss.Add(i);\n            }\n\
    \        }\n        if (negs.Count < 1) {\n            negs.Add((long)null);\n\
    \        }\n        if (poss.Count < 1) {\n            poss.Add((long)null);\n\
    \        }\n        return Tuple.Create(negs.Max(), poss.Min());", "        //\
    \ Try using Linq and please use your name as the author to avoid\n        // any\
    \ conflict with other submissions.\n        // Implement your function here and\
    \ remove the next line.\n        throw new NotImplementedException();", '        return
    (null, null);', "        // TODO: Implement the function\n        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);", "        if(lst.Count == 0) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        if(lst.Count == 1) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        var positive = lst.Where(x => x > 0).OrderBy(x\
    \ => x).ToList();\n        var negative = lst.Where(x => x < 0).OrderByDescending(x\
    \ => x).ToList();\n        Nullable<long> small = null;\n        Nullable<long>\
    \ large = null;\n        if(positive.Count > 0) small = positive[0];\n       \
    \ if(negative.Count > 0) large = negative[0];\n        return Tuple.Create(large,\
    \ small);", "        Nullable<long> largest = null;\n        Nullable<long> smallest\
    \ = null;\n        foreach (long x in lst) {\n            if (x < 0 && (largest\
    \ == null || x > largest)) {\n                largest = x;\n            }\n  \
    \          if (x > 0 && (smallest == null || x < smallest)) {\n              \
    \  smallest = x;\n            }\n        }\n        return Tuple.Create(largest,\
    \ smallest);", "        if(lst.Count == 0) return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long l = 0, s = 0;\n        bool foundL = false,\
    \ foundS = false;\n        for(int i = 0; i < lst.Count; i++) {\n            long\
    \ v = lst[i];\n            if(v < 0) {\n                if(!foundL) {\n      \
    \              l = v;\n                    foundL = true;\n                } else\
    \ if(v > l) {\n                    l = v;\n                }\n            } else\
    \ if(v > 0) {\n                if(!foundS) {\n                    s = v;\n   \
    \                 foundS = true;\n                } else if(v < s) {\n       \
    \             s = v;\n                }\n            }\n        }\n        return\
    \ Tuple.Create((Nullable<long>)(foundL ? l : (Nullable<long>)null), (Nullable<long>)(foundS\
    \ ? s : (Nullable<long>)null));", "        Nullable<long> largestNegativeNumber\
    \ = null;\n        Nullable<long> smallestPositiveNumber = null;\n        if (lst.Count\
    \ > 0) {\n            List<long> negatives = new List<long>();\n            List<long>\
    \ positives = new List<long>();\n            foreach (long l in lst) {\n     \
    \           if (l < 0) {\n                    negatives.Add(l);\n            \
    \    } else if (l > 0) {\n                    positives.Add(l);\n            \
    \    }\n            }\n            if (negatives.Count > 0) {\n              \
    \  largestNegativeNumber = negatives.Max();\n            }\n            if (positives.Count\
    \ > 0) {\n                smallestPositiveNumber = positives.Min();\n        \
    \    }\n        }\n        return Tuple.Create(largestNegativeNumber, smallestPositiveNumber);",
  "        bool n = false;\n        bool p = false;\n        long nmax = long.MinValue;\n\
    \        long pmax = long.MaxValue;\n        foreach (var item in lst) {\n   \
    \         if (item > 0) {\n                p = true;\n                if (item\
    \ < pmax) {\n                    pmax = item;\n                }\n           \
    \ }\n            if (item < 0) {\n                n = true;\n                if\
    \ (item > nmax) {\n                    nmax = item;\n                }\n     \
    \       }\n        }\n        if (n && p) {\n            return Tuple.Create((Nullable<long>)nmax,\
    \ (Nullable<long>)pmax);\n        }\n        else if (n) {\n            return\
    \ Tuple.Create((Nullable<long>)nmax, (Nullable<long>)null);\n        }\n     \
    \   else if (p) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)pmax);\n\
    \        }\n        else {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }", "        long? a = null;\n        long?\
    \ b = null;\n        foreach (long i in lst) {\n            if (i < 0 && (a ==\
    \ null || i > a)) {\n                a = i;\n            }\n            if (i\
    \ > 0 && (b == null || i < b)) {\n                b = i;\n            }\n    \
    \    }\n        return Tuple.Create(a, b);", '        throw new NotImplementedException();',
  '        throw new NotImplementedException();', "        var positiveNumbers = lst.Where(x\
    \ => x > 0);\n        var negativeNumbers = lst.Where(x => x < 0);\n        return\
    \ Tuple.Create(negativeNumbers.Any() ? negativeNumbers.Max() : (Nullable<long>)null,\
    \ positiveNumbers.Any() ? positiveNumbers.Min() : (Nullable<long>)null);", " \
    \       if (lst.Count() == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        long min = long.MaxValue;\n     \
    \   long max = long.MinValue;\n        foreach (long i in lst) {\n           \
    \ if (i < 0) {\n                if (i > max) {\n                    max = i;\n\
    \                }\n            } else if (i > 0) {\n                if (i < min)\
    \ {\n                    min = i;\n                }\n            }\n        }\n\
    \        return Tuple.Create((max == long.MinValue) ? (Nullable<long>)null : max,\
    \ (min == long.MaxValue) ? (Nullable<long>)null : min);", "        // Implement\
    \ your function here\n        long? nullableInt = null;\n        long? largestInt\
    \ = null;\n        long? smallestInt = null;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] >= 0) {\n                if (smallestInt == null)\
    \ {\n                    smallestInt = lst[i];\n                } else if (lst[i]\
    \ < smallestInt) {\n                    smallestInt = lst[i];\n              \
    \  }\n            } else {\n                if (largestInt == null) {\n      \
    \              largestInt = lst[i];\n                } else if (lst[i] > largestInt)\
    \ {\n                    largestInt = lst[i];\n                }\n           \
    \ }\n        }\n        return Tuple.Create(largestInt, smallestInt);", "    \
    \    var pos = lst.Where(x => x > 0).DefaultIfEmpty().Min();\n        var neg\
    \ = lst.Where(x => x < 0).DefaultIfEmpty().Max();\n        if(pos == 0) {\n  \
    \          pos = null;\n        }\n        if(neg == 0) {\n            neg = null;\n\
    \        }\n        return Tuple.Create(neg, pos);", "        var negs = lst.Where(x\
    \ => x < 0);\n        var poss = lst.Where(x => x > 0);\n        return Tuple.Create(negs.Any()\
    \ ? negs.Max() : (Nullable<long>)null, poss.Any() ? poss.Min() : (Nullable<long>)null);",
  '        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);', '        throw
    new NotImplementedException();', "        long a = 0;\n        bool flag_a = false;\n\
    \        long b = 0;\n        bool flag_b = false;\n        for (int i = 0; i\
    \ < lst.Count; i++) {\n            if (lst[i] < 0) {\n                if (flag_a\
    \ == false) {\n                    a = lst[i];\n                    flag_a = true;\n\
    \                } else {\n                    if (lst[i] > a) {\n           \
    \             a = lst[i];\n                    }\n                }\n        \
    \    } else if (lst[i] > 0) {\n                if (flag_b == false) {\n      \
    \              b = lst[i];\n                    flag_b = true;\n             \
    \   } else {\n                    if (lst[i] < b) {\n                        b\
    \ = lst[i];\n                    }\n                }\n            }\n       \
    \ }\n        return Tuple.Create((Nullable<long>)a, (Nullable<long>)b);", "  \
    \    // Write your code here!\n      return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", '        return new Tuple<Nullable<long>, Nullable<long>>(lst.Where(n
    => n < 0).Max(), lst.Where(n => n > 0).Min());', '        throw new NotImplementedException();',
  '        return (Tuple<Nullable<long>, Nullable<long>>)null;', "        long? smallest\
    \ = null;\n        long? largest = null;\n        foreach (long num in lst) {\n\
    \            if (num > 0) {\n                if (smallest == null || num < smallest)\
    \ {\n                    smallest = num;\n                }\n            } else\
    \ if (num < 0) {\n                if (largest == null || num > largest) {\n  \
    \                  largest = num;\n                }\n            }\n        }\n\
    \        return Tuple.Create(largest, smallest);", "        // your code goes\
    \ here\n        return null;", "        long largestNegative = long.MinValue;\n\
    \        long smallestPositive = long.MaxValue;\n        foreach (long num in\
    \ lst) {\n            if (num < 0 && num > largestNegative) {\n              \
    \  largestNegative = num;\n            }\n            if (num > 0 && num < smallestPositive)\
    \ {\n                smallestPositive = num;\n            }\n        }\n     \
    \   return Tuple.Create(largestNegative == long.MinValue ? (Nullable<long>)null\
    \ : largestNegative, smallestPositive == long.MaxValue ? (Nullable<long>)null\
    \ : smallestPositive);", "        // return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        // return Tuple.Create((Nullable<long>)null,\
    \ 1L);\n        if (lst.Count == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long max_negative = -1 * long.MaxValue;\n  \
    \      long min_positive = long.MaxValue;\n        foreach (long item in lst)\
    \ {\n            if (item >= 0) {\n                if (item < min_positive)\n\
    \                    min_positive = item;\n            } else {\n            \
    \    if (item > max_negative)\n                    max_negative = item;\n    \
    \        }\n        }\n        if (max_negative == -1 * long.MaxValue)\n     \
    \       max_negative = (Nullable<long>)null;\n        if (min_positive == long.MaxValue)\n\
    \            min_positive = (Nullable<long>)null;\n        return Tuple.Create(max_negative,\
    \ min_positive);", "        long? maxNegative = lst.Where(i => i < 0).Max();\n\
    \        long? minPositive = lst.Where(i => i > 0).Min();\n        return Tuple.Create(maxNegative,\
    \ minPositive);", "        var negatives = lst.Where(x => x < 0).ToList();\n \
    \       var positives = lst.Where(x => x > 0).ToList();\n        if (negatives.Count\
    \ == 0) {\n            if (positives.Count == 0) {\n                return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n            } else {\n                return Tuple.Create((Nullable<long>)null,\
    \ positives.Min());\n            }\n        } else {\n            if (positives.Count\
    \ == 0) {\n                return Tuple.Create(negatives.Max(), (Nullable<long>)null);\n\
    \            } else {\n                return Tuple.Create(negatives.Max(), positives.Min());\n\
    \            }\n        }", "        // Write your code here\n        var vals\
    \ = lst.Where(a => a < 0).ToList();\n        var vals2 = lst.Where(a => a > 0).ToList();\n\
    \        long? a = null;\n        long? b = null;\n        if (vals.Count > 0)\
    \ {\n            a = vals.Max();\n        }\n        if (vals2.Count > 0) {\n\
    \            b = vals2.Min();\n        }\n        return Tuple.Create(a, b);",
  "        // yield null;\n        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);",
  "        // look at the integers in lst.\n        // if it is negative it is one\
    \ of the smallest.\n        // if it is positive it is one of the largest.\n \
    \       // return (largest negative, smallest positive) as a tuple\n        //\
    \ if there are none of either, return (null, null) as a tuple.\n        // null\
    \ is a valid input to this function\n        long? largestNegative = null;\n \
    \       long? smallestPositive = null;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            long current = lst[i];\n            if (current < 0 && (largestNegative\
    \ == null || current > largestNegative)) {\n                largestNegative =\
    \ current;\n            }\n            if (current > 0 && (smallestPositive ==\
    \ null || current < smallestPositive)) {\n                smallestPositive = current;\n\
    \            }\n        }\n        return Tuple.Create(largestNegative, smallestPositive);",
  "        Nullable<long> negMax = null;\n        Nullable<long> posMin = null;\n\
    \        for (long i = 0; i < lst.Count; i++) {\n            if (lst[(int)i] <\
    \ 0L) {\n                if (negMax == null || lst[(int)i] > negMax) {\n     \
    \               negMax = lst[(int)i];\n                }\n            }\n    \
    \        else if (lst[(int)i] > 0L) {\n                if (posMin == null || lst[(int)i]\
    \ < posMin) {\n                    posMin = lst[(int)i];\n                }\n\
    \            }\n        }\n        return Tuple.Create(negMax, posMin);", "  \
    \      // >>> your code goes here <<<\n        long? max = null;\n        long?\
    \ min = null;\n        foreach (long x in lst) {\n            if (x >= 0) {\n\
    \                if (min == null || x < min) {\n                    min = x;\n\
    \                }\n            } else {\n                if (max == null || x\
    \ > max) {\n                    max = x;\n                }\n            }\n \
    \       }\n        return Tuple.Create(max, min);", "        var l = new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        foreach (var i in lst) {\n           \
    \ if (i < 0) {\n                if (l.Item1 == null || i > l.Item1) {\n      \
    \              l = new Tuple<Nullable<long>, Nullable<long>>(i, l.Item2);\n  \
    \              }\n            } else if (i > 0) {\n                if (l.Item2\
    \ == null || i < l.Item2) {\n                    l = new Tuple<Nullable<long>,\
    \ Nullable<long>>(l.Item1, i);\n                }\n            }\n        }\n\
    \        return l;", "        if (lst.Count == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        Nullable<long> min = null;\n    \
    \    Nullable<long> max = null;\n        foreach (long i in lst) {\n         \
    \   if (i > 0) {\n                if (min == null || i < min) {\n            \
    \        min = i;\n                }\n            } else if (i < 0) {\n      \
    \          if (max == null || i > max) {\n                    max = i;\n     \
    \           }\n            }\n        }\n        return Tuple.Create(max, min);",
  "        Nullable<long> smallest = null;\n        Nullable<long> largest = null;\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] > 0) {\n\
    \                if (smallest == null || lst[i] < smallest) {\n              \
    \      smallest = lst[i];\n                }\n            } else if (lst[i] <\
    \ 0) {\n                if (largest == null || lst[i] > largest) {\n         \
    \           largest = lst[i];\n                }\n            }\n        }\n \
    \       return Tuple.Create(largest, smallest);", "        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(\n            lst.Where(x => x < 0).DefaultIfEmpty().Max(),\n\
    \            lst.Where(x => x > 0).DefaultIfEmpty().Min());", "        long[]\
    \ lstarr = lst.ToArray();\n        var MaxNegative = lstarr.Where(x => x < 0).Max();\n\
    \        var MinPositive = lstarr.Where(x => x > 0).Min();\n        return Tuple.Create((Nullable<long>)MaxNegative,\
    \ (Nullable<long>)MinPositive);", "        if (lst.Count() == 0) {\n         \
    \   return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n       \
    \ }\n        if (lst.Count() == 1) {\n            if (lst[0] == 0) {\n       \
    \         return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n \
    \           }\n        }\n        var negativeList = new List<long>();\n     \
    \   var positiveList = new List<long>();\n        foreach (var item in lst) {\n\
    \            if (item < 0) {\n                negativeList.Add(item);\n      \
    \      }\n            if (item > 0) {\n                positiveList.Add(item);\n\
    \            }\n        }\n        if (negativeList.Count() == 0) {\n        \
    \    if (positiveList.Count() == 0) {\n                return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n            }\n            return Tuple.Create((Nullable<long>)null,\
    \ positiveList.Min());\n        }\n        if (positiveList.Count() == 0) {\n\
    \            return Tuple.Create(negativeList.Max(), (Nullable<long>)null);\n\
    \        }\n        return Tuple.Create(negativeList.Max(), positiveList.Min());",
  '        throw new NotImplementedException();', '        return Tuple.Create((Nullable<long>)null,
    (Nullable<long>)null);', "        // Write your code here.\n        bool pos =\
    \ false;\n        bool neg = false;\n        Nullable<long> large = 0;\n     \
    \   Nullable<long> small = 0;\n        foreach (var num in lst) {\n          \
    \  if (num > 0) {\n                pos = true;\n                if (small == 0)\
    \ {\n                    small = num;\n                }\n                else\
    \ if (num < small) {\n                    small = num;\n                }\n  \
    \          }\n            else if (num < 0) {\n                neg = true;\n \
    \               if (large == 0) {\n                    large = num;\n        \
    \        }\n                else if (num > large) {\n                    large\
    \ = num;\n                }\n            }\n        }\n        return (pos &&\
    \ neg) ? Tuple.Create(large, small) : Tuple.Create((Nullable<long>)null, (Nullable<long>)null);",
  "        // your code here\n        return Tuple.Create(\n            lst.Where(i\
    \ => i < 0).DefaultIfEmpty(0).Max(),\n            lst.Where(i => i > 0).DefaultIfEmpty(0).Min()\n\
    \        );", "        Nullable<long> largest = null;\n        Nullable<long>\
    \ smallest = null;\n        foreach (long v in lst) {\n            if (v < 0)\
    \ {\n                if (largest == null || v > largest) {\n                 \
    \   largest = v;\n                }\n            } else if (v > 0) {\n       \
    \         if (smallest == null || v < smallest) {\n                    smallest\
    \ = v;\n                }\n            }\n        }\n        return Tuple.Create(largest,\
    \ smallest);", "        // return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);", " \
    \       return new Tuple<Nullable<long>, Nullable<long>>(\n            null, \n\
    \            (long)lst.Min()\n        );", "        Nullable<long> min = null;\n\
    \        Nullable<long> max = null;\n        for (int i = 0; i < lst.Count; i++)\
    \ {\n            if (lst[i] < 0) {\n                if (max == null || lst[i]\
    \ > max) {\n                    max = lst[i];\n                }\n           \
    \ } else if (lst[i] > 0) {\n                if (min == null || lst[i] < min) {\n\
    \                    min = lst[i];\n                }\n            }\n       \
    \ }\n        return Tuple.Create(max, min);", '        return null;', "      \
    \  // Write your code here\n        return null;", '        return Tuple.Create(lst.OrderByDescending(x
    => x).FirstOrDefault(y => y < 0), lst.OrderBy(x => x).FirstOrDefault(y => y >
    0));', '        throw new NotImplementedException();', '        return null;',
  "        long? max = null;\n        long? min = null;\n        foreach (long i in\
    \ lst) {\n            if (i >= 0) {\n                if (min == null || i < min)\
    \ {\n                    min = i;\n                }\n            } else {\n \
    \               if (max == null || i > max) {\n                    max = i;\n\
    \                }\n            }\n        }\n        return Tuple.Create(max,\
    \ min);", "        long a = 0;\n        long b = 0;\n        foreach (long l in\
    \ lst) {\n            if (l > b) {\n                b = l;\n            }\n  \
    \          if (l < a) {\n                a = l;\n            }\n        }\n  \
    \      Nullable<long> nullable_a = Nullable<long>.Null;\n        Nullable<long>\
    \ nullable_b = Nullable<long>.Null;\n        if (a != 0) {\n            nullable_a\
    \ = a;\n        }\n        if (b != 0) {\n            nullable_b = b;\n      \
    \  }\n        return Tuple.Create(nullable_a, nullable_b);", "        if (lst.Count\
    \ == 0) {\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null,\
    \ null);\n        }\n        long largestNegative = 0;\n        bool setLargestNegative\
    \ = false;\n        long smallestPositive = 0;\n        bool setSmallestPositive\
    \ = false;\n        foreach (long l in lst) {\n            if (l < 0) {\n    \
    \            if (!setLargestNegative || l > largestNegative) {\n             \
    \       largestNegative = l;\n                    setLargestNegative = true;\n\
    \                }\n            } else if (l > 0) {\n                if (!setSmallestPositive\
    \ || l < smallestPositive) {\n                    smallestPositive = l;\n    \
    \                setSmallestPositive = true;\n                }\n            }\n\
    \        }\n        return Tuple.Create<Nullable<long>, Nullable<long>>(setLargestNegative\
    \ ? (Nullable<long>)largestNegative : null, setSmallestPositive ? (Nullable<long>)smallestPositive\
    \ : null);", "        // TODO: fix this function.\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", "        var positive = lst.Where(x => x > 0).DefaultIfEmpty(0).Min();\n\
    \        var negative = lst.Where(x => x < 0).DefaultIfEmpty(0).Max();\n     \
    \   return Tuple.Create(positive == 0 ? (Nullable<long>)null : positive, negative\
    \ == 0 ? (Nullable<long>)null : negative);", "        return new Tuple<Nullable<long>,\
    \ Nullable<long>>(\n            lst.Where(x => x < 0).Count() == 0 ? (Nullable<long>)null\
    \ : lst.Where(x => x < 0).Max(),\n            lst.Where(x => x > 0).Count() ==\
    \ 0 ? (Nullable<long>)null : lst.Where(x => x > 0).Min());", "        return (from\
    \ x in lst\n                where x < 0\n                select x).Max() == 0\
    \ ?\n            Tuple.Create((Nullable<long>)null, (Nullable<long>)lst.Min())\
    \ :\n            Tuple.Create((Nullable<long>)lst.Max(), (Nullable<long>)lst.Min());",
  "        long n = 0L;\n        long p = 0L;\n        bool flag = false;\n      \
    \  bool flagp = false;\n        foreach (long v in lst) {\n            if (v <\
    \ 0L) {\n                if (v > n) {\n                    n = v;\n          \
    \      }\n                flag = true;\n            }\n            if (v > 0L)\
    \ {\n                if (v < p || !flagp) {\n                    p = v;\n    \
    \            }\n                flagp = true;\n            }\n        }\n    \
    \    return Tuple.Create((flag ? n : (Nullable<long>)null), (flagp ? p : (Nullable<long>)null));",
  "        // Your code goes here\n        long max_neg = 0, min_pos = 0;\n      \
    \  bool neg_found = false, pos_found = false;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] > 0) {\n                if (!pos_found) {\n \
    \                   min_pos = lst[i];\n                    pos_found = true;\n\
    \                } else {\n                    min_pos = Math.Min(min_pos, lst[i]);\n\
    \                }\n            } else if (lst[i] < 0) {\n                if (!neg_found)\
    \ {\n                    max_neg = lst[i];\n                    neg_found = true;\n\
    \                } else {\n                    max_neg = Math.Max(max_neg, lst[i]);\n\
    \                }\n            }\n        }\n        if (!neg_found) {\n    \
    \        max_neg = (Nullable<long>)null;\n        }\n        if (!pos_found) {\n\
    \            min_pos = (Nullable<long>)null;\n        }\n        return Tuple.Create(max_neg,\
    \ min_pos);", "        Nullable<long> max_negative = null;\n        Nullable<long>\
    \ min_positive = null;\n        foreach (long elem in lst) {\n            if (elem\
    \ < 0) {\n                if (max_negative == null || elem > max_negative) {\n\
    \                    max_negative = elem;\n                }\n            } else\
    \ if (elem > 0) {\n                if (min_positive == null || elem < min_positive)\
    \ {\n                    min_positive = elem;\n                }\n           \
    \ }\n        }\n        return Tuple.Create(max_negative, min_positive);", '        return
    null;', "        long? maxNeg = null;\n        long? minPos = null;\n        for\
    \ (int x = 0; x < lst.Count; x++) {\n            if (lst[x] > 0) {\n         \
    \       if (minPos == null || lst[x] < minPos) {\n                    minPos =\
    \ lst[x];\n                }\n            } else if (lst[x] < 0) {\n         \
    \       if (maxNeg == null || lst[x] > maxNeg) {\n                    maxNeg =\
    \ lst[x];\n                }\n            }\n        }\n        return Tuple.Create(maxNeg,\
    \ minPos);", "        var a = lst.Max();\n        var b = lst.Min();\n       \
    \ if (a < 0) {\n            return Tuple.Create(a, b);\n        } else if (b >\
    \ 0) {\n            return Tuple.Create(a, b);\n        } else {\n           \
    \ return Tuple.Create(null, null);\n        }", "        Nullable<long> max =\
    \ null;\n        Nullable<long> min = null;\n        foreach (long number in lst)\
    \ {\n            if (number < 0) {\n                if (!max.HasValue || number\
    \ > max) {\n                    max = number;\n                }\n           \
    \ } else if (number > 0) {\n                if (!min.HasValue || number < min)\
    \ {\n                    min = number;\n                }\n            }\n   \
    \     }\n        return Tuple.Create(max, min);", "        long? largestNegativeInt\
    \ = null;\n        long? smallestPositiveInt = null;\n        bool foundNegativeInt\
    \ = false;\n        bool foundPositiveInt = false;\n        foreach (long l in\
    \ lst) {\n            if (l < 0) {\n                if (largestNegativeInt ==\
    \ null || l > largestNegativeInt) {\n                    largestNegativeInt =\
    \ l;\n                }\n                foundNegativeInt = true;\n          \
    \  } else if (l > 0) {\n                if (smallestPositiveInt == null || l <\
    \ smallestPositiveInt) {\n                    smallestPositiveInt = l;\n     \
    \           }\n                foundPositiveInt = true;\n            }\n     \
    \   }\n        return Tuple.Create(largestNegativeInt, smallestPositiveInt);",
  "        // Write your code here\n        Nullable<long> x = null;\n        Nullable<long>\
    \ y = null;\n        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i]\
    \ > 0) {\n                if (y == null)\n                    y = lst[i];\n  \
    \              else if (lst[i] < y)\n                    y = lst[i];\n       \
    \     }\n            else if (lst[i] < 0) {\n                if (x == null)\n\
    \                    x = lst[i];\n                else if (lst[i] > x)\n     \
    \               x = lst[i];\n            }\n        }\n        return Tuple.Create(x,\
    \ y);", "        if (lst.Count <= 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        var maxn = -0xffffffffffffffffL;\n\
    \        var minp = 0xffffffffffffffffL;\n        foreach (var i in lst) {\n \
    \           if (i > 0 && i < minp) {\n                minp = i;\n            }\n\
    \            if (i < 0 && i > maxn) {\n                maxn = i;\n           \
    \ }\n        }\n        return Tuple.Create(((maxn < -0xffffffffffffffffL) ? (Nullable<long>)null\
    \ : (Nullable<long>)maxn), ((minp > 0xffffffffffffffffL) ? (Nullable<long>)null\
    \ : (Nullable<long>)minp));", "        long max = 0;\n        long min = 0;\n\
    \        bool found_max = false;\n        bool found_min = false;\n        foreach\
    \ (long num in lst) {\n            if (num > 0) {\n                if (!found_min)\
    \ {\n                    min = num;\n                    found_min = true;\n \
    \               } else {\n                    if (num < min) {\n             \
    \           min = num;\n                    }\n                }\n           \
    \ } else if (num < 0) {\n                if (!found_max) {\n                 \
    \   max = num;\n                    found_max = true;\n                } else\
    \ {\n                    if (num > max) {\n                        max = num;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ Tuple.Create(found_max ? (Nullable<long>)max : (Nullable<long>)null, found_min\
    \ ? (Nullable<long>)min : (Nullable<long>)null);", "        long max=0, min=0;\n\
    \        bool max_set=false, min_set=false;\n        for (int i=0; i<lst.Count;\
    \ i++) {\n            if (lst[i]<0) {\n                if (!max_set) {\n     \
    \               max=lst[i];\n                    max_set=true;\n             \
    \   } else if (lst[i]>max) {\n                    max=lst[i];\n              \
    \  }\n            } else if (lst[i]>0) {\n                if (!min_set) {\n  \
    \                  min=lst[i];\n                    min_set=true;\n          \
    \      } else if (lst[i]<min) {\n                    min=lst[i];\n           \
    \     }\n            }\n        }\n        return Tuple.Create((Nullable<long>)max,\
    \ (Nullable<long>)min);", "        long? largestNegative = null;\n        long?\
    \ smallestPositive = null;\n        foreach (long x in lst) {\n            if\
    \ (x < 0) {\n                if (largestNegative == null || x > largestNegative)\
    \ {\n                    largestNegative = x;\n                }\n           \
    \ } else if (x > 0) {\n                if (smallestPositive == null || x < smallestPositive)\
    \ {\n                    smallestPositive = x;\n                }\n          \
    \  }\n        }\n        return Tuple.Create(largestNegative, smallestPositive);",
  "        // replace 'null' with correct code\n        return null;", "        long?\
    \ largestNeg = null;\n        long? smallestPos = null;\n        foreach (long\
    \ value in lst) {\n            if (value < 0 && (largestNeg == null || value >\
    \ largestNeg)) {\n                largestNeg = value;\n            }\n       \
    \     if (value > 0 && (smallestPos == null || value < smallestPos)) {\n     \
    \           smallestPos = value;\n            }\n        }\n        return Tuple.Create(largestNeg,\
    \ smallestPos);", "        if (lst.Count == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        long maxNegative = (long)-1;\n        long minPositive\
    \ = (long)1;\n        foreach (long item in lst) {\n            if (item < 0 &&\
    \ item > maxNegative)\n                maxNegative = item;\n            if (item\
    \ > 0 && item < minPositive)\n                minPositive = item;\n        }\n\
    \        if (maxNegative < 0)\n            return Tuple.Create(maxNegative, minPositive);\n\
    \        else\n            return Tuple.Create((Nullable<long>)null, minPositive);",
  "        var max = (Nullable<long>)null;\n        var min = (Nullable<long>)null;\n\
    \        foreach (var item in lst) {\n            if (item > 0) {\n          \
    \      if (min == null || item < min) {\n                    min = item;\n   \
    \             }\n            } else if (item < 0) {\n                if (max ==\
    \ null || item > max) {\n                    max = item;\n                }\n\
    \            }\n        }\n        return Tuple.Create(max, min);", "        var\
    \ minPos = lst.Where(n => n > 0).DefaultIfEmpty().Min();\n        var maxNeg =\
    \ lst.Where(n => n < 0).DefaultIfEmpty().Max();\n        return Tuple.Create(maxNeg,\
    \ minPos);", "      Tuple<Nullable<long>, Nullable<long>> tuple = new Tuple<Nullable<long>,\
    \ Nullable<long>>(null, null);\n      int length = lst.Count;\n      if (length\
    \ == 0) {\n        return tuple;\n      }\n      if (length == 1) {\n        if\
    \ (lst[0] > 0) {\n          tuple = new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ lst[0]);\n        } else if (lst[0] < 0) {\n          tuple = new Tuple<Nullable<long>,\
    \ Nullable<long>>(lst[0], null);\n        }\n        return tuple;\n      }\n\
    \      // Used to find the smallest positive number\n      List<long> positiveNums\
    \ = new List<long>();\n      // Used to find the largest negative number\n   \
    \   List<long> negativeNums = new List<long>();\n      foreach (long num in lst)\
    \ {\n        if (num < 0) {\n          negativeNums.Add(num);\n        } else\
    \ if (num > 0) {\n          positiveNums.Add(num);\n        }\n      }\n     \
    \ int negLength = negativeNums.Count;\n      int posLength = positiveNums.Count;\n\
    \      if (negLength > 0) {\n        tuple = new Tuple<Nullable<long>, Nullable<long>>(negativeNums.Max(),\
    \ null);\n      }\n      if (posLength > 0) {\n        tuple = new Tuple<Nullable<long>,\
    \ Nullable<long>>(tuple.Item1, positiveNums.Min());\n      }\n      return tuple;",
  "        // Implement this function\n        Tuple<Nullable<long>, Nullable<long>>\
    \ result = new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        bool\
    \ first_p = true;\n        bool first_n = true;\n        foreach (long elem in\
    \ lst) {\n            if (elem > 0) {\n                if (first_p) {\n      \
    \              result = new Tuple<Nullable<long>, Nullable<long>>(result.Item1,\
    \ elem);\n                    first_p = false;\n                } else {\n   \
    \                 if (elem < result.Item2) {\n                        result =\
    \ new Tuple<Nullable<long>, Nullable<long>>(result.Item1, elem);\n           \
    \         }\n                }\n            } else if (elem < 0) {\n         \
    \       if (first_n) {\n                    result = new Tuple<Nullable<long>,\
    \ Nullable<long>>(elem, result.Item2);\n                    first_n = false;\n\
    \                } else {\n                    if (elem > result.Item1) {\n  \
    \                      result = new Tuple<Nullable<long>, Nullable<long>>(elem,\
    \ result.Item2);\n                    }\n                }\n            }\n  \
    \      }\n        return result;", "        var asd = lst.Where(l => l < 0);\n\
    \        var dsa = lst.Where(l => l > 0);\n        Nullable<long> minPositive\
    \ = null;\n        Nullable<long> maxNegative = null;\n        if (dsa.Count()\
    \ > 0) {\n            minPositive = dsa.Min();\n        }\n        if (asd.Count()\
    \ > 0) {\n            maxNegative = asd.Max();\n        }\n        return Tuple.Create(maxNegative,\
    \ minPositive);", "        // your solution:\n        long min=1;\n        long\
    \ max=-1;\n        foreach(long i in lst){\n            if(i>=0 && i<min){\n \
    \               min=i;\n            }\n            if(i<0 && i>max){\n       \
    \         max=i;\n            }\n        }\n        Nullable<long> nMin=min==1?null:(Nullable<long>)min;\n\
    \        Nullable<long> nMax=max==-1?null:(Nullable<long>)max;\n        return\
    \ Tuple.Create(nMax,nMin);", '        return null;', "        if (lst.Count ==\
    \ 0)\n            return Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n\
    \        long minPos = long.MaxValue;\n        long maxNeg = long.MinValue;\n\
    \        bool foundPos = false;\n        bool foundNeg = false;\n        foreach\
    \ (long item in lst) {\n            if (item > 0) {\n                foundPos\
    \ = true;\n                if (item < minPos)\n                    minPos = item;\n\
    \            }\n            else if (item < 0) {\n                foundNeg = true;\n\
    \                if (item > maxNeg)\n                    maxNeg = item;\n    \
    \        }\n        }\n        if (!foundPos)\n            minPos = null;\n  \
    \      if (!foundNeg)\n            maxNeg = null;\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(maxNeg, minPos);", "        if (lst.Count == 0) {\n        \
    \    return Tuple.Create<Nullable<long>, Nullable<long>>(null, null);\n      \
    \  }\n        long max = long.MinValue;\n        long min = long.MaxValue;\n \
    \       foreach (long i in lst) {\n            if (i < 0) {\n                if\
    \ (i > max) {\n                    max = i;\n                }\n            }\
    \ else if (i > 0) {\n                if (i < min) {\n                    min =\
    \ i;\n                }\n            }\n        }\n        if (max == long.MinValue)\
    \ {\n            max = (long)null;\n        }\n        if (min == long.MaxValue)\
    \ {\n            min = (long)null;\n        }\n        return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(max, min);", "        var s = Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        if (lst.Count() != 0) {\n            s = Tuple.Create((Nullable<long>)lst.Min(),\
    \ (Nullable<long>)lst.Max());\n        }\n        return s;", "        List<long>\
    \ negs = new List<long>();\n        List<long> poss = new List<long>();\n    \
    \    foreach (long n in lst) {\n            if (n < 0) {\n                negs.Add(n);\n\
    \            } else if (n > 0) {\n                poss.Add(n);\n            }\n\
    \        }\n        Nullable<long> neg = null;\n        Nullable<long> pos = null;\n\
    \        if (negs.Count > 0) {\n            neg = negs.Max();\n        }\n   \
    \     if (poss.Count > 0) {\n            pos = poss.Min();\n        }\n      \
    \  return Tuple.Create(neg, pos);", "        // initialize variables\n       \
    \ Nullable<long> positive = null;\n        Nullable<long> negative = null;\n \
    \       // loop through the list and find the positive and negative numbers\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            // positive\n    \
    \        if (lst[i] > 0) {\n                if (positive == null)\n          \
    \          positive = lst[i];\n                else if (lst[i] < positive)\n \
    \                   positive = lst[i];\n            }\n            // negative\n\
    \            else if (lst[i] < 0) {\n                if (negative == null)\n \
    \                   negative = lst[i];\n                else if (lst[i] > negative)\n\
    \                    negative = lst[i];\n            }\n        }\n        //\
    \ create the tuple and return it\n        return Tuple.Create(negative, positive);",
  '        return Tuple.Create(lst.Where(i => i < 0).DefaultIfEmpty().Max(), lst.Where(i
    => i > 0).DefaultIfEmpty().Min());', "        long? largest = null;\n        long?\
    \ smallest = null;\n        foreach (long x in lst) {\n            if (x < 0)\
    \ {\n                if (largest == null || x > largest) {\n                 \
    \   largest = x;\n                }\n            } else if (x > 0) {\n       \
    \         if (smallest == null || x < smallest) {\n                    smallest\
    \ = x;\n                }\n            }\n        }\n        return Tuple.Create(largest,\
    \ smallest);", "        long neg = 0;\n        long pos = 0;\n        int i =\
    \ 0;\n        int j = 0;\n        while (i < lst.Count) {\n            if (lst[i]\
    \ < 0) {\n                neg = lst[i];\n                break;\n            }\n\
    \            i += 1;\n        }\n        while (j < lst.Count) {\n           \
    \ if (lst[j] > 0) {\n                pos = lst[j];\n                break;\n \
    \           }\n            j += 1;\n        }\n        while (i < lst.Count) {\n\
    \            if (lst[i] < 0 && lst[i] > neg) {\n                neg = lst[i];\n\
    \            }\n            i += 1;\n        }\n        while (j < lst.Count)\
    \ {\n            if (lst[j] > 0 && lst[j] < pos) {\n                pos = lst[j];\n\
    \            }\n            j += 1;\n        }\n        if (i == lst.Count) {\n\
    \            neg = (long)null;\n        }\n        if (j == lst.Count) {\n   \
    \         pos = (long)null;\n        }\n        return Tuple.Create((Nullable<long>)neg,\
    \ (Nullable<long>)pos);", "        long biggest = 0;\n        long smallest =\
    \ 0;\n        bool firstbig = true;\n        bool firstsmall = true;\n       \
    \ foreach (long x in lst) {\n            if (x < 0) {\n                if (firstbig\
    \ || x > biggest) {\n                    biggest = x;\n                    firstbig\
    \ = false;\n                }\n            } else if (x > 0) {\n             \
    \   if (firstsmall || x < smallest) {\n                    smallest = x;\n   \
    \                 firstsmall = false;\n                }\n            }\n    \
    \    }\n        if (firstbig) biggest = 0;\n        if (firstsmall) smallest =\
    \ 0;\n        return Tuple.Create<Nullable<long>, Nullable<long>>((long)biggest,\
    \ (long)smallest);", "        var neg = from i in lst where i < 0 select i;\n\
    \        var pos = from i in lst where i > 0 select i;\n        var negm = neg.Max();\n\
    \        var posm = pos.Min();\n        if (negm == 0) negm = null;\n        if\
    \ (posm == 0) posm = null;\n        return Tuple.Create(negm, posm);", "     \
    \   bool positive = false;\n        bool negative = false;\n        long smallestPositiveNumber\
    \ = 0;\n        long largestNegativeNumber = 0;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < 0) {\n                if (negative == false)\
    \ {\n                    largestNegativeNumber = lst[i];\n                   \
    \ negative = true;\n                } else {\n                    if (lst[i] >\
    \ largestNegativeNumber) {\n                        largestNegativeNumber = lst[i];\n\
    \                    }\n                }\n            } else if (lst[i] > 0)\
    \ {\n                if (positive == false) {\n                    smallestPositiveNumber\
    \ = lst[i];\n                    positive = true;\n                } else {\n\
    \                    if (lst[i] < smallestPositiveNumber) {\n                \
    \        smallestPositiveNumber = lst[i];\n                    }\n           \
    \     }\n            }\n        }\n        if (negative == false) {\n        \
    \    largestNegativeNumber = (Nullable<long>)null;\n        }\n        if (positive\
    \ == false) {\n            smallestPositiveNumber = (Nullable<long>)null;\n  \
    \      }\n        return Tuple.Create((Nullable<long>)largestNegativeNumber, (Nullable<long>)smallestPositiveNumber);",
  "        if (lst.Any()) {\n            return Tuple.Create(lst.Where(x => x < 0).DefaultIfEmpty().Max(),\
    \ lst.Where(x => x > 0).DefaultIfEmpty().Min());\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", '        return Tuple.Create((long?)null, (long?)null);',
  "        // TODO\n        throw new NotImplementedException();", '        throw
    new NotImplementedException();', "        var negatives = lst.Where(n => n < 0).ToList();\n\
    \        var positives = lst.Where(n => n > 0).ToList();\n        var l = negatives.Count\
    \ == 0 ? null : (long?)negatives.Max();\n        var s = positives.Count == 0\
    \ ? null : (long?)positives.Min();\n        return Tuple.Create(l, s);", "   \
    \     List<long> negatives = new List<long>();\n        List<long> positives =\
    \ new List<long>();\n        foreach (long item in lst) {\n            if (item\
    \ < 0) {\n                negatives.Add(item);\n            } else if (item >\
    \ 0) {\n                positives.Add(item);\n            }\n        }\n     \
    \   if (negatives.Count == 0) {\n            negatives.Add((long)0L);\n      \
    \  }\n        if (positives.Count == 0) {\n            positives.Add((long)0L);\n\
    \        }\n        return Tuple.Create((long)negatives.Max(), (long)positives.Min());",
  "        long maxNegative = long.MinValue;\n        long minPositive = long.MaxValue;\n\
    \        foreach (long item in lst) {\n            if (item > 0 && item < minPositive)\
    \ {\n                minPositive = item;\n            }\n            if (item\
    \ < 0 && item > maxNegative) {\n                maxNegative = item;\n        \
    \    }\n        }\n        if (maxNegative == long.MinValue) {\n            maxNegative\
    \ = (Nullable<long>)null;\n        }\n        if (minPositive == long.MaxValue)\
    \ {\n            minPositive = (Nullable<long>)null;\n        }\n        return\
    \ Tuple.Create((Nullable<long>)maxNegative, (Nullable<long>)minPositive);", " \
    \       // Your code goes here!\n        return new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ null);", "        if(lst.Count < 1) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        long neg = lst.Where(i => i < 0).Max();\n\
    \        long pos = lst.Where(i => i > 0).Min();\n        if(neg == 0 || pos ==\
    \ 0) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        return Tuple.Create((Nullable<long>)neg, (Nullable<long>)pos);",
  "        long min = (long)1E15;\n        long max = (long)(-1E15);\n        bool\
    \ allZeros = true;\n        for (int i = 0; i < lst.Count; i++) {\n          \
    \  if (lst[i] > 0) {\n                allZeros = false;\n                if (lst[i]\
    \ < min) {\n                    min = lst[i];\n                }\n           \
    \ } else if (lst[i] < 0) {\n                allZeros = false;\n              \
    \  if (lst[i] > max) {\n                    max = lst[i];\n                }\n\
    \            }\n        }\n        return (allZeros) ? Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null) : Tuple.Create((Nullable<long>)max, (Nullable<long>)min);",
  "        // Write your code here\n        long min = 0;\n        long max = 0;\n\
    \        bool min_found = false;\n        bool max_found = false;\n        foreach\
    \ (long i in lst) {\n            if (i < 0) {\n                if (!min_found)\
    \ {\n                    min = i;\n                    min_found = true;\n   \
    \             } else {\n                    if (i > min) {\n                 \
    \       min = i;\n                    }\n                }\n            } else\
    \ if (i > 0) {\n                if (!max_found) {\n                    max = i;\n\
    \                    max_found = true;\n                } else {\n           \
    \         if (i < max) {\n                        max = i;\n                 \
    \   }\n                }\n            }\n        }\n        if (min_found) {\n\
    \            if (max_found) {\n                return Tuple.Create((Nullable<long>)min,\
    \ (Nullable<long>)max);\n            } else {\n                return Tuple.Create((Nullable<long>)min,\
    \ (Nullable<long>)null);\n            }\n        } else {\n            if (max_found)\
    \ {\n                return Tuple.Create((Nullable<long>)null, (Nullable<long>)max);\n\
    \            } else {\n                return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n            }\n        }", "        // Set up some variables\n\
    \        var negative = new List<long>();\n        var positive = new List<long>();\n\
    \        var tuple = new Tuple<Nullable<long>, Nullable<long>>(null, null);\n\
    \        // There is no point in continuing if the list is empty\n        if (lst.Count\
    \ == 0) {\n            return tuple;\n        }\n        // Sort the list by integer\
    \ value\n        lst.Sort();\n        // Look through the sorted list, and build\
    \ up our two lists\n        foreach (var i in lst) {\n            if (i < 0) {\n\
    \                negative.Add(i);\n            } else if (i > 0) {\n         \
    \       positive.Add(i);\n            }\n        }\n        // Now that we have\
    \ our two lists, check if there are any elements\n        // in them, and if so,\
    \ we can use them to replace the tuple\n        if (negative.Count > 0) {\n  \
    \          tuple = new Tuple<Nullable<long>, Nullable<long>>(negative.Last(),\
    \ tuple.Item2);\n        }\n        if (positive.Count > 0) {\n            tuple\
    \ = new Tuple<Nullable<long>, Nullable<long>>(tuple.Item1, positive.First());\n\
    \        }\n        return tuple;", '        return null;', "        // your code\
    \ here\n        return null;", "        ///////////////////\n        // Algorithm\
    \ description:\n        // - Go through the list and find the largest negative\
    \ and the smallest positive number\n        ///////////////////\n        long\
    \ largestNegativeNumber = long.MinValue;\n        long smallestPositiveNumber\
    \ = long.MaxValue;\n        foreach (long l in lst) {\n            if (l < 0)\
    \ {\n                if (l > largestNegativeNumber) {\n                    largestNegativeNumber\
    \ = l;\n                }\n            } else if (l > 0) {\n                if\
    \ (l < smallestPositiveNumber) {\n                    smallestPositiveNumber =\
    \ l;\n                }\n            }\n        }\n        if (largestNegativeNumber\
    \ == long.MinValue) {\n            largestNegativeNumber = long.MaxValue;\n  \
    \      }\n        if (smallestPositiveNumber == long.MaxValue) {\n           \
    \ smallestPositiveNumber = long.MinValue;\n        }\n        return Tuple.Create((Nullable<long>)largestNegativeNumber,\
    \ (Nullable<long>)smallestPositiveNumber);", "        //return Tuple.Create(lst.Where(x\
    \ => x < 0).Max(), lst.Where(x => x > 0).Min());\n        return Tuple.Create(lst.Where(x\
    \ => x < 0).Aggregate((x, y) => x > y ? x : y), lst.Where(x => x > 0).Aggregate((x,\
    \ y) => x < y ? x : y));", "        Tuple<Nullable<long>, Nullable<long>> t =\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        for (int i =\
    \ 0; i < lst.Count; i++) {\n            if (lst[i] > 0) {\n                if\
    \ (t.Item2 == null)\n                    t = new Tuple<Nullable<long>, Nullable<long>>(t.Item1,\
    \ lst[i]);\n                else if (lst[i] < t.Item2)\n                    t\
    \ = new Tuple<Nullable<long>, Nullable<long>>(t.Item1, lst[i]);\n            }\
    \ else if (lst[i] < 0) {\n                if (t.Item1 == null)\n             \
    \       t = new Tuple<Nullable<long>, Nullable<long>>(lst[i], t.Item2);\n    \
    \            else if (lst[i] > t.Item1)\n                    t = new Tuple<Nullable<long>,\
    \ Nullable<long>>(lst[i], t.Item2);\n            }\n        }\n        return\
    \ t;", "        long smallestPos = long.MaxValue;\n        long largestNeg = long.MinValue;\n\
    \        bool anyPos = false;\n        bool anyNeg = false;\n        foreach (long\
    \ i in lst) {\n            if (i < 0) {\n                if (i > largestNeg) {\n\
    \                    largestNeg = i;\n                }\n                anyNeg\
    \ = true;\n            } else if (i > 0) {\n                if (i < smallestPos)\
    \ {\n                    smallestPos = i;\n                }\n               \
    \ anyPos = true;\n            }\n        }\n        return Tuple.Create(anyNeg\
    \ ? (Nullable<long>)largestNeg : (Nullable<long>)null, anyPos ? (Nullable<long>)smallestPos\
    \ : (Nullable<long>)null);", "        long max = 0, min = 0;\n        bool amax\
    \ = false, amin = false;\n        foreach (var i in lst) {\n            if (i\
    \ < 0) {\n                if (!amax) {\n                    max = i;\n       \
    \             amax = true;\n                } else if (i > max) {\n          \
    \          max = i;\n                }\n            } else if (i > 0) {\n    \
    \            if (!amin) {\n                    min = i;\n                    amin\
    \ = true;\n                } else if (i < min) {\n                    min = i;\n\
    \                }\n            }\n        }\n        return Tuple.Create((Nullable<long>)(amax\
    \ ? max : null), (Nullable<long>)(amin ? min : null));", "        // >>> LargestSmallestIntegers(lst)\n\
    \        return null;", "        // Write your code here.\n        return null;",
  "        long? negmin = null;\n        long? posmin = null;\n        for (int i\
    \ = 0; i < lst.Count; i++) {\n            if (lst[i] < 0) {\n                if\
    \ (!negmin.HasValue || lst[i] > negmin) {\n                    negmin = lst[i];\n\
    \                }\n            } else if (lst[i] > 0) {\n                if (!posmin.HasValue\
    \ || lst[i] < posmin) {\n                    posmin = lst[i];\n              \
    \  }\n            }\n        }\n        return Tuple.Create(negmin, posmin);",
  "        if (lst.Count > 0) {\n            // Type your solution here.\n       \
    \     long largest = long.MinValue;\n            long smallest = long.MaxValue;\n\
    \            bool found_negative = false;\n            bool found_positive = false;\n\
    \            foreach (long num in lst) {\n                if (num < 0) {\n   \
    \                 if (num > largest) {\n                        largest = num;\n\
    \                    }\n                    found_negative = true;\n         \
    \       } else if (num > 0) {\n                    if (num < smallest) {\n   \
    \                     smallest = num;\n                    }\n               \
    \     found_positive = true;\n                }\n            }\n            return\
    \ Tuple.Create(found_negative ? (Nullable<long>)largest : (Nullable<long>)null,\
    \ found_positive ? (Nullable<long>)smallest : (Nullable<long>)null);\n       \
    \ } else {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }", "        var largest = lst.Where(x => x < 0).DefaultIfEmpty().Max();\n\
    \        var smallest = lst.Where(x => x > 0).DefaultIfEmpty().Min();\n      \
    \  return Tuple.Create(largest, smallest);", "        var largestNegative = new\
    \ Nullable<long>();\n        var smallestPositive = new Nullable<long>();\n  \
    \      foreach (var i in lst) {\n            if (i < 0) {\n                if\
    \ (largestNegative == null || i > largestNegative) {\n                    largestNegative\
    \ = i;\n                }\n            } else if (i > 0) {\n                if\
    \ (smallestPositive == null || i < smallestPositive) {\n                    smallestPositive\
    \ = i;\n                }\n            }\n        }\n        return Tuple.Create(largestNegative,\
    \ smallestPositive);", "        // Iterate the list and find the largest negative\
    \ and smallest positive numbers.\n        long largestNegative = 0;\n        long\
    \ smallestPositive = 0;\n        foreach (long n in lst) {\n            if (n\
    \ > largestNegative) {\n                largestNegative = n;\n            }\n\
    \            if (n < smallestPositive) {\n                smallestPositive = n;\n\
    \            }\n        }\n        // If the largest negative number is greater\
    \ than the smallest positive number,\n        // return a tuple with both values.\n\
    \        if (largestNegative > smallestPositive) {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(largestNegative, smallestPositive);\n        }\n        // If\
    \ the largest negative number is less than or equal to the smallest positive number,\n\
    \        // return a tuple with a nullable largest negative number, and a nullable\
    \ smallest positive number.\n        else {\n            return Tuple.Create<Nullable<long>,\
    \ Nullable<long>>(null, null);\n        }", "        long smallest = (long)lst[0];\n\
    \        long largest = (long)lst[0];\n        bool positive = false;\n      \
    \  bool negative = false;\n        foreach (var n in lst) {\n            if (n\
    \ < 0) {\n                negative = true;\n                if (n > largest) {\n\
    \                    largest = n;\n                }\n            }\n        \
    \    if (n > 0) {\n                positive = true;\n                if (n < smallest)\
    \ {\n                    smallest = n;\n                }\n            }\n   \
    \     }\n        return (negative ? Tuple.Create(largest, (Nullable<long>)null)\
    \ : (positive ? Tuple.Create((Nullable<long>)null, smallest) : Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null)));", "        // Your code goes here.\n        return\
    \ null;", "        long maxNeg = long.MinValue;\n        long minPos = long.MaxValue;\n\
    \        for (long i = 0; i < lst.Count; i++) {\n            if (lst[(int)i] <\
    \ 0) {\n                if (lst[(int)i] > maxNeg) {\n                    maxNeg\
    \ = lst[(int)i];\n                }\n            } else if (lst[(int)i] > 0) {\n\
    \                if (lst[(int)i] < minPos) {\n                    minPos = lst[(int)i];\n\
    \                }\n            }\n        }\n        if (maxNeg == long.MinValue)\
    \ {\n            maxNeg = (Nullable<long>)null;\n        }\n        if (minPos\
    \ == long.MaxValue) {\n            minPos = (Nullable<long>)null;\n        }\n\
    \        Tuple<Nullable<long>, Nullable<long>> result = Tuple.Create(maxNeg, minPos);\n\
    \        return result;", "        var s = lst.Where(x => x > 0).ToList();\n \
    \       var l = lst.Where(x => x < 0).ToList();\n        return Tuple.Create(l.Count\
    \ > 0 ? (Nullable<long>)l.Max() : (Nullable<long>)null, s.Count > 0 ? (Nullable<long>)s.Min()\
    \ : (Nullable<long>)null);", '        return new Tuple<Nullable<long>, Nullable<long>>(null,
    null);', "        var c = lst.Count;\n        long max = -99999;\n        long\
    \ min = 99999;\n        if (c == 0) {\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        }\n        for (int i = 0; i < c; i++) {\n \
    \           if (lst[i] < 0) {\n                if (lst[i] > max) {\n         \
    \           max = lst[i];\n                }\n            }\n            if (lst[i]\
    \ > 0) {\n                if (lst[i] < min) {\n                    min = lst[i];\n\
    \                }\n            }\n        }\n        if (max == -99999) {\n \
    \           max = 0;\n        }\n        if (min == 99999) {\n            min\
    \ = 0;\n        }\n        if (max == 0) {\n            max = -2;\n        }\n\
    \        if (min == 0) {\n            min = -2;\n        }\n        if (max ==\
    \ -2 && min == -2) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        if (max == -2) {\n            return Tuple.Create((Nullable<long>)null,\
    \ min);\n        }\n        if (min == -2) {\n            return Tuple.Create(max,\
    \ (Nullable<long>)null);\n        }\n        return Tuple.Create(max, min);",
  "        Tuple<Nullable<long>, Nullable<long>> ret = null;\n        return ret;",
  "        var smallest = lst.Where(x => x > 0).DefaultIfEmpty(Nullable<long>.Value).Min();\n\
    \        var largest = lst.Where(x => x < 0).DefaultIfEmpty(Nullable<long>.Value).Max();\n\
    \        return Tuple.Create(largest, smallest);", "        long? biggest = null;\n\
    \        long? smallest = null;\n        foreach (long item in lst) {\n      \
    \      if (item < 0) {\n                if (biggest == null || item > biggest)\
    \ {\n                    biggest = item;\n                }\n            } else\
    \ if (item > 0) {\n                if (smallest == null || item < smallest) {\n\
    \                    smallest = item;\n                }\n            }\n    \
    \    }\n        return Tuple.Create(biggest, smallest);", "        var min = (from\
    \ i in lst\n                   where i > 0\n                   select i).Min();\n\
    \        var max = (from i in lst\n                   where i < 0\n          \
    \         select i).Max();\n        if (min == 0) {\n            min = (Nullable<long>)null;\n\
    \        }\n        if (max == 0) {\n            max = (Nullable<long>)null;\n\
    \        }\n        return Tuple.Create(max, min);", "        Tuple<Nullable<long>,\
    \ Nullable<long>> res = Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        foreach (long val in lst) {\n            if (val < 0) {\n           \
    \     if (res.Item1 == null || val > res.Item1) {\n                    res = Tuple.Create(val,\
    \ res.Item2);\n                }\n            } else if (val > 0) {\n        \
    \        if (res.Item2 == null || val < res.Item2) {\n                    res\
    \ = Tuple.Create(res.Item1, val);\n                }\n            }\n        }\n\
    \        return res;", "        // Write your code here\n        var LargestSmallestIntegers\
    \ = new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null, (Nullable<long>)null);\n\
    \        if (lst.Count == 0)\n        {\n            return LargestSmallestIntegers;\n\
    \        }\n        lst.Sort();\n        if (lst[0] > 0)\n        {\n        \
    \    return LargestSmallestIntegers;\n        }\n        if (lst[lst.Count - 1]\
    \ < 0)\n        {\n            return LargestSmallestIntegers;\n        }\n  \
    \      int i = 0;\n        while (lst[i] < 0)\n        {\n            i++;\n \
    \       }\n        LargestSmallestIntegers = new Tuple<Nullable<long>, Nullable<long>>(lst[i\
    \ - 1], lst[i]);\n        return LargestSmallestIntegers;", "        // Add your\
    \ code here.\n        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);",
  "        Tuple<Nullable<long>, Nullable<long>> nullTuple = Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        if (lst.Count == 0) {\n            return nullTuple;\n\
    \        }\n        long min = long.MaxValue;\n        long max = long.MinValue;\n\
    \        bool minSet = false;\n        bool maxSet = false;\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            if (lst[i] < 0 && lst[i] > max) {\n\
    \                max = lst[i];\n                maxSet = true;\n            }\n\
    \            if (lst[i] > 0 && lst[i] < min) {\n                min = lst[i];\n\
    \                minSet = true;\n            }\n        }\n        if (!minSet)\
    \ {\n            min = (Nullable<long>)null;\n        }\n        if (!maxSet)\
    \ {\n            max = (Nullable<long>)null;\n        }\n        return Tuple.Create(max,\
    \ min);", "        // >>> your code here <<<\n        long min = -1, max = -1;\n\
    \        if (lst.Count == 0)\n            return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);\n        foreach (long item in lst)\n        {\n    \
    \        if (item > 0)\n            {\n                if (min == -1)\n      \
    \              min = item;\n                else if (item < min)\n           \
    \         min = item;\n            }\n            else if (item < 0)\n       \
    \     {\n                if (max == -1)\n                    max = item;\n   \
    \             else if (item > max)\n                    max = item;\n        \
    \    }\n        }\n        return Tuple.Create((Nullable<long>)max, (Nullable<long>)min);",
  "        // find the biggest negative integer\n        // find the smallest positive\
    \ integer\n        long min = long.MaxValue;\n        long max = long.MinValue;\n\
    \        bool anyPositive = false;\n        bool anyNegative = false;\n      \
    \  foreach (long n in lst) {\n            if (n < 0) {\n                anyNegative\
    \ = true;\n                if (n > max) max = n;\n            } else if (n > 0)\
    \ {\n                anyPositive = true;\n                if (n < min) min = n;\n\
    \            }\n        }\n        return new Tuple<Nullable<long>, Nullable<long>>(\n\
    \            anyNegative ? (Nullable<long>)max : (Nullable<long>)null,\n     \
    \       anyPositive ? (Nullable<long>)min : (Nullable<long>)null);", "       \
    \ // >>> YOUR CODE HERE <<<\n        long max = long.MinValue;\n        long min\
    \ = long.MaxValue;\n        foreach (long i in lst) {\n            if (i > 0 &&\
    \ i < min) {\n                min = i;\n            }\n            if (i < 0 &&\
    \ i > max) {\n                max = i;\n            }\n        }\n        if (max\
    \ == long.MinValue) max = (Nullable<long>)null;\n        if (min == long.MaxValue)\
    \ min = (Nullable<long>)null;\n        return Tuple.Create(max, min);", "    \
    \    //TODO\n        throw new NotImplementedException();", '        return Tuple.Create((Nullable<long>)
    null, (Nullable<long>) null);', '        throw new NotImplementedException();',
  "        // Write your code here\n        return null;", "        // YOUR CODE HERE\n\
    \        return null;", '        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);',
  "        long? largestNegative = null;\n        long? smallestPositive = null;\n\
    \        long? i = null;\n        long? largestNegative_0 = null;\n        long?\
    \ smallestPositive_0 = null;\n        long? i_0 = null;\n        if (lst.Count\
    \ == 0) {\n            return Tuple.Create((Nullable<long>)largestNegative, (Nullable<long>)smallestPositive);\n\
    \        }\n        else {\n            foreach (long i_1 in lst) {\n        \
    \        i = i_1;\n                if (i < 0) {\n                    if (largestNegative\
    \ == null) {\n                        largestNegative = i;\n                 \
    \   }\n                    else {\n                        if (i > largestNegative)\
    \ {\n                            largestNegative = i;\n                      \
    \  }\n                    }\n                }\n                else {\n     \
    \               if (i > 0) {\n                        if (smallestPositive ==\
    \ null) {\n                            smallestPositive = i;\n               \
    \         }\n                        else {\n                            if (i\
    \ < smallestPositive) {\n                                smallestPositive = i;\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n            largestNegative_0 = largestNegative;\n\
    \            smallestPositive_0 = smallestPositive;\n            i_0 = i;\n  \
    \          return Tuple.Create((Nullable<long>)largestNegative_0, (Nullable<long>)smallestPositive_0);\n\
    \        }", "        // put your code here\n        long max = 0;\n        long\
    \ min = 0;\n        var positive = false;\n        var negative = false;\n   \
    \     long[] values = lst.ToArray();\n        foreach (var i in values) {\n  \
    \          if (i >= 0) {\n                positive = true;\n                if\
    \ (min == 0) {\n                    min = i;\n                }\n            \
    \    else if (i < min) {\n                    min = i;\n                }\n  \
    \          }\n            else {\n                negative = true;\n         \
    \       if (i > max) {\n                    max = i;\n                }\n    \
    \        }\n        }\n        if (positive == false) {\n            min = (Nullable<long>)null;\n\
    \        }\n        if (negative == false) {\n            max = (Nullable<long>)null;\n\
    \        }\n        return Tuple.Create(max, min);", "        // Write your code\
    \ here\n        long max = lst.Where(x => x < 0).DefaultIfEmpty(0).Max();\n  \
    \      long min = lst.Where(x => x > 0).DefaultIfEmpty(0).Min();\n        return\
    \ Tuple.Create((Nullable<long>)max, (Nullable<long>)min);", "        var ret =\
    \ new Tuple<Nullable<long>, Nullable<long>>(null, null);\n        var pos = new\
    \ List<long>();\n        var neg = new List<long>();\n        foreach (var i in\
    \ lst) {\n            if (i > 0) {\n                pos.Add(i);\n            }\
    \ else if (i < 0) {\n                neg.Add(i);\n            }\n        }\n \
    \       if (pos.Count > 0) {\n            ret = new Tuple<Nullable<long>, Nullable<long>>(null,\
    \ pos.Min());\n        }\n        if (neg.Count > 0) {\n            ret = new\
    \ Tuple<Nullable<long>, Nullable<long>>(neg.Max(), ret.Item2);\n        }\n  \
    \      return ret;", "        var dict = new Dictionary<long, long>();\n     \
    \   foreach (var item in lst) {\n            if (dict.ContainsKey(item)) {\n \
    \               dict[item]++;\n            } else {\n                dict[item]\
    \ = 1;\n            }\n        }\n        var dict2 = new Dictionary<long, long>();\n\
    \        foreach (var item in dict) {\n            var key = item.Key;\n     \
    \       var value = item.Value;\n            if (dict2.ContainsKey(value)) {\n\
    \                dict2[value]++;\n            } else {\n                dict2[value]\
    \ = 1;\n            }\n        }\n        var dict3 = new Dictionary<long, long>();\n\
    \        foreach (var item in dict2) {\n            var key = item.Key;\n    \
    \        var value = item.Value;\n            if (dict3.ContainsKey(value)) {\n\
    \                dict3[value]++;\n            } else {\n                dict3[value]\
    \ = 1;\n            }\n        }\n        if (dict3.ContainsKey((long)1L)) {\n\
    \            var set = new HashSet<long>();\n            foreach (var item in\
    \ dict) {\n                if (item.Value == (long)1L) {\n                   \
    \ set.Add(item.Key);\n                }\n            }\n            if (set.Count\
    \ == lst.Count) {\n                return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \            }\n        }\n        var set2 = new HashSet<long>();\n        foreach\
    \ (var item in dict) {\n            if (item.Value == (long)2L) {\n          \
    \      set2.Add(item.Key);\n            }\n        }\n        if (set2.Count ==\
    \ lst.Count) {\n            return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n\
    \        }\n        var list = new List<long>();\n        foreach (var item in\
    \ dict2) {\n            if (item.Value == (long)1L) {\n                list.Add(item.Key);\n\
    \            }\n        }\n        list.Sort();\n        var", '        return
    new Tuple<Nullable<long>, Nullable<long>>((long?)lst.Count, 0);', "        long[]\
    \ lstNeg = lst.Where(x => x < 0).ToArray();\n        long[] lstPos = lst.Where(x\
    \ => x > 0).ToArray();\n        long maxNeg = long.MinValue;\n        long minPos\
    \ = long.MaxValue;\n        if (lstNeg.Length > 0) {\n            maxNeg = lstNeg.Max();\n\
    \        }\n        if (lstPos.Length > 0) {\n            minPos = lstPos.Min();\n\
    \        }\n        return Tuple.Create((Nullable<long>)maxNeg, (Nullable<long>)minPos);",
  "        return Tuple.Create(\n            lst.Count > 0 ? lst.Min() : (Nullable<long>)null,\n\
    \            lst.Count > 0 ? lst.Max() : (Nullable<long>)null\n        );", '        return
    new Tuple<Nullable<long>, Nullable<long>>(1L, 1L);', "        long? min = null;\n\
    \        long? max = null;\n        foreach (long elem in lst) {\n           \
    \ if (elem > 0) {\n                if (min == null || elem < min) {\n        \
    \            min = elem;\n                }\n            } else if (elem < 0)\
    \ {\n                if (max == null || elem > max) {\n                    max\
    \ = elem;\n                }\n            }\n        }\n        return Tuple.Create(max,\
    \ min);", "        // Write your code here\n        if (lst.Count <= 0)\n    \
    \        return Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n  \
    \      long largest = -1;\n        long smallest = Int64.MaxValue;\n        bool\
    \ neg = false;\n        bool pos = false;\n        foreach (long i in lst) {\n\
    \            if (i < 0) {\n                neg = true;\n                if (i\
    \ > largest)\n                    largest = i;\n            }\n            if\
    \ (i > 0) {\n                pos = true;\n                if (i < smallest)\n\
    \                    smallest = i;\n            }\n        }\n        return Tuple.Create((neg\
    \ ? (Nullable<long>)largest : (Nullable<long>)null), (pos ? (Nullable<long>)smallest\
    \ : (Nullable<long>)null));", "        if (lst.Count == 0) {\n            return\
    \ Tuple.Create((Nullable<long>)null, (Nullable<long>)null);\n        }\n     \
    \   else {\n            return Tuple.Create(lst.Where(x => x < 0).Max(), lst.Where(x\
    \ => x > 0).Min());\n        }", '        return new Tuple<Nullable<long>, Nullable<long>>((Nullable<long>)null,
    (Nullable<long>)null);', "        Nullable<long> minPos = null;\n        Nullable<long>\
    \ maxNeg = null;\n        foreach (long item in lst) {\n            if (item <\
    \ 0) {\n                if (maxNeg == null || item > maxNeg)\n               \
    \     maxNeg = item;\n            } else if (item > 0) {\n                if (minPos\
    \ == null || item < minPos)\n                    minPos = item;\n            }\n\
    \        }\n        return Tuple.Create(maxNeg, minPos);", "        long? max_neg\
    \ = null;\n        long? min_pos = null;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < 0) {\n                if (max_neg == null ||\
    \ lst[i] > max_neg) {\n                    max_neg = lst[i];\n               \
    \ }\n            } else if (lst[i] > 0) {\n                if (min_pos == null\
    \ || lst[i] < min_pos) {\n                    min_pos = lst[i];\n            \
    \    }\n            }\n        }\n        return Tuple.Create(max_neg, min_pos);",
  "        var min = lst.Min();\n        var max = lst.Max();\n        if (min < 0)\
    \ {\n            return Tuple.Create(max, min);\n        }\n        return Tuple.Create((Nullable<long>)null,\
    \ (Nullable<long>)null);", '        throw new Exception("You need to implement
    this function");', '        throw new NotImplementedException();', '        return
    Tuple.Create((Nullable<long>)null, (Nullable<long>)null);']
stop_tokens:
- "\n    }\n"
