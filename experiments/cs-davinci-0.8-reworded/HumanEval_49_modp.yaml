name: HumanEval_49_modp
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> Modp((3L),\
  \ (5L))\n    // (3L)\n    // >>> Modp((1101L), (101L))\n    // (2L)\n    // >>>\
  \ Modp((0L), (101L))\n    // (1L)\n    // >>> Modp((3L), (11L))\n    // (8L)\n \
  \   // >>> Modp((100L), (101L))\n    // (1L)\n    public static long Modp(long n,\
  \ long p) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Modp((3L),\
  \ (5L)) == (3L));\n    Debug.Assert(Modp((1101L), (101L)) == (2L));\n    Debug.Assert(Modp((0L),\
  \ (101L)) == (1L));\n    Debug.Assert(Modp((3L), (11L)) == (8L));\n    Debug.Assert(Modp((100L),\
  \ (101L)) == (1L));\n    Debug.Assert(Modp((30L), (5L)) == (4L));\n    Debug.Assert(Modp((31L),\
  \ (5L)) == (3L));\n    }\n\n}\n"
completions: ['        return BigInteger.ModPow(new BigInteger(2), new BigInteger(n),
    new BigInteger(p)).ToString().ToLong();', "        var R = BigInteger.ModPow(new\
    \ BigInteger(2), new BigInteger(n), new BigInteger(p));\n        return (long)R;",
  "        if (n == 0) return 1;\n        long ans = 1;\n        long mul = n;\n \
    \       while (p > 0) {\n            if ((p & 1) > 0) {\n                ans =\
    \ (ans * mul) % 1000000007;\n            }\n            mul = (mul * mul) % 1000000007;\n\
    \            p >>= 1;\n        }\n        return ans;", "        long ret = 1;\n\
    \        for (; n > 0; n >>= 1) {\n            if ((n & 1) != 0) {\n         \
    \       ret = (ret * n) % p;\n            }\n        }\n        return ret;",
  "        if (n >= p) {\n            return n % p;\n        }\n        return n;",
  "        Debug.Assert(p >= 2L);\n        Debug.Assert(n >= 0L);\n        if (n <\
    \ p) {\n            return n;\n        }\n        // Now 2^n > p >= 2.\n     \
    \   // Use binary exponentiation.\n        long res = 1L;\n        for (long m\
    \ = n; m > 0L; m >>= 1L) {\n            if ((m & 1L) == 1L) {\n              \
    \  res = (res * 2L) % p;\n            }\n        }\n        return res;", "  \
    \      if (n < 2) return n;\n        if (n % 2 == 0) {\n            return Modp(n\
    \ / 2, p) * 2 % p;\n        } else {\n            return Modp(n / 2, p) * 2 %\
    \ p + 1;\n        }", "        long result = n % p;\n        if (result < 0) result\
    \ += p;\n        return result;", "        if (n == 0) return 1;\n        BigInteger\
    \ modp = n % p;\n        if (modp < 0) modp += p;\n        return (long)modp;",
  "        long r = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
    \                r = (r * n) % p;\n            }\n            n = n >> 1;\n  \
    \          n = (n * n) % p;\n        }\n        return r;", "        // return\
    \ (long) BigInteger.ModPow(2, n, p);\n        // return (long) BigInteger.Pow(2,\
    \ n) % p;\n        long r = 1;\n        while (n > 0) {\n            if ((n &\
    \ 1) == 1) {\n                r = (r * 2) % p;\n            }\n            n >>=\
    \ 1;\n            if (n > 0) {\n                r = (r * r) % p;\n           \
    \ }\n        }\n        return r;", "        var q = BigInteger.Pow(2, (int)n);\n\
    \        var r = q % p;\n        return (long)r;", "        if (n % p == 0) return\
    \ 0;\n        BigInteger r = 1, d = n;\n        while (d > 0) {\n            if\
    \ ((d & 1) == 1) r = (r * n) % p;\n            d >>= 1;\n            n = (n *\
    \ n) % p;\n        }\n        return (long)r;", "        long result = 1;\n  \
    \      while (n > 0) {\n            if ((n & 1) != 0)\n                result\
    \ = (result * n) % p;\n            n = n >> 1;\n        }\n        return result;",
  "        if (n == 0) return 1;\n        long q = Modp(n / 2, p);\n        long r\
    \ = q * q % p;\n        if (n % 2 == 1) r = r * 2 % p;\n        return r;", " \
    \       long result = 1;\n        while (n > 0) {\n            if ((n & 1) ==\
    \ 1)\n                result = (result * n) % p;\n            n >>= 1;\n     \
    \   }\n        return result;", "        if (n == 0) return 1;\n        long ret\
    \ = Modp(n / 2, p);\n        ret = ret * ret % p;\n        if (n % 2 == 1) ret\
    \ = ret * n % p;\n        return ret;", "        long r = 0;\n        while (n\
    \ > 0) {\n            r = (r + (n & 1) * p) % p;\n            n = n >> 1;\n  \
    \          p = (p << 1) % Constants.p;\n        }\n        return r;", "     \
    \   if (n == 0) {\n            return 1L;\n        }\n        if (n % 2 == 0)\
    \ {\n            long half = Modp(n / 2, p);\n            return (half * half)\
    \ % p;\n        }\n        return ((Modp(n - 1, p) * n) % p);", "        if (n\
    \ < 0) {\n            return (n%p + p)%p;\n        }\n        return n%p;", " \
    \       long r = n % p;\n        if (r < 0) {\n            r += p;\n        }\n\
    \        return r;", "        if (n == 0) {\n            return 1;\n        }\
    \ else if (n == 1) {\n            return n;\n        } else if (n % 2 == 0) {\n\
    \            return Modp(n / 2, p) * Modp(n / 2, p) % p;\n        } else {\n \
    \           return Modp(n / 2, p) * Modp(n / 2, p) * n % p;\n        }", "   \
    \     if (n >= p) {\n            n %= p;\n        }\n        if (n >= p/2) {\n\
    \            n -= p;\n        }\n        return n;", "        var res = 1L;\n\
    \        var a = 2L;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n\
    \                res = (res * a) % p;\n            }\n            a = (a * a)\
    \ % p;\n            n >>= 1;\n        }\n        return res;", '        return
    BigInteger.ModPow(new BigInteger(2), new BigInteger(n), new BigInteger(p)).ToString().ToInt();',
  "        long a = 1;\n        long b = n;\n        long c = p;\n        while (b\
    \ > 0) {\n            long d = b;\n            b = c % b;\n            c = d;\n\
    \        }\n        if (c == 1) {\n            long r = n % p;\n            if\
    \ (r < 0) {\n                r += p;\n            }\n            return r;\n \
    \       } else {\n            throw new ArgumentException(string.Format(\"Argument\
    \ ({0}) and modulus ({1}) are not coprime.\", n, p));\n        }", "        long\
    \ res = 1;\n        for (int i = 0; i < n; i++) {\n            res = (res * 2)\
    \ % p;\n        }\n        return res;", "        long r = 1;\n        long e\
    \ = n;\n        while (e > 0) {\n            if ((e & 1) != 0) r = (r * n) % p;\n\
    \            n = (n * n) % p;\n            e >>= 1;\n        }\n        return\
    \ r;", "        var result = 1L;\n        var n_factor = n;\n        var p_factor\
    \ = p;\n        while (n_factor > 0) {\n            if ((n_factor & 1) != 0) {\n\
    \                result = (result * n_factor) % p_factor;\n            }\n   \
    \         n_factor = n_factor >> 1;\n            n_factor = (n_factor * n_factor)\
    \ % p_factor;\n        }\n        return result;", "        if (n == 0) return\
    \ 1;\n        if (n % 2 == 0) return Modp(n / 2, p) * Modp(n / 2, p) % p;\n  \
    \      return Modp(n / 2, p) * Modp(n / 2, p) * n % p;", "        if (n < p) return\
    \ n;\n        return (2 * Modp(n - p, p) + n - p) % p;", "        if (n == 0)\
    \ return 1L;\n        if (n == 1) return n;\n        if (n == 2) return (n % p)\
    \ * (n % p) % p;\n        long half = Modp(n / 2, p);\n        long i = (half\
    \ * half) % p;\n        if (n % 2 == 1) {\n            i = (i * 2) % p;\n    \
    \    }\n        return i;", "        long res = 1;\n        while (n > 0) {\n\
    \            if ((n & 1) != 0) {\n                res = (res * (n % p)) % p;\n\
    \            }\n            n = n >> 1;\n        }\n        return res;", "  \
    \      if (n == 0) return 1;\n        if (n % 2 == 0) {\n            return Modp(n/2,\
    \ p) * Modp(n/2, p) % p;\n        } else {\n            return n * Modp(n-1, p)\
    \ % p;\n        }", "        long v = 1;\n        for (int i = 0; i < n; i++)\
    \ {\n            v = (v * 2) % p;\n        }\n        return v;", "        if\
    \ (n < 0) {\n            n += p;\n        }\n        return (BigInteger.ModPow(2,\
    \ n, p)).LongValue;", "        if (n == 0) return 1;\n        long q = Modp(n\
    \ / 2, p);\n        if (n % 2 == 0) {\n            return (q * q) % p;\n     \
    \   } else {\n            return (2 * q * q) % p;\n        }", '        return
    BigInteger.ModPow(2, n, p).ToInt64();', "        if (n < 0) return p - Modp(-n,\
    \ p);\n        if (n < p) return n;\n        if (n % p == 0) return 0;\n     \
    \   if (n < 1L << 32) return n % p;\n        return Modp(n % p, p) + ((n / p)\
    \ % p) * p;", "        // TODO: write me\n        long x = 1;\n        long y\
    \ = n;\n        while (p > 0) {\n            if ((p & 1) != 0) {\n           \
    \     x = (x * y) % p;\n            }\n            y = (y * y) % p;\n        \
    \    p >>= 1;\n        }\n        return x;", "        Debug.Assert(n >= 0);\n\
    \        Debug.Assert(p >= 0);\n        Debug.Assert(p != 0);\n        if (n ==\
    \ 0) return 1;\n        if (n % 2 == 0) {\n            long r = Modp(n / 2, p);\n\
    \            return r * r % p;\n        } else {\n            return n * Modp(n\
    \ - 1, p) % p;\n        }", "        if (n == 0) return 1;\n        long v = Modp(n\
    \ / 2, p);\n        v = (v * v) % p;\n        if (n % 2 == 1) v = (v * n) % p;\n\
    \        return v;", '        return (BigInteger.ModPow(new BigInteger(2), new
    BigInteger(n), new BigInteger(p))).ToInt64();', "        long product = 1;\n \
    \       long factor = n;\n        while (p > 0) {\n            long n1 = (p %\
    \ 2);\n            if (n1 == 1) {\n                product = (product * factor)\
    \ % 1000000007;\n            }\n            factor = (factor * factor) % 1000000007;\n\
    \            p = p / 2;\n        }\n        return product;", "        if (n ==\
    \ 0) {\n            return 1;\n        }\n        long x = Modp(n / 2, p);\n \
    \       x = (x * x) % p;\n        if (n % 2 == 1) {\n            x = (x * 2) %\
    \ p;\n        }\n        return x;", "        long l = n % p;\n        if (l <\
    \ 0) l += p;\n        return l;", "        long b = 1;\n        while (n > 0)\
    \ {\n            long o = n % 2;\n            if (o > 0) b = (b * 2) % p;\n  \
    \          n = n / 2;\n        }\n        return b;", "        long r = 1;\n \
    \       while (n > 0) {\n            if ((n & 1) != 0) {\n                r =\
    \ (r * n) % p;\n            }\n            n >>= 1;\n            if (n == 0) break;\n\
    \            n = (n * n) % p;\n        }\n        return r;", "        long res\
    \ = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n             \
    \   res = (res * n) % p;\n            n = n >> 1;\n            n = (n * n) % p;\n\
    \        }\n        return res;", "        if (n == 0) return 1;\n        if (n\
    \ % 2 == 0) {\n            var t = Modp(n / 2, p);\n            return t * t %\
    \ p;\n        }\n        else {\n            return Modp(n - 1, p) * n % p;\n\
    \        }", "        if (n == 0) return 1;\n        long t = Modp(n/2, p);\n\
    \        t = (t*t) % p;\n        if (n % 2 == 1) t = (t*2) % p;\n        return\
    \ t;", "        BigInteger result = BigInteger.ModPow(new BigInteger(2), new BigInteger(n),\
    \ new BigInteger(p));\n        return (long)result;", "        long pow = n;\n\
    \        long r = 1;\n        for (long i = 1; i <= n; i++) {\n            r =\
    \ (r * pow) % p;\n            pow = (pow * pow) % p;\n        }\n        return\
    \ r;", "        var m = p;\n        var r = 1L;\n        var e = n;\n        while\
    \ (e > 0) {\n            if ((e & 1) != 0) {\n                r = (r * m) % p;\n\
    \            }\n            e >>= 1;\n            m = (m * m) % p;\n        }\n\
    \        return r;", "        Debug.Assert(n >= 0);\n        Debug.Assert(p >=\
    \ 2);\n        if (n < p) return n;\n        return Modp(n / p, p) * 2 % p + n\
    \ % 2;", "        long result = 1;\n        while (n > 0) {\n            if ((n\
    \ & 1) != 0) {\n                result = result * p % M;\n            }\n    \
    \        p = p * p % M;\n            n = n >> 1;\n        }\n        return result;",
  "        long result = 1;\n        for (long i = 0; i < n; i++) {\n            result\
    \ = (result * 2) % p;\n        }\n        return result;", "        var a = BigInteger.ModPow(new\
    \ BigInteger(2), new BigInteger(n), new BigInteger(p));\n        return (long)a;",
  '        return BigInteger.ModPow(new BigInteger(2), new BigInteger(n), new BigInteger(p)).ToString().ToLong();',
  "        if (n == 0) return 1;\n        long ans = Modp(n / 2, p);\n        ans\
    \ = (ans * ans) % p;\n        if (n % 2 == 1) ans = (ans * 2) % p;\n        return\
    \ ans;", '        return BigInteger.ModPow(2, n, p).ToString().Length == 1 ? BigInteger.ModPow(2,
    n, p) : BigInteger.ModPow(2, n, p) - p;', "        long r = 1;\n        while\
    \ (n > 0) {\n            if ((n & 1) != 0) {\n                r = (r * n) % p;\n\
    \            }\n            n = n >> 1;\n            n = (n * n) % p;\n      \
    \  }\n        return r;", "        if (n == 0) {\n            return 1;\n    \
    \    }\n        else if (n % 2 == 0) {\n            long w = Modp(n / 2, p);\n\
    \            return (w * w) % p;\n        }\n        else {\n            return\
    \ ((n % p) * Modp(n - 1, p)) % p;\n        }", "        long k = 1;\n        while\
    \ (n > 0) {\n            if ((n & 1) == 1) {\n                k = (k * 2) % p;\n\
    \            }\n            n >>= 1;\n        }\n        return k;", "       \
    \ var prod = n;\n        var sum = 1L;\n        while (p > 0) {\n            if\
    \ ((p & 1) == 1) {\n                sum = (sum * prod) % mod;\n            }\n\
    \            prod = (prod * prod) % mod;\n            p >>= 1;\n        }\n  \
    \      return sum;", "        long r = 1L;\n        long t = 2L;\n        n %=\
    \ p;\n        while (n > 0L) {\n            if ((n & 1L) > 0L) {\n           \
    \     r = (r * t) % p;\n            }\n            t = (t * t) % p;\n        \
    \    n = n >> 1;\n        }\n        return r;", "        if (n < 0) return (p\
    \ - ((-n) % p)) % p;\n        else return n % p;", "        if (n < 0) {\n   \
    \         n = n % p + p;\n        }\n        return BigInteger.ModPow(new BigInteger(2),\
    \ new BigInteger(n), new BigInteger(p)).LongValue;", "        if (n % p < 0) n\
    \ = n % p + p;\n        else n = n % p;\n        long res = 1;\n        long val\
    \ = n;\n        long pr = p;\n        while (val > 0) {\n            if ((val\
    \ & 1) == 1) {\n                res = (res * val) % pr;\n            }\n     \
    \       val = val >> 1;\n            val = (val * val) % pr;\n        }\n    \
    \    return res;", "        // int result = 1;\n        // for (int i = 0; i <\
    \ n; i++) {\n        //     result = (result * 2) % p;\n        // }\n       \
    \ // return result;\n        return BigInteger.ModPow(2, n, p);", "        if\
    \ (n < 0) {\n            return Modp(n + p, p);\n        }\n        if (n < p)\
    \ {\n            return n;\n        }\n        if (n == p) {\n            return\
    \ 0;\n        }\n        // p <= n < 2*p\n        return n - p;", "        if\
    \ (n == 0) return 1;\n        long r = 1;\n        while (n > 0) {\n         \
    \   if ((n & 1) != 0) {\n                r = r * n % p;\n            }\n     \
    \       n >>= 1;\n            n = n * n % p;\n        }\n        return r;", " \
    \       long ans = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\
    \ {\n                ans = (ans * n) % p;\n            }\n            n >>= 1;\n\
    \            n = (n * n) % p;\n        }\n        return ans;", "        var result\
    \ = new BigInteger(1);\n        var a = new BigInteger(n);\n        var m = new\
    \ BigInteger(p);\n        var b = new BigInteger(2);\n        while (n > 0) {\n\
    \            if ((n & 1) == 1) {\n                result = (result * a) % m;\n\
    \            }\n            a = (a * a) % m;\n            n >>= 1;\n        }\n\
    \        return (long)result;", "        // We need the precision!\n        return\
    \ BigInteger.ModPow(new BigInteger(2), (int)n, (int)p).LongValue;", "        if\
    \ (n < 0)\n            return (p - ((-n) % p)) % p;\n        else\n          \
    \  return n % p;", "        if (n == 0) {\n            return 1;\n        } else\
    \ if (n % 2 == 0) {\n            long r = Modp(n / 2, p);\n            return\
    \ r * r % p;\n        } else {\n            return n * Modp(n - 1, p) % p;\n \
    \       }", "        if (n == 0) return 1;\n        else {\n            long x\
    \ = Modp(n / 2, p);\n            x = x * x % p;\n            if (n % 2 == 1) x\
    \ = x * 2 % p;\n            return x;\n        }", "        if (n < 0) {\n   \
    \         n = (n % p) + p;\n        }\n        if (n > p) {\n            n %=\
    \ p;\n        }\n        return n;", "        if (n < 0) {\n            return\
    \ p - Modp(-n, p);\n        }\n        if (n < p) {\n            return n;\n \
    \       }\n        if (n % p == 0) {\n            return 0;\n        }\n     \
    \   if (n % 2 == 0) {\n            long m = Modp(n / 2, p);\n            return\
    \ 2 * m >= p ? 2 * m - p : 2 * m;\n        }\n        long m1 = Modp(n / 2, p);\n\
    \        long m2 = Modp(n / 2 + 1, p);\n        return m1 + m2 >= p ? m1 + m2\
    \ - p : m1 + m2;", '        return n < 2 ? n : n % p;', "        if (n < 0) {\n\
    \            return (p - Modp(-n, p)) % p;\n        }\n        if (n == 0) {\n\
    \            return 1;\n        }\n        long t = Modp(n / 2, p);\n        t\
    \ = (t * t) % p;\n        if (n % 2 == 1) {\n            t = (t * 2) % p;\n  \
    \      }\n        return t;", '        return BigInteger.ModPow(2, n, p).ToInt64();',
  "        n %= p;\n        if (n < 0) {\n            n += p;\n        }\n       \
    \ return n;", "        long t = n % p;\n        return t < 0 ? t + p : t;", " \
    \       if (n == 0) return 1;\n        if (n % 2 == 0) {\n            long t =\
    \ Modp(n / 2, p);\n            return t * t % p;\n        }\n        return n\
    \ * Modp(n - 1, p) % p;", '        return (long)((BigInteger.ModPow(2, n, p *
    p) - 1) % p);', "        if (n <= 1) {\n            return n;\n        } else\
    \ {\n            long pp = p;\n            long temp = Modp(n/2, p);\n       \
    \     temp = (temp * temp) % pp;\n            if (n % 2 == 1) {\n            \
    \    temp = (temp * p) % pp;\n            }\n            return temp;\n      \
    \  }", "        Debug.Assert(n >= 0);\n        Debug.Assert(p >= 2);\n       \
    \ if (n == 0) return 1;\n        long result = 1;\n        long h = n / 2;\n \
    \       long l = n - h;\n        for (long i = 0; i < h; i++) result = (result\
    \ * 2) % p;\n        for (long i = 0; i < l; i++) result = (result * 2 + 1) %\
    \ p;\n        return result;", "        if (n == 0) return 1;\n        if (n ==\
    \ 1) return n;\n        long root = Modp(n / 2, p);\n        root = (root * root)\
    \ % p;\n        if (n % 2 == 1) root = (root * n) % p;\n        return root;",
  '        return BigInteger.ModPow(2, n, p).ToInt64();', '        return BigInteger.ModPow(2,
    n, p).ToInt64();', "        if (n == 0) return 1;\n        return (Modp(n / 2,\
    \ p) * Modp(n - n / 2, p)) % p;", "        var t = BigInteger.ModPow(2, n, p);\n\
    \        return (long)t;", "        long c = n % p;\n        return (c + p) %\
    \ p;", '        return BigInteger.ModPow(2, n, p).ToString().ToLong();', "   \
    \     if (n == 0) {\n            return 1;\n        }\n        var b = n % 2;\n\
    \        var a = (n - b) / 2;\n        long m = Modp(a, p);\n        long s =\
    \ (m * m) % p;\n        if (b == 1) {\n            s = (s * 2) % p;\n        }\n\
    \        return s;", "        long r = 1;\n        long i = 0;\n        long n_copy\
    \ = n;\n        n_copy = n_copy % p;\n        while (n > 0) {\n            if\
    \ ((n & 1) == 1) {\n                r = (r * n_copy) % p;\n            }\n   \
    \         n = n >> 1;\n            n_copy = (n_copy * n_copy) % p;\n        }\n\
    \        return r;", "        if (n == 0) {\n            return 1;\n        }\
    \ else if (n % 2 == 0) {\n            long half = Modp(n / 2, p);\n          \
    \  return (half * half) % p;\n        } else {\n            return ((n % p) *\
    \ Modp(n - 1, p)) % p;\n        }", "        long b = 1;\n        while (n > 0)\
    \ {\n            if ((n & 1) == 1) {\n                b = (b * n) % p;\n     \
    \       }\n            n >>= 1;\n            n = (n * n) % p;\n        }\n   \
    \     return b;", "        if (n <= 1) return n;\n        var r = Modp(n >> 1,\
    \ p);\n        r = (r * r) % p;\n        if ((n & 1) == 1) r = (r * n) % p;\n\
    \        return r;", "        long result = 1;\n        long baseI = n;\n    \
    \    long exponent = p;\n        while (exponent > 0) {\n            if ((exponent\
    \ & 1) == 1) {\n                result = (result * baseI) % p;\n            }\n\
    \            exponent >>= 1;\n            baseI = (baseI * baseI) % p;\n     \
    \   }\n        return result;", "        long z = 1;\n        long a = 2;\n  \
    \      for (long i = n; i > 0; i >>= 1) {\n            if ((i & 1) == 1) {\n \
    \               z = z * a % p;\n            }\n            a = a * a % p;\n  \
    \      }\n        return z;", "        if (n == 0) return 1;\n        var t =\
    \ Modp(n / 2, p);\n        if (n % 2 == 0) return t * t % p;\n        return t\
    \ * t % p * n % p;", "        if (n >= p) {\n            return n % p;\n     \
    \   }\n        else if (n < 0) {\n            return (((n % p) + p) % p);\n  \
    \      }\n        else {\n            return n;\n        }", "        var rem\
    \ = new List<BigInteger>();\n        while (n != 0) {\n            rem.Add(n %\
    \ 2);\n            n = n / 2;\n        }\n        var ans = 1L;\n        foreach\
    \ (var r in rem) {\n            ans = (ans * ans) % p;\n            if (r == 1)\
    \ {\n                ans = (ans * 2) % p;\n            }\n        }\n        return\
    \ ans;", "        long r = 1;\n        while (n > 0) {\n            if ((n & 1)\
    \ != 0)\n                r = (r * n) % p;\n            n >>= 1;\n            n\
    \ %= p;\n        }\n        return r;", "        BigInteger a = BigInteger.ModPow(2,\
    \ n, p);\n        if (a < 0) {\n            a += p;\n        }\n        return\
    \ (long)a;", "        // Complexity: O(log n)\n        // We use the property\
    \ that if p is prime:\n        // x^(p-1) = 1 (mod p)\n        // 2^n * 2^(p-1)\
    \ = 2^(n + p - 1)\n        // 2^(n + p - 1) = 1 (mod p)\n        // 2^n = 2^(n\
    \ + p - 1) * 2^-1 = 2^(n + p - 1) (mod p)\n        // Therefore:\n        // 2^n\
    \ = 2^(n mod (p-1)) (mod p)\n        // We only need to compute 2^(n mod (p-1))\n\
    \        // which is done with the help of a binary\n        // exponentiation\
    \ algorithm.\n        if (n >= p) {\n            return Modp(n % (p - 1), p);\n\
    \        }\n        long result = 1;\n        long factor = 2;\n        while\
    \ (n > 0) {\n            if (n % 2 == 1) {\n                result = (result *\
    \ factor) % p;\n            }\n            factor = (factor * factor) % p;\n \
    \           n /= 2;\n        }\n        return result;", "        // Treat n as\
    \ a BigInteger.\n        n = n % p;\n        var a = BigInteger.ModPow(2, n, p);\n\
    \        return (long)a;", "        if (n < 0)\n            return ((n % p) +\
    \ p) % p;\n        else\n            return n % p;", '        return (n % p +
    p) % p;', "        if (n == 0) return 1;\n        long sq = Modp(n / 2, p);\n\
    \        if (n % 2 == 0) return sq * sq % p;\n        else return sq * sq % p\
    \ * n % p;", "        long res = 1;\n        while (n > 0) {\n            if ((n\
    \ & 1) != 0) {\n                res = (res * n) % p;\n            }\n        \
    \    n = n >> 1;\n            n = (n * n) % p;\n        }\n        return res;",
  "        var result = BigInteger.ModPow(2, (int)n, (int)p);\n        return (long)result;",
  "        if (n == 0) return 1;\n        else if (n % 2 == 0) {\n            long\
    \ sqrt = Modp(n / 2, p);\n            return sqrt * sqrt % p;\n        } else\
    \ {\n            return n * Modp(n - 1, p) % p;\n        }", "        if (n >=\
    \ p) {\n            return n % p;\n        }\n        return n;", "        var\
    \ b = BigInteger.Pow(2, n);\n        return (b % p).ToInt64();", "        if (n\
    \ < 0) {\n            return (n % p + p) % p;\n        }\n        return n % p;",
  '        return BigInteger.ModPow(2, n, p).ToInt64();', "        long res = 1;\n\
    \        for (int i = 0; i < n; i++) {\n            res = (res * 2) % p;\n   \
    \     }\n        return res;", "        if (n == 0) return 1;\n        if (n ==\
    \ 1) return n;\n        if (n % 2 == 0) {\n            long r = Modp(n / 2, p);\n\
    \            return (r * r) % p;\n        }\n        long r2 = Modp(n - 1, p);\n\
    \        return (r2 * n) % p;", "        // Implement this function from scratch.\n\
    \        long result = 1;\n        long factor = 2;\n        while (n > 0) {\n\
    \            if (n % 2 == 1) {\n                result = (result * factor) % p;\n\
    \            }\n            factor = (factor * factor) % p;\n            n = n\
    \ / 2;\n        }\n        return result;", "        Debug.Assert(n >= 0);\n \
    \       Debug.Assert(p >= 2);\n        if (n >= p) return n % p;\n        if (n\
    \ == 0) return 1;\n        if (n == 1) return n;\n        long result = 1;\n \
    \       long k = n;\n        while (k > 0) {\n            if ((k & 1) == 1) result\
    \ = (result * n) % p;\n            k >>= 1;\n            n = (n * n) % p;\n  \
    \      }\n        return result;", "        if (n == 0) return 1;\n        if\
    \ (n % 2 == 0) {\n            long b = Modp(n / 2, p);\n            return (b\
    \ * b) % p;\n        } else {\n            return ((Modp(n - 1, p) * n) % p);\n\
    \        }", "        long r = n % p;\n        return (r + p) % p;", '        return
    BigInteger.ModPow(new BigInteger(2), new BigInteger(n), new BigInteger(p)).ToInt64();',
  "        if (n < p && n >= 0) return n;\n        if (n < 0) return Modp(n + p, p);\n\
    \        return (Modp(n >> 1, p) * Modp(2, p) + n % 2) % p;", "        long res\
    \ = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n             \
    \   res = (res * n) % p;\n            n = n >> 1;\n            n = (n * n) % p;\n\
    \        }\n        return res;", "        if (n == 0) return 1;\n        long\
    \ half = Modp(n >> 1, p);\n        long full = half * half % p;\n        if (n\
    \ % 2 == 1) full = full * 2 % p;\n        return full;", "        var pow = (long)Math.Pow(2,\
    \ n);\n        return (pow % p);", "        long result = 1;\n        while (n\
    \ > 0) {\n            if ((n & 1) == 1) {\n                result = (result *\
    \ n) % p;\n            }\n            n = n >> 1;\n            n = (n * n) % p;\n\
    \        }\n        return result;", "        long r = n % p;\n        if (r <\
    \ 0) {\n            r += p;\n        }\n        return r;", "        long res\
    \ = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n           \
    \     res = res * n % p;\n            }\n            n = n >> 1;\n           \
    \ n = n * n % p;\n        }\n        return res;", "        if (n == 0) {\n  \
    \          return 1;\n        }\n        else if (n == 1) {\n            return\
    \ n;\n        }\n        else if (n % 2 == 0) {\n            long x = Modp(n /\
    \ 2, p);\n            return (x * x) % p;\n        }\n        else {\n       \
    \     return (n * Modp(n - 1, p)) % p;\n        }", '        return BigInteger.ModPow(2,
    n, p).ToInt64();', "        if (n < 0) {\n            n = n % p + p;\n       \
    \ }\n        long x = 1;\n        for (int k = 0; k < n; k++) {\n            x\
    \ = (x * 2) % p;\n        }\n        return x;", "        if (n < 0) return Modp(n\
    \ + p, p);\n        if (n < p) return n;\n        if (n == p) return 0;\n    \
    \    if (n % 2 == 0) return Modp(n / 2, p) * 2 % p;\n        return Modp(n / 2,\
    \ p) * 2 % p + 1;", "        // Assume n>=0 and p>=2.\n        long retval;\n\
    \        if (n < p) {\n            retval = n;\n        } else {\n           \
    \ retval = Modp(n/p, p) * 10 + n % p;\n            retval %= p;\n        }\n \
    \       return retval;", "        if (n >= p) n %= p;\n        if (n < 0) n +=\
    \ p;\n        return n;", '        return BigInteger.ModPow(2, n, p).ToString().Length
    <= p.ToString().Length ? (long)BigInteger.ModPow(2, n, p) : 0;', "        if (n\
    \ < 0) return Modp(-n, p);\n        if (n == 0) return 1;\n        if (n == 1)\
    \ return n;\n        if (n % 2 == 0) return (Modp(n / 2, p) * Modp(n / 2, p))\
    \ % p;\n        return (Modp(n / 2, p) * Modp(n / 2, p) * n) % p;", "        if\
    \ (n < 0)\n            return ((-n/p + 1)*p + n) % p;\n        else\n        \
    \    return n % p;", "        long y = n;\n        long x = 1;\n        while\
    \ (y > 0) {\n            long r = y % 2;\n            if (r > 0) {\n         \
    \       x = (x * n) % p;\n            }\n            n = (n * n) % p;\n      \
    \      y = y / 2;\n        }\n        return x;", "        if (n == 0) {\n   \
    \         return 1;\n        }\n        if (n == 1) {\n            return n;\n\
    \        }\n        var u = Modp(n >> 1, p);\n        u = (u * u) % p;\n     \
    \   if ((n & 1) == 1) {\n            u = (u * n) % p;\n        }\n        return\
    \ u;", "        if (n <= 0) return 1;\n        long res = 1;\n        while (n\
    \ > 0) {\n            if ((n & 1) == 1) res = (res * n) % p;\n            n >>=\
    \ 1;\n        }\n        return res;", "        if (n == 0) return 1;\n      \
    \  if (n == 1) return n;\n        long r = n % p;\n        if (r == 0) return\
    \ 0;\n        if (r == 1) return 1;\n        // A^B mod C = (A mod C)^B mod C\n\
    \        if (n < 1000000000) {\n            return r * r % p;\n        }\n   \
    \     return r * Modp(r, p) % p;", "        if (n == 0) return 1;\n        if\
    \ (n % 2 == 0) return Modp(n/2, p) * Modp(n/2, p) % p;\n        else return Modp(n/2,\
    \ p) * Modp(n/2, p) * n % p;", "        long result = 1;\n        for (; n > 0;\
    \ n >>= 1) {\n            if ((n & 1) == 1) {\n                result = (result\
    \ * n) % p;\n            }\n        }\n        return result;", "        if (n\
    \ == 0) {\n            return 1;\n        }\n        if (n % 2 == 0) {\n     \
    \       return squareModp(Modp(n / 2, p), p);\n        }\n        return (Modp(n\
    \ - 1, p) * n) % p;", "        long ans = 1;\n        for (int i = 0; i < n; i++)\n\
    \            ans = (ans * 2) % p;\n        return ans;", "        if (n == 0)\
    \ return 1;\n        BigInteger res = 1;\n        BigInteger x = n;\n        BigInteger\
    \ pb = p;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n        \
    \        res = (res * x) % pb;\n            }\n            x = (x * x) % pb;\n\
    \            n >>= 1;\n        }\n        return (long)res;", "        if (n ==\
    \ 0) {\n            return 1;\n        }\n        // if (n == 1) { return 1; }\n\
    \        long k = n >> 1;\n        long even = Modp(k, p);\n        long r = (even\
    \ * even) % p;\n        if ((n & 1) == 1) {\n            r = (r * n) % p;\n  \
    \      }\n        return r;", "        if (n < p) return n;\n        return Modp(n\
    \ / 2, p) * 2 % p + n % 2;", '        return BigInteger.ModPow(2, n, p).ToString().To<long>();',
  "        var res = 1L;\n        while (n > 0) {\n            if ((n & 1) != 0)\n\
    \                res = (res * n) % p;\n            n = n >> 1;\n            n\
    \ = (n * n) % p;\n        }\n        return res;", "        long b = 1;\n    \
    \    while (n > 0) {\n            if ((n & 1) == 1) {\n                b = (b\
    \ * n) % p;\n            }\n            n >>= 1;\n            if (n > 0) {\n \
    \               n = (n * n) % p;\n            }\n        }\n        return b;",
  "        long res = 1;\n        for (long i = 0; i < n; i++) {\n            res\
    \ = (res * 2) % p;\n        }\n        return res;", "        if (n < 0) {\n \
    \           return p - Modp(-n, p);\n        }\n        if (n < 100) {\n     \
    \       return BigInteger.ModPow(2, n, p).ToInt64();\n        }\n        if (n\
    \ % 2 == 0) {\n            return (Modp(n / 2, p) * Modp(n / 2, p)) % p;\n   \
    \     }\n        return (Modp(n / 2, p) * Modp(n / 2, p) * 2) % p;", "       \
    \ if (n == 0) {\n            return 1;\n        } else if (n % 2 == 0) {\n   \
    \         long x = Modp(n / 2, p);\n            return (x * x) % p;\n        }\
    \ else {\n            return (n * Modp(n - 1, p)) % p;\n        }", "        if\
    \ (n < p) return n;\n        long ret = 1;\n        long mod = p;\n        long\
    \ mul = n;\n        while (mul > 0) {\n            if ((mul & 1) == 1) ret = (ret\
    \ * mod) % p;\n            mod = (mod * mod) % p;\n            mul = mul >> 1;\n\
    \        }\n        return ret;", "        long result = 1;\n        for (int\
    \ i = 0; i < n; i++)\n            result = (result * 2) % p;\n        return result;",
  "        long r = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
    \                r = (r * n) % p;\n            }\n            n >>= 1;\n     \
    \       if (n > 0) {\n                n = (n * n) % p;\n            }\n      \
    \  }\n        return r;", '        return (new BigInteger(n) % new BigInteger(p)).ToByteArray().ToInt64();',
  "        if (n == 0) return 1;\n        if (n % 2 == 0) return Modp(n/2, p) * Modp(n/2,\
    \ p) % p;\n        else return n * Modp(n-1, p) % p;", "        if (n == 0) {\n\
    \            return 1;\n        } else if (n == 1) {\n            return n;\n\
    \        } else if (n % 2 == 0) {\n            return Modp(n / 2, p) * Modp(n\
    \ / 2, p) % p;\n        } else {\n            return n * Modp(n - 1, p) % p;\n\
    \        }", "        var bits = new List<long>();\n        var tmp = n;\n   \
    \     while (tmp > 0) {\n            bits.Add(tmp & 1);\n            tmp >>= 1;\n\
    \        }\n        var value = 1L;\n        for (var i = bits.Count - 1; i >=\
    \ 0; i--) {\n            value = (value * value) % p;\n            if (bits[i]\
    \ > 0) {\n                value = (value * n) % p;\n            }\n        }\n\
    \        return value;", "        if (n == 0) {\n            return 1;\n     \
    \   } else if (n == 1) {\n            return n;\n        } else if (n % 2 == 0)\
    \ {\n            return Modp(n/2, p) * Modp(n/2, p) % p;\n        } else {\n \
    \           return Modp(n/2, p) * Modp(n/2, p) * n % p;\n        }", "       \
    \ long t = 1;\n        while (n > 0) {\n            if ((n & 1) == 1)\n      \
    \          t = (t * t) % p;\n            t = (t * t) % p;\n            n >>= 1;\n\
    \        }\n        return t;", "        if (n < 0) return Modp(-n, p);\n    \
    \    if (n < p) return n;\n        return Modp(n >> 1, p) << 1 % p + Modp(n &\
    \ 1, p);", "        Debug.Assert(n >= 0);\n        Debug.Assert(p >= 2);\n   \
    \     if (n < p) return n;\n        long x = 1;\n        for (int i = 0; i < 50;\
    \ i++) {\n            x = (x * 2) % p;\n        }\n        return (n - p) * x\
    \ + n;", "        Debug.Assert(p >= 1);\n        Debug.Assert(n >= 0);\n     \
    \   if (n == 0) return 1;\n        if (n == 1) return n % p;\n        long res\
    \ = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n           \
    \     res = (res * n) % p;\n            }\n            n = n >> 1;\n         \
    \   n = (n * n) % p;\n        }\n        return res;", "        if (n == 0) {\n\
    \            return 1;\n        }\n        if (n % 2 == 0) {\n            long\
    \ x = Modp(n / 2, p);\n            return (x * x) % p;\n        }\n        return\
    \ (Modp(n - 1, p) * n) % p;", "        var ret = (n % p);\n        if (ret < 0)\
    \ ret += p;\n        return ret;", "        if (n == 0) {\n            return\
    \ 1;\n        }\n        if (n % 2 == 0) {\n            var half = Modp(n / 2,\
    \ p);\n            return (half * half) % p;\n        }\n        return (n * Modp(n\
    \ - 1, p)) % p;", "        // Frequently it is actually better to use the built-in\
    \ % operator\n        // instead.\n        // >>> -2 % 7\n        // 5\n     \
    \   // >>> pow(2, -2, 7)\n        // 5\n        if (n == 0) {\n            return\
    \ 1;\n        }\n        if (n < 0) {\n            return Modp(-n, p);\n     \
    \   }\n        if (n % 2 == 0) {\n            long t = Modp(n / 2, p);\n     \
    \       return (t * t) % p;\n        }\n        return (Modp(n - 1, p) * n) %\
    \ p;", "        long p2 = p;\n        long res = 1;\n        while (n > 0) {\n\
    \            if ((n & 1) == 1) {\n                res = res * p2 % p;\n      \
    \      }\n            p2 = p2 * p2 % p;\n            n >>= 1;\n        }\n   \
    \     return res;", "        BigInteger res = BigInteger.ModPow(2, n, p);\n  \
    \      return (long)res;", "        if (n == 0) return 1;\n        long ans =\
    \ 1;\n        for (int i = 0; i < n; i++)\n            ans = (ans * 2) % p;\n\
    \        return ans;", "        if (n < 0) {\n            n += p * ((-n / p) +\
    \ 1);\n        }\n        return n % p;", "        long r = 1;\n        while\
    \ (n > 0) {\n            if ((n & 1) != 0) {\n                r = (r * n) % p;\n\
    \            }\n            n >>= 1;\n            n %= p;\n        }\n       \
    \ return r;", "        if (n < p) return n;\n        long h = n / p;\n       \
    \ long r = n - h * p;\n        long x = Modp(h, p);\n        long y = Modp(x +\
    \ r, p);\n        return y;", "        long r = 1;\n        long b = n;\n    \
    \    while (p > 0) {\n            if ((p & 1) != 0) {\n                r = (r\
    \ * b) % Modulus;\n            }\n            p >>= 1;\n            b = (b * b)\
    \ % Modulus;\n        }\n        return r;", "        long result = 1;\n     \
    \   while (n > 0) {\n            if ((n & 1) == 1) {\n                result =\
    \ (result * n) % p;\n            }\n            n = n >> 1;\n            n = (n\
    \ * n) % p;\n        }\n        return result;", "        long r = n % p;\n  \
    \      if (n > 0) {\n            return r;\n        } else {\n            return\
    \ p + r;\n        }", "        if (n == 0) {\n            return 1;\n        }\n\
    \        long k = n / 2;\n        long b = Modp(k, p);\n        long res = b *\
    \ b % p;\n        if (n % 2 == 1) {\n            res = res * n % p;\n        }\n\
    \        return res;", "        if (n < 0)\n            return Modp(n % p + p,\
    \ p);\n        if (n == 0)\n            return 1;\n        else if (n == 1)\n\
    \            return 0;\n        else if (n % 2 == 0)\n            return Modp(n\
    \ / 2, p) * (1 + (long)Math.Pow(2, n / 2)) % p;\n        else\n            return\
    \ Modp(n - 1, p) * 2 % p;", "        long modp = 0;\n        for (int i = 0; i\
    \ < n; i++) {\n            modp += p;\n            modp %= p;\n        }\n   \
    \     return modp;", "        if (n == 0) {\n            return 1;\n        }\n\
    \        if (n == 1) {\n            return 0;\n        }\n        if (n % 2 ==\
    \ 0) {\n            return Modp(n / 2, p) * (1 + p) % p;\n        }\n        else\
    \ {\n            return (Modp(n / 2, p) * (1 + p) + p) % p;\n        }", "   \
    \     // * modp(n, p)\n        // * \n        // * Returns 2^n modulo p.\n   \
    \     // * 1 < p < 2^63.\n        // *\n        // * This algorithm is from:\n\
    \        // *     https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method\n\
    \        // * \n        // * This method works especially well when the exponent\n\
    \        // * has few non-zero bits.\n        // * That is because the binary\
    \ right-to-left method\n        // * has the property that the number of multiplications\
    \ is reduced.\n        // * \n        // * n must be an integer, but p may be\
    \ of any type.\n        long res = 1;\n        while (n > 0) {\n            long\
    \ bit = n & 1;\n            if (bit == 1) {\n                res = (res * 2) %\
    \ p;\n            }\n            n >>= 1;\n            if (n > 0) {\n        \
    \        res = (res * res) % p;\n            }\n        }\n        return res;",
  "        Debug.Assert(n >= 0);\n        Debug.Assert(p >= 2);\n        if (n ==\
    \ 0) return 1;\n        if (n == 1) return n;\n        if (n == 2) return (n %\
    \ p);\n        long r = Modp(n / 2, p);\n        r = (r * r) % p;\n        if\
    \ (n % 2 == 1) r = (r * 2) % p;\n        return r;", "        Debug.Assert(n >=\
    \ 0);\n        Debug.Assert(p >= 2);\n        long r = n % p;\n        if (r <\
    \ 0) {\n            r += p;\n        }\n        return r;", "        if (n ==\
    \ 0) {\n            return 1L;\n        }\n        long[] facts = new long[64];\n\
    \        int i = 0;\n        long f = p - 1;\n        for (; f > 0; f >>= 1) {\n\
    \            facts[i++] = f;\n        }\n        long result = n;\n        for\
    \ (int j = i - 1; j >= 0; j--) {\n            result = result * result % p;\n\
    \            if ((facts[j] & 1) == 1) {\n                result = result * n %\
    \ p;\n            }\n        }\n        return result;", "        BigInteger result\
    \ = BigInteger.ModPow(new BigInteger(2), new BigInteger(n), new BigInteger(p));\n\
    \        return (long)result;", "        long res = 1;\n        while (n > 0)\
    \ {\n            if ((n & 1) == 1)\n                res = (res * n) % p;\n   \
    \         n = n >> 1;\n            n = (n * n) % p;\n        }\n        return\
    \ res;", "        //assert p >= 2\n        var result = 1L;\n        for (var\
    \ i = 0; i < n; i++) {\n            result = (result * 2) % p;\n        }\n  \
    \      return result;", "        long res = 1;\n        while (n > 0) {\n    \
    \        if ((n & 1) != 0)\n                res = (res * 2) % p;\n           \
    \ n = n >> 1;\n        }\n        return res;", "        long res = 1;\n     \
    \   while (n > 0) {\n            if ((n & 1) == 1) {\n                res = (res\
    \ * n) % p;\n            }\n            n = n >> 1;\n            n = (n * n) %\
    \ p;\n        }\n        return res;", "        if (n < 0) { return p - Modp(-n,\
    \ p); }\n        if (n == 0) { return 1; }\n        if (n == 1) { return n; }\n\
    \        if (n % 2 == 0) { return Modp(n / 2, p) * Modp(n / 2, p) % p; }\n   \
    \     return Modp(n / 2, p) * Modp(n / 2, p) * Modp(1, p) % p;", "        Debug.Assert(p\
    \ > 0L);\n        if (n < 0L) {\n            n = (n % p) + p;\n        }\n   \
    \     return n % p;"]
stop_tokens:
- "\n    }\n"
