name: HumanEval_47_median
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return median of elements in the list l.\n    // >>> Median((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L})))\n \
  \   // (float)3L\n    // >>> Median((new List<long>(new long[]{(long)-10L, (long)4L,\
  \ (long)6L, (long)1000L, (long)10L, (long)20L})))\n    // (15.0f)\n    public static\
  \ float Median(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)3L, (long)1L, (long)2L, (long)4L, (long)5L}))) ==\
  \ (float)3L);\n    Debug.Assert(Median((new List<long>(new long[]{(long)-10L, (long)4L,\
  \ (long)6L, (long)1000L, (long)10L, (long)20L}))) == (8.0f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)5L}))) == (float)5L);\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)6L, (long)5L}))) == (5.5f));\n    Debug.Assert(Median((new\
  \ List<long>(new long[]{(long)8L, (long)1L, (long)3L, (long)9L, (long)9L, (long)2L,\
  \ (long)7L}))) == (float)7L);\n    }\n\n}\n"
completions: ["        var s = l.Select(x => (float)x).ToList();\n        s.Sort();\n\
    \        int n = s.Count;\n        if (n == 0) {\n            return 0.0f;\n \
    \       } else if (n % 2 == 1) {\n            return s[n / 2];\n        } else\
    \ {\n            return (s[n / 2 - 1] + s[n / 2]) / 2.0f;\n        }", "     \
    \   if (l.Count == 0) {\n            return 0;\n        }\n        l.Sort();\n\
    \        if (l.Count % 2 == 1) {\n            return l[l.Count / 2];\n       \
    \ }\n        else {\n            return (l[l.Count / 2 - 1] + l[l.Count / 2])\
    \ / 2;\n        }", "        if (l.Count == 0) {\n            return 0.0f;\n \
    \       }\n        List<long> s = l.OrderBy((long x) => x).ToList();\n       \
    \ int m = l.Count / 2;\n        if (l.Count % 2 == 0) {\n            return (float)(s[m\
    \ - 1] + s[m]) / 2;\n        }\n        else {\n            return (float)s[m];\n\
    \        }", "        l.Sort();\n        return l[l.Count/2];", "        long\
    \ sz = (long)l.Count;\n        long mid = sz / (long)2L;\n        if (sz % (long)2L\
    \ == (long)0L) {\n            return (float)((double)(l[(int)(mid - (long)1L)]\
    \ + l[(int)mid]) / (double)2L);\n        }\n\n        return (float)l[(int)mid];\n",
  "        int n = l.Count;\n        int mid = n / 2;\n        // mid is a float here,\
    \ not an int.\n        if (n % 2 == 1) {\n            return (float)l[mid];\n\
    \        } else {\n            return (float)((float)l[mid - 1] + (float)l[mid])\
    \ / 2f;\n        }", "        if (l.Count == 0) {\n            return 0.0f;\n\
    \        }\n        else {\n            List<long> t = new List<long>(l);\n  \
    \          t.Sort();\n            if (t.Count % 2 == 1) {\n                return\
    \ t[t.Count / 2];\n            }\n            else {\n                return (t[t.Count\
    \ / 2 - 1] + t[t.Count / 2]) / 2.0f;\n            }\n        }", "        List<long>\
    \ tmp = new List<long>(l);\n        tmp.Sort();\n        int idx = tmp.Count /\
    \ 2;\n        if (tmp.Count % 2 == 0) {\n            return (float)((long)(tmp[idx\
    \ - 1] + tmp[idx]) / (long)2L);\n        }\n        else {\n            return\
    \ (float)tmp[idx];\n        }", '        return l.Median();', "        l.Sort();\n\
    \        var i = l.Count / 2;\n        if (l.Count % 2 == 0) {\n            return\
    \ (float)((l[i - 1] + l[i]) / 2);\n        } else {\n            return (float)l[i];\n\
    \        }", "        // Write your code here\n        float result = 0.0f;\n\
    \        float temp = 0.0f;\n        float half = l.Count;\n        if(half %\
    \ 2 == 0){\n            for(int x = 0; x < l.Count; x++){\n                for(int\
    \ y = 0; y < l.Count - 1; y++){\n                    if(l[y] > l[y + 1]){\n  \
    \                      temp = l[y];\n                        l[y] = l[y + 1];\n\
    \                        l[y + 1] = temp;\n                    }\n           \
    \     }\n            }\n            result = ((float)l[(int)(half / 2)] + (float)l[(int)(half\
    \ / 2) - 1]) / 2;\n        }\n        else{\n            for(int x = 0; x < l.Count;\
    \ x++){\n                for(int y = 0; y < l.Count - 1; y++){\n             \
    \       if(l[y] > l[y + 1]){\n                        temp = l[y];\n         \
    \               l[y] = l[y + 1];\n                        l[y + 1] = temp;\n \
    \                   }\n                }\n            }\n            result =\
    \ (float)l[(int)(half / 2)];\n        }\n        return result;", "        l.Sort();\n\
    \        int n = l.Count;\n        if (n == 0) {\n            return (0);\n  \
    \      }\n        if (n % 2 == 1) {\n            return (l[n / 2]);\n        }\n\
    \        else {\n            return ((l[n / 2 - 1] + l[n / 2]) / 2f);\n      \
    \  }", "        long n = (long)l.Count;\n        if (n == 0L) {\n            return\
    \ 0.0f;\n        }\n\n        List<long> sort = new List<long>(l);\n        sort.Sort();\n\
    \        if (n % 2L == 1L) {\n            return sort[n / 2L];\n        }\n\n\
    \        return (sort[n / 2L - 1L] + sort[n / 2L]) / 2.0f;\n", "        long count\
    \ = (long)l.Count;\n        long median = count / (long)2L;\n        l.Sort();\n\
    \        if (count % (long)2L == (long)0L) {\n            return (float)((l[(int)median]\
    \ + l[(int)(median - (long)1L)]) / (long)2L);\n        }\n        else {\n   \
    \         return (float)l[(int)median];\n        }", "        l.Sort();\n    \
    \    int m = l.Count / 2;\n        if (l.Count % 2 == 0) {\n            return\
    \ (float)(l[m - 1] + l[m]) / 2f;\n        }\n        else {\n            return\
    \ (float)l[m];\n        }", "        int i = l.Count / 2;\n        if (l.Count\
    \ % 2 == 0) {\n            // Handle even number of elements.\n            float\
    \ median = (l[i] + l[i - 1]) / 2.0f;\n            return median;\n        } else\
    \ {\n            // Handle odd number of elements.\n            return l[i];\n\
    \        }", "        l.Sort();\n        if (l.Count == 0) {\n            return\
    \ 0;\n        }\n        int left = 0;\n        int right = l.Count - 1;\n   \
    \     int length = right - left + 1;\n        int median = left + length / 2;\n\
    \        if (length % 2 == 1) {\n            return l[median];\n        }\n  \
    \      else {\n            return (l[median - 1] + l[median]) / 2.0f;\n      \
    \  }", "        long len = l.Count;\n        long sum = (long)0L;\n        foreach\
    \ (long elem in l) {\n            sum += elem;\n        }\n        float mean\
    \ = (float)sum / (float)len;\n        long ssum = (long)0L;\n        foreach (long\
    \ elem in l) {\n            long tmp = elem - (long)mean;\n            ssum +=\
    \ tmp * tmp;\n        }\n        float variance = (float)ssum / (float)len;\n\
    \        float sigma = (float)Math.Sqrt((double)variance);\n        float sigmam\
    \ = sigma / (float)Math.Sqrt((double)len);\n        return sigmam;", "       \
    \ l.Sort();\n        if ((l.Count % 2L) == 1L) {\n            return (float)l[(l.Count\
    \ / 2L)];\n        }\n\n        return ((float)l[(l.Count / 2L) - 1L] + (float)l[(l.Count\
    \ / 2L)]) / 2f;\n", "        long count = (long)l.Count;\n        if (count ==\
    \ (long)0L) {\n            return (float)0L;\n        }\n\n        l.Sort();\n\
    \        if (count % (long)2L == (long)0L) {\n            return ((float)l[(int)((count\
    \ / (long)2L) - (long)1L)] + (float)l[(int)(count / (long)2L)]) / (float)2L;\n\
    \        }\n\n        return (float)l[(int)(count / (long)2L)];\n", "        l.Sort();\n\
    \        return (float)((l[(l.Count) / 2] + l[(l.Count - 1) / 2]) / 2);", "  \
    \      l.Sort();\n        if (l.Count % 2 == 1) {\n            return (float)l[l.Count\
    \ / 2];\n        } else {\n            return (float)(l[l.Count / 2 - 1] + l[l.Count\
    \ / 2]) / 2;\n        }", "        l.Sort();\n        int sz = l.Count;\n    \
    \    if (sz % 2 == 1) {\n            return (float)l[sz / 2];\n        }\n   \
    \     else {\n            return (float)(l[sz / 2 - 1] + l[sz / 2]) / 2f;\n  \
    \      }", "        // Sort list.\n        l.Sort();\n        // Return median.\n\
    \        if (l.Count % 2 == 0) {\n            // Even number of elements.\n  \
    \          long a = l[l.Count / 2 - 1];\n            long b = l[l.Count / 2];\n\
    \            return (a + b) / 2f;\n        } else {\n            // Odd number\
    \ of elements.\n            return l[l.Count / 2];\n        }", "        l.Sort();\n\
    \        return l[l.Count / 2];", "        int len = l.Count;\n        l.Sort();\n\
    \        if (len % 2 == 1) {\n            return (float)l[len / 2];\n        }\
    \ else {\n            return (float)((l[len / 2 - 1] + l[len / 2]) / 2.0);\n \
    \       }", "        l.Sort();\n        long len = (long)l.Count;\n        if\
    \ (len % 2L == 1L) {\n            return (float)l[len / 2L];\n        }\n\n  \
    \      return ((float)l[len / 2L - 1L] + (float)l[len / 2L]) / 2f;\n", "     \
    \   int c = l.Count;\n        int half = c / 2;\n        l.Sort();\n        if\
    \ (c % 2 == 0) {\n            return (float)((l[half - 1] + l[half]) / 2);\n \
    \       } else {\n            return (float)l[half];\n        }", "        if\
    \ ((l.Count % 2L) == 0L) {\n            float x = (float)l[(l.Count / 2L) - 1L];\n\
    \            float y = (float)l[(l.Count / 2L)];\n            return (x + y) /\
    \ 2f;\n        }\n        else {\n            return (float)l[(l.Count / 2L)];\n\
    \        }", "        l.Sort();\n        return (float)((l[l.Count / 2 - 1] +\
    \ l[l.Count / 2]) / 2);", "        if (l.Count == 0) {\n            return 0.0f;\n\
    \        }\n        if (l.Count == 1) {\n            return (float)l[0];\n   \
    \     }\n        if (l.Count == 2) {\n            return (float)(l[0] + l[1])\
    \ / 2.0f;\n        }\n        l.Sort();\n        if (l.Count % 2 == 1) {\n   \
    \         return (float)l[l.Count / 2];\n        }\n        else {\n         \
    \   return (float)(l[l.Count / 2 - 1] + l[l.Count / 2]) / 2.0f;\n        }", " \
    \       l.Sort();\n        int len = l.Count;\n        if (len % 2 == 1) {\n \
    \           return (float)l[len / 2];\n        }\n        else {\n           \
    \ return (float)(l[len / 2 - 1] + l[len / 2]) / 2;\n        }", "        l.Sort();\n\
    \        long x = 0L;\n        long y = 0L;\n        for (long i = 0L; i < l.Count;\
    \ i++) {\n            if (i % 2L == 0L) {\n                x = l[(int)i];\n  \
    \          }\n            else {\n                y = l[(int)i];\n           \
    \ }\n\n        }\n\n        if (l.Count % 2L == 0L) {\n            return (float)((x\
    \ + y) / 2L);\n        }\n\n        return (float)x;\n", "        int index =\
    \ l.Count / 2;\n        if (l.Count % 2 == 0) {\n            return (float)((l[index]\
    \ + l[index - 1]) / 2.0f);\n        } else {\n            return (float)l[index];\n\
    \        }", "        //median of even and odd numbers\n        l.Sort();\n  \
    \      if (((l.Count) % (2L)) == (0L)) {\n            return ((((float)(l[(((l.Count)\
    \ / (2L)) - (1L))])) + ((float)(l[((l.Count) / (2L))]))) / (2.0f));\n        }\n\
    \        else {\n            return ((float)(l[((l.Count) / (2L))]));\n      \
    \  }\n", "        int n = l.Count;\n        if (n == 0) {\n            return\
    \ 0;\n        }\n        l.Sort();\n        if (n % 2 == 1) {\n            return\
    \ l[n / 2];\n        }\n        else {\n            return (l[n / 2 - 1] + l[n\
    \ / 2]) / 2.0f;\n        }", "        int i = l.Count / 2;\n        int j = l.Count\
    \ / 2;\n        if (l.Count % 2 == 0) {\n            i--;\n        }\n       \
    \ l.Sort();\n        return (float)((l[i] + l[j]) / 2.0);", "        l.Sort();\n\
    \        int n = l.Count;\n        if (n % 2 == 1) {\n            return (float)l[n\
    \ / 2];\n        }\n        else {\n            return (float)(l[n / 2 - 1] +\
    \ l[n / 2]) / 2;\n        }", "        l.Sort();\n        int n = l.Count;\n \
    \       if (n % 2 == 1) {\n            return (float)l[n / 2];\n        }\n  \
    \      else {\n            return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n    \
    \    }", "        l.Sort();\n        if (l.Count % 2 == 1) {\n            return\
    \ (float)l[l.Count / 2];\n        } else {\n            return (float)((l[l.Count\
    \ / 2] + l[l.Count / 2 - 1]) / 2);\n        }", "        l.Sort();\n        return\
    \ ((float)(l[(int)((long)(l.Count) / (long)2L)]) + (float)(l[(int)((long)(l.Count)\
    \ / (long)2L - (long)1L)]) / (float)2L);", "        l.Sort();\n        long __a\
    \ = (long)l.Count;\n        if ((__a & (long)1L) == (long)0L) {\n            return\
    \ (float)(((long)l[__a / (long)2L - (long)1L] + (long)l[__a / (long)2L]) / (long)2L);\n\
    \        }\n\n        return (float)l[__a / (long)2L];\n", "        l.Sort();\n\
    \        long h = (long)l.Count();\n        long m = h / 2L;\n        if (h %\
    \ 2L == 0L) {\n            return (float)((l[(int)m] + l[(int)(m - 1L)]) / 2L);\n\
    \        }\n        else {\n            return (float)l[(int)m];\n        }",
  "        l.Sort();\n        int m = l.Count / 2;\n        return (l.Count % 2 ==\
    \ 0) ? (l[m - 1] + l[m]) / 2f : l[m];", "        l.Sort();\n        return (float)(l[(int)((ulong)l.Count\
    \ >> (int)1UL)] + l[(int)((ulong)(l.Count - 1L) >> (int)1UL)]) / 2f;", "     \
    \   l.Sort();\n        long i = l.Count / 2;\n        if (l.Count % 2 == 0) {\n\
    \            return (float)(l[(int)i] + l[(int)(i - 1L)]) / 2f;\n        }\n\n\
    \        return (float)l[(int)i];\n", "        l.Sort();\n        if (l.Count\
    \ % 2 == 1) {\n            return (float)l[l.Count / 2];\n        } else {\n \
    \           return (float)(l[l.Count / 2 - 1] + l[l.Count / 2]) / 2;\n       \
    \ }", "        List<long> nl = l.OrderBy(x => x).ToList();\n        long n = nl.Count;\n\
    \        if (n % 2 == 1) {\n            return nl[n / 2];\n        }\n       \
    \ return (nl[n / 2 - 1] + nl[n / 2]) / 2.0f;", "        int n = l.Count;\n   \
    \     if (n % 2 == 1) {\n            long ll = (long)Math.Ceiling((float)n / 2);\n\
    \            long rr = n - ll;\n            return (float)(l[(int)ll - 1] + l[(int)rr])\
    \ / 2;\n        }\n        long r = (long)Math.Ceiling((float)n / 2);\n      \
    \  return (float)l[(int)r - 1];", "        long i = 0L;\n        long j = 0L;\n\
    \        long n = (long)l.Count;\n        long n2 = 0L;\n        for (long k =\
    \ 0L; k < n; k++) {\n            if (l[(int)k] < l[(int)i]) {\n              \
    \  i = k;\n            }\n            if (l[(int)k] > l[(int)j]) {\n         \
    \       j = k;\n            }\n        }\n        n2 = n / 2L;\n        if (n\
    \ % 2L == 0L) {\n            long sum = l[(int)i] + l[(int)j];\n            return\
    \ (float)(sum / 2L);\n        }\n        return (float)l[(int)n2];", "       \
    \ l.Sort();\n        if (l.Count == 0)\n        {\n            return 0.0f;\n\
    \        }\n\n        if (l.Count % 2 == 1)\n        {\n            return l[l.Count\
    \ / 2];\n        }\n\n        return (l[l.Count / 2 - 1] + l[l.Count / 2]) / 2.0f;\n",
  "        List<long> temp = new List<long>(l);\n        temp.Sort();\n        if\
    \ (temp.Count % 2 == 1) {\n            return temp[temp.Count / 2];\n        }\n\
    \        else {\n            return (temp[temp.Count / 2 - 1] + temp[temp.Count\
    \ / 2]) / 2.0f;\n        }", "        l.Sort();\n        if ((l.Count % 2L) ==\
    \ 0L) {\n            return (((float)(l[(l.Count / 2L) - 1L] + l[l.Count / 2L]))\
    \ / 2f);\n        }\n\n        return (float)l[l.Count / 2L];\n", "        l.Sort();\n\
    \        if ((l.Count % 2L) == 0L) {\n            return ((float)(l[(l.Count /\
    \ 2L) - 1L] + l[l.Count / 2L]) / 2f);\n        }\n        else {\n           \
    \ return l[l.Count / 2L];\n        }", "        l.Sort();\n        int n = l.Count;\n\
    \        if (n % 2 == 1) {\n            return (float)l[n / 2];\n        }\n \
    \       else {\n            return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n   \
    \     }", "        l.Sort();\n        long n = (long)l.Count;\n        long n2\
    \ = n / (long)2L;\n        if (n % (long)2L == (long)0L) {\n            return\
    \ (float)((float)(l[(int)n2] + l[(int)(n2 - (long)1L)]) / (float)2L);\n      \
    \  }\n        return (float)l[(int)n2];", "        l.Sort();\n        var len\
    \ = (long)l.Count;\n        long n = len / 2L;\n        if (len % 2L == 1L) {\n\
    \            return (float)l[(int)n];\n        }\n        else {\n           \
    \ return (float)((l[(int)n] + l[(int)(n - 1L)]) / 2L);\n        }", "        var\
    \ l2 = l.OrderBy((x) => x).ToList();\n        var n = l2.Count();\n        if\
    \ (n % 2 == 1) {\n            return l2[n / 2];\n        } else {\n          \
    \  return (l2[n / 2 - 1] + l2[n / 2]) / 2f;\n        }", "        l.Sort();\n\
    \        if ((l.Count % 2L) == 0L) {\n            return (((float)(l[(l.Count\
    \ / 2L) - 1L] + l[l.Count / 2L])) / 2f);\n        }\n        else {\n        \
    \    return (float)l[l.Count / 2L];\n        }", "        long size = l.Count;\n\
    \        long middle = (long) (size / 2L);\n        if (size % 2L == 1L) {\n \
    \           return (float) l[(int) middle];\n        } else {\n            return\
    \ (float) (l[(int) middle] + l[(int) (middle - 1L)]) / 2f;\n        }", "    \
    \    var ordered = l.OrderBy((long x) => x).ToList();\n        var n = ordered.Count;\n\
    \        var t = ordered[n / 2];\n        if (n % 2 == 0) {\n            t +=\
    \ ordered[n / 2 - 1];\n            t /= 2.0f;\n        }\n        return t;",
  "        l.Sort();\n        long n = (long)l.Count;\n        if (n == 0L) {\n  \
    \          return 0f;\n        }\n        if (n % 2L == 1L) {\n            return\
    \ (float)l[(int)(n / 2L)];\n        }\n        return ((float)l[(int)(n / 2L -\
    \ 1L)] + (float)l[(int)(n / 2L)]) / 2f;", "        int size = l.Count;\n     \
    \   l.Sort();\n        if (size % 2 == 0) {\n            return (float)(l[size\
    \ / 2] + l[size / 2 - 1]) / 2;\n        } else {\n            return (float)l[size\
    \ / 2];\n        }", "        // l.Sort();\n        var c = l.Count();\n     \
    \   var half = c / 2;\n        return (c % 2 != 0) ? l[half] : (l[half - 1] +\
    \ l[half]) / 2.0f;", "        int n = l.Count;\n        l.Sort();\n        if\
    \ (n % 2 == 1) {\n            return (float)l[n / 2];\n        } else {\n    \
    \        return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n        }", "        long\
    \ n = (long)l.Count;\n        long tmp = 0L;\n        long median = (long)0L;\n\
    \        for (long i = (long)0L; i < n; i++) {\n            for (long j = (long)0L;\
    \ j < n - i - (long)1L; j++) {\n                if (l[(int)(j)] > l[(int)(j +\
    \ (long)1L)]) {\n                    tmp = l[(int)(j)];\n                    l[(int)(j)]\
    \ = l[(int)(j + (long)1L)];\n                    l[(int)(j + (long)1L)] = tmp;\n\
    \                }\n            }\n        }\n        if (n % (long)2L == (long)0L)\
    \ {\n            median = (l[(int)(n / (long)2L - (long)1L)] + l[(int)(n / (long)2L)])\
    \ / (long)2L;\n        }\n        else {\n            median = l[(int)(n / (long)2L)];\n\
    \        }\n        return (float)median;", "        long _l = 0L;\n        foreach\
    \ (var i in l) {\n            _l += i;\n        }\n        return ((float)_l)\
    \ / ((float)l.Count);", "        var c = l.Count();\n        if (c % 2 == 1) {\n\
    \            return l[c / 2];\n        } else {\n            return (l[c / 2 -\
    \ 1] + l[c / 2]) / 2.0f;\n        }", "        long n = (long)l.Count;\n     \
    \   long n2 = n / 2L;\n        float m;\n        if (n % 2L == 0L) {\n       \
    \     m = ((float)((l[(int)n2] + l[(int)(n2 - 1L)])) / 2f);\n        }\n     \
    \   else {\n            m = (float)l[(int)n2];\n        }\n        return m;",
  "        var tmp = l.ToArray();\n        Array.Sort(tmp);\n        int n = tmp.Length;\n\
    \        if (n % 2 == 1) {\n            return tmp[n / 2];\n        } else {\n\
    \            return (tmp[n / 2 - 1] + tmp[n / 2]) / 2.0f;\n        }", "     \
    \   l.Sort();\n        var mid = (l.Count + 1) / 2;\n        if (l.Count % 2 ==\
    \ 0) {\n            var x = l[mid - 1];\n            var y = l[mid];\n       \
    \     return (x + y) / 2f;\n        }\n        else {\n            return l[mid\
    \ - 1];\n        }", "        var count = l.Count;\n        var middle = count\
    \ / 2;\n        long temp = 0;\n        for (int i = 0; i < count; i++) {\n  \
    \          for (int j = 0; j < count - 1; j++) {\n                if (l[j] > l[j\
    \ + 1]) {\n                    temp = l[j + 1];\n                    l[j + 1]\
    \ = l[j];\n                    l[j] = temp;\n                }\n            }\n\
    \        }\n        return count % 2 == 1 ? l[middle] : (l[middle - 1] + l[middle])\
    \ / 2.0f;", "        l.Sort();\n        long length = (long)l.Count;\n       \
    \ if (length == 0L) {\n            return 0f;\n        }\n        if (length %\
    \ 2L == 0L) {\n            return (float)((l[(int)((length / 2L) - 1L)] + l[(int)(length\
    \ / 2L)]) / 2L);\n        }\n        return (float)l[(int)(length / 2L)];", " \
    \       int n = l.Count;\n        if (n % 2 == 1) {\n            return (float)l[n\
    \ / 2];\n        }\n        else {\n            return (float)((l[n / 2 - 1] +\
    \ l[n / 2]) / 2.0);\n        }", "        long n = (long)l.Count;\n        long\
    \ n2 = n / 2L;\n        l.Sort();\n        if (n % 2L == 0L) {\n            return\
    \ (float)((l[(int)n2 - 1L] + l[(int)n2]) / 2L);\n        }\n        return (float)l[(int)n2];",
  "        var _tup_1 = (l).Sort();\n        List<long> sorted = _tup_1.Item1;\n \
    \       long _ = _tup_1.Item2;\n        return MedianSorted(sorted);", "     \
    \   if (l.Count == 0) {\n            return 0.0f;\n        }\n        int half\
    \ = l.Count / 2;\n        l.Sort();\n        if (l.Count % 2 == 0) {\n       \
    \     return (float)(l[half - 1] + l[half]) / 2.0f;\n        }\n        else {\n\
    \            return (float)l[half];\n        }", "        l.Sort();\n        if\
    \ (((l.Count) % (2L)) == (0L)) {\n            return ((((float)(l[(((l.Count)\
    \ / (2L)) - (1L))])) + ((float)(l[((l.Count) / (2L))]))) / (2f));\n        }\n\
    \        else {\n            return ((float)(l[((l.Count) / (2L))]));\n      \
    \  }\n", "        l.Sort();\n        int n = l.Count;\n        if (n == 0) {\n\
    \            return 0;\n        }\n\n        if (n % 2 == 1) {\n            return\
    \ l[n / 2];\n        }\n\n        return (l[n / 2 - 1] + l[n / 2]) / 2f;\n", " \
    \       // INSERT YOUR CODE HERE\n        l.Sort();\n        if (l.Count % 2 ==\
    \ 0) {\n            return (float)(l[l.Count / 2] + l[l.Count / 2 - 1]) / 2;\n\
    \        } else {\n            return (float)l[l.Count / 2];\n        }", "  \
    \      long sum = 0L;\n        long s = 0L;\n        long u = 0L;\n        long\
    \ v = 0L;\n        long w = 0L;\n        long a = 0L;\n        long b = 0L;\n\
    \        long c = 0L;\n        long d = 0L;\n        long n = (long)l.Count;\n\
    \        long n2 = n / 2L;\n        sum = 0L;\n        foreach (long l1 in l)\
    \ {\n            sum += l1;\n        }\n        s = sum;\n        foreach (long\
    \ l1 in l) {\n            u = s - l1;\n            v = u - l1;\n            w\
    \ = v - l1;\n            a = s - v;\n            b = u - w;\n            c = b\
    \ + l1;\n            d = c - l1;\n            if (a > n2) {\n                break;\n\
    \            }\n            s = d;\n        }\n        return (float)l[(int)((n\
    \ - 1L) - (a - n2))];", "        long[] larr = l.ToArray();\n        int arrlen\
    \ = larr.Length;\n        int split = (int)Math.Ceiling((decimal)arrlen / 2);\n\
    \        if (arrlen % 2 == 0) {\n            return (float)(larr[split - 1] +\
    \ larr[split]) / 2;\n        } else {\n            return (float)larr[split -\
    \ 1];\n        }", '        return (float)l[(int)(((long)l.Count) / 2L)];', " \
    \       l.Sort();\n        int length = l.Count;\n        int mid = length / 2;\n\
    \        return (float)((((length % 2) == 1) ? l[mid] : (((double)l[mid]) + l[(mid\
    \ - 1)])) / (double)2);", "        l.Sort();\n        if (l.Count % 2 == 1) {\n\
    \            return (float)l[l.Count / 2];\n        } else {\n            return\
    \ (float)(l[l.Count / 2 - 1] + l[l.Count / 2]) / 2;\n        }", "        int\
    \ n = l.Count;\n        l.Sort();\n        if (n % 2 != 0) {\n            return\
    \ (float)l[n / 2];\n        }\n        else {\n            return (float)(l[n\
    \ / 2] + l[n / 2 - 1]) / 2f;\n        }", "        var tmp = l.OrderBy((long it)\
    \ => it).ToList();\n        if (tmp.Count % 2 == 1) {\n            return (float)tmp[tmp.Count\
    \ / 2];\n        }\n        else {\n            return (float)(tmp[tmp.Count /\
    \ 2 - 1] + tmp[tmp.Count / 2]) / 2f;\n        }", "        var lCopy = l.ToList();\n\
    \        lCopy.Sort();\n        var n = lCopy.Count;\n        if (n == 0) {\n\
    \            return 0;\n        }\n\n        return (float)(n % 2L == 0L ? (lCopy[n\
    \ / 2L - 1L] + lCopy[n / 2L]) / 2f : lCopy[n / 2L]);\n", "        l.Sort();\n\
    \        long s = 0L;\n        long n = (long)l.Count;\n        foreach (long\
    \ e in l) {\n            s += e;\n        }\n        if (n % 2L == 0L) {\n   \
    \         return (l[(int)((n / 2L) - 1L)] + l[(int)(n / 2L)]) / 2.0f;\n      \
    \  }\n        return l[(int)(n / 2L)];", "        // TODO: Implement me\n    \
    \    List<long> num = new List<long>(l);\n        long n = (long)num.Count();\n\
    \        long n2 = n / 2L;\n        if (n % 2L == 1L) {\n            return num[n2];\n\
    \        }\n        else {\n            float f = (float)(num[n2 - 1L] + num[n2]);\n\
    \            return f / 2.0f;\n        }", "        if (l.Count % 2 == 1) {\n\
    \            return l[l.Count / 2];\n        }\n        else {\n            long\
    \ a = l[l.Count / 2 - 1];\n            long b = l[l.Count / 2];\n            return\
    \ (a + b) / 2.0f;\n        }", "        int n = l.Count;\n        List<long> l_copy\
    \ = new List<long>(l);\n        l_copy.Sort();\n        if (n % 2 == 1) {\n  \
    \          return (float)l_copy[n / 2];\n        }\n        else {\n         \
    \   return (float)((l_copy[n / 2 - 1] + l_copy[n / 2]) / 2.0f);\n        }", " \
    \       var sl = l.OrderBy((i) => i).ToList();\n        var mid = sl.Count / 2;\n\
    \        return sl.Count % 2 == 0 ? ((float)(sl[mid - 1] + sl[mid])) / 2 : sl[mid];",
  "        int n = l.Count;\n        int half = n / 2;\n        if (n % 2 == 1) {\n\
    \            return l[half];\n        } else {\n            return (l[half] +\
    \ l[half - 1]) / 2.0f;\n        }", "        if (l.Count == 0) {\n           \
    \ return 0.0f;\n        }\n        List<long> lt = l.OrderBy(x => x).ToList();\n\
    \        int len = lt.Count;\n        if (len % 2 == 1) {\n            return\
    \ (float)lt[len / 2];\n        }\n        else {\n            return (float)(lt[len\
    \ / 2 - 1] + lt[len / 2]) / 2;\n        }", "        l.Sort();\n        return\
    \ ((float)(l[(int)((l.Count / (float)2L) - (float)1L)] + l[(int)(l.Count / (float)2L)]))\
    \ / (float)2L;", "        List<long> copy = new List<long>(l);\n        copy.Sort();\n\
    \        long length = (long)copy.Count;\n        if (length == 0L) {\n      \
    \      return 0.0f;\n        }\n        if (length % 2L == 1L) {\n           \
    \ return (float)copy[(int)(length / 2L)];\n        }\n        else {\n       \
    \     return (float)((float)(copy[(int)(length / 2L) - 1]) + (float)(copy[(int)(length\
    \ / 2L)]) / 2.0f);\n        }", "        if (((((l.Count) % (2L)) == (0L)) ||\
    \ (((l.Count) % (2L)) == (1L)))) {\n            return (float)((float)((l[((int)((float)((float)((l.Count)\
    \ / (2L))) + ((float)((float)((l.Count) % (2L)) / (2L)))))] + (l[((int)((float)((float)((l.Count)\
    \ / (2L))) + ((float)((float)((l.Count) % (2L)) / (2L)))))])) / (2L)));\n    \
    \    }\n        else {\n            return (float)(l[((int)((float)((float)((l.Count)\
    \ / (2L))) + ((float)((float)((l.Count) % (2L)) / (2L)))))]);\n        }\n", " \
    \       if ((len(l) == (long)0L)) {\n            return (float)0L;\n        }\n\
    \n        {\n            long n__prev1 = n;\n\n            foreach (var (_, __n)\
    \ in l)\n            {\n                n = __n;\n                if (n < (long)0L)\n\
    \                {\n                    throw new InvalidOperationException(\"\
    Cannot compute median of negative numbers\");\n                }\n\n         \
    \   }\n\n            n = n__prev1;\n        }\n\n        var l2 = new List<long>(l);\n\
    \        l2.Sort();\n        return Median(l2);\n", "        l.Sort();\n     \
    \   return l[l.Count / 2];", "        int n = l.Count;\n        l.Sort();\n  \
    \      if (n % 2 == 1) {\n            return (float)l[n / 2];\n        } else\
    \ {\n            return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n        }", " \
    \       l.Sort();\n        if (l.Count % 2 == 1) {\n            // odd\n     \
    \       return (float)l[l.Count / 2];\n        } else {\n            // even\n\
    \            return (float)((double)l[l.Count / 2 - 1] + (double)l[l.Count / 2])\
    \ / 2;\n        }", "        // Write your code here.\n        l.Sort();\n   \
    \     long index = l.Count / 2;\n        if (l.Count % 2 == 0) {\n           \
    \ return (float)(l[(int)index] + l[(int)index - 1]) / 2;\n        }\n        return\
    \ (float)l[(int)index];", "        long n = (long)l.Count;\n        long i = n\
    \ / 2L;\n        l.Sort();\n        if (n % 2L == 0L) {\n            return (float)((double)(l[(int)i\
    \ - 1L] + l[(int)i]) / 2.0);\n        }\n\n        return (float)l[(int)i];\n",
  "        l.Sort();\n        long sz = l.Count;\n        if (sz % 2L == 1L) {\n \
    \           return (float)l[(int)((sz - 1L) / 2L)];\n        }\n\n        return\
    \ (float)(l[(int)(sz / 2L)] + l[(int)((sz / 2L) - 1L)]) / 2.0f;\n", "        float\
    \ f;\n        int n = l.Count;\n        int m = n / 2;\n        l.Sort();\n  \
    \      if (n % 2 == 0) {\n            f = ((float)(l[m - 1L] + l[m])) / 2f;\n\
    \        }\n        else {\n            f = (float)l[m];\n        }\n        return\
    \ f;", "        l.Sort();\n        if (l.Count == 0) {\n            return 0;\n\
    \        }\n        else if (l.Count % 2 == 1) {\n            return l[l.Count\
    \ / 2];\n        }\n        else {\n            long a = l[l.Count / 2 - 1];\n\
    \            long b = l[l.Count / 2];\n            return (a + b) / 2.0f;\n  \
    \      }", "        float med = (float)0;\n        l.Sort();\n        if (l.Count\
    \ % 2 == 0) {\n            med = (float)(l[l.Count / 2] + l[l.Count / 2 - 1])\
    \ / 2;\n        }\n        else {\n            med = (float)l[l.Count / 2];\n\
    \        }\n        return med;", "        if (l.Count == 0) {\n            return\
    \ 0.0f;\n        }\n        // Sort our list first.\n        l.Sort();\n     \
    \   if (l.Count % 2 == 1) {\n            // Our list is odd.\n            return\
    \ (float)l[l.Count / 2];\n        }\n        else {\n            // Our list is\
    \ even.\n            return (float)(l[l.Count / 2] + l[l.Count / 2 - 1]) / 2.0f;\n\
    \        }", "        l.Sort();\n        return ((l[(l.Count/2)-1] + l[l.Count/2])\
    \ / 2.0f);", "        int len = (int)l.Count;\n        if (len == 0L) {\n    \
    \        return (float)0L;\n        }\n\n        // Make a sorted copy of elements\
    \ in l.\n        var a = new long[len];\n        {\n            long index = 0L;\n\
    \            long _index0 = 0L;\n            long __index0 = 0L;\n           \
    \ long _rhs = len;\n            long __rhs = _rhs;\n            for (index = _index0;\
    \ index < __rhs; index++) {\n                a[index] = l[index];\n          \
    \  }\n        }\n\n        // Find median element.\n        if (len % 2L == 0L)\
    \ {\n            long low = a[len / 2L - 1L];\n            long high = a[len /\
    \ 2L];\n            return (float)((low + high) / 2L);\n        }\n\n        return\
    \ (float)a[len / 2L];\n", "        int n = l.Count;\n        if (n == 0) {\n \
    \           return 0;\n        }\n        long[] v = new long[n];\n        for\
    \ (int i = 0; i < n; i++) {\n            v[i] = l[i];\n        }\n        Array.Sort(v);\n\
    \        if (n % 2 == 1) {\n            return v[n / 2];\n        }\n        else\
    \ {\n            return (v[n / 2 - 1] + v[n / 2]) / 2;\n        }", "        l.Sort();\n\
    \        int count = l.Count;\n        if (count % 2 == 0) {\n            long\
    \ sum = l[count / 2 - 1] + l[count / 2];\n            return (float)sum / 2;\n\
    \        }\n        else {\n            return (float)l[count / 2];\n        }",
  "        int n = l.Count;\n        if (n == 0) {\n            return (float)0L;\n\
    \        }\n        if (n == 1) {\n            return (float)l[0L];\n        }\n\
    \        if (n == 2) {\n            return (float)(l[0L] + l[1L]) / (float)2L;\n\
    \        }\n        List<long> p = new List<long>(l);\n        Sort(p);\n    \
    \    if (n % 2L == 1L) {\n            return (float)p[n / 2L];\n        }\n  \
    \      return (float)(p[n / 2L - 1L] + p[n / 2L]) / (float)2L;", "        var\
    \ sorted = (l.OrderBy((x) => x)).ToList();\n        var idx = (int)((sorted.Count\
    \ - 1) / 2.0f);\n        var med = sorted[idx];\n        if (sorted.Count % 2\
    \ == 0) {\n            med = (med + sorted[idx + 1]) / 2.0f;\n        }\n    \
    \    return med;", "        int i = l.Count / 2;\n        l.Sort();\n        if\
    \ (l.Count % 2 == 1) {\n            return (float)l[i];\n        }\n        else\
    \ {\n            return (float)(l[i - 1] + l[i]) / 2;\n        }", "        l.Sort();\n\
    \        if (l.Count % 2 == 1) {\n            return (float)l[l.Count / 2];\n\
    \        }\n        return (float)(l[l.Count / 2 - 1] + l[l.Count / 2]) / 2;",
  "        int a = l.Count / 2;\n        float b = (float) l[a];\n        if (l.Count\
    \ % 2 == 0) {\n            b = ((float) l[a] + (float) l[a - 1]) / 2f;\n     \
    \   }\n        return b;", "        var n = l.Count;\n        if (n == 0) {\n\
    \            return 0;\n        }\n        if (n == 1) {\n            return l[0];\n\
    \        }\n        l.Sort();\n        if (n % 2 == 1) {\n            return l[n\
    \ / 2];\n        }\n        return (l[n / 2 - 1] + l[n / 2]) / 2f;", "       \
    \ long median = default(long);\n        long odd = default(long);\n        if\
    \ (l.Count % 2L == 0L) {\n            odd = 0L;\n        }\n        else {\n \
    \           odd = 1L;\n        }\n\n        median = l.Count / 2L;\n        long\
    \ a = l[(int)median];\n        long b = l[(int)(median - 1L + odd)];\n       \
    \ return (float)((double)(a + b) / 2.0);", "        int n = l.Count;\n       \
    \ long x = n / 2;\n        // sort the list\n        l.Sort();\n        if (n\
    \ % 2 == 1) {\n            return (float)l[(int)x];\n        }\n        return\
    \ (float)((double)(l[(int)x - 1L] + l[(int)x]) / 2.0);", "        float median\
    \ = 0f;\n        var ordered = l.OrderBy((x) => x).ToList();\n        int count\
    \ = ordered.Count;\n        if (count % 2 == 0) {\n            // Number of elements\
    \ is even\n            median = (float)(ordered[count / 2] + ordered[count / 2\
    \ - 1]) / 2;\n        } else {\n            // Number of elements is odd\n   \
    \         median = (float)ordered[count / 2];\n        }\n        return median;",
  "        var sorted = l.OrderBy((long x) => x).ToList();\n        long mid = (long)sorted.Count\
    \ / (long)2L;\n        if ((sorted.Count % (long)2L) == (long)0L) {\n        \
    \    return (float)((sorted[(int)mid] + sorted[(int)(mid - (long)1L)]) / (long)2L);\n\
    \        }\n\n        return (float)sorted[(int)mid];\n", "        long sum =\
    \ 0L;\n        long min = Int64.MaxValue;\n        long max = Int64.MinValue;\n\
    \        foreach (long a in l) {\n            sum += a;\n            if (a < min)\
    \ {\n                min = a;\n            }\n            if (a > max) {\n   \
    \             max = a;\n            }\n        }\n        sum -= (min + max);\n\
    \        return (float)sum / (float)(l.Count - 2);", "        long n = l.Count;\n\
    \        long middle = (long)Math.Floor(((double)n) / 2);\n        l.Sort();\n\
    \        if (n % 2 == 1) {\n            return (float)l[middle];\n        }\n\
    \        else {\n            return (float)(((double)l[middle - 1L]) + ((double)l[middle]))\
    \ / 2f;\n        }", "        // Copy to a temp list because we need to sort it\n\
    \        var t = new List<long>(l);\n        t.Sort();\n        var n = t.Count;\n\
    \        if (n % 2 == 1) {\n            return t[n / 2];\n        } else {\n \
    \           return ((float)(t[n / 2 - 1] + t[n / 2])) / 2;\n        }", "    \
    \    int len = l.Count;\n        int index = len / 2;\n        if (len % 2 ==\
    \ 0) {\n            long v1 = l[index];\n            long v2 = l[index - 1];\n\
    \            return (v1 + v2) / 2.0f;\n        } else {\n            return l[index];\n\
    \        }", "        int size = l.Count;\n        l.Sort();\n        if (size\
    \ % 2 == 0) {\n            return (float)((l[size / 2 - 1] + l[size / 2]) / 2);\n\
    \        }\n        else {\n            return (float)l[size / 2];\n        }",
  "        long total = (long)0L;\n        foreach (var x in l) {\n            total\
    \ += x;\n        }\n\n        var list = l.ToList();\n        list.Sort();\n \
    \       if (list.Count % 2L == 0L) {\n            return (float)((list[list.Count\
    \ / 2L - 1L] + list[list.Count / 2L]) / 2L);\n        }\n\n        return (float)list[list.Count\
    \ / 2L];\n", "        l.Sort();\n        int n = l.Count;\n        if (n % 2 ==\
    \ 1) {\n            return (float)l[n / 2];\n        }\n        else {\n     \
    \       return (float)((l[n / 2 - 1] + l[n / 2]) / 2.0);\n        }", "      \
    \  float ret = 0.0f;\n        List<long> sorted = new List<long>(l);\n       \
    \ sorted.Sort();\n        int n = sorted.Count;\n        if (n % 2 == 0) {\n \
    \           ret = (float)(sorted[n / 2 - 1] + sorted[n / 2]) / 2;\n        } else\
    \ {\n            ret = (float)sorted[n / 2];\n        }\n        return ret;",
  "        long n = (long)l.Count;\n        long m = n >> 1;\n        long k = ((n\
    \ & 1L) == 1L) ? m : (m - 1L);\n        var i = l.OrderBy<long, long>((long x)\
    \ => x).ToList();\n        return ((i[(int)k] + i[(int)(k + 1L)]) / 2.0f);", " \
    \       l.Sort();\n        if (l.Count == 0) {\n            return (float)0L;\n\
    \        }\n        if (l.Count % 2 == 1) {\n            return (float)l[l.Count\
    \ / 2];\n        }\n        else {\n            return (float)((l[l.Count / 2]\
    \ + l[l.Count / 2 - 1]) / 2);\n        }", "        l.Sort();\n        if ((l.Count)\
    \ % 2 == 1) {\n            return (float)l[l.Count / 2];\n        } else {\n \
    \           return (((float)l[l.Count / 2]) + ((float)l[(l.Count / 2) - 1])) /\
    \ 2f;\n        }", "        l.Sort();\n        int len = l.Count;\n        if\
    \ (len % 2 == 1) {\n            return (float)l[len / 2];\n        }\n       \
    \ else {\n            return (float)(l[len / 2 - 1] + l[len / 2]) / 2;\n     \
    \   }", "        l.Sort();\n        int n = l.Count;\n        int m = n / 2;\n\
    \        if (n % 2 == 1) {\n            return (float)l[m];\n        }\n     \
    \   else {\n            return (float)((l[m - 1] + l[m]) / 2.0);\n        }",
  "        int i = 0;\n        int n = l.Count;\n        List<long> t = new List<long>(l);\n\
    \        t.Sort();\n        if (n % 2 == 1) {\n            i = n / 2;\n      \
    \      return (float)t[i];\n        }\n        else {\n            i = n / 2;\n\
    \            return (float)(t[i] + t[i - 1]) / 2f;\n        }", "        float\
    \ a = 0f;\n        float b = 0f;\n        float c = 0f;\n        float d = 0f;\n\
    \        float e = 0f;\n        if (l.Count() > 5) {\n            l.Sort();\n\
    \            a = l[0];\n            b = l[1];\n            c = l[2];\n       \
    \     d = l[3];\n            e = l[4];\n        }\n        else {\n          \
    \  a = l[0];\n            b = l[1];\n            c = l[2];\n            d = l[3];\n\
    \            e = l[4];\n        }\n        var ret = ((a + b + c + d + e) / (float)5L);\n\
    \        return ret;", "        l.Sort();\n        float ans = 0;\n        int\
    \ i = l.Count;\n        if (i % 2 == 0) {\n            ans = (float)((l[i / 2\
    \ - 1] + l[i / 2]) / 2);\n        }\n        else {\n            ans = (float)l[i\
    \ / 2];\n        }\n        return ans;", "        if (l.Count == 0) {\n     \
    \       return 0;\n        }\n\n        // Sorts in place.\n        l.Sort();\n\
    \        if (l.Count % 2 == 1) {\n            return l[l.Count / 2];\n       \
    \ }\n\n        return (l[l.Count / 2 - 1] + l[l.Count / 2]) / 2.0f;", "      \
    \  l.Sort();\n        int __il__1 = (int)0L;\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            long t = l[i];\n            l[i] = l[__il__1];\n       \
    \     l[__il__1] = t;\n            __il__1 = __il__1 + 1;\n        }\n       \
    \ long mid = (long)l.Count / (long)2L;\n        if ((l.Count % (long)2L) == (long)0L)\
    \ {\n            return (float)((l[(int)mid] + l[(int)(mid - (long)1L)]) / (long)2L);\n\
    \        }\n        else {\n            return (float)l[(int)mid];\n        }",
  "        int n = l.Count;\n        long[] arr = l.ToArray();\n        Array.Sort(arr);\n\
    \        if (n % 2 == 1) {\n            return arr[n / 2];\n        }\n      \
    \  return (arr[n / 2 - 1] + arr[n / 2]) / 2f;", "        int n = l.Count;\n  \
    \      l.Sort();\n        if (n % 2 == 1) {\n            return (float)l[n / 2];\n\
    \        }\n        else {\n            return (float)(l[n / 2 - 1] + l[n / 2])\
    \ / 2;\n        }", "        if (l.Count % 2 == 1) {\n            return (float)l[l.Count\
    \ / 2];\n        } else {\n            return (float)((l[l.Count / 2] + l[l.Count\
    \ / 2 - 1]) / 2.0);\n        }", "        long n = (long)l.Count;\n        if\
    \ (n == (long)0L) {\n            return 0;\n        }\n\n        l.Sort();\n \
    \       if (n % (long)2L == (long)0L) {\n            return (float)(l[(int)((n\
    \ / (long)2L) - (long)1L)] + l[(int)(n / (long)2L)]) / (float)2L;\n        }\n\
    \n        return (float)l[(int)(n / (long)2L)];\n", "        long sum = 0L;\n\
    \        long cnt = 0L;\n        foreach (var v in l) {\n            sum += v;\n\
    \            cnt += 1L;\n        }\n        return (float)(sum / cnt);", "   \
    \     float v = (float)l[l.Count / 2L];\n        if (l.Count % 2L == 0L) {\n \
    \           v = (v + (float)l[l.Count / 2L - 1L]) / 2f;\n        }\n\n       \
    \ return v;\n", "        // Debug.Assert(l.Count != 0);\n        l.Sort();\n \
    \       if (l.Count % 2 == 1) {\n            return (float)l[l.Count / 2];\n \
    \       }\n        else {\n            return (float)((float)l[l.Count / 2 - 1]\
    \ + (float)l[l.Count / 2]) / 2f;\n        }", "        l.Sort();\n        if ((l.Count\
    \ % 2L) == 1L) {\n            return (float)l[(l.Count / 2L)];\n        }\n  \
    \      else {\n            return ((float)(l[(l.Count / 2L) - 1L] + l[(l.Count\
    \ / 2L)]) / 2.0f);\n        }", "        // >>> l.Sort()\n        // >>> l\n \
    \       // [1, 2, 3, 4, 5]\n        l.Sort();\n        // >>> import math\n  \
    \      // >>> math.Floor((float)l.Count() / (float)2L)\n        // (float)2L\n\
    \        // >>> l[(int)2L]\n        // (int)3L\n        if (l.Count() % 2 == 1)\
    \ {\n            return (float)l[(int)Math.Floor((float)l.Count() / (float)2L)];\n\
    \        }\n        else {\n            return ((float)l[(int)Math.Floor((float)l.Count()\
    \ / (float)2L)] + (float)l[(int)Math.Floor((float)l.Count() / (float)2L) - 1])\
    \ / (float)2L;\n        }", "        l.Sort();\n        int mid = l.Count / 2;\n\
    \        if (l.Count % 2 == 1) {\n            return (float)l[mid];\n        }\n\
    \        else {\n            return (float)((l[mid] + l[mid - 1]) / 2.0);\n  \
    \      }", "        List<long> sorted = l.OrderBy(x => x).ToList();\n        if\
    \ (((sorted.Count) % (2L)) == (0L)) {\n            long midIndex = (sorted.Count)\
    \ / (2L);\n            return (((float)(sorted[midIndex])) + ((float)(sorted[(midIndex\
    \ - 1L)]))) / (2f);\n        }\n        return (float)(sorted[((sorted.Count)\
    \ / (2L))]);", "        long size = (long)l.Count;\n        long mid = (long)(size\
    \ / 2L);\n        if (size % 2L == 1L) {\n            return (float)l[(int)mid];\n\
    \        }\n\n        return (float)((l[(int)mid] + l[(int)(mid - 1L)]) / 2L);\n",
  "        float half = l.Count / 2;\n        l.Sort();\n        return l.Count %\
    \ 2 == 0 ? (l[(int)Math.Ceiling(half)] + l[(int)Math.Floor(half)]) / 2.0f : l[(int)Math.Floor(half)];",
  "        l.Sort();\n        if ((l.Count) % 2L == 0L) {\n            return ((float)(l[(l.Count)\
    \ / 2L - 1L] + l[(l.Count) / 2L]) / 2f);\n        }\n        else {\n        \
    \    return (float)l[(l.Count) / 2L];\n        }", "        l.Sort();\n      \
    \  var len = l.Count;\n        var h = len / 2;\n        if (len % 2 == 0) {\n\
    \            return (float)((l[h - 1] + l[h]) / 2.0f);\n        } else {\n   \
    \         return (float)l[h];\n        }", "        var s = new SortedSet<long>(l);\n\
    \        int mid = s.Count / 2;\n        if (s.Count % 2 == 0) {\n           \
    \ return ((float)(s.ElementAt(mid - 1) + s.ElementAt(mid))) / 2;\n        }\n\
    \        else {\n            return (float)s.ElementAt(mid);\n        }", "  \
    \      int n = l.Count;\n        l.Sort();\n        if (n % 2 == 1) {\n      \
    \      return (float)l[n / 2];\n        }\n        else {\n            return\
    \ (float)((double)(l[n / 2 - 1L] + l[n / 2]) / 2.0);\n        }", "        l.Sort();\n\
    \        var length = l.Count;\n        if (length % 2 == 0) {\n            return\
    \ (float)((l[length / 2 - 1] + l[length / 2]) / 2.0);\n        } else {\n    \
    \        return (float)l[length / 2];\n        }", "        int n = l.Count;\n\
    \        l.Sort();\n        if (n % 2 == 1) {\n            return (float)l[n /\
    \ 2];\n        } else {\n            return (float)(l[n / 2 - 1] + l[n / 2]) /\
    \ 2;\n        }", "        int n = l.Count;\n        l.Sort();\n        float\
    \ med = 0;\n        if (n % 2 == 0) {\n            med = (float)((float)(l[n /\
    \ 2] + l[n / 2 - 1]) / 2.0f);\n        }\n        else {\n            med = (float)l[n\
    \ / 2];\n        }\n        return med;", "        int n = l.Count;\n        var\
    \ c = l.OrderBy(x => x).ToList();\n        return (float)(c[n / 2] + c[(n - 1)\
    \ / 2]) / 2;", "        long n = l.Count;\n        long m = n / 2;\n        l.Sort();\n\
    \        if (n % 2 == 1) {\n            return (float)l[m];\n        }\n     \
    \   else {\n            return (float)(l[m - 1] + l[m]) / 2.0f;\n        }", " \
    \       if (l.Count % 2 == 1) {\n            return l[l.Count / 2];\n        }\
    \ else {\n            return (l[l.Count / 2 - 1] + l[l.Count / 2]) / 2.0f;\n \
    \       }", "        long[] ls = l.ToArray();\n        Array.Sort(ls);\n     \
    \   int m = ls.Length / 2;\n        return (ls.Length % 2 == 0) ? (ls[m] + ls[m\
    \ - 1]) / 2.0f : ls[m];", "        l.Sort();\n        if (l.Count % 2 == 1) {\n\
    \            return (float)l[l.Count / 2];\n        }\n        else {\n      \
    \      return (float)(l[l.Count / 2 - 1] + l[l.Count / 2]) / 2;\n        }", " \
    \       int m = l.Count / 2;\n        if (l.Count % 2 == 0) {\n            return\
    \ (float)(l[m] + l[m - 1]) / 2f;\n        } else {\n            return (float)l[m];\n\
    \        }", "        int count = l.Count;\n        long middle = count / 2;\n\
    \        if (count % 2 == 1) {\n            return l[middle];\n        }\n   \
    \     else {\n            return (l[middle] + l[middle - 1]) / 2.0f;\n       \
    \ }", "        if (l.Count == 0) {\n            return 0.0f;\n        }\n    \
    \    List<long> ll = new List<long>(l);\n        ll.Sort();\n        long mid\
    \ = ll.Count / 2;\n        if (ll.Count % 2 == 0) {\n            return (float)((ll[mid]\
    \ + ll[mid - 1]) / 2);\n        }\n        else {\n            return (float)ll[mid];\n\
    \        }", "        if (l.Count < 1) {\n            throw new ArgumentException(\"\
    The input list must contain at least one element.\");\n        }\n        if (l.Count\
    \ % 2 == 1) {\n            return l[l.Count / 2];\n        }\n        else {\n\
    \            return (l[l.Count / 2] + l[l.Count / 2 - 1]) / 2.0f;\n        }",
  "        long num = (long)0L;\n        long num2 = (long)0L;\n        long num3\
    \ = (long)0L;\n        long num4 = (long)0L;\n        long num5 = (long)0L;\n\
    \        long num6 = (long)0L;\n        long num7 = (long)0L;\n        long num8\
    \ = (long)0L;\n        long num9 = (long)0L;\n        long num10 = (long)0L;\n\
    \        long num11 = (long)0L;\n        long num12 = (long)0L;\n        long\
    \ num13 = (long)0L;\n        long num14 = (long)0L;\n        long num15 = (long)0L;\n\
    \        long num16 = (long)0L;\n        long num17 = (long)0L;\n        long\
    \ num18 = (long)0L;\n        long num19 = (long)0L;\n        long num20 = (long)0L;\n\
    \        long num21 = (long)0L;\n        long num22 = (long)0L;\n        long\
    \ num23 = (long)0L;\n        long num24 = (long)0L;\n        long num25 = (long)0L;\n\
    \        long num26 = (long)0L;\n        long num27 = (long)0L;\n        long\
    \ num28 = (long)0L;\n        long num29 = (long)0L;\n        long num30 = (long)0L;\n\
    \        long num31 = (long)0L;\n        long num32 = (long)0L;\n        long\
    \ num33 = (long)0L;\n        long num34 = (long)0L;\n        long num35 = (long)0L;\n\
    \        long num36 = (long)0L;\n        long num37 = (long)0L;\n        long\
    \ num38 = (long)0L;\n        long num39 = (long)0L;\n        long num40 = (long)0L;\n\
    \        long num41 = (long)0L;\n        long num42 = (long)0L;\n        long\
    \ num43 = (long)", "        int n = l.Count;\n        l.Sort();\n        if (n\
    \ % 2 == 1) {\n            return (float)l[n / 2];\n        } else {\n       \
    \     return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n        }", "        var ll\
    \ = l.Count();\n        var m = ll / 2;\n        if (ll % 2 == 0) {\n        \
    \    return (l[m - 1] + l[m]) / 2f;\n        } else {\n            return l[m];\n\
    \        }", "        if (((l.Count) == (0L))) {\n            throw new ArgumentOutOfRangeException();\n\
    \        }\n        else {\n            long __ilast = (l.Count) - (1L);\n   \
    \         for (long __i = (0L); __i <= __ilast; __i++) {\n                long\
    \ x = l[(int)__i];\n                l[(int)__i] = (long)Math.Abs((double)x);\n\
    \            }\n            l.Sort();\n            long idx = (long)(((l.Count)\
    \ / (float)2f) + (((l.Count) % (float)2f) / (float)2f));\n            return (float)l[(int)idx];\n\
    \        }", "        l.Sort();\n        return ((float)(l[(int)(l.Count() / (long)2L)])\
    \ + (float)(l[(int)((l.Count() - (long)1L) / (long)2L)]) / (float)(2L));", " \
    \       int n = l.Count;\n        if (n == 0)\n        {\n            return 0;\n\
    \        }\n\n        l.Sort();\n        if (n % 2 == 1)\n        {\n        \
    \    return l[n / 2];\n        }\n\n        return (l[n / 2 - 1] + l[n / 2]) /\
    \ 2.0f;\n", "        // >>> l.Sort(((a, b) => a - b));\n        l.Sort();\n  \
    \      // >>> l\n        // [1, 2, 3, 4, 5]\n        var n = l.Count();\n    \
    \    // >>> n\n        // (int)5\n        if (n % 2 == 1) {\n            // >>>\
    \ l[(n - 1) / 2]\n            // (long)3\n            return l[(n - 1) / 2];\n\
    \        }\n        else {\n            // >>> float(l[n / 2] + l[n / 2 - 1])\
    \ / 2\n            // (float)3\n            return (float)(l[n / 2] + l[n / 2\
    \ - 1]) / 2;\n        }", "        if (l.Count == 0) {\n            return (float)0L;\n\
    \        }\n        if (l.Count == 1) {\n            return (float)l[0L];\n  \
    \      }\n        List<long> sorted = l.ToList();\n        sorted.Sort();\n  \
    \      if (sorted.Count % 2L == 1L) {\n            return (float)sorted[sorted.Count\
    \ / 2L];\n        }\n        return ((float)sorted[sorted.Count / 2L - 1L] + (float)sorted[sorted.Count\
    \ / 2L]) / (float)2L;", "        l.Sort();\n        return (float)(l[l.Count /\
    \ 2] + l[(l.Count + 1) / 2]) / 2;", "        if ((l.Count) == (0L)) {\n      \
    \      return 0f;\n        }\n\n        l.Sort();\n        return (((l.Count)\
    \ % (2L)) == (0L)) ? (((float)(l[((l.Count) / (2L)) - (1L)])) + ((float)(l[(l.Count)\
    \ / (2L)]))) / (2f) : ((float)(l[(l.Count) / (2L)]));", "        int n = l.Count;\n\
    \        if (n % 2 == 1) {\n            return (float)l[n / 2];\n        }\n \
    \       else {\n            return (float)(l[n / 2 - 1] + l[n / 2]) / 2;\n   \
    \     }", "        l.Sort();\n        if (l.Count % 2 == 1) {\n            return\
    \ (float)l[l.Count / 2];\n        }\n        else {\n            return (float)((l[l.Count\
    \ / 2] + l[l.Count / 2 - 1]) / 2);\n        }", "        int n = l.Count;\n  \
    \      int mid = n / 2;\n        float ans = (n % 2 == 1) ? l[mid] : ((float)(l[mid\
    \ - 1] + l[mid])) / (float)2L;\n        return ans;", "        // Sort the list.\n\
    \        l.Sort();\n\n        // Get the length of the list.\n        int length\
    \ = l.Count;\n\n        // Is the list length even?\n        if (length % 2 ==\
    \ 0) {\n            // Get the middle two numbers and return the average of them.\n\
    \            return (float)((float)(l[length / 2 - 1] + l[length / 2]) / 2.0f);\n\
    \        }\n\n        // Return the middle number.\n        return (float)l[length\
    \ / 2];", "        int N = l.Count;\n        long[] a = l.ToArray();\n       \
    \ int mid = (N-1)/2;\n        long temp;\n        for (int i = 0; i <= mid; i++)\
    \ {\n            for (int j = i; j < N; j++) {\n                if (a[i] > a[j])\
    \ {\n                    temp = a[i];\n                    a[i] = a[j];\n    \
    \                a[j] = temp;\n                }\n            }\n        }\n \
    \       if (N % 2 == 0) {\n            return (float)(a[mid] + a[mid+1])/2;\n\
    \        } else {\n            return (float)a[mid];\n        }", "        if\
    \ (l.Count == 0)\n        {\n            return 0;\n        }\n\n        l.Sort();\n\
    \        var m = l.Count / 2;\n        if (l.Count % 2 == 0)\n        {\n    \
    \        return (float)(l[m - 1] + l[m]) / 2;\n        }\n\n        return l[m];\n",
  "        long s = 0L;\n        long x = 0L;\n        long i = 0L;\n        long\
    \ n = (long)l.Count;\n        long j = n / 2L;\n        while (i < j) {\n    \
    \        x = l[(int)i];\n            l[(int)i] = l[(int)(n - i - 1L)];\n     \
    \       l[(int)(n - i - 1L)] = x;\n            i = i + 1L;\n        }\n      \
    \  float ret = 0.0f;\n        if (n % 2L == 0L) {\n            ret = (((float)l[(int)(n\
    \ / 2L - 1L)] + (float)l[(int)(n / 2L)]) / 2.0f);\n        }\n        else {\n\
    \            ret = (float)l[(int)(n / 2L)];\n        }\n        return ret;",
  "        l.Sort();\n        long middle = (long)l.Count / (long)2L;\n        if\
    \ ((l.Count % (long)2L) == (long)0L) {\n            return (float)((l[(int)middle]\
    \ + l[(int)(middle - (long)1L)]) / (long)2L);\n        }\n\n        return (float)l[(int)middle];\n",
  "        l.Sort();\n        if (l.Count % 2 == 1) {\n            return (float)l[l.Count\
    \ / 2];\n        }\n        return (float)(l[l.Count / 2 - 1] + l[l.Count / 2])\
    \ / 2f;", "        l.Sort();\n        long len = (long)l.Count;\n        long\
    \ half = len / (long)2L;\n        if (len % (long)2L == (long)0L) {\n        \
    \    return (float)(l[(int)half - 1L] + l[(int)half]) / (float)2L;\n        }\n\
    \n        return (float)l[(int)half];\n", "        float m = 0;\n        int n\
    \ = l.Count;\n        if (n % 2 == 0) {\n            m = ((float)(l[n / 2 - 1]\
    \ + l[n / 2])) / (float)2;\n        }\n        else {\n            m = (float)l[n\
    \ / 2];\n        }\n        return m;", "        long sum = 0L;\n        long\
    \ count = 0L;\n        foreach (long v in l) {\n            sum += v;\n      \
    \      count++;\n        }\n        float m = (float)sum / (float)count;\n   \
    \     return m;", "        l.Sort();\n        int length = l.Count;\n        float\
    \ median = (float)0L;\n        if (length % (long)2L == (long)0L) {\n        \
    \    median = (float)((l[length / (long)2L - (long)1L] + l[length / (long)2L])\
    \ / (long)2L);\n        }\n        else {\n            median = (float)l[length\
    \ / (long)2L];\n        }\n\n        return median;\n", "        if (l.Count()\
    \ == 0) {\n            return float.NaN;\n        }\n        l.Sort();\n     \
    \   if (l.Count() % 2 == 1) {\n            return (float)l[l.Count() / 2];\n \
    \       }\n        else {\n            return (float)(l[l.Count() / 2 - 1] + l[l.Count()\
    \ / 2]) / 2;\n        }", "        l.Sort();\n        int n = l.Count;\n     \
    \   int m = n / 2;\n        if (n % 2 == 1) {\n            return (float)l[m];\n\
    \        }\n        else {\n            return (float)(l[m - 1] + l[m]) / 2;\n\
    \        }", "        if ((l.Count % 2L) == 0L) {\n            return ((float)(l[l.Count\
    \ / 2L] + l[(l.Count / 2L) - 1L]) / 2f);\n        }\n        else {\n        \
    \    return l[l.Count / 2L];\n        }", "        if (l.Count == 0) {\n     \
    \       return 0.0f;\n        }\n        l.Sort();\n        var c = l.Count;\n\
    \        if (c % 2 == 1) {\n            return l[c / 2];\n        }\n        return\
    \ ((l[c / 2] + l[c / 2 - 1]) / 2.0f);", "        l.Sort();\n        long len =\
    \ (long)l.Count;\n        long mid = (long)(len / 2L);\n        if (len % 2L ==\
    \ 0L) {\n            return (float)((l[(int)mid] + l[(int)(mid - 1L)]) / 2L);\n\
    \        }\n\n        return (float)l[(int)mid];\n", "        var s = new SortedSet<long>(l);\n\
    \        if (s.Count % 2 == 1) {\n            return (float)s.ElementAt(s.Count\
    \ / 2);\n        } else {\n            return (float)(s.ElementAt(s.Count / 2)\
    \ + s.ElementAt(s.Count / 2 - 1)) / 2;\n        }", "        l.Sort();\n     \
    \   long n = (long)l.Count;\n        if (n % 2L == 1L) {\n            return l[n\
    \ / 2L];\n        }\n\n        return (l[n / 2L - 1L] + l[n / 2L]) / 2.0f;\n"]
stop_tokens:
- "\n    }\n"
