name: HumanEval_116_sort_array
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // In this Kata, you have to sort a list of non-negative integers\
  \ according to\n    // number of ones in their binary representation in ascending\
  \ order.\n    // For similar number of ones, sort based on decimal value.\n    //\
  \ It must be implemented like this:\n    // >>> SortArray((new List<long>(new long[]{(long)1L,\
  \ (long)5L, (long)2L, (long)3L, (long)4L})))\n    // (new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)4L, (long)5L}))\n    // >>> SortArray((new List<long>(new\
  \ long[]{(long)-2L, (long)-3L, (long)-4L, (long)-5L, (long)-6L})))\n    // (new\
  \ List<long>(new long[]{(long)-6L, (long)-5L, (long)-4L, (long)-3L, (long)-2L}))\n\
  \    // >>> SortArray((new List<long>(new long[]{(long)1L, (long)0L, (long)2L, (long)3L,\
  \ (long)4L})))\n    // (new List<long>(new long[]{(long)0L, (long)1L, (long)2L,\
  \ (long)3L, (long)4L}))\n    public static List<long> SortArray(List<long> arr)\
  \ {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(SortArray((new\
  \ List<long>(new long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L}))).Equals((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)4L, (long)3L, (long)5L}))));\n\
  \    Debug.Assert(SortArray((new List<long>(new long[]{(long)-2L, (long)-3L, (long)-4L,\
  \ (long)-5L, (long)-6L}))).Equals((new List<long>(new long[]{(long)-4L, (long)-2L,\
  \ (long)-6L, (long)-5L, (long)-3L}))));\n    Debug.Assert(SortArray((new List<long>(new\
  \ long[]{(long)1L, (long)0L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)0L, (long)1L, (long)2L, (long)4L, (long)3L}))));\n    Debug.Assert(SortArray((new\
  \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(SortArray((new List<long>(new\
  \ long[]{(long)2L, (long)5L, (long)77L, (long)4L, (long)5L, (long)3L, (long)5L,\
  \ (long)7L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L,\
  \ (long)2L, (long)4L, (long)4L, (long)3L, (long)3L, (long)5L, (long)5L, (long)5L,\
  \ (long)7L, (long)77L}))));\n    Debug.Assert(SortArray((new List<long>(new long[]{(long)3L,\
  \ (long)6L, (long)44L, (long)12L, (long)32L, (long)5L}))).Equals((new List<long>(new\
  \ long[]{(long)32L, (long)3L, (long)5L, (long)6L, (long)12L, (long)44L}))));\n \
  \   Debug.Assert(SortArray((new List<long>(new long[]{(long)2L, (long)4L, (long)8L,\
  \ (long)16L, (long)32L}))).Equals((new List<long>(new long[]{(long)2L, (long)4L,\
  \ (long)8L, (long)16L, (long)32L}))));\n    Debug.Assert(SortArray((new List<long>(new\
  \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))).Equals((new List<long>(new\
  \ long[]{(long)2L, (long)4L, (long)8L, (long)16L, (long)32L}))));\n    }\n\n}\n"
completions: ["        //return arr.OrderBy(x => NumberOfOnes(x)).ThenBy(x => x).ToList();\n\
    \        return arr.OrderBy(x => x == 0 ? 0 : NumberOfOnes(x)).ThenBy(x => x).ToList();",
  "        var temp = arr.ToArray();\n        Array.Sort(temp, (long a, long b) =>\
    \ {\n            var onesA = CountOnes(a);\n            var onesB = CountOnes(b);\n\
    \            if (onesA != onesB) {\n                return onesA - onesB;\n  \
    \          }\n            return (int)a - (int)b;\n        });\n        return\
    \ temp.ToList();", "        // use a temporary array to store information about\
    \ each integer\n        // key = number of ones, value = list of integers with\
    \ that number of ones\n        Dictionary<int, List<long>> dict = new Dictionary<int,\
    \ List<long>>();\n        foreach (long n in arr) {\n            int ones = CountOnes(n);\n\
    \            if (!dict.ContainsKey(ones)) {\n                dict[ones] = new\
    \ List<long>();\n            }\n            dict[ones].Add(n);\n        }\n  \
    \      // sort each list in ascending order by key\n        foreach (KeyValuePair<int,\
    \ List<long>> pair in dict) {\n            List<long> list = pair.Value;\n   \
    \         list.Sort();\n        }\n        // concatenate each sorted list in\
    \ ascending order by key\n        List<long> ret = new List<long>();\n       \
    \ foreach (KeyValuePair<int, List<long>> pair in dict.OrderBy(pair => pair.Key))\
    \ {\n            ret.AddRange(pair.Value);\n        }\n        return ret;", " \
    \       // Your Code here\n        // Console.WriteLine(string.Join(\", \", arr));\n\
    \        return arr.OrderBy(x => Convert.ToString(x, 2).Count(y => y == '1')).ThenBy(x\
    \ => x).ToList();", "        arr.Sort((a, b) => {\n            var onesInA = a.ToString().Select(c\
    \ => c == '1').Count();\n            var onesInB = b.ToString().Select(c => c\
    \ == '1').Count();\n            if (onesInA == onesInB) {\n                return\
    \ a.CompareTo(b);\n            }\n            return onesInA.CompareTo(onesInB);\n\
    \        });\n        return arr;", "        return arr.OrderBy(a => Convert.ToString(a,\
    \ 2).Count(b => b == '1')).ThenBy(a => a).ToList();", '        return arr.OrderBy(x
    => x.BitCount()).ThenBy(x => x).ToList();', "        var arr1 = arr.Select(x =>\
    \ new {\n            value = x,\n            count = CountOnes(x)\n        });\n\
    \        var sorted = arr1.OrderBy(x => x.count).ThenBy(x => x.value);\n     \
    \   return sorted.Select(x => x.value).ToList();", "        // We just make a\
    \ list of the index of the item,\n        // and sort it according to the index,\
    \ so the\n        // original list will be sorted by the order\n        // of\
    \ the indexes.\n        List<long> indexes = new List<long>();\n        List<long>\
    \ newList = new List<long>();\n        for (int i = 0; i < arr.Count; i++) {\n\
    \            indexes.Add(i);\n        }\n        indexes.Sort((idx1, idx2) =>\
    \ {\n            // If they have the same number of ones, sort\n            //\
    \ by decimal value.\n            if (CountOnesInBinary(arr[(int)idx1]) == CountOnesInBinary(arr[(int)idx2]))\
    \ {\n                return arr[(int)idx1].CompareTo(arr[(int)idx2]);\n      \
    \      }\n            // Sort by number of ones in binary.\n            return\
    \ CountOnesInBinary(arr[(int)idx1]).CompareTo(CountOnesInBinary(arr[(int)idx2]));\n\
    \        });\n        foreach (long idx in indexes) {\n            newList.Add(arr[(int)idx]);\n\
    \        }\n        return newList;", "        List<long> result = new List<long>();\n\
    \        var length = arr.Count;\n        var dict = new Dictionary<long, long>();\n\
    \        for (var i = 0; i < length; i++) {\n            var n = arr[i];\n   \
    \         var cnt = 0;\n            while (n > 0) {\n                cnt += (n\
    \ & 1);\n                n >>= 1;\n            }\n            if (!dict.ContainsKey(cnt))\
    \ {\n                dict[cnt] = 0;\n            }\n            dict[cnt] = (dict[cnt]\
    \ << 32) | arr[i];\n        }\n        foreach (var d in dict.OrderBy(x => x.Key))\
    \ {\n            while (d.Value > 0) {\n                result.Add(d.Value & 0xffffffff);\n\
    \                d.Value >>= 32;\n            }\n        }\n        return result;",
  '        return arr.OrderBy(a => CountBits(a)).ThenBy(a => a).ToList();', "    \
    \    var sorted = from x in arr\n                orderby CountOnes(x), x\n   \
    \             select x;\n        return sorted.ToList();", "        List<long>\
    \ copy = new List<long>(arr);\n        copy.Sort(delegate(long x, long y) {\n\
    \            var x_ones = ones(x);\n            var y_ones = ones(y);\n      \
    \      if (x_ones == y_ones) {\n                return x < y ? -1 : 1;\n     \
    \       }\n            return x_ones < y_ones ? -1 : 1;\n        });\n       \
    \ return copy;", "        return arr.OrderBy(x => HammingWeight(x))\n        \
    \        .ThenBy(x => x)\n                .ToList();", "        List<long> results\
    \ = new List<long>();\n        var onesCount = new List<KeyValuePair<long, long>>();\n\
    \        for (long i = 0; i < arr.Count; i++) {\n            onesCount.Add(new\
    \ KeyValuePair<long, long>(arr[(int)i], arr[(int)i].ToBinaryString().Count(c =>\
    \ c == '1')));\n        }\n        var sorted = onesCount.OrderBy(x => x.Value).ThenBy(x\
    \ => x.Key);\n        foreach (var item in sorted) {\n            results.Add(item.Key);\n\
    \        }\n        return results;", "        arr.Sort((a, b) => {\n        \
    \    var aOneCount = BitCount(a);\n            var bOneCount = BitCount(b);\n\
    \            if (aOneCount == bOneCount) {\n                return (int)a - (int)b;\n\
    \            }\n            return aOneCount - bOneCount;\n        });\n     \
    \   return arr;", "        var oneAndZero = arr.Select(x =>\n            new {\
    \ Ones = CountOnes(x), Number = x });\n        return oneAndZero.OrderBy(x =>\
    \ x.Ones).ThenBy(x => x.Number).Select(x => x.Number).ToList();", "        arr.Sort((i,\
    \ j) => {\n            if (CountOnes(i) == CountOnes(j)) {\n                return\
    \ i.CompareTo(j);\n            }\n            return CountOnes(i).CompareTo(CountOnes(j));\n\
    \        });\n        return arr;", "        List<long> sorted = new List<long>();\n\
    \        for (long i = 0; i < arr.Count; i++) {\n            sorted.Add(arr[(int)i]);\n\
    \        }\n        sorted.Sort((a, b) => compare(a, b));\n        return sorted;",
  "        return arr.OrderBy(a => a.ToString(\"b\").Count(c => c == '1')).ThenBy(a\
    \ => a).ToList();", "        var query = arr.Select(x => new {x, count = CountOnes(x)});\n\
    \        return query.OrderBy(x => x.count).ThenBy(x => x.x).Select(x => x.x).ToList();",
  "        return arr.OrderBy(a => Convert.ToString(a, 2).Count(c => c == '1')).ThenBy(a\
    \ => a).ToList();", "        // sort by number of bits, then by value\n      \
    \  arr.Sort((x, y) => {\n            var xBits = getBits(x);\n            var\
    \ yBits = getBits(y);\n            if (xBits != yBits) {\n                return\
    \ xBits - yBits;\n            }\n            return (int) x - (int) y;\n     \
    \   });\n        return arr;", '        return arr.OrderBy(i => BigInteger.Parse(Convert.ToString(i,
    2))).ToList();', "        // your code here\n        return arr;", '        return
    arr.OrderBy(x => (int)CountOnes(x)).ThenBy(x => x).ToList();', "        var array\
    \ = arr.Select(x => new Tuple<long, long>(x, CountBits(x))).ToArray();\n     \
    \   Array.Sort(array, (a, b) => {\n            if (a.Item2 == b.Item2) {\n   \
    \             return a.Item1.CompareTo(b.Item1);\n            }\n            return\
    \ a.Item2.CompareTo(b.Item2);\n        });\n        return array.Select(x => x.Item1).ToList();",
  "        return arr.OrderBy(i => Convert.ToString(i, 2).Count(c => c == '1')).ThenBy(i\
    \ => i).ToList();", "        // NOTE: this is the correct algorithm but it's a\
    \ bit slow:\n        // return arr.OrderBy(x => Convert.ToString(x, 2)).ThenBy(x\
    \ => x).ToList();\n        // Writing it in a loop is faster:\n        return\
    \ arr.OrderBy(x => BitCount(x)).ThenBy(x => x).ToList();", "        List<long>\
    \ sorted = new List<long>();\n        sorted.AddRange(arr);\n        sorted.Sort(compare);\n\
    \        return sorted;", "        arr.Sort((x, y) => {\n            int numOnesA\
    \ = CountOnes(x);\n            int numOnesB = CountOnes(y);\n            if (numOnesA\
    \ == numOnesB) {\n                return x < y ? -1 : 1;\n            }\n    \
    \        return numOnesA < numOnesB ? -1 : 1;\n        });\n        return arr;",
  "        arr.Sort(delegate(long x, long y) {\n            return CompareValues(x,\
    \ y);\n        });\n        return arr;", "        for (int i = 0; i < arr.Count;\
    \ i++) {\n            for (int j = i + 1; j < arr.Count; j++) {\n            \
    \    if (arr[i] == arr[j]) {\n                    break;\n                }\n\
    \                if (arr[i] > arr[j]) {\n                    long temp = arr[i];\n\
    \                    arr[i] = arr[j];\n                    arr[j] = temp;\n  \
    \              }\n            }\n        }\n        return arr;", "        List<long>\
    \ copy = new List<long>(arr);\n        copy.Sort((x, y) => BinaryCompare(x, y));\n\
    \        return copy;", "        // Your code goes here\n        arr.Sort((x,\
    \ y) => GetBit(x).CompareTo(GetBit(y)));\n        return arr;", "        List<long>\
    \ negatives = new List<long>();\n        List<long> positives = new List<long>();\n\
    \        for (int i = 0; i < arr.Count; i++) {\n            if (arr[i] < 0) {\n\
    \                negatives.Add(arr[i]);\n            } else {\n              \
    \  positives.Add(arr[i]);\n            }\n        }\n        positives.Sort((a,\
    \ b) => {\n            if (Convert.ToString(a, 2).Count(x => x == '1') == Convert.ToString(b,\
    \ 2).Count(x => x == '1')) {\n                return a.CompareTo(b);\n       \
    \     } else {\n                return Convert.ToString(a, 2).Count(x => x ==\
    \ '1').CompareTo(Convert.ToString(b, 2).Count(x => x == '1'));\n            }\n\
    \        });\n        negatives.Sort((a, b) => {\n            if (Convert.ToString(a,\
    \ 2).Count(x => x == '1') == Convert.ToString(b, 2).Count(x => x == '1')) {\n\
    \                return b.CompareTo(a);\n            } else {\n              \
    \  return Convert.ToString(b, 2).Count(x => x == '1').CompareTo(Convert.ToString(a,\
    \ 2).Count(x => x == '1'));\n            }\n        });\n        List<long> result\
    \ = new List<long>();\n        foreach (long x in negatives) {\n            result.Add(x);\n\
    \        }\n        foreach (long x in positives) {\n            result.Add(x);\n\
    \        }\n        return result;", "        arr.Sort((x, y) => {\n         \
    \   var xBits = countSetBits(x);\n            var yBits = countSetBits(y);\n \
    \           if (xBits != yBits) {\n                return xBits.CompareTo(yBits);\n\
    \            }\n            return x.CompareTo(y);\n        });\n        return\
    \ arr;", "        Dictionary<int, List<long>> dictionary = new Dictionary<int,\
    \ List<long>>();\n        arr.ForEach(e => {\n            var base2 = Convert.ToString(e,\
    \ 2);\n            var ones = base2.Count(c => c == '1');\n            if (!dictionary.ContainsKey(ones))\
    \ {\n                dictionary.Add(ones, new List<long>());\n            }\n\
    \            dictionary[ones].Add(e);\n        });\n        var keys = dictionary.Keys.ToList();\n\
    \        keys.Sort();\n        var answer = new List<long>();\n        keys.ForEach(k\
    \ => {\n            answer.AddRange(dictionary[k]);\n        });\n        return\
    \ answer;", "        arr.Sort(delegate(long x, long y) {\n            int xOnes\
    \ = CountOnes(x);\n            int yOnes = CountOnes(y);\n            if (xOnes\
    \ != yOnes) {\n                return xOnes - yOnes;\n            }\n        \
    \    return (int)x - (int)y;\n        });\n        return arr;", "        // your\
    \ code here\n        return null;", "        Dictionary<long, long> indexes =\
    \ new Dictionary<long, long>();\n        foreach (long element in arr) {\n   \
    \         long bits = 0;\n            string binary = Convert.ToString(element,\
    \ 2);\n            foreach (char bit in binary) {\n                if (bit ==\
    \ '1') bits++;\n            }\n            if (indexes.ContainsKey(bits)) {\n\
    \                indexes[bits]++;\n            } else {\n                indexes.Add(bits,\
    \ 1);\n            }\n        }\n        List<long> sorted = new List<long>();\n\
    \        foreach (KeyValuePair<long, long> entry in indexes) {\n            for\
    \ (long i = 0; i < entry.Value; i++) {\n                sorted.Add(entry.Key);\n\
    \            }\n        }\n        sorted.Sort();\n        for (long i = 0; i\
    \ < arr.Count; i++) {\n            arr[i] = sorted[i];\n        }\n        return\
    \ arr;", "        return arr.OrderBy(x => {\n            if (x >= 0) {\n     \
    \           return Convert.ToString(x, 2).Replace(\"0\", \"\").Length.ToString()\
    \ + x.ToString();\n            } else {\n                return (-1 * Convert.ToString(-x,\
    \ 2).Replace(\"0\", \"\").Length).ToString() + x.ToString();\n            }\n\
    \        }).ToList();", "        if (arr == null) return arr;\n        List<long>\
    \ answer = new List<long>();\n        for (int i = 0; i < arr.Count; i++) {\n\
    \            answer.Add(arr[i]);\n        }\n        if (arr.Count == 0) return\
    \ answer;\n        for (int i = 0; i < arr.Count; i++) {\n            for (int\
    \ j = 0; j < arr.Count; j++) {\n                if (answer[i] < answer[j]) {\n\
    \                    var tmp = answer[i];\n                    answer[i] = answer[j];\n\
    \                    answer[j] = tmp;\n                }\n            }\n    \
    \    }\n        // answer.Reverse();\n        return answer;", "        arr.Sort((a,\
    \ b) => {\n            var a_bits = CountBits(a);\n            var b_bits = CountBits(b);\n\
    \            if (a_bits == b_bits) {\n                return (int) (a - b);\n\
    \            }\n            return a_bits - b_bits;\n        });\n        return\
    \ arr;", "        return arr.OrderBy(n => CountOnes(n))\n                  .ThenBy(n\
    \ => n)\n                  .ToList();", "        // Make a list of tuples of value\
    \ and count of 1 bits\n        var tuples = new List<Tuple<long, int>>();\n  \
    \      foreach (var item in arr) {\n            int count = BitOperations.PopCount(item);\n\
    \            tuples.Add(new Tuple<long, int>(item, count));\n        }\n     \
    \   // Sort the tuple list with custom comparer\n        tuples.Sort(new Num1BitCmp());\n\
    \        // Extract only the value list\n        var ret = new List<long>();\n\
    \        foreach (var item in tuples) {\n            ret.Add(item.Item1);\n  \
    \      }\n        return ret;", "        // 1) Convert each element in the list\
    \ to a BigInteger\n        // 2) Convert each element to a string of 0's and 1's\n\
    \        // 3) Count the number of 1's\n        // 4) Return an order of number\
    \ of 1's and array index, then sort\n        // 5) Extract the list of 1's and\
    \ return it\n        var bigIntList = arr.Select(x => new BigInteger(x)).ToList();\n\
    \        var bigIntBinaryList = bigIntList.Select(x => Convert.ToString(x, 2)).ToList();\n\
    \        var numOnesList = bigIntBinaryList.Select(x => x.Count(c => c == '1')).ToList();\n\
    \        var numOnesTupleList = numOnesList.Select((x, i) => new Tuple<int, int>(x,\
    \ i)).ToList();\n        numOnesTupleList.Sort();\n        var sortedIntList =\
    \ numOnesTupleList.Select(x => bigIntList[x.Item2]).ToList();\n        return\
    \ sortedIntList.Select(x => (long)x).ToList();", "        return arr.OrderBy(x\
    \ => x < 0 ? 0 : x.ToString(\"X\").Count(c => c == '1')).ThenBy(x => x).ToList();",
  "        return arr.OrderBy(v => Convert.ToString(v, 2).Count(x => x == '1')).ThenBy(v\
    \ => v).ToList();", "        var list = arr.Select(v => (long)v).ToList();\n \
    \       for (int i = 0; i < list.Count; i++) {\n            for (int j = 0; j\
    \ < list.Count; j++) {\n                if (list[i] == list[j]) continue;\n  \
    \              var onesi = Convert.ToString(list[i], 2).Count(c => c == '1');\n\
    \                var onesj = Convert.ToString(list[j], 2).Count(c => c == '1');\n\
    \                if (onesi > onesj) {\n                    var temp = list[i];\n\
    \                    list[i] = list[j];\n                    list[j] = temp;\n\
    \                } else if (onesi == onesj) {\n                    if (list[i]\
    \ > list[j]) {\n                        var temp = list[i];\n                \
    \        list[i] = list[j];\n                        list[j] = temp;\n       \
    \             }\n                }\n            }\n        }\n        return list;",
  "        arr.Sort((a, b) => {\n            var ca = CountOnes(a);\n            var\
    \ cb = CountOnes(b);\n            if (ca < cb) return -1;\n            if (ca\
    \ > cb) return 1;\n            return a < b ? -1 : 1;\n        });\n        return\
    \ arr;", "        return arr.OrderBy(x => Convert.ToString(x, 2).Count(y => y\
    \ == '1')).ThenBy(x => x).ToList();", "        arr.Sort(delegate(long a, long\
    \ b) {\n            // The number of ones in the binary representation\n     \
    \       // of |a| and |b| is irrelevant.\n            var ab = Math.Abs(a) - Math.Abs(b);\n\
    \            if (ab == 0) {\n                // If the number of ones is equal,\
    \ the absolute value is irrelevant.\n                ab = a - b;\n           \
    \ }\n            if (ab == 0) {\n                // If the values are still equal,\
    \ the signs are irrelevant.\n                ab = Math.Sign(a) - Math.Sign(b);\n\
    \            }\n            return ab;\n        });\n        return arr;", " \
    \       var numbers = arr.Select(n => new BinaryAndDecimal(n)).ToList();\n   \
    \     numbers.Sort((x, y) => {\n            if (x.Ones != y.Ones) {\n        \
    \        return x.Ones - y.Ones;\n            }\n            return x.Decimal\
    \ - y.Decimal;\n        });\n        return numbers.Select(x => x.Decimal).ToList();",
  '        return arr.OrderBy(x => x.CountOnes()).ThenBy(x => x).ToList();', "   \
    \     int bits = 0;\n        long max = 0;\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            long value = arr[i];\n            if (value < 0) {\n   \
    \             value = Math.Abs(value);\n            }\n            if (value >\
    \ max) {\n                max = value;\n            }\n        }\n        while\
    \ (max > 0) {\n            bits++;\n            max >>= 1;\n        }\n      \
    \  bits += 1;\n        arr.Sort(new OneComparator(bits));\n        return arr;",
  "        if (arr == null)\n            return null;\n        Dictionary<long, int>\
    \ dic = new Dictionary<long, int>();\n        foreach (long x in arr) {\n    \
    \        int binary_size = 0;\n            int binary_value = 0;\n           \
    \ try {\n                binary_size = (int)Convert.ToString(x, 2).Length;\n \
    \               binary_value = Convert.ToString(x, 2).ToCharArray().Count(c =>\
    \ c == '1');\n            } catch (Exception) {\n                Console.WriteLine(\"\
    Warning: Not a number!\");\n            }\n            if (dic.ContainsKey(x))\
    \ {\n                if (dic[x] < binary_value)\n                    dic[x] =\
    \ binary_value;\n            } else {\n                dic.Add(x, binary_value);\n\
    \            }\n        }\n        arr.Sort();\n        arr.Sort((x, y) => dic[x].CompareTo(dic[y]));\n\
    \        return arr;", "        return arr.OrderBy(x => Convert.ToString(x, 2).Count(c\
    \ => c == '1')).ThenBy(x => x).ToList();", "        var digitMap = arr.ToDictionary(x\
    \ => x, \n            x => new { Ones = Convert.ToString(x, 2).Count(y => y ==\
    \ '1'), Decimal = x });\n        var result = arr.OrderBy(x => digitMap[x].Ones).ThenBy(x\
    \ => digitMap[x].Decimal).ToList();\n        return result;", "        int i =\
    \ 0;\n        var result = new List<long>();\n        while (arr.Count > 0) {\n\
    \            long min = arr[0];\n            int minIndex = 0;\n            for\
    \ (int j = 0; j < arr.Count; j++) {\n                if (BinaryLength(arr[j])\
    \ < BinaryLength(min)) {\n                    min = arr[j];\n                \
    \    minIndex = j;\n                } else if (BinaryLength(arr[j]) == BinaryLength(min))\
    \ {\n                    if (arr[j] < min) {\n                        min = arr[j];\n\
    \                        minIndex = j;\n                    }\n              \
    \  }\n            }\n            result.Add(min);\n            arr.RemoveAt(minIndex);\n\
    \        }\n        return result;", "        List<Tuple<int,long>> onedictionary\
    \ = new List<Tuple<int,long>>();\n        for (int i = 0; i < arr.Count; i++)\
    \ {\n            int onescount = 0;\n            for (int j = 0; j < 8*sizeof(long);\
    \ j++) {\n                if ((arr[i] & (1L << j)) != 0) {\n                 \
    \   onescount++;\n                }\n            }\n            onedictionary.Add(new\
    \ Tuple<int,long>(onescount, arr[i]));\n        }\n        onedictionary.Sort(\n\
    \            delegate(Tuple<int,long> left, Tuple<int,long> right) {\n       \
    \         if (left.Item1 < right.Item1) return -1;\n                if (left.Item1\
    \ > right.Item1) return 1;\n                if (left.Item2 < right.Item2) return\
    \ -1;\n                if (left.Item2 > right.Item2) return 1;\n             \
    \   return 0;\n            }\n        );\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            arr[i] = onedictionary[i].Item2;\n        }\n        return\
    \ arr;", "        // return arr.OrderBy(n => {\n        //     if (n == 0) return\
    \ 0;\n        //     return GetBitCount(n);\n        // }).ThenBy(n => n).ToList();\n\
    \        return arr.OrderBy(n => CountOnes(n)).ThenBy(n => n).ToList();", "  \
    \      List<long> sorted = new List<long>();\n        long binVal = 0L;\n    \
    \    int decVal = 0;\n        while (arr.Count > 0) {\n            long minVal\
    \ = long.MaxValue;\n            foreach (long val in arr) {\n                binVal\
    \ = val;\n                decVal = (int)val;\n                int ones = 0;\n\
    \                while (binVal > 0) {\n                    if (binVal % 2 == 1)\
    \ ones++;\n                    binVal /= 2;\n                }\n             \
    \   if (ones < minVal) {\n                    minVal = ones;\n               \
    \ }\n            }\n            foreach (long val in arr) {\n                binVal\
    \ = val;\n                decVal = (int)val;\n                int ones = 0;\n\
    \                while (binVal > 0) {\n                    if (binVal % 2 == 1)\
    \ ones++;\n                    binVal /= 2;\n                }\n             \
    \   if (ones == minVal) {\n                    sorted.Add(val);\n            \
    \        arr.Remove(val);\n                }\n            }\n        }\n     \
    \   return sorted;", '        return arr.OrderBy(x => x == -1).ThenBy(x => CountOnesInBinary(x)).ToList();',
  "        return arr.OrderBy(x => NumberOfOnesInBinary(x))\n            .ThenBy(x\
    \ => x)\n            .ToList();", "        List<long> binary = new List<long>();\n\
    \        List<long> zeros = new List<long>();\n        List<long> ones = new List<long>();\n\
    \        foreach (long item in arr) {\n            string binaryRep = Convert.ToString(item,\
    \ 2);\n            binary.Add(Convert.ToInt64(binaryRep));\n        }\n      \
    \  foreach (long item in binary) {\n            int numberOfOnes = 0;\n      \
    \      char[] chars = item.ToString().ToCharArray();\n            foreach (char\
    \ i in chars) {\n                if (i == '1') {\n                    numberOfOnes++;\n\
    \                }\n            }\n            if (numberOfOnes == 0) {\n    \
    \            zeros.Add(item);\n            } else {\n                ones.Add(item);\n\
    \            }\n        }\n        ones.Sort();\n        List<long> result = new\
    \ List<long>();\n        foreach (long item in ones) {\n            result.Add(Convert.ToInt64(item.ToString(),\
    \ 2));\n        }\n        foreach (long item in zeros) {\n            result.Add(Convert.ToInt64(item.ToString(),\
    \ 2));\n        }\n        return result;", "        List<int> ones = new List<int>();\n\
    \        foreach (long n in arr) {\n            int i = 0;\n            while\
    \ (n > 0) {\n                if (n % 2 == 1) i++;\n                n /= 2;\n \
    \           }\n            ones.Add(i);\n        }\n        List<long>[] lists\
    \ = new List<long>[arr.Count];\n        for (int i = 0; i < lists.Length; i++)\
    \ lists[i] = new List<long>();\n        for (int i = 0; i < arr.Count; i++) lists[ones[i]].Add(arr[i]);\n\
    \        lists = lists.OrderBy(l => l.First()).ToArray();\n        arr.Clear();\n\
    \        foreach (List<long> l in lists) {\n            l.Sort();\n          \
    \  arr.AddRange(l);\n        }\n        return arr;", "        List<long> sorted\
    \ = new List<long>();\n        foreach (long val in arr) {\n            sorted.Add(val);\n\
    \        }\n        sorted.Sort((a, b) => {\n            int a1 = (int)a, b1 =\
    \ (int)b;\n            return BitCount(a1) - BitCount(b1) == 0 ? a1 - b1 : BitCount(a1)\
    \ - BitCount(b1);\n        });\n        return sorted;", "        return arr.OrderBy(x\
    \ => Convert.ToString(x, 2).Count(c => c == '1')).ThenBy(x => x).ToList();", " \
    \       return arr.OrderBy(x => {\n            // Have to use something other\
    \ than byte because byte is signed\n            // so you get nonsense like 9\
    \ > 10 because 0b1001 < 0b1010\n            var bits = new BitArray(BitConverter.GetBytes(x));\n\
    \            var count = bits.Cast<bool>().Count(b => b);\n            return\
    \ (count, x);\n        }).ToList();", "        return arr.OrderBy(x => GetNumberOfOnes(x))\n\
    \                  .ThenBy(x => x)\n                  .ToList();", "        arr.Sort(delegate(long\
    \ left, long right) {\n            int leftBitCount = BitCount(left);\n      \
    \      int rightBitCount = BitCount(right);\n            if (leftBitCount != rightBitCount)\
    \ {\n                return leftBitCount - rightBitCount;\n            }\n   \
    \         return (int)left - (int)right;\n        });\n        return arr;", " \
    \       var ordered = arr.OrderBy(x => x);\n        var orderedDec = ordered.ThenBy(x\
    \ => Convert.ToString(x, 2).Count(c => c == '1'));\n        return orderedDec.ToList();",
  '        return arr.OrderBy(a => CountOnes(a).ToString()).ThenBy(a => a).ToList();',
  "        // Here are the results of the test:\n        // [1L, 5L, 2L, 3L, 4L] =>\
    \ [1L, 2L, 3L, 4L, 5L]\n        // [1L, 0L, 2L, 3L, 4L] => [0L, 1L, 2L, 3L, 4L]\n\
    \        // [-2L, -3L, -4L, -5L, -6L] => [-6L, -5L, -4L, -3L, -2L]\n        //\
    \ [-9L, 0L, -1L, 3L, 2L] => [-9L, -1L, 0L, 2L, 3L]\n        // [-9L, 2L, -1L,\
    \ 3L, 0L] => [-9L, -1L, 0L, 2L, 3L]\n        // [1L, 2L, 3L, 4L, 5L] => [1L, 2L,\
    \ 3L, 4L, 5L]\n        // [1L, 0L, -1L, 3L, 2L] => [-1L, 0L, 1L, 2L, 3L]\n   \
    \     // [0L, -1L, 1L, 2L, 3L] => [-1L, 0L, 1L, 2L, 3L]\n        // [2L, 3L, 4L,\
    \ 5L, 6L] => [2L, 3L, 4L, 5L, 6L]\n        // [0L, -9L, -1L, 3L, 2L] => [-9L,\
    \ -1L, 0L, 2L, 3L]\n        // [-9L, 0L, -1L, 2L, 3L] => [-9L, -1L, 0L, 2L, 3L]\n\
    \        // You can see that the last cases are very easy to break.\n        //\
    \ It is pretty easy to determine whether the number is negative or not:\n    \
    \    // >>> if (Num <= 0L)\n        // ... ... ... return 1;\n        // ... ...\
    \ ... else\n        // ... ... ... ... return 0;\n        // But there is no way\
    \ to compare the number of ones in their", "        // Add your code here\n  \
    \      return arr;", "        List<long> r = new List<long>();\n        // Loop\
    \ through arr.\n        foreach (long l in arr) {\n            int ones = 0;\n\
    \            string l2s = Convert.ToString(l, 2);\n            foreach (char c\
    \ in l2s) {\n                if (c == '1') ones++;\n            }\n          \
    \  // Add (ones, l) pair to result list.\n            r.Add(((long)ones) * ((long)Math.Pow(10,\
    \ 12)) + l);\n        }\n        // Sort the result list.\n        r.Sort();\n\
    \        // Remove the ones field.\n        for (int i = 0; i < r.Count; i++)\
    \ {\n            r[i] = r[i] % ((long)Math.Pow(10, 12));\n        }\n        return\
    \ r;", "        List<int> ones = new List<int>();\n        foreach (long num in\
    \ arr) {\n            ones.Add(BitConverter.GetBytes(num).Count(b => b == 1));\n\
    \        }\n        arr.Sort((a, b) => {\n            int aOnes = BitConverter.GetBytes(a).Count(b\
    \ => b == 1);\n            int bOnes = BitConverter.GetBytes(b).Count(b => b ==\
    \ 1);\n            if (aOnes != bOnes) {\n                return aOnes - bOnes;\n\
    \            }\n            else {\n                return (int)a - (int)b;\n\
    \            }\n        });\n        return arr;", "        // Console.WriteLine(\"\
    In: \" + String.Join(\", \", arr));\n        // if(arr.Count == 1) {\n       \
    \ //     return arr;\n        // }\n        List<long> sorted = new List<long>();\n\
    \        // sorted.Add(arr[0]);\n        foreach(long i in arr) {\n          \
    \  if(sorted.Count == 0) {\n                sorted.Add(i);\n            } else\
    \ {\n                // Console.WriteLine(\"Inserting \" + i);\n             \
    \   int n = 0;\n                int onesInI = (int)CountBits(i);\n           \
    \     // Console.WriteLine(\"Ones in \" + i + \" is \" + onesInI);\n         \
    \       while(n < sorted.Count) {\n                    int onesInN = (int)CountBits(sorted[n]);\n\
    \                    // Console.WriteLine(\"Ones in \" + sorted[n] + \" is \"\
    \ + onesInN);\n                    if(onesInI < onesInN) {\n                 \
    \       sorted.Insert(n, i);\n                        break;\n               \
    \     } else if(onesInI == onesInN) {\n                        if(i < sorted[n])\
    \ {\n                            sorted.Insert(n, i);\n                      \
    \      break;\n                        }\n                    }\n            \
    \        n++;\n                }\n                if(n == sorted.Count) {\n  \
    \                  sorted.Add(i);\n                }\n            }\n        }\n\
    \        // Console.WriteLine(\"Out: \" + String.Join(\", \", sorted));\n    \
    \    return sorted;", '        return arr.OrderBy(x => GetNumOnes(x)).ThenBy(x
    => x).ToList();', '        return arr.OrderBy(x => GetBitCount(x)).ThenBy(x =>
    x).ToList();', '        return arr.OrderBy(a => Bin1s(a)).ThenBy(a => a).ToList();',
  "        long[] array = arr.ToArray();\n        int[] index = new int[array.Length];\n\
    \        int[] sort = new int[array.Length];\n        int[] ones = new int[array.Length];\n\
    \        for (int i = 0; i < array.Length; i++) {\n            index[i] = i;\n\
    \            sort[i] = i;\n            ones[i] = CountOnes(array[i]);\n      \
    \  }\n        Array.Sort(ones, index);\n        Array.Sort(array, sort);\n   \
    \     for (int i = 0; i < array.Length; i++) {\n            if (index[i] != sort[i])\
    \ {\n                int tmp = index[i];\n                index[i] = sort[i];\n\
    \                index[Array.IndexOf(index, sort[i])] = tmp;\n            }\n\
    \        }\n        List<long> result = new List<long>();\n        for (int i\
    \ = 0; i < array.Length; i++) {\n            result.Add(array[index[i]]);\n  \
    \      }\n        return result;", "        var len = arr.Count;\n        var\
    \ ans = new List<long>(len);\n        ans.AddRange(arr);\n        for (int i =\
    \ 0; i < len; i++) {\n            var a = arr[i];\n            var b = ans[i];\n\
    \            var ones = Convert.ToString(a, 2).Count(x => x == '1');\n       \
    \     var j = i + 1;\n            while (j < len) {\n                var c = arr[j];\n\
    \                var ones2 = Convert.ToString(c, 2).Count(x => x == '1');\n  \
    \              if (ones > ones2) {\n                    ans[i] = c;\n        \
    \            ans[j] = b;\n                    break;\n                } else if\
    \ (ones == ones2) {\n                    if (a > c) {\n                      \
    \  ans[i] = c;\n                        ans[j] = b;\n                        break;\n\
    \                    }\n                }\n                j++;\n            }\n\
    \        }\n        return ans;", "        var list = new List<KeyValuePair<long,\
    \ int>>();\n        for (int i = 0; i < arr.Count; i++) {\n            var kvp\
    \ = new KeyValuePair<long, int>(arr[i], i);\n            list.Add(kvp);\n    \
    \    }\n        list.Sort((a, b) => {\n            var aBitStr = GetBitString(a.Key);\n\
    \            var bBitStr = GetBitString(b.Key);\n            if (aBitStr.Count()\
    \ == bBitStr.Count()) {\n                return a.Key.CompareTo(b.Key);\n    \
    \        }\n            return aBitStr.Count().CompareTo(bBitStr.Count());\n \
    \       });\n        var listOrdered = new List<long>();\n        for (int i =\
    \ 0; i < list.Count; i++) {\n            listOrdered.Add(list[i].Key);\n     \
    \   }\n        return listOrdered;", "        var arrs = arr.ToArray();\n    \
    \    long[] arrss = new long[arrs.Length];\n        for (int i = 0; i < arrs.Length;\
    \ i++) {\n            arrss[i] = arrs[i];\n        }\n        var result = Sort(arrss);\n\
    \        List<long> resultl = new List<long>();\n        for (int i = 0; i < result.Length;\
    \ i++) {\n            resultl.Add(result[i]);\n        }\n        return resultl;",
  "        // List<long> retval = new List<long>();\n        // int one_count = 0;\n\
    \        // long ones_count_max = 0;\n        // long max_val = 0;\n        //\
    \ long ones_count_min = 0;\n        // long min_val = 0;\n        // long[] ones_count\
    \ = new long[arr.Count];\n        // long[] values = new long[arr.Count];\n  \
    \      // for (int i = 0; i < arr.Count; i++) {\n        //     for (int j = 0;\
    \ j < arr.Count; j++) {\n        //         one_count = 0;\n        //       \
    \  for (int k = 0; k < arr[j].ToString().Length; k++) {\n        //          \
    \   if (arr[j].ToString()[k] == '1') {\n        //                 one_count++;\n\
    \        //             }\n        //         }\n        //         ones_count[j]\
    \ = one_count;\n        //         values[j] = arr[j];\n        //     }\n   \
    \     //     ones_count_max = ones_count.Max();\n        //     max_val = arr.Max();\n\
    \        //     ones_count_min = ones_count.Min();\n        //     min_val = arr.Min();\n\
    \        //     if (ones_count_max == ones_count_min) {\n        //         retval.Add(arr.Min());\n\
    \        //         arr.Remove(arr.Min());\n        //     } else {\n        //\
    \         retval.Add(max_val);\n        //         arr.Remove(max_val);\n    \
    \    //     }\n        // }\n        // return retval;\n        return arr.OrderBy(i\
    \ => i.ToString().Count(x => x == '1')).ThenBy(i => i).ToList();", "        var\
    \ sortList = new List<long>(arr);\n        // var sortList = new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)2L, (long)3L, (long)4L});\n        for (int\
    \ i = 0; i < sortList.Count; i++) {\n            for (int j = 0; j < sortList.Count;\
    \ j++) {\n                // Console.WriteLine(i + \" \" + j);\n             \
    \   int a = NumberOfOnes(sortList[i]);\n                int b = NumberOfOnes(sortList[j]);\n\
    \                // Console.WriteLine(a + \" \" + b);\n                if (a <\
    \ b) {\n                    Swap(sortList, i, j);\n                } else if (a\
    \ == b) {\n                    if (sortList[i] < sortList[j]) {\n            \
    \            Swap(sortList, i, j);\n                    }\n                }\n\
    \            }\n        }\n        return sortList;", "        int[] bits = new\
    \ int[arr.Count];\n        for (int i = 0; i < arr.Count; i++) {\n           \
    \ bits[i] = Convert.ToString(arr[i], 2).Count(c => c == '1');\n        }\n   \
    \     for (int i = 0; i < arr.Count; i++) {\n            for (int j = 0; j < arr.Count\
    \ - 1; j++) {\n                if (bits[j] > bits[j + 1]) {\n                \
    \    Swap(ref bits[j], ref bits[j + 1]);\n                    Swap(ref arr[j],\
    \ ref arr[j + 1]);\n                } else if (bits[j] == bits[j + 1]) {\n   \
    \                 if (arr[j] > arr[j + 1]) {\n                        Swap(ref\
    \ arr[j], ref arr[j + 1]);\n                    }\n                }\n       \
    \     }\n        }\n        return arr;", '        return arr.OrderBy(v => CountOnes(v)).ThenBy(v
    => v).ToList();', "        // Convert each number to binary\n        // Put each\
    \ one in a tuple (Count of 1s, decimal number)\n        // Order by the tuple\
    \ in ascending order\n        // Return the decimal values\n        return arr.Select(x\
    \ => {\n            var binary = Convert.ToString(x, 2);\n            return (binary.Count(y\
    \ => y == '1'), x);\n        }).OrderBy(x => x.Item1).ThenBy(x => x.Item2).Select(x\
    \ => x.Item2).ToList();", "        // Sort the elements of the list based on number\
    \ of ones in binary\n        // representation, in ascending order.\n        //\
    \ For similar number of ones, sort based on decimal value.\n        arr.Sort((a,\
    \ b) => (getNumOnes(a) == getNumOnes(b)) ? a.CompareTo(b) : getNumOnes(a).CompareTo(getNumOnes(b)));\n\
    \        return arr;", "        // using System.Linq;\n        return arr.OrderBy(num\
    \ => num.ToString(\"X\").Replace(\"0\", \"\").Length).ThenBy(num => num).ToList();",
  "        return arr.OrderBy(x => Convert.ToString(x, 2).Count(y => y == '1')).ThenBy(x\
    \ => x).ToList();", "        return arr.OrderBy(i => i.ToString(\"X\").Count(c\
    \ => c == '1')).ThenBy(i => i).ToList();", "        var ones = new List<Tuple<int,\
    \ long>>();\n        var zeros = new List<Tuple<int, long>>();\n        foreach\
    \ (var val in arr) {\n            var count = val.ToString().Count(c => c == '1');\n\
    \            if (count == 0) {\n                zeros.Add(new Tuple<int, long>(val,\
    \ val));\n            } else {\n                ones.Add(new Tuple<int, long>(count,\
    \ val));\n            }\n        }\n        var oneList = ones.OrderBy(p => p.Item1).ThenBy(p\
    \ => p.Item2).Select(p => p.Item2).ToList();\n        var zeroList = zeros.OrderBy(p\
    \ => p.Item1).ThenBy(p => p.Item2).Select(p => p.Item2).ToList();\n        oneList.AddRange(zeroList);\n\
    \        return oneList;", '        return arr.OrderBy(v => v >= 0 ? new BitArray(BitConverter.GetBytes(v)).Cast<bool>().Count(b
    => b) : -1).ThenBy(v => v).ToList();', "        arr.Sort((left, right) => {\n\
    \            if (left == right) return 0;\n            var leftOnes = CountOnes(left);\n\
    \            var rightOnes = CountOnes(right);\n            if (leftOnes == rightOnes)\
    \ {\n                return left < right ? -1 : 1;\n            }\n          \
    \  return leftOnes < rightOnes ? -1 : 1;\n        });\n        return arr;", " \
    \       // Create a dictionary to store the number of ones as the key, and a list\
    \ as the value.\n        // The number of ones will not be more than the number\
    \ of bits, so the key will be a value between 0 and 64.\n        Dictionary<int,\
    \ List<long>> ones = new Dictionary<int, List<long>>();\n        // Get the number\
    \ of bits and create a new BigInteger.\n        int bits = sizeof(long) * 8;\n\
    \        BigInteger bi = new BigInteger();\n        // Iterate through the list,\
    \ adding the numbers to the dictionary,\n        // sorted by number of ones in\
    \ the binary representation.\n        foreach (long n in arr) {\n            //\
    \ Initialize the number of ones to 0.\n            int count = 0;\n          \
    \  // Convert the number to a BigInteger.\n            bi = n;\n            //\
    \ Iterate through the bits, checking if the bit is 1 or 0.\n            for (int\
    \ i = 0; i < bits; i++) {\n                if (bi % 2 == 1) {\n              \
    \      count++;\n                }\n                bi /= 2;\n            }\n\
    \            // If the key is not in the dictionary, create a new list.\n    \
    \        if (!ones.ContainsKey(count)) {\n                ones.Add(count, new\
    \ List<long>());\n            }\n            // Add the number to the dictionary.\n\
    \            ones[count].Add(n);\n        }\n        // Create a new list and\
    \ iterate through the dictionary to add each item in order.\n        List<long>\
    \ sorted = new List<long>();\n        foreach (KeyValuePair<int, List<long>> kvp\
    \ in ones) {\n            // Sort the list of numbers for the current key.\n \
    \           kvp.Value.Sort();\n            // Add the list of numbers to the sorted\
    \ list.\n            sorted.AddRange(kvp.Value);\n        }\n        // Return\
    \ the sorted list.\n        return sorted;", "        Dictionary<int, List<long>>\
    \ zeroes = new Dictionary<int, List<long>>();\n        Dictionary<int, List<long>>\
    \ ones = new Dictionary<int, List<long>>();\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            int count = CountOnes(arr[i]);\n            if (arr[i] >=\
    \ 0) {\n                if (!ones.ContainsKey(count)) {\n                    ones[count]\
    \ = new List<long>();\n                }\n                ones[count].Add(arr[i]);\n\
    \            } else {\n                if (!zeroes.ContainsKey(count)) {\n   \
    \                 zeroes[count] = new List<long>();\n                }\n     \
    \           zeroes[count].Add(arr[i]);\n            }\n        }\n        List<long>\
    \ ret = new List<long>();\n        foreach (var val in zeroes.Values) {\n    \
    \        ret.AddRange(val);\n        }\n        foreach (var val in ones.Values)\
    \ {\n            ret.AddRange(val);\n        }\n        return ret;", "      \
    \  var result = arr.Select(i => new { Count = CountOnesInBinary(i), Value = i\
    \ })\n            .OrderBy(x => x.Count)\n            .ThenBy(x => x.Value)\n\
    \            .Select(x => x.Value).ToList();\n        return result;", "     \
    \   arr.Sort((a, b) => {\n            var aOnes = Convert.ToString(a, 2).Count(c\
    \ => c == '1');\n            var bOnes = Convert.ToString(b, 2).Count(c => c ==\
    \ '1');\n            return aOnes == bOnes ? a.CompareTo(b) : aOnes.CompareTo(bOnes);\n\
    \        });\n        return arr;", "        // Sort the list first.\n       \
    \ arr.Sort();\n        // Create a list of tuples of (number of ones, value).\n\
    \        List<Tuple<int, long>> numbers = new List<Tuple<int, long>>();\n    \
    \    foreach (long n in arr) {\n            numbers.Add(new Tuple<int, long>(GetOnesCount(n),\
    \ n));\n        }\n        // Sort by ones then value.\n        numbers.Sort((a,\
    \ b) => {\n            int result = a.Item1.CompareTo(b.Item1);\n            if\
    \ (result == 0) {\n                result = a.Item2.CompareTo(b.Item2);\n    \
    \        }\n            return result;\n        });\n        // Recreate a list\
    \ from the sorted tuples.\n        List<long> result = new List<long>();\n   \
    \     foreach (Tuple<int, long> t in numbers) {\n            result.Add(t.Item2);\n\
    \        }\n        return result;", "        var ans = arr.ToArray();\n     \
    \   Array.Sort(ans, delegate(long a, long b) {\n            var sa = Convert.ToString(a,\
    \ 2);\n            var sb = Convert.ToString(b, 2);\n            int la = sa.Length;\n\
    \            int lb = sb.Length;\n            int cmp = la.CompareTo(lb);\n  \
    \          if (cmp != 0) {\n                return cmp;\n            }\n     \
    \       for (int i = 0; i < la; i++) {\n                cmp = (sa[i] - '0').CompareTo(sb[i]\
    \ - '0');\n                if (cmp != 0) {\n                    return cmp;\n\
    \                }\n            }\n            return 0;\n        });\n      \
    \  return ans.ToList();", "        var sorted = arr.OrderBy(x => x.ToString(\"\
    X\").Count(c => c == '1')).ThenBy(x => x);\n        var ret = new List<long>();\n\
    \        foreach (var x in sorted) {\n            ret.Add(x);\n        }\n   \
    \     return ret;", "        Dictionary<long, int> dict = new Dictionary<long,\
    \ int>();\n        foreach (long num in arr) {\n            if (dict.ContainsKey(num))\
    \ {\n                dict[num]++;\n            } else {\n                dict.Add(num,\
    \ 1);\n            }\n        }\n        var sortDict = dict.OrderBy(i => Convert.ToString(i.Key,\
    \ 2).Count(c => c == '1')).ThenBy(i => i.Key);\n        List<long> result = new\
    \ List<long>();\n        foreach (var kvp in sortDict) {\n            for (int\
    \ i = 0; i < kvp.Value; i++) {\n                result.Add(kvp.Key);\n       \
    \     }\n        }\n        return result;", '        return arr.OrderBy(k =>
    k.BitCount()).ThenBy(k => k).ToList();', "        return arr.OrderBy(x => HammingWeight(x))\n\
    \                  .ThenBy(x => x)\n                  .ToList();", "        //\
    \ Write your code here\n        return arr;", "        long[] a = arr.ToArray();\n\
    \        Array.Sort(a, (x, y) => {\n            int xn = (int)x, yn = (int)y;\n\
    \            int xb = 0, yb = 0;\n            for (int i = 0; i < 32; i++) {\n\
    \                xb += (xn >> i) & 1;\n                yb += (yn >> i) & 1;\n\
    \            }\n            if (xb != yb) {\n                return xb - yb;\n\
    \            }\n            else {\n                return (int)x - (int)y;\n\
    \            }\n        });\n        return new List<long>(a);", "        // Your\
    \ code is here...\n        List<long> ans = new List<long>();\n        if (arr.Count\
    \ == 0) return ans;\n        arr.Sort((x, y) => {\n            int xOnes = CountOnes(x);\n\
    \            int yOnes = CountOnes(y);\n            return (xOnes == yOnes) ?\
    \ x.CompareTo(y) : xOnes.CompareTo(yOnes);\n        });\n        return arr;",
  "        List<long> onesList = new List<long>();\n        List<long> sorted = new\
    \ List<long>();\n        for (int i = 0; i < arr.Count; i++) {\n            if\
    \ (IsOne(arr[i])) {\n                onesList.Add(arr[i]);\n            } else\
    \ {\n                sorted.Add(arr[i]);\n            }\n        }\n        onesList.Sort();\n\
    \        sorted.Sort();\n        sorted.Reverse();\n        foreach (long item\
    \ in onesList) {\n            sorted.Add(item);\n        }\n        return sorted;",
  "        return arr.OrderBy(x => CountSetBits(x))\n                  .ThenBy(x =>\
    \ x)\n                  .ToList();", "        return arr.OrderBy(i => BinaryHelper.Binary(i).Count(b\
    \ => b == '1')).ThenBy(i => i).ToList();", "        var result = arr.Select(x\
    \ => new { Decimal = x, Binary = Convert.ToString(x, 2) })\n            .Select(x\
    \ => new { Decimal = x.Decimal, Binary = x.Binary.Count(y => y == '1') })\n  \
    \          .GroupBy(x => x.Binary)\n            .OrderBy(x => x.Key)\n       \
    \     .SelectMany(x => x.OrderBy(y => y.Decimal))\n            .Select(x => x.Decimal)\n\
    \            .ToList();\n        return result;", "        List<long> result =\
    \ new List<long>();\n        int maxValue = arr.Max();\n        int maxBits =\
    \ Convert.ToString(maxValue, 2).Length;\n        for (int j = 0; j < maxBits;\
    \ j++) {\n            for (int i = 0; i < arr.Count; i++) {\n                if\
    \ (Convert.ToString(arr[i], 2).Length == j) {\n                    result.Add(arr[i]);\n\
    \                }\n            }\n        }\n        return result;", '        return
    arr.OrderBy(x => x.ToString("X"), new DecimalHexComparer()).ToList();', "    \
    \    return arr.OrderBy(x => \n        {\n            //If the number is negative\
    \ then invert it so it looks like a positive number.\n            long num = x\
    \ < 0 ? ~x : x;\n            return Convert.ToString(num, 2).Count(y => y == '1');\n\
    \        }).ThenBy(x => x).ToList();", "        arr.Sort((a, b) => {\n       \
    \     // high ones first\n            int aOnes = GetOnes(a);\n            int\
    \ bOnes = GetOnes(b);\n            if (aOnes != bOnes)\n                return\
    \ bOnes - aOnes;\n            return (int)a - (int)b;\n        });\n        return\
    \ arr;", '        return arr.OrderBy(x => x.ToString(), new BinaryOnesComparer()).ToList();',
  "        // The solution is to use an intermediate data structure to maintain the\
    \ relations of objects and\n        // then sort the intermediate data structure.\
    \ The intermediate data structure could be a list of\n        // tuples, or a\
    \ dictionary of lists, or even a list of classes.\n        // http://www.codewars.com/kata/reviews/557d12a588509eab1b00019a/groups/557f4b6478fe23fbd5002a63\n\
    \        // I tried using a class, but the class instance does not have a proper\
    \ sorting method.\n        // So I went for a dictionary.\n        // However,\
    \ I really dislike the way the dictionary looks in my solution.\n        //  I\
    \ think I should be able to do better.\n\n        // Idea:\n        // Have another\
    \ list to keep track of the count of 1s.\n        // Have another list to keep\
    \ track of the count of 0s.\n        // Loop through the list and add to the count\
    \ lists.\n        // Sort the count lists.\n        // Then loop through the count\
    \ lists and add the numbers to the main list.\n        // Sort the main list.\n\
    \        // Return the main list.\n\n        Dictionary<int, int> onesCountDict\
    \ = new Dictionary<int, int>();\n        Dictionary<int, int> zerosCountDict =\
    \ new Dictionary<int, int>();\n        List<int> finalList = new List<int>();\n\
    \        for (int i = 0; i < arr.Count; i++) {\n            int onesCount = GetNumberOfOnesInBinaryForm(arr[i]);\n\
    \            if (onesCountDict.ContainsKey(onesCount)) {\n                onesCountDict[onesCount]++;\n\
    \            } else {\n                onesCountDict.Add(onesCount, 1);\n    \
    \        }\n            int zerosCount = GetNumberOfZerosInBinaryForm(arr[i]);\n\
    \            if (zerosCountDict.ContainsKey(zerosCount)) {\n                zerosCountDict[zerosCount]++;\n\
    \            } else {\n                zerosCountDict.Add(zerosCount, 1);\n  \
    \          }\n        }\n        var sortedOnesCountDict = onesCountDict.OrderBy(x\
    \ => x.Key);", "        arr.Sort(delegate(long lhs, long rhs) {\n            int\
    \ lhsOnes = CountOnes(lhs);\n            int rhsOnes = CountOnes(rhs);\n     \
    \       if (lhsOnes == rhsOnes) {\n                return lhs.CompareTo(rhs);\n\
    \            }\n            return lhsOnes.CompareTo(rhsOnes);\n        });\n\
    \        return arr;", "        arr.Sort((x, y) => {\n            var count1 =\
    \ CountOnes(x);\n            var count2 = CountOnes(y);\n            if (count1\
    \ != count2) {\n                return count1.CompareTo(count2);\n           \
    \ }\n            return x.CompareTo(y);\n        });\n        return arr;", " \
    \       // Your code here\n        Console.WriteLine(arr.Count);\n        return\
    \ arr;", "        return arr.OrderBy(x => {\n            // \u5BFE\u8C61\u306E\
    \u30D3\u30C3\u30C8\u6570\n            int keta = 64;\n            // \u30D3\u30C3\
    \u30C8\u6570\u3067\u30EB\u30FC\u30D7\u3059\u308B\n            for (int i = keta;\
    \ i > 0; i--) {\n                // \u53F3\u306B\u30B7\u30D5\u30C8\u3057\u3066\
    1\u306E\u30D3\u30C3\u30C8\u3068\u8AD6\u7406\u7A4D\n                // \u305D\u306E\
    \u30D3\u30C3\u30C8\u304C1\u3067\u3042\u308C\u30701\u304C\u7D9A\u304F\u3068\u89E3\
    \u91C8\n                // 1\u304C\u7D9A\u304F\u3053\u3068\u3092\u6709\u52B9\u306B\
    \u3059\u308B\u305F\u3081\u306E\u30D3\u30C3\u30C8\u30DE\u30B9\u30AF\n         \
    \       // \u6307\u5B9A\u306E\u30D3\u30C3\u30C8\u6570\u306E\u53F3\u306B\u7D9A\u304F\
    1\u306E\u30D3\u30C3\u30C8\u6570\n                // \u3053\u306E\u5024\u304C0\u306B\
    \u306A\u308B\u3068i\u304C0\u306B\u306A\u308B\u307E\u3067\u7D9A\u304F\n       \
    \         // 1\u304C\u7D9A\u304F\u3053\u3068\u3092\u6709\u52B9\u306B\u3059\u308B\
    \u305F\u3081\u306E\u30D3\u30C3\u30C8\u30DE\u30B9\u30AF\n                // \u6307\
    \u5B9A\u306E\u30D3\u30C3\u30C8\u6570\u306E\u53F3\u306B\u7D9A\u304F1\u306E\u30D3\
    \u30C3\u30C8\u6570\n                // \u3053\u306E\u5024\u304C0\u306B\u306A\u308B\
    \u3068i\u304C0\u306B\u306A\u308B\u307E\u3067\u7D9A\u304F\n                if ((x\
    \ >> i & 1) != 0) {\n                    // 1\u304C\u7D9A\u304F\u30D3\u30C3\u30C8\
    \u6570\n                    int cnt = i;\n                    // \u307E\u3060\
    1\u304C\u7D9A\u304F\u5834\u5408\n                    while (cnt > 0) {\n     \
    \                   // 1\u30D3\u30C3\u30C8\u53F3\u306B\u30B7\u30D5\u30C8\n   \
    \                     x >>= 1;\n                        // \u3053\u306E\u30D3\u30C3\
    \u30C8\u30821\u3067\u3042\u308C\u3070\u7D9A\u304F\n                        if\
    \ ((x & 1) != 0) {\n                            // 1\u304C\u7D9A\u304F\n     \
    \                       cnt--;\n                        } else {\n           \
    \                 // 1\u304C\u7D9A\u304B\u306A\u3044\n                       \
    \     break;\n                        }\n                    }\n             \
    \       // 1\u304C\u7D9A\u304F\u30D3\u30C3\u30C8\u6570\u3092\u8FD4\u3059\n   \
    \                 return cnt;\n                }\n            }\n            //\
    \ \u5168\u30D3\u30C3\u30C8\u304C0\u3067\u3042\u308C\u30700\u3092\u8FD4\u3059\n\
    \            return 0;\n        }).ThenBy(x => x).ToList();", "        arr.Sort((x,\
    \ y) => {\n            var b1 = Convert.ToString(x, 2);\n            var b2 =\
    \ Convert.ToString(y, 2);\n            var ones1 = b1.Count(c => c == '1');\n\
    \            var ones2 = b2.Count(c => c == '1');\n            if (ones1 != ones2)\
    \ {\n                return ones1.CompareTo(ones2);\n            }\n         \
    \   return x.CompareTo(y);\n        });\n        return arr;", '        return
    arr.OrderBy(a => CountOnes(a)).ThenBy(a => a).ToList();', "        return arr.OrderBy(l\
    \ => Convert.ToString(l, 2).Count(c => c == '1')).ThenBy(l => l).ToList();", " \
    \       // your code here.\n        //IEnumerable<long> solution = arr.Where(x\
    \ => x >= 0).OrderBy(x => Convert.ToString(x, 2).Count(y => y == '1')).ThenBy(x\
    \ => x);\n        return arr.Where(x => x >= 0).OrderBy(x => Convert.ToString(x,\
    \ 2).Count(y => y == '1')).ThenBy(x => x).ToList();", "        var myarr = new\
    \ List<List<long>>();\n        for (var i = 0; i < arr.Count; i++) {\n       \
    \     var ones = arr[i] >= 0 ? CountOnes(arr[i]) : -CountOnes(-arr[i]);\n    \
    \        var decim = arr[i] >= 0 ? arr[i] : -arr[i];\n            myarr.Add(new\
    \ List<long>() { decim, ones, arr[i] });\n        }\n        myarr.Sort(new Comparison<List<long>>((a,\
    \ b) => {\n            if (a[1] > b[1]) return 1;\n            if (a[1] < b[1])\
    \ return -1;\n            if (a[0] > b[0]) return 1;\n            if (a[0] < b[0])\
    \ return -1;\n            return 0;\n        }));\n        var result = new List<long>();\n\
    \        for (var i = 0; i < myarr.Count; i++) {\n            result.Add(myarr[i][2]);\n\
    \        }\n        return result;", "        arr.Sort((i, j) => {\n         \
    \   var n = i.ToString(\"B\").Length - j.ToString(\"B\").Length;\n           \
    \ if (n == 0) {\n                return i.CompareTo(j);\n            }\n     \
    \       return n;\n        });\n        return arr;", "        arr.Sort((long\
    \ a, long b) => {\n            var binA = Convert.ToString(a, 2);\n          \
    \  var binB = Convert.ToString(b, 2);\n            var onesA = binA.Count(c =>\
    \ c == '1');\n            var onesB = binB.Count(c => c == '1');\n           \
    \ if (onesA != onesB) {\n                return onesA.CompareTo(onesB);\n    \
    \        }\n            return a.CompareTo(b);\n        });\n        return arr;",
  "        // Your code here\n        List<long> result = new List<long>();\n    \
    \    int minBitLength = int.MaxValue;\n        foreach (long x in arr) {\n   \
    \         int bitLength = BitLength(x);\n            if (bitLength < minBitLength)\
    \ {\n                minBitLength = bitLength;\n            }\n        }\n   \
    \     for (int i = 0; i < minBitLength; i++) {\n            result.AddRange(arr.Where(v\
    \ => BitGet(v, i)).OrderBy(v => v));\n            result.AddRange(arr.Where(v\
    \ => !BitGet(v, i)).OrderBy(v => v));\n        }\n        result.AddRange(arr.Where(v\
    \ => BitLength(v) == minBitLength).OrderBy(v => v));\n        return result;",
  '        return arr.OrderBy(x => x == 0 ? 0 : BitCount(Math.Abs(x))).ThenBy(x =>
    x).ToList();', "        arr.Sort((a, b) => {\n            int c = CountBits(a).CompareTo(CountBits(b));\n\
    \            if (c == 0) {\n                return a.CompareTo(b);\n         \
    \   }\n            return c;\n        });\n        return arr;", "        arr.Sort(BinaryCompare);\n\
    \        return arr;", "        arr.Sort(SortByBinaryRepresentation);\n      \
    \  return arr;", "        for (int k = 0; k < arr.Count - 1; k++) {\n        \
    \    for (int i = 0; i < arr.Count - 1; i++) {\n                if (getOnes(arr[i])\
    \ > getOnes(arr[i + 1])) {\n                    long tmp = arr[i];\n         \
    \           arr[i] = arr[i + 1];\n                    arr[i + 1] = tmp;\n    \
    \            } else if (getOnes(arr[i]) == getOnes(arr[i + 1])) {\n          \
    \          if (arr[i] > arr[i + 1]) {\n                        long tmp = arr[i];\n\
    \                        arr[i] = arr[i + 1];\n                        arr[i +\
    \ 1] = tmp;\n                    }\n                }\n            }\n       \
    \ }\n        return arr;", "        // Sort the list, so that any elements with\
    \ the same number of\n        // ones are adjacent to each other, and then convert\
    \ the list\n        // to a sequence of tuples (number of ones, element)\n   \
    \     var sorted = arr.OrderBy(x => CountOnes(x));\n        var sortedTuples =\
    \ sorted.Select(x => Tuple.Create(CountOnes(x), x));\n        // Group the tuples\
    \ by their number of ones, so that each group is\n        // a sequence of tuples\
    \ with the same number of ones.\n        var groups = sortedTuples.GroupBy(x =>\
    \ x.Item1);\n        // Sort each group by the second element of each tuple, so\
    \ that the\n        // elements within each group are sorted based on their decimal\
    \ value.\n        var sortedGroups = groups.Select(g => g.OrderBy(t => t.Item2));\n\
    \        // Flatten the groups into a single sequence and return the second\n\
    \        // elements of each tuple (which are the actual list elements)\n    \
    \    return sortedGroups.SelectMany(x => x).Select(x => x.Item2).ToList();", " \
    \       for (int i = 0; i < arr.Count; i++) {\n            for (int j = i + 1;\
    \ j < arr.Count; j++) {\n                if (Compare(arr[i], arr[j]) > 0) {\n\
    \                    var x = arr[i];\n                    arr[i] = arr[j];\n \
    \                   arr[j] = x;\n                }\n            }\n        }\n\
    \        return arr;", "        List<long> res = new List<long>();\n        Dictionary<int,\
    \ List<long>> dic = new Dictionary<int, List<long>>();\n        foreach (long\
    \ num in arr) {\n            int ones = GetNumberOfOnes(num);\n            if\
    \ (!dic.ContainsKey(ones)) {\n                dic.Add(ones, new List<long>());\n\
    \            }\n            dic[ones].Add(num);\n        }\n        foreach (KeyValuePair<int,\
    \ List<long>> pair in dic) {\n            pair.Value.Sort();\n            res.AddRange(pair.Value);\n\
    \        }\n        return res;", "        //arr.Sort((a, b) => {\n        //\
    \    var aInt = (int)a;\n        //    var bInt = (int)b;\n        //    return\
    \ BitCount(aInt) == BitCount(bInt) ? aInt.CompareTo(bInt) : BitCount(aInt).CompareTo(BitCount(bInt));\n\
    \        //});\n        //return arr;\n        arr.Sort((a, b) => {\n        \
    \    var aInt = (int)a;\n            var bInt = (int)b;\n            return BitCount(aInt)\
    \ == BitCount(bInt) ? aInt.CompareTo(bInt) : BitCount(aInt).CompareTo(BitCount(bInt));\n\
    \        });\n        return arr;", "        var sorted = new SortedDictionary<long,\
    \ long[]>();\n        foreach (var x in arr) {\n            var bin = Convert.ToString(x,\
    \ 2);\n            var ones = bin.Count(c => c == '1');\n            if (!sorted.ContainsKey(ones))\
    \ {\n                sorted[ones] = new long[arr.Count];\n            }\n    \
    \        sorted[ones][x] = x;\n        }\n        var result = new List<long>();\n\
    \        foreach (var kvp in sorted) {\n            foreach (var x in kvp.Value)\
    \ {\n                if (x != 0) {\n                    result.Add(x);\n     \
    \           }\n            }\n        }\n        return result;", "        List<Tuple<long,\
    \ long>> res = new List<Tuple<long, long>>();\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            long val = arr[i];\n            long ones = 0;\n       \
    \     while (val > 0) {\n                ones += val % 2;\n                val\
    \ /= 2;\n            }\n            res.Add(new Tuple<long, long>(ones, arr[i]));\n\
    \        }\n        res.Sort((a, b) => {\n            if (a.Item1 != b.Item1)\
    \ {\n                return a.Item1.CompareTo(b.Item1);\n            }\n     \
    \       return a.Item2.CompareTo(b.Item2);\n        });\n        List<long> result\
    \ = new List<long>();\n        for (int i = 0; i < res.Count; i++) {\n       \
    \     result.Add(res[i].Item2);\n        }\n        return result;", '        return
    arr.OrderBy(x => x < 0 ? int.MaxValue : (int)Math.Ceiling(Math.Log(x + 1, 2))).ThenBy(x
    => x).ToList();', "        var oneCount = new int[arr.Count];\n        var original\
    \ = new long[arr.Count];\n        for (int i = 0; i < arr.Count; i++) {\n    \
    \        var a = arr[i];\n            if (a == 0) {\n                oneCount[i]\
    \ = 0;\n                original[i] = 0;\n            } else {\n             \
    \   var one = 0;\n                while (a > 0) {\n                    one +=\
    \ a & 1;\n                    a >>= 1;\n                }\n                oneCount[i]\
    \ = one;\n                original[i] = arr[i];\n            }\n        }\n  \
    \      Array.Sort(oneCount, original);\n        return new List<long>(original);",
  "        List<long> result = new List<long>();\n        foreach (var num in arr)\
    \ {\n            result.Add(num);\n        }\n        result.Sort((a, b) => {\n\
    \            var first = (int)a;\n            var second = (int)b;\n         \
    \   var diff = GetBits(first) - GetBits(second);\n            if (diff == 0) {\n\
    \                diff = first - second;\n            }\n            return diff;\n\
    \        });\n        return result;", "        // The ultimate sorting\n    \
    \    return arr.OrderBy(e => CountOnes(e)).ThenBy(e => e).ToList();", "      \
    \  return arr.OrderBy(x => Convert.ToString(x, 2).Count(y => y == '1')).ThenBy(x\
    \ => x).ToList();", "        // your code here\n        return null;", "     \
    \   // Write your code here\n        // Assuming the integers in the list are\
    \ non-negative.\n        // Assuming the integers in the list are all in the range\
    \ of Int64.\n        var list = arr.Select(x => new Tuple<long, string>(x, Convert.ToString(x,\
    \ 2))).ToList();\n        list.Sort((x, y) =>\n        {\n            var r =\
    \ x.Item2.Count(c => c == '1') - y.Item2.Count(c => c == '1');\n            if\
    \ (r != 0)\n                return r;\n            return (int)(x.Item1 - y.Item1);\n\
    \        });\n        return list.Select(x => x.Item1).ToList();", "        return\
    \ arr.OrderBy(x => Convert.ToString(x, 2).Count(y => y == '1')).ThenBy(x => x).ToList();",
  "        // write code here\n        arr.Sort(delegate(long a, long b) {\n     \
    \       int counta = 0;\n            int countb = 0;\n            int digit =\
    \ 0;\n            while (digit < 64) {\n                if (((1L << digit) & a)\
    \ > 0) {\n                    counta++;\n                }\n                if\
    \ (((1L << digit) & b) > 0) {\n                    countb++;\n               \
    \ }\n                digit++;\n            }\n            if (counta == countb)\
    \ {\n                return a.CompareTo(b);\n            }\n            return\
    \ counta.CompareTo(countb);\n        });\n        return arr;", "        Dictionary<int,\
    \ List<long>> dict = new Dictionary<int, List<long>>();\n        for (int i =\
    \ 0; i < arr.Count; i++) {\n            int ones = BitCount(arr[i]);\n       \
    \     if (!dict.ContainsKey(ones)) {\n                dict[ones] = new List<long>();\n\
    \            }\n            dict[ones].Add(arr[i]);\n        }\n        var sorted\
    \ = dict.OrderBy(kvp => kvp.Key);\n        List<long> result = new List<long>();\n\
    \        foreach (var kvp in sorted) {\n            result.AddRange(kvp.Value.OrderBy(x\
    \ => x));\n        }\n        return result;", "        // from the start of arr,\
    \ \n        // look for elements that have the same number of \"1\"s\n       \
    \ // and put them in the result list\n\n        // if the element to be added\
    \ has more \"1\"s than the elements in the result list,\n        // put it at\
    \ the end\n\n        // if the element to be added has less \"1\"s than the elements\
    \ in the result list,\n        // put it at the appropriate index\n        var\
    \ result = new List<long>();\n        foreach (var num in arr) {\n           \
    \ var ones = BitCount(num);\n            var index = 0;\n            foreach (var\
    \ r in result) {\n                if (BitCount(r) < ones) {\n                \
    \    index++;\n                } else {\n                    break;\n        \
    \        }\n            }\n            result.Insert(index, num);\n        }\n\
    \        return result;", "        // sort by number of 1s, then by value\n  \
    \      return arr.OrderBy(x => Convert.ToString(x, 2).Count(c => c == '1')).ThenBy(x\
    \ => x).ToList();", "        arr.Sort((a, b) => {\n            var aOnes = OneCount(a);\n\
    \            var bOnes = OneCount(b);\n            if (aOnes == bOnes) {\n   \
    \             return a.CompareTo(b);\n            }\n            return aOnes.CompareTo(bOnes);\n\
    \        });\n        return arr;", "        // Your code here\n        if (arr\
    \ == null)\n            return null;\n        List<long> res = new List<long>();\n\
    \        List<long> res2 = new List<long>();\n        foreach (long i in arr)\
    \ {\n            if (i >= 0)\n                res.Add(i);\n            else\n\
    \                res2.Add(i);\n        }\n        res.Sort((a, b) => {\n     \
    \       if (OneInBinary(a) == OneInBinary(b))\n                return a.CompareTo(b);\n\
    \            else\n                return OneInBinary(a).CompareTo(OneInBinary(b));\n\
    \        });\n        res2.Sort((a, b) => {\n            if (OneInBinary(a) ==\
    \ OneInBinary(b))\n                return a.CompareTo(b);\n            else\n\
    \                return OneInBinary(a).CompareTo(OneInBinary(b));\n        });\n\
    \        res2.Reverse();\n        res.AddRange(res2);\n        return res;", " \
    \       Dictionary<long, long> ones = new Dictionary<long, long>();\n        for\
    \ (int i = 0; i < arr.Count; i++) {\n            if (arr[i] < 0) continue;\n \
    \           long key = 0;\n            long num = arr[i];\n            while (num\
    \ > 0) {\n                key += num % 2;\n                num /= 2;\n       \
    \     }\n            if (ones.ContainsKey(key)) {\n                ones[key] +=\
    \ (long)Math.Pow(10, numOfDigits(arr[i]));\n            } else {\n           \
    \     ones[key] = (long)Math.Pow(10, numOfDigits(arr[i]));\n            }\n  \
    \      }\n        ones = ones.OrderBy(x => x.Key).ToDictionary(x => x.Key, x =>\
    \ x.Value);\n        List<long> l = new List<long>();\n        foreach (var item\
    \ in ones) {\n            long num = item.Value;\n            long digits = numOfDigits(num);\n\
    \            long key = item.Key;\n            for (int i = 0; i < digits; i++)\
    \ {\n                l.Add(num % 10);\n                num /= 10;\n          \
    \  }\n        }\n        int pos = 0;\n        for (int i = 0; i < arr.Count;\
    \ i++) {\n            if (arr[i] < 0) {\n                l.Insert(pos, arr[i]);\n\
    \                pos++;\n            }\n        }\n        return l;", "     \
    \   arr.Sort((a, b) => {\n            var ones_a = Convert.ToString(a, 2).Count(x\
    \ => x == '1');\n            var ones_b = Convert.ToString(b, 2).Count(x => x\
    \ == '1');\n            if (ones_a == ones_b) {\n                return (int)a\
    \ - (int)b;\n            }\n            return ones_a - ones_b;\n        });\n\
    \        return arr;", "        List<long> results = new List<long>();\n     \
    \   var sorted = arr.OrderBy(x => CountBits(x)).ToList();\n        for (var i\
    \ = sorted.Count - 1; i >= 0; i--) {\n            if (CountBits(sorted[i]) % 2\
    \ == 0) {\n                results.Add(sorted[i]);\n            } else {\n   \
    \             results.Insert(0, sorted[i]);\n            }\n        }\n      \
    \  return results;", "        arr.Sort((a, b) => {\n            var binA = BigInteger.Parse(Convert.ToString(a,\
    \ 2));\n            var binB = BigInteger.Parse(Convert.ToString(b, 2));\n   \
    \         return binA.ToString().Count(c => c == '1').CompareTo(binB.ToString().Count(c\
    \ => c == '1'));\n        });\n        return arr;", "        arr.Sort((x, y)\
    \ => {\n            if (x < 0 && y < 0) {\n                return (int)(x - y);\n\
    \            }\n            return (int)(Bits(x) - Bits(y));\n        });\n  \
    \      return arr;", "        arr.Sort(delegate(long a, long b) {\n          \
    \  int A = CountOnes(a);\n            int B = CountOnes(b);\n            if (A\
    \ == B) {\n                return (int) (a - b);\n            }\n            return\
    \ A - B;\n        });\n        return arr;", "        List<long> sorted = new\
    \ List<long>();\n        long len = arr.Count;\n        for (long i = 0; i < len;\
    \ i++) {\n            sorted.Add(arr[(int)i]);\n        }\n        sorted.Sort((x,\
    \ y) => CountOnes(x).CompareTo(CountOnes(y)));\n        return sorted;", "   \
    \     arr.Sort((a, b) => {\n            int aOnes = a == 0 ? 0 : Convert.ToString(a,\
    \ 2).Count(c => c == '1');\n            int bOnes = b == 0 ? 0 : Convert.ToString(b,\
    \ 2).Count(c => c == '1');\n            return aOnes == bOnes ? Math.Sign(a -\
    \ b) : aOnes - bOnes;\n        });\n        return arr;", '        return arr.OrderBy(num
    => GetOnesCount(num)).ThenBy(num => num).ToList();', "        var pairs = arr.Select(n\
    \ => Tuple.Create(n, n.ToString(\"X\").Count(x => x == '1'))).ToList();\n    \
    \    pairs.Sort((a, b) =>\n            a.Item2 != b.Item2 ? a.Item2.CompareTo(b.Item2)\
    \ : a.Item1.CompareTo(b.Item1));\n        return pairs.Select(p => p.Item1).ToList();",
  "        // The input is not valid: contains negative value\n        if (arr.Any(a\
    \ => a < 0)) {\n            throw new ArgumentException();\n        }\n      \
    \  // Get the decimal and binary value for each number\n        arr = arr.Select(a\
    \ => {\n            var val = (decimal: a, binary: Convert.ToString(a, 2));\n\
    \            return val;\n        }).ToList();\n        // Sort in reverse order\
    \ of number of 1s in their binary representation\n        arr = arr.OrderByDescending(a\
    \ => a.binary.Count(c => c == '1')).ThenBy(a => a.decimal).ToList();\n       \
    \ // Return the decimal values\n        return arr.Select(a => a.decimal).ToList();",
  "        Dictionary<long, long> dic = new Dictionary<long, long>();\n        int\
    \ n = arr.Count;\n        for (int i = 0; i < n; i++) {\n            long num\
    \ = arr[i];\n            long bits = 0;\n            while (num > 0) {\n     \
    \           bits += num % 2;\n                num /= 2;\n            }\n     \
    \       if (!dic.ContainsKey(bits)) {\n                dic.Add(bits, 1);\n   \
    \         } else {\n                dic[bits] += 1;\n            }\n        }\n\
    \        List<long>[] arr_bits = new List<long>[dic.Count];\n        int i_a =\
    \ 0;\n        foreach (KeyValuePair<long, long> kvp in dic) {\n            arr_bits[i_a]\
    \ = new List<long>();\n            arr_bits[i_a].Add(kvp.Key);\n            arr_bits[i_a].Add(kvp.Value);\n\
    \            i_a++;\n        }\n        Array.Sort(arr_bits, delegate (List<long>\
    \ x, List<long> y) {\n            if (x[0] < y[0]) return -1;\n            if\
    \ (x[0] > y[0]) return 1;\n            return 0;\n        });\n        List<long>\
    \ sorted = new List<long>();\n        for (int i = 0; i < dic.Count; i++) {\n\
    \            for (int j = 0; j < arr_bits[i][1]; j++) {\n                sorted.Add(arr[j]);\n\
    \            }\n            int k = 0;\n            for (int j = (int)arr_bits[i][1];\
    \ j < n; j++) {\n                sorted.Add(arr[j]);\n                arr[k] =\
    \ arr[j];\n                k++;\n            }\n            n -= (int)arr_bits[i][1];\n\
    \        }\n        return sorted;", "        // Your code here\n        return\
    \ arr;", "        //\n        // This is not a good solution, I just wanted to\
    \ try to learn how to use\n        // sort and compare in c#. It doesn't work\
    \ for values with more than 63\n        // bits and since this is long, it only\
    \ counts 32 bits.\n        //\n        arr.Sort((left, right) => {\n         \
    \   var sleft = Convert.ToString(left, 2);\n            var sright = Convert.ToString(right,\
    \ 2);\n            if (sleft.Where(ch => ch == '1').Count() == sright.Where(ch\
    \ => ch == '1').Count()) {\n                return left.CompareTo(right);\n  \
    \          }\n            return sleft.Where(ch => ch == '1').Count().CompareTo(sright.Where(ch\
    \ => ch == '1').Count());\n        });\n        return arr;", '        return
    arr.OrderBy(x => GetOneCount(x)).ThenBy(x => x).ToList();', "        int[] sort_list\
    \ = arr.Select(BitConverter.GetBytes).Select(b => b.Where(byte_ => byte_ == 1).Count()).ToArray();\n\
    \        int[] index_list = new int[arr.Count];\n        for (int i = 0; i < arr.Count;\
    \ i++) index_list[i] = i;\n        Array.Sort(sort_list, index_list);\n      \
    \  int j = 0;\n        for (int i = 1; i < sort_list.Length; i++) {\n        \
    \    if (sort_list[i] == sort_list[i - 1]) continue;\n            Array.Sort(arr.ToArray(),\
    \ index_list[j], i - j);\n            j = i;\n        }\n        Array.Sort(arr.ToArray(),\
    \ index_list[j], arr.Count - j);\n        return arr;", "        Dictionary<long,\
    \ long> hashtable = new Dictionary<long, long>();\n        foreach (long n in\
    \ arr) {\n            long i = n;\n            long b = 0;\n            while\
    \ (i > 0) {\n                b += i % 2;\n                i /= 2;\n          \
    \  }\n            hashtable[n] = b;\n        }\n        arr.Sort((a, b) => {\n\
    \            if (hashtable[a] < hashtable[b]) return -1;\n            if (hashtable[a]\
    \ > hashtable[b]) return 1;\n            if (a < b) return -1;\n            if\
    \ (a > b) return 1;\n            return 0;\n        });\n        return arr;",
  '        return arr.OrderBy(x => BitCount(x)).ThenBy(x => x).ToList();', "     \
    \   //return arr.OrderBy(n => Convert.ToString(n, 2).Count(c => c == '1')).ThenBy(n\
    \ => n).ToList();\n        return arr.OrderBy(n => Convert.ToString(n, 2).Count(c\
    \ => c == '1')).ThenBy(n => n).ToList();", "        List<long> outlist = new List<long>();\n\
    \        var myDict = new Dictionary<long, int>();\n        int count = 0;\n \
    \       // dictionary to hold number of 1's\n        foreach (long item in arr)\
    \ {\n            if (item > 0) {\n                count = 0;\n               \
    \ while (item > 0) {\n                    count++;\n                    item =\
    \ item / 2;\n                }\n                myDict.Add(item, count);\n   \
    \         }\n        }\n        foreach (long x in arr) {\n            // if you\
    \ have a number with more ones than another number, put it first\n           \
    \ // if you have a number with the same number of ones as another number,\n  \
    \          // put the smaller number first. If a number has zero ones, just put\
    \ it\n            // at the end of the list\n            if (myDict[x] > 0) {\n\
    \                // if the list is empty, or you have more ones than any other\
    \ number\n                // already in the list, place the number at the beginning\n\
    \                if (outlist.Count == 0 || myDict[x] > myDict[outlist[0]]) {\n\
    \                    outlist.Insert(0, x);\n                }\n              \
    \  // otherwise, go through the list to find where it should go\n            \
    \    else {\n                    for (int i = 1; i < outlist.Count; i++) {\n \
    \                       // if the number of ones of the number is less than the\
    \ number\n                        // in the list, insert the number in that position\n\
    \                        if (myDict[x] < myDict[outlist[i]]) {\n             \
    \               outlist.Insert(i, x);\n                            break;\n  \
    \                      }\n                        // if the number of ones of\
    \ the number is equal to the number\n                        // in the list, and\
    \ the number is smaller than the number in the\n                        // list,\
    \ insert the number in that position\n                        else if (myDict[x]\
    \ == myDict[outlist[i]] && x < outlist[i]) {\n                            outlist.Insert(i,\
    \ x);\n                            break;\n                        }\n       \
    \                 // otherwise, go to the next number in the list\n          \
    \              else {\n                            continue;\n               \
    \         }\n                    }\n               ", "        // TODO\n     \
    \   return null;", "        var result = arr.Select(x => Tuple.Create(x, HammingWeight(x))).OrderBy(x\
    \ => x.Item2).ThenBy(x => x.Item1).Select(x => x.Item1).ToList();\n        return\
    \ result;", "        return arr.OrderBy(item => Convert.ToString(item, 2), new\
    \ Comparison<string>((s1, s2) => {\n            if (s1.Count(c => c == '1') <\
    \ s2.Count(c => c == '1')) {\n                return -1;\n            } else if\
    \ (s1.Count(c => c == '1') > s2.Count(c => c == '1')) {\n                return\
    \ 1;\n            } else {\n                if (s1.CompareTo(s2) < 0) {\n    \
    \                return -1;\n                } else if (s1.CompareTo(s2) > 0)\
    \ {\n                    return 1;\n                } else {\n               \
    \     return 0;\n                }\n            }\n        })).ToList();", " \
    \       var sorted = from num in arr\n                     orderby Convert.ToString(num,\
    \ 2).Count(x => x == '1'), num\n                     select num;\n        return\
    \ sorted.ToList();", "        //// sorter func. sort by ones\n        //var list\
    \ = arr.Select(x => {\n        //    var bits = new BitArray(BitConverter.GetBytes(x)).Cast<bool>().ToArray();\n\
    \        //    return new {\n        //        count = bits.Count(b => b),\n \
    \       //        value = x\n        //    };\n        //}).OrderBy(x => x.count).ThenBy(x\
    \ => x.value).ToList();\n        //return list.Select(x => x.value).ToList();\n\
    \n        //// hacky solution\n        //var list = arr.Select(x => {\n      \
    \  //    var bits = new BitArray(BitConverter.GetBytes(x)).Cast<bool>().ToArray();\n\
    \        //    return new {\n        //        count = bits.Count(b => b),\n \
    \       //        value = x\n        //    };\n        //}).OrderBy(x => x.count).ThenBy(x\
    \ => x.value).ToList();\n        //return list.Select(x => x.value).ToList();\n\
    \n        //// working solution\n        //var list = arr.Select(x => {\n    \
    \    //    var bits = new BitArray(BitConverter.GetBytes(x)).Cast<bool>().ToArray();\n\
    \        //    return new {\n        //        count = bits.Count(b => b),\n \
    \       //        value = x\n        //    };\n        //}).OrderBy(x => x.count).ThenBy(x\
    \ => x.value).ToList();\n        //return list.Select(x => x.value).ToList();\n\
    \n        //// working solution\n        //var list = arr.Select(x => {\n    \
    \    //    var bits = new BitArray(BitConverter.GetBytes(x)).Cast<bool>().ToArray();\n\
    \        //    return new {\n        //        count = bits.Count(b => b),\n \
    \       //        value = x\n        //    };\n        //}).OrderBy(x => x.count).ThenBy(x\
    \ => x.value).ToList();\n        //return list.Select(x => x.value).ToList();\n\
    \n        //// working solution\n        //var", "        arr.Sort(\n        \
    \    (a, b) => {\n                var bitA = Convert.ToString(a, 2);\n       \
    \         var bitB = Convert.ToString(b, 2);\n                var countA = bitA.Count(x\
    \ => x == '1');\n                var countB = bitB.Count(x => x == '1');\n   \
    \             if (countA == countB) {\n                    return a.CompareTo(b);\n\
    \                }\n                return countA.CompareTo(countB);\n       \
    \     }\n        );\n        return arr;", "        arr.Sort((a, b) => (new OnesAndDecimals(a)).CompareTo(new\
    \ OnesAndDecimals(b)));\n        return arr;", "        // This sortArray function\
    \ uses the custom IComparer defined below\n        arr.Sort(new SortByNumberOfOnes());\n\
    \        return arr;", "        return arr.OrderBy(x => CountOnes(x))\n      \
    \            .ThenBy(x => x)\n                  .ToList();", "        int[] ones\
    \ = new int[arr.Count];\n        for (int i = 0; i < arr.Count; i++) {\n     \
    \       ones[i] = (int)toOnes(arr[i]);\n        }\n        return quicksort(arr,\
    \ ones, 0, arr.Count - 1);", "        if (arr == null) {\n            return null;\n\
    \        }\n        arr.Sort((x, y) => {\n            long xones = CountBits(x);\n\
    \            long yones = CountBits(y);\n            if (xones < yones) {\n  \
    \              return -1;\n            } else if (xones > yones) {\n         \
    \       return 1;\n            } else {\n                return x.CompareTo(y);\n\
    \            }\n        });\n        return arr;", "        // your code here\n\
    \        long[] onesList = new long[arr.Count];\n        int[] indexList = new\
    \ int[arr.Count];\n        long[] sortedOnesList = new long[arr.Count];\n    \
    \    long[] reorderedList = new long[arr.Count];\n        int[] reorderedIndexList\
    \ = new int[arr.Count];\n        int listLength = 0;\n        long tempLong =\
    \ 0;\n        int tempInt = 0;\n        for (int i = 0; i < arr.Count; i++) {\n\
    \            onesList[i] = arr[i];\n            sortedOnesList[i] = arr[i];\n\
    \            indexList[i] = i;\n            listLength = i;\n        }\n     \
    \   for (int i = 0; i < listLength; i++) {\n            for (int j = 0; j < listLength;\
    \ j++) {\n                if (onesList[i] < onesList[j]) {\n                 \
    \   tempLong = onesList[i];\n                    onesList[i] = onesList[j];\n\
    \                    onesList[j] = tempLong;\n                    tempInt = indexList[i];\n\
    \                    indexList[i] = indexList[j];\n                    indexList[j]\
    \ = tempInt;\n                }\n            }\n        }\n        for (int i\
    \ = 0; i < listLength; i++) {\n            onesList[i] = Ones(onesList[i]);\n\
    \        }\n        for (int i = 0; i < listLength; i++) {\n            for (int\
    \ j = 0; j < listLength; j++) {\n                if (onesList[i] < onesList[j])\
    \ {\n                    tempLong = onesList[i];\n                    onesList[i]\
    \ = onesList[j];\n                    onesList[j] = tempLong;\n              \
    \      tempInt = indexList[i];\n                    indexList[i] = indexList[j];\n\
    \                    indexList[j] = tempInt;\n                }\n            }\n\
    \        }\n        int finalListIndex = 0;\n        for (int i = 0; i < listLength;\
    \ i++) {\n            finalListIndex = 0;\n            for (int j = 0; j < listLength;\
    \ j++) {\n                if", "        //          .........\n        // also\
    \ what we do with negative numbers\n        return arr.OrderBy(n => CountOnes(n)).ThenBy(n\
    \ => n).ToList();", "        // Count the number of bits set in each number\n\
    \        // This will be our sort key\n        var bitCount = new Dictionary<long,\
    \ int>();\n        foreach (var n in arr) {\n            var n1 = n;\n       \
    \     var count = 0;\n            while (n1 > 0) {\n                count += (int)(n1\
    \ & 1);\n                n1 >>= 1;\n            }\n            bitCount[n] = count;\n\
    \        }\n        // Sort the list based on the bit count\n        arr.Sort((a,\
    \ b) => bitCount[a] == bitCount[b] ?\n            a.CompareTo(b) : bitCount[a].CompareTo(bitCount[b]));\n\
    \        return arr;", "        arr.Sort((l1, l2) => {\n            int n1 = CountBits(l1);\n\
    \            int n2 = CountBits(l2);\n            if (n1 != n2) {\n          \
    \      return n1 - n2;\n            }\n            return (int)l1 - (int)l2;\n\
    \        });\n        return arr;", "        var test = arr.OrderBy(x => Convert.ToString(x,\
    \ 2).Count(b => b == '1')).ThenBy(x => x).ToList();\n        return test;", " \
    \       return arr.OrderBy(x => Convert.ToString(x, 2).Count(c => c == '1')).ThenBy(x\
    \ => x).ToList();", "        int i,j;\n        long temp;\n        for (i = 0;\
    \ i < arr.Count - 1; i++) {\n            for (j = 0; j < arr.Count - i - 1; j++)\
    \ {\n                if (arr[j] > arr[j + 1]) {\n                    temp = arr[j];\n\
    \                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n\
    \                }\n            }\n        }\n        return arr;", "        //\
    \ for each array element\n        // compute the number of 1s in the binary representation\n\
    \        // sort based on those values\n        // this is O(n^2) because it's\
    \ a simple sort\n        var sorted = arr.OrderBy(x => {\n            var ones\
    \ = (new BigInteger(x)).ToString(2).Count(c => c == '1');\n            return\
    \ new { Ones = ones, Decimal = x };\n        });\n        return sorted.Select(x\
    \ => x.Decimal).ToList();", "        var sorted = from num in arr\n          \
    \           orderby (from bit in Convert.ToString(num, 2)\n                  \
    \            where bit == '1'\n                              select bit).Count(),\
    \ num\n                     select num;\n        return sorted.ToList();", " \
    \       // return arr.OrderBy(i => CountOnes(i)).ThenBy(i => i).ToList();\n  \
    \      return arr.OrderBy(i => BitCount(i)).ThenBy(i => i).ToList();", "     \
    \   // for each number in the array\n        //     find the binary rep.\n   \
    \     //     for each digit in binary rep.\n        //         count 1s\n    \
    \    //     add number to list of tuples (number, count of 1s)\n        // sort\
    \ list\n        // return sorted array\n        var numCounts = new List<(long\
    \ num, int count)>();\n        foreach (var num in arr) {\n            var binaryRep\
    \ = new StringBuilder();\n            var n = num;\n            while (n > 0)\
    \ {\n                binaryRep.Append(n % 2);\n                n /= 2;\n     \
    \       }\n            var count = binaryRep.ToString().Count(c => c == '1');\n\
    \            numCounts.Add((num, count));\n        }\n        var sortedNums =\
    \ numCounts.OrderBy(n => n.count).ThenBy(n => n.num).Select(n => n.num).ToList();\n\
    \        return sortedNums;"]
stop_tokens:
- "\n    }\n"
