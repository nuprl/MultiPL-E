name: HumanEval_55_fib
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return n-th Fibonacci number.\n    // >>> Fib((10L))\n    //\
  \ (55L)\n    // >>> Fib((1L))\n    // (1L)\n    // >>> Fib((8L))\n    // (21L)\n\
  \    public static long Fib(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Fib((10L))\
  \ == (55L));\n    Debug.Assert(Fib((1L)) == (1L));\n    Debug.Assert(Fib((8L)) ==\
  \ (21L));\n    Debug.Assert(Fib((11L)) == (89L));\n    Debug.Assert(Fib((12L)) ==\
  \ (144L));\n    }\n\n}\n"
completions: ["        Debug.Assert(n >= 0);\n        if (n == 0) {\n            return\
    \ 0;\n        }\n        else if (n == 1) {\n            return 1;\n        }\n\
    \        long a = 0;\n        long b = 1;\n        for (long i = 2; i <= n; i++)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \     }\n        return b;", "        // From http://www.ic.unicamp.br/~meidanis/courses/mc336/2009s2/prolog/problemas/\n\
    \        //         and http://stackoverflow.com/questions/43334466/matrix-power-algorithm-for-long-numbers-biginteger\n\
    \        if (n == 0L) {\n            return (0L);\n        }\n        BigInteger\
    \ r0 = BigInteger.Zero;\n        BigInteger r1 = BigInteger.One;\n        BigInteger\
    \ s0 = BigInteger.One;\n        BigInteger s1 = BigInteger.One;\n        BigInteger\
    \ t0 = BigInteger.One;\n        BigInteger t1 = BigInteger.Zero;\n        while\
    \ (n > 0L) {\n            if ((n % 2L) == 1L) {\n                BigInteger r2\
    \ = ((r0 * s1) + (r1 * s0));\n                BigInteger s2 = ((r0 * t1) + (r1\
    \ * t0));\n                BigInteger t2 = ((s0 * t1) + (s1 * t0));\n        \
    \        r0 = r2;\n                s0 = s2;\n                t0 = t2;\n      \
    \      }\n            BigInteger r2_ = ((r1 * r1) + (s1 * t1));\n            BigInteger\
    \ s2_ = (r1 * s1);\n            BigInteger t2_ = ((s1 * s1) + (t1 * t1));\n  \
    \          r1 = r2_;\n            s1 = s2_;\n            t1 = t2_;\n         \
    \   n = (n / 2L);\n        }\n        return ((r0 % 10000000000L));", '        return
    MatrixPow(new Matrix(new long[,] { { 0, 1 }, { 1, 1 } }), n)[0, 1];', "      \
    \  long a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++) {\n\
    \            long c = a + b;\n            a = b;\n            b = c;\n       \
    \ }\n        return a;", "        if (n == 0) {\n            return 0;\n     \
    \   }\n        if (n == 1) {\n            return 1;\n        }\n        long x\
    \ = 0;\n        long y = 1;\n        for (int i = 2; i <= n; i++) {\n        \
    \    long z = x + y;\n            x = y;\n            y = z;\n        }\n    \
    \    return y;", "        if (n == 0) return 0;\n        var a = BigInteger.One;\n\
    \        var b = BigInteger.One;\n        for (var i = 2; i < n; i++) {\n    \
    \        var c = a + b;\n            a = b;\n            b = c;\n        }\n \
    \       return (long)b;", "        long a = 0L;\n        long b = 1L;\n      \
    \  long i = 1L;\n        while (i < n) {\n            i = i + 1L;\n          \
    \  long c = a + b;\n            a = b;\n            b = c;\n        }\n      \
    \  return b;", "        BigInteger a = 0;\n        BigInteger b = 1;\n       \
    \ BigInteger c = 0;\n        if (n == 0) return a;\n        if (n == 1) return\
    \ b;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n       \
    \     a = b;\n            b = c;\n        }\n        return (long)c;", "     \
    \   if(n < 0) {\n            throw new ArgumentException();\n        }\n     \
    \   BigInteger a = 0;\n        BigInteger b = 1;\n        BigInteger p = 0;\n\
    \        BigInteger q = 1;\n        long m = 0;\n        for(long i = 63 - n.BitLength();\
    \ i >= 0; i--) {\n            // Loop invariant: a/b == F(m)\n            // \
    \               p/q == F(m+1)\n            Debug.Assert(a * q == p * b);\n   \
    \         Debug.Assert(a * q + b * p == b * q);\n            if(n.Bit(i)) {\n\
    \                BigInteger t = p * a + q * b; // F(2m+1)\n                b =\
    \ p * b + q * a; // F(2m+2)\n                a = t;\n                m *= 2;\n\
    \                m++;\n            } else {\n                BigInteger t = p\
    \ * p + q * q; // F(2m+2)\n                p = p * q + q * p; // F(2m+1)\n   \
    \             q = t;\n                m *= 2;\n            }\n        }\n    \
    \    Debug.Assert(a == n);\n        return m;", "        if (n == 0) return 0;\n\
    \        if (n == 1) return 1;\n        long a = 0;\n        long b = 1;\n   \
    \     for (long i = 1; i < n; i++) {\n            long c = a + b;\n          \
    \  a = b;\n            b = c;\n        }\n        return b;", "        if (n <=\
    \ 1) {\n            return n;\n        }\n        else {\n            return Fib(n\
    \ - 1) + Fib(n - 2);\n        }", "        if (n == 0L) {\n            return\
    \ 0L;\n        }\n        else if (n == 1L) {\n            return 1L;\n      \
    \  }\n        else {\n            return Problem.Fib((n - 1L)) + Problem.Fib((n\
    \ - 2L));\n        }", "        long v1 = 1;\n        long v2 = 0;\n        long\
    \ tmp;\n        for (long i = 0; i < n; i++) {\n            tmp = v1;\n      \
    \      v1 = v1 + v2;\n            v2 = tmp;\n        }\n        return v2;", " \
    \       if (n <= 1) return n;\n        return Fib(n - 1) + Fib(n - 2);", "   \
    \     // Write your code here.\n        return 0;", "        long k = n - 1;\n\
    \        long x = 0L;\n        long y = 1L;\n        while (k > 0L) {\n      \
    \      if ((k & 1L) == 1L) {\n                long t = x;\n                x =\
    \ y;\n                y = (y + t);\n            }\n            k >>= 1L;\n   \
    \         long t1 = x;\n            x = (t1 * t1);\n            y = (((t1 * t1)\
    \ + (t1 * y)) + (y * y));\n        }\n        return x;", "        if (n == 0)\
    \ return 0;\n        long a = 0;\n        long b = 1;\n        for (long i = 2;\
    \ i <= n; i++) {\n            long c = a + b;\n            a = b;\n          \
    \  b = c;\n        }\n        return b;", "        long[] A = new long[2];\n \
    \       long[] B = new long[2];\n        long[] C = new long[2];\n        long[]\
    \ T = new long[2];\n        A[0] = 1;\n        A[1] = 0;\n        B[0] = 0;\n\
    \        B[1] = 1;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n\
    \                // C = A + B\n                C[0] = A[0] * B[0] + A[1] * B[1];\n\
    \                C[1] = A[0] * B[1] + A[1] * (B[0] + B[1]);\n                //\
    \ B = C\n                B[0] = C[0];\n                B[1] = C[1];\n        \
    \    }\n            // T = A + A\n            T[0] = A[0] * A[0] + A[1] * A[1];\n\
    \            T[1] = A[0] * A[1] + A[1] * (A[0] + A[1]);\n            // A = T\n\
    \            A[0] = T[0];\n            A[1] = T[1];\n            n >>= 1;\n  \
    \      }\n        return B[1];", "        if (n < 0) {\n            throw new\
    \ ArgumentException(\"n must be positive\");\n        }\n        if (n == 0) {\n\
    \            return 0;\n        }\n        long x = 0;\n        long y = 1;\n\
    \        for (int i = 0; i < n - 1; i++) {\n            long z = x + y;\n    \
    \        x = y;\n            y = z;\n        }\n        return y;", "        //\
    \ Replace this code with a faster implementation\n        return n <= 1 ? n :\
    \ Fib(n - 1) + Fib(n - 2);", "        long a = 0;\n        long b = 1;\n     \
    \   for (int i = 0; i < n; i++) {\n            long c = a + b;\n            a\
    \ = b;\n            b = c;\n        }\n        return a;", "        if (n <= 1)\
    \ {\n            return n;\n        }\n        long first = 0;\n        long second\
    \ = 1;\n        long tmp;\n        for (long i = 2; i <= n; i++) {\n         \
    \   tmp = first + second;\n            first = second;\n            second = tmp;\n\
    \        }\n        return second;", "        BigInteger a = 0;\n        BigInteger\
    \ b = 1;\n        while (n > 0) {\n            BigInteger c = a + b;\n       \
    \     a = b;\n            b = c;\n            n -= 1;\n        }\n        return\
    \ (long)a;", "        if (n == 0) {\n            return 0;\n        }\n      \
    \  long a = 0;\n        long b = 1;\n        while (n > 1) {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n            n--;\n     \
    \   }\n        return b;", "        BigInteger a = 0;\n        BigInteger b =\
    \ 1;\n        while (n > 0) {\n            a += b;\n            n -= 1;\n    \
    \        b += a;\n            n -= 1;\n        }\n        return (long)a;", " \
    \       if (n < 2) {\n            return 1;\n        }\n        return Fib(n -\
    \ 1) + Fib(n - 2);", "        if(n==0 || n==1) return 1;\n        long[] a = new\
    \ long[n+1];\n        a[0] = 1;\n        a[1] = 1;\n        for(int i=2; i<=n;\
    \ i++) {\n            a[i] = a[i-1] + a[i-2];\n        }\n        return a[n];",
  "        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n\
    \            return 1;\n        }\n        return Fib(n - 1) + Fib(n - 2);", " \
    \       BigInteger f0 = 0;\n        BigInteger f1 = 1;\n        BigInteger f2\
    \ = f0 + f1;\n        for (long i = 2; i <= n; i++) {\n            f2 = f0 + f1;\n\
    \            f0 = f1;\n            f1 = f2;\n        }\n        return (long)f2;",
  "        if(n == 0) return 0;\n        if(n == 1) return 1;\n        long a = 0;\n\
    \        long b = 1;\n        for(long i = 2; i <= n; i++) {\n            long\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ b;", "        BigInteger a = 1;\n        BigInteger b = 1;\n        BigInteger\
    \ c = 0;\n        for (long i = 2; i < n; i++) {\n            c = a + b;\n   \
    \         a = b;\n            b = c;\n        }\n        return (long)c;", " \
    \       long first = 0;\n        long second = 1;\n        for (long i = 0; i\
    \ < n; i++) {\n            long tmp = first;\n            first = second;\n  \
    \          second = tmp + second;\n        }\n        return first;", "      \
    \  if (n <= 0) {\n            return 0;\n        }\n        if (n == 1) {\n  \
    \          return 1;\n        }\n        long a = 0;\n        long b = 1;\n  \
    \      long c = 1;\n        while (n-- > 1) {\n            c = a + b;\n      \
    \      a = b;\n            b = c;\n        }\n        return c;", "        long\
    \ a = 0L;\n        long b = 1L;\n        while (n > 0L) {\n            n -= 1L;\n\
    \            long t = a;\n            a = b;\n            b = t + b;\n       \
    \ }\n        return a;", "        long a = 0;\n        long b = 1;\n        while\
    \ (n > 0) {\n            long t = a;\n            a = b;\n            b = t +\
    \ b;\n            n -= 1;\n        }\n        return a;", "        long prev =\
    \ 1;\n        long curr = 1;\n        for (long i = 2; i < n; i++) {\n       \
    \     long next = curr + prev;\n            prev = curr;\n            curr = next;\n\
    \        }\n        return curr;", "        if (n == 0) {\n            return\
    \ 0;\n        }\n        if (n == 1) {\n            return 1;\n        }\n   \
    \     long ret = 0;\n        long a = 0;\n        long b = 1;\n        for (long\
    \ i = 2; i <= n; i++) {\n            ret = a + b;\n            a = b;\n      \
    \      b = ret;\n        }\n        return ret;", "        var m = new Matrix<BigInteger>(\n\
    \            new BigInteger[,] {\n                { 0, 1 },\n                {\
    \ 1, 1 }\n            });\n        var x = new Matrix<BigInteger>(\n         \
    \   new BigInteger[,] {\n                { 0 },\n                { 1 }\n     \
    \       });\n        var y = m.Power(n).Multiply(x);\n        return (long)y[1,\
    \ 0];", '        return n <= 1 ? n : Fib(n - 1) + Fib(n - 2);', "        if (n\
    \ < 2) {\n            return 1;\n        }\n        var a = Fib(n - 1);\n    \
    \    var b = Fib(n - 2);\n        return a + b;", "        // ********** IMPLEMENT\
    \ HERE **********\n        if (n < 2)\n            return n;\n        long a =\
    \ 0;\n        long b = 1;\n        long c = 0;\n        while (n > 0) {\n    \
    \        c = a + b;\n            a = b;\n            b = c;\n            n--;\n\
    \        }\n        return c;", "        if (n == 0) {\n            return 0;\n\
    \        }\n        if (n == 1) {\n            return 1;\n        }\n        long\
    \ f1 = 0;\n        long f2 = 1;\n        for (long i = 2; i <= n; i++) {\n   \
    \         long f = f1 + f2;\n            f1 = f2;\n            f2 = f;\n     \
    \   }\n        return f2;", "        long x = 1;\n        long y = 0;\n      \
    \  for (int i = 63 - n.GetBitCount(); i >= 0; i--) {\n            long tx = x;\n\
    \            x = x * x + y * y;\n            y = (tx + y) * y + y * y;\n     \
    \       if (n.GetBit(i)) {\n                long t = x;\n                x = x\
    \ + y;\n                y = t + y;\n            }\n        }\n        return y;",
  "        // Calculate and return (n+1)-th Fibonacci number.\n        long[] m =\
    \ new long[2];\n        m[0] = 1;\n        m[1] = 1;\n        long s = 1;\n  \
    \      for (long i = 2; i <= n; i++) {\n            s = (m[0] + m[1]) % 1000003;\n\
    \            m[0] = m[1];\n            m[1] = s;\n        }\n        return s;",
  "        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n\
    \            return 1;\n        }\n        long cur = 1;\n        long prev =\
    \ 0;\n        for (long i = 2; i <= n; i++) {\n            long tmp = cur;\n \
    \           cur = cur + prev;\n            prev = tmp;\n        }\n        return\
    \ cur;", "        long a = 0L;\n        long b = 1L;\n        long i = 0L;\n \
    \       while (i < n) {\n            long tmp = a;\n            a = b;\n     \
    \       b = tmp + b;\n            i = i + 1L;\n        }\n        return a;",
  "        if (n < 0)\n            throw new Exception(\"Fib: bad argument\");\n \
    \       if (n == 0)\n            return 0;\n        if (n == 1)\n            return\
    \ 1;\n        // Init f0 = 0, f1 = 1\n        long f0 = 0;\n        long f1 =\
    \ 1;\n        // Fibo(n) = Fibo(n-1) + Fibo(n-2)\n        for (long i = 2; i <=\
    \ n; i++) {\n            long f2 = f0 + f1;\n            f0 = f1;\n          \
    \  f1 = f2;\n        }\n        return f1;", "        // ...\n        long a =\
    \ 0;\n        long b = 1;\n        // In N steps compute Fibonacci sequence iteratively.\n\
    \        for (long i = 0; i < n; i++) {\n            long temp = a;\n        \
    \    a = b;\n            b = temp + b;\n        }\n        return a;", "     \
    \   var F = new List<long>();\n        F.Add(0);\n        F.Add(1);\n        for\
    \ (int i = 2; i <= n; i++) {\n            F.Add(F[i - 1] + F[i - 2]);\n      \
    \  }\n        return F[n];", "        long a = 0L;\n        long b = 1L;\n   \
    \     for (long i = 0L; i < n; i++) {\n            long c = a + b;\n         \
    \   a = b;\n            b = c;\n        }\n        return a;", "        long a\
    \ = 0L;\n        long b = 1L;\n        for (long i = 1L; i < n; i++) {\n     \
    \       long c = a + b;\n            a = b;\n            b = c;\n        }\n \
    \       return b;", '        return 0;', "        long a = 0L;\n        long b\
    \ = 1L;\n        long c = 1L;\n        long i = 0L;\n        while (i < n) {\n\
    \            c = a + b;\n            a = b;\n            b = c;\n            i\
    \ = i + 1L;\n        }\n        return a;", "        BigInteger a = 0;\n     \
    \   BigInteger b = 1;\n        for (int i = 0; i < n; i++) {\n            BigInteger\
    \ c = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ (long)a;", "        long a = 0L;\n        long b = 1L;\n        while (n > 0L)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \         n -= 1L;\n        }\n        return a;", "        // YOUR CODE HERE\n\
    \        long a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++)\
    \ {\n            long temp = a;\n            a = b;\n            b = temp + b;\n\
    \        }\n        return a;", "        long fibN = 0;\n        long fibN1 =\
    \ 1;\n        long fibN2 = 1;\n        for (long i = 2; i <= n; i++) {\n     \
    \       fibN = fibN1 + fibN2;\n            fibN2 = fibN1;\n            fibN1 =\
    \ fibN;\n        }\n        return fibN;", "        if (n == 0) {\n          \
    \  return 1;\n        }\n        if (n == 1) {\n            return 1;\n      \
    \  }\n        long a = 1;\n        long b = 1;\n        for (long i = 2; i <=\
    \ n; i++) {\n            long temp = a;\n            a = b;\n            b = b\
    \ + temp;\n        }\n        return b;", "        long a = 0;\n        long b\
    \ = 1;\n        for (long i = 0; i < n; i++) {\n            long temp = a;\n \
    \           a = b;\n            b = temp + b;\n        }\n        return a;",
  '        return FibLoop(n, 1, 0);', "        if (n == 0) {\n            return 0;\n\
    \        }\n        long[] fib = new long[n + 1];\n        fib[0] = 0;\n     \
    \   fib[1] = 1;\n        for (long i = 2; i <= n; i++) {\n            fib[i] =\
    \ fib[i - 1] + fib[i - 2];\n        }\n        return fib[n];", "        // Your\
    \ code here!\n        return 0;", "        if (n < 0) {\n            return 0;\n\
    \        }\n        if (n == 0) {\n            return 1;\n        }\n        long\
    \ a = 1;\n        long b = 1;\n        for (long i = 2; i <= n; i++) {\n     \
    \       long c = a + b;\n            a = b;\n            b = c;\n        }\n \
    \       return b;", "        if (n < 2) {\n            return n;\n        }\n\
    \        long a = 0;\n        long b = 1;\n        for (long i = 2; i <= n; i++)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \     }\n        return b;", "        // var_0 = Matrix.Power(Matrix.OneTwoOne(),\
    \ n)\n        var_0 = Matrix.Power(Matrix.OneTwoOne(), n);\n        // var_1 =\
    \ var_0.first()\n        var_1 = var_0.first();\n        // return var_1\n   \
    \     return var_1;", "        // Compute Fibonacci using a memoized recursive\
    \ algorithm.\n        return _FibHelper(n, new Dictionary<long, long>(){{0L, 0L},\
    \ {1L, 1L}});", "        var F0 = 0L;\n        var F1 = 1L;\n        for (var\
    \ i = 0L; i < n; i++) {\n            var T = F0;\n            F0 = F1;\n     \
    \       F1 = T + F1;\n        }\n        return F0;", "        BigInteger x =\
    \ 0;\n        BigInteger y = 1;\n        BigInteger z = 1;\n        BigInteger\
    \ i = 0;\n        BigInteger tmp;\n        while (i < n) {\n            tmp =\
    \ x;\n            x = y;\n            y = tmp + y;\n            i = i + 1;\n \
    \       }\n        return (long)x;", "        long a = 0L;\n        long b = 1L;\n\
    \        while (0L < n) {\n            long c = a + b;\n            a = b;\n \
    \           b = c;\n            n = n - 1L;\n        }\n        return a;", " \
    \       long a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \     }\n        return a;", "        var x = BigInteger.One;\n        var y =\
    \ BigInteger.Zero;\n        while (n > 0) {\n            y = x + y;\n        \
    \    x = y - x;\n            n = n - 1;\n        }\n        return (long) y;",
  "        BigInteger a, b, c;\n        BigInteger b0 = 0;\n        BigInteger b1\
    \ = 1;\n        if (n == 0)\n            return b0;\n        for (long i = 2;\
    \ i <= n; i++) {\n            c = b0 + b1;\n            b0 = b1;\n           \
    \ b1 = c;\n        }\n        return b1;", "        if (n == 0) {\n          \
    \  return 0;\n        }\n        long n2 = 0;\n        long n1 = 1;\n        for\
    \ (long i = 1; i < n; i++) {\n            long n0 = n2 + n1;\n            n2 =\
    \ n1;\n            n1 = n0;\n        }\n        return n1;", '        return ((n
    == 0L) ? (0L) : (Fib_helper(1L, 0L, 1L, n)));', "        if(n == 0) return 0;\n\
    \        if(n == 1) return 1;\n        BigInteger a = 1;\n        BigInteger b\
    \ = 1;\n        BigInteger c = 1;\n        BigInteger i = 3;\n        for(; i\
    \ < n + 1; i++) {\n            c = a + b;\n            a = b;\n            b =\
    \ c;\n        }\n        return (long)c;", "        long[,] arr = new long[,]\
    \ { { 1, 1 }, { 1, 0 } };\n        long[,] unit = new long[,] { { 1, 0 }, { 0,\
    \ 1 } };\n        while (n > 0) {\n            if ((n & 1) == 1) {\n         \
    \       unit = Multiply(unit, arr);\n            }\n            arr = Multiply(arr,\
    \ arr);\n            n >>= 1;\n        }\n        return unit[0, 1];", "     \
    \   // >>> h = { 1L:1L, 2L:1L }\n        // >>> h[0L]\n        // KeyError: 0L\n\
    \        // >>> h.get(0L, 0L)\n        // (0L)\n        // >>> h[0L] = 0L\n  \
    \      // >>> h[0L]\n        // (0L)\n        var h = new Dictionary<long, long>();\n\
    \        h[1L] = 1L;\n        h[2L] = 1L;\n        h[0L] = 0L;\n        return\
    \ Fib_Aux(n, h);", "        if (n == 0) {\n            return 0;\n        }\n\
    \        if (n == 1) {\n            return 1;\n        }\n        long a = 0;\n\
    \        long b = 1;\n        for (long i = 1; i < n; i++) {\n            long\
    \ t = a + b;\n            a = b;\n            b = t;\n        }\n        return\
    \ b;", "        // ...\n        // n should be between 0 and 93, or the result\
    \ will overflow!\n        // ...\n        long[] arr = new long[n + 1];\n    \
    \    arr[0] = 0;\n        arr[1] = 1;\n        for (int i = 2; i <= n; i++) {\n\
    \            arr[i] = arr[i - 1] + arr[i - 2];\n        }\n        return arr[n];",
  "        long a, b, c;\n        a = 1;\n        b = 1;\n        c = 0;\n       \
    \ for (long i = 2; i < n; i++) {\n            c = a + b;\n            a = b;\n\
    \            b = c;\n        }\n        return c;", "        // >>> Fib((1L))\n\
    \        // (1L)\n        if (n == 1L) {\n            return 1L;\n        }\n\
    \        // >>> Fib((2L))\n        // (1L)\n        if (n == 2L) {\n         \
    \   return 1L;\n        }\n        var res = 0L;\n        var f1 = 1L;\n     \
    \   var f2 = 1L;\n        var cnt = 3L;\n        // >>> Fib((3L))\n        //\
    \ (2L)\n        while (cnt <= n) {\n            // >>> Fib((8L))\n           \
    \ // (21L)\n            res = f1 + f2;\n            f1 = f2;\n            f2 =\
    \ res;\n            cnt = cnt + 1L;\n        }\n        return res;", "      \
    \  Debug.Assert(n >= 0);\n        if (n <= 1) return n;\n        BigInteger a\
    \ = 0;\n        BigInteger b = 1;\n        BigInteger c = 1;\n        for (long\
    \ i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n        \
    \    b = c;\n        }\n        return (long)c;", '        return (long)Fib(n,
    Vector.Zero<long>(), Vector.One<long>());', "        long[] a = new long[n+1];\n\
    \        a[0] = 0;\n        a[1] = 1;\n        for (long i = 2; i <= n; i++) {\n\
    \            a[i] = a[i-1] + a[i-2];\n        }\n        return a[n];", "    \
    \    if (n<0) {\n            throw new ArgumentException(\"n must be non-negative\"\
    );\n        }\n        if (n<=1) {\n            return n;\n        }\n       \
    \ long a = 0L;\n        long b = 1L;\n        for (long i=2L; i<=n; i++) {\n \
    \           long t = a+b;\n            a = b;\n            b = t;\n        }\n\
    \        return b;", "        if (n <= 0)\n            return 0;\n        if (n\
    \ == 1)\n            return 1;\n        return Fib(n - 1) + Fib(n - 2);", "  \
    \      long a = 0L;\n        long b = 1L;\n        while (n > 0L) {\n        \
    \    long next = a + b;\n            a = b;\n            b = next;\n         \
    \   n -= 1L;\n        }\n        return a;", "        if (n == 0L) {\n       \
    \     return 0L;\n        }\n        if (n == 1L) {\n            return 1L;\n\
    \        }\n        long fib0 = 0L;\n        long fib1 = 1L;\n        for (long\
    \ i = 2L; i <= n; i++) {\n            long tmp = fib0 + fib1;\n            fib0\
    \ = fib1;\n            fib1 = tmp;\n        }\n        return fib1;", "      \
    \  if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n  \
    \          return 1;\n        }\n        return Fib(n - 1) + Fib(n - 2);", " \
    \       long k = (n - ((long)1L));\n        if (k <= ((long)0L)) {\n         \
    \   return (long)1L;\n        }\n        var p = Fib(k);\n        k = (k - ((long)1L));\n\
    \        if (k <= ((long)0L)) {\n            return p;\n        }\n        var\
    \ q = Fib(k);\n        return (p + q);", "        long a = 0;\n        long b\
    \ = 1;\n        for (long i = 0; i < n; i++) {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return a;", '        return
    Fib_(n).Item1;', "        long a = 0;\n        long b = 1;\n        for (long\
    \ i = 0; i < n; i++) {\n            long c = a + b;\n            a = b;\n    \
    \        b = c;\n        }\n        return a;", "        if (n < 1)\n        \
    \    throw new Exception(\"Fib(n) is defined for n > 0.\");\n        long a =\
    \ 0;\n        long b = 1;\n        while (n > 0) {\n            long t = a;\n\
    \            a = b;\n            b = t + b;\n            n -= 1;\n        }\n\
    \        return a;", "        BigInteger v = (new BigInteger(n) * (new BigInteger(5L)\
    \ * new BigInteger(n) + new BigInteger(4L)) * (new BigInteger(5L) * new BigInteger(n)\
    \ - new BigInteger(4L)));\n        if (((v & 1L) == 0L)) {\n            v = (v\
    \ / 2L);\n        } else {\n            v = ((v - 1L) / 2L);\n        }\n    \
    \    return ((long)(v % (new BigInteger(1000000007L))));", "        long[] numbers\
    \ = new long[2];\n        numbers[0] = 0;\n        numbers[1] = 1;\n        for\
    \ (long i = 2; i <= n; i++) {\n            numbers[i % 2] = numbers[(i - 1) %\
    \ 2] + numbers[(i - 2) % 2];\n        }\n        return numbers[n % 2];", "  \
    \      var a = 1L;\n        var b = 1L;\n        for (var i = 2L; i < n; i++)\
    \ {\n            var c = a + b;\n            a = b;\n            b = c;\n    \
    \    }\n        return b;", "        if (n < 2) {\n            return n;\n   \
    \     }\n        var sqrt5 = (long) Math.Sqrt(5);\n        var fibn = ((long)\
    \ Math.Pow((1 + sqrt5) / 2, n) - (long) Math.Pow((1 - sqrt5) / 2, n)) / sqrt5;\n\
    \        return fibn;", "        BigInteger a = 0, b = 1;\n        for (long i\
    \ = 0; i < n; i++) {\n            BigInteger t = a;\n            a = b;\n    \
    \        b = t + b;\n        }\n        return (long)a;", "        long prev =\
    \ 0;\n        long curr = 1;\n        for (long i = 0; i < n; i++) {\n       \
    \     long next = prev + curr;\n            prev = curr;\n            curr = next;\n\
    \        }\n        return prev;", "        long p = 1L;\n        long q = 0L;\n\
    \        for (long i = 0L; i < n; i += 1L) {\n            long _p = p;\n     \
    \       long _q = q;\n            p = _p + _q;\n            q = _p;\n        }\n\
    \        return q;", "        if (n < 2) return 1;\n        else return Fib(n\
    \ - 1) + Fib(n - 2);", "        var a = BigInteger.Zero;\n        var b = BigInteger.One;\n\
    \        for (var i = 0L; i < n; i++) {\n            var c = a + b;\n        \
    \    a = b;\n            b = c;\n        }\n        return (long)a;", "      \
    \  if (n < 2) {\n            return n;\n        } else {\n            return Fib(n\
    \ - 1) + Fib(n - 2);\n        }", "        if (n < 2) {\n            return n;\n\
    \        } else {\n            long f1 = 1L;\n            long f2 = 1L;\n    \
    \        for (long i = 2L; i < n; i++) {\n                long f = f1 + f2;\n\
    \                f1 = f2;\n                f2 = f;\n            }\n          \
    \  return f2;\n        }", "        var a = BigInteger.One;\n        var b = BigInteger.One;\n\
    \        while (n-- > 1) {\n            var c = a + b;\n            a = b;\n \
    \           b = c;\n        }\n        return (long)b;", "        int n2 = (int)(n/2);\n\
    \        long[] fib = new long[n2+1];\n        fib[0] = 1;\n        fib[1] = 1;\n\
    \        for (int i = 2; i <= n2; i++) {\n            fib[i] = fib[i-1] + fib[i-2];\n\
    \        }\n        long a = fib[n2];\n        if (n % 2 == 0) {\n           \
    \ return a * a + fib[n2-1] * fib[n2-1];\n        } else {\n            return\
    \ a * a + a * fib[n2-1] * 2;\n        }", "        if (n <= 1) return n;\n   \
    \     long a = 0, b = 1;\n        while (n-- > 1) {\n            long t = a +\
    \ b;\n            a = b;\n            b = t;\n        }\n        return b;", " \
    \       long a = 0;\n        long b = 1;\n        for (int i = 0; i < n; i++)\
    \ {\n            long temp = a;\n            a = b;\n            b = temp + b;\n\
    \        }\n        return a;", "        if (n == 0) return 0;\n        long f1\
    \ = 0;\n        long f2 = 1;\n        for (long i = 2; i <= n; i++) {\n      \
    \      long f3 = f1 + f2;\n            f1 = f2;\n            f2 = f3;\n      \
    \  }\n        return f2;", "        if (n < 2) return 1;\n        var a = BigInteger.One;\n\
    \        var b = BigInteger.One;\n        for (var i = 1; i < n; i++) {\n    \
    \        var t = a;\n            a = b;\n            b = a + t;\n        }\n \
    \       return (long)b;", "        BigInteger a = 0;\n        BigInteger b = 1;\n\
    \        BigInteger c = 1;\n        BigInteger d = 0;\n        while (n > 0) {\n\
    \            if (n % 2 == 1) {\n                BigInteger x = b;\n          \
    \      BigInteger y = d;\n                BigInteger z = b * c + a * d;\n    \
    \            b = x + y;\n                d = y;\n                a = x;\n    \
    \            c = z;\n            }\n            BigInteger x = a;\n          \
    \  BigInteger y = b;\n            BigInteger z = a * a + b * b;\n            a\
    \ = x + y;\n            b = y;\n            c = z;\n            n = n / 2;\n \
    \       }\n        return (long)b;", "        if (n <= 1) {\n            return\
    \ n;\n        }\n        var matrix = new Matrix2x2(1, 1, 1, 0);\n        return\
    \ matrix.Pow(n - 1).M11;", "        long a = 0;\n        long b = 1;\n       \
    \ while (n > 0) {\n            long c = a + b;\n            a = b;\n         \
    \   b = c;\n            n -= 1;\n        }\n        return a;", "        long\
    \ prevprev = 0;\n        long prev = 1;\n        for (long i = 0; i < n; i++)\
    \ {\n            long next = prev + prevprev;\n            prevprev = prev;\n\
    \            prev = next;\n        }\n        return prevprev;", "        n =\
    \ n % 60;\n        long[] Fn = new long[60];\n        Fn[0] = 0;\n        Fn[1]\
    \ = 1;\n        for (int i = 2; i < 60; i++) {\n            Fn[i] = (Fn[i - 1]\
    \ + Fn[i - 2]) % 10;\n        }\n        return Fn[n];", "        int[,] a = new\
    \ int[2, 2] { { 1, 1 }, { 1, 0 } };\n        int[,] x = new int[2, 2] { { 1, 0\
    \ }, { 0, 1 } };\n        while (n > 0) {\n            if ((n & 1) == 1) {\n \
    \               x = Mul(x, a);\n            }\n            a = Mul(a, a);\n  \
    \          n = n >> 1;\n        }\n        return x[0, 1];", "        // Write\
    \ your code here.\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n\
    \        BigInteger a = 0;\n        BigInteger b = 1;\n        BigInteger c =\
    \ 1;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n       \
    \     a = b;\n            b = c;\n        }\n        return (long)c;", "     \
    \   if (n < 1) {\n            throw new Exception();\n        }\n        long\
    \ prev_1 = 1;\n        long prev_2 = 0;\n        for (long i = 2; i <= n; i++)\
    \ {\n            long next = prev_1 + prev_2;\n            prev_2 = prev_1;\n\
    \            prev_1 = next;\n        }\n        return prev_1;", "        long\
    \ a = 0;\n        long b = 1;\n        while (n > 0) {\n            long c = a\
    \ + b;\n            a = b;\n            b = c;\n            n -= 1;\n        }\n\
    \        return a;", "        long a = 0;\n        long b = 1;\n        for (long\
    \ i = 0; i < n; i++) {\n            long t = a;\n            a = b;\n        \
    \    b = t + b;\n        }\n        return a;", "        if (n == 0) {\n     \
    \       return 0;\n        }\n        if (n == 1) {\n            return 1;\n \
    \       }\n        var a = 0L;\n        var b = 1L;\n        for (var i = 2; i\
    \ <= n; i++) {\n            var c = a + b;\n            a = b;\n            b\
    \ = c;\n        }\n        return b;", "        long f1 = 1;\n        long f2\
    \ = 1;\n        long f3 = 1;\n        for (long i = 3; i <= n; i++) {\n      \
    \      f3 = f1 + f2;\n            f1 = f2;\n            f2 = f3;\n        }\n\
    \        return f3;", '        return (n == 0L) ? 0L : ((n == 1L) ? 1L : (Fib(n
    - 1L) + Fib(n - 2L)));', "        if (n <= 1) {\n            return n;\n     \
    \   }\n        long a = 0;\n        long b = 1;\n        long i = 2;\n       \
    \ while (i <= n) {\n            long c = a + b;\n            a = b;\n        \
    \    b = c;\n            i += 1;\n        }\n        return b;", "        long\
    \ a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++) {\n      \
    \      long c = a + b;\n            a = b;\n            b = c;\n        }\n  \
    \      return a;", "        var s = new List<long>();\n        s.Add(1);\n   \
    \     s.Add(1);\n        while (s.Count <= n) {\n            s.Add(s[s.Count -\
    \ 1] + s[s.Count - 2]);\n        }\n        return s[s.Count - 1];", "       \
    \ if (n == 0) return 0;\n        long a = 0;\n        long b = 1;\n        for\
    \ (long i = 2; i <= n; i++) {\n            long c = a + b;\n            a = b;\n\
    \            b = c;\n        }\n        return b;", "        if (n == 0) {\n \
    \           return 1;\n        }\n        if (n == 1) {\n            return 1;\n\
    \        }\n        return Fib(n - 1) + Fib(n - 2);", "        if (n < 0) {\n\
    \            throw new ArgumentException(\"Input must be non-negative.\");\n \
    \       }\n        long a = 0;\n        long b = 1;\n        for (long i = 1;\
    \ i < n; i++) {\n            long c = a + b;\n            a = b;\n           \
    \ b = c;\n        }\n        return b;", "        if (n < 2) {\n            return\
    \ n;\n        }\n        long a = 0L;\n        long b = 1L;\n        for (long\
    \ i = 2L; i <= n; i++) {\n            long tmp = a + b;\n            a = b;\n\
    \            b = tmp;\n        }\n        return b;", "        long[] a = new\
    \ long[n + 1];\n        for (long i = 0; i <= n; i++) {\n            if (i <=\
    \ 1)\n                a[i] = 1;\n            else\n                a[i] = a[i\
    \ - 1] + a[i - 2];\n        }\n        return a[n];", "        BigInteger[][]\
    \ M = new BigInteger[][] {\n            new BigInteger[] {1,1},\n            new\
    \ BigInteger[] {1,0}\n        };\n        Matrix.Power(M, n-1);\n        return\
    \ (long) M[0][0];", "        long a = 0;\n        long b = 1;\n        for (long\
    \ i = 0; i < n; i++) {\n            long c = a + b;\n            a = b;\n    \
    \        b = c;\n        }\n        return a;", "        // Calculate Fibonacci\
    \ number for n\n        return (long)BigInteger.ModPow(new BigInteger(1), new\
    \ BigInteger(1), new BigInteger(2));", "        long[] f = new long[2];\n    \
    \    f[0] = 0;\n        f[1] = 1;\n        for (long i = 0; i < n; i++) {\n  \
    \          f[i % 2] = f[0] + f[1];\n        }\n        return f[n % 2];", "  \
    \      if (n == 0L) {\n            return 0L;\n        }\n        if (n == 1L)\
    \ {\n            return 1L;\n        }\n        return (Fib((n - 1L)) + Fib((n\
    \ - 2L)));", "        // Assume n >= 0\n        Debug.Assert(n >= 0);\n      \
    \  if (n <= 1) {\n            return n;\n        } else {\n            long a\
    \ = 0;\n            long b = 1;\n            for (long i = 0; i < n - 1; i++)\
    \ {\n                long c = a + b;\n                a = b;\n               \
    \ b = c;\n            }\n            return b;\n        }", "        BigInteger\
    \ a = 0;\n        BigInteger b = 1;\n        while (n > 0) {\n            if ((n\
    \ & 1) != 0) {\n                var t = a;\n                a = b;\n         \
    \       b = t + b;\n            }\n            n >>= 1;\n            var tt =\
    \ a;\n            a = a + a;\n            b = b + b;\n            if (a >= MOD)\
    \ a -= MOD;\n            if (b >= MOD) b -= MOD;\n        }\n        return (long)\
    \ a;", "        if (n < 1) {\n            return 0;\n        }\n        long a\
    \ = 0, b = 1;\n        for (long i = 0; i < n; i++) {\n            long c = a\
    \ + b;\n            a = b;\n            b = c;\n        }\n        return a;",
  "        if (n <= 1) {\n            return n;\n        } else {\n            var\
    \ a = 0L;\n            var b = 1L;\n            while (n > 1) {\n            \
    \    var c = a + b;\n                a = b;\n                b = c;\n        \
    \        n -= 1;\n            }\n            return b;\n        }", "        if\
    \ (n < 0) throw new ArgumentException();\n        if (n == 0) return 0;\n    \
    \    if (n == 1) return 1;\n        var a = Fib(n / 2);\n        var b = Fib(n\
    \ / 2 + 1);\n        if (n % 2 == 0) {\n            return a * (2 * b - a);\n\
    \        } else {\n            return b * b + a * a;\n        }", "        if\
    \ (n < 0) {\n            throw new ArgumentException(\"Negative argument.\");\n\
    \        }\n        if (n == 0) {\n            return 0;\n        }\n        if\
    \ (n == 1) {\n            return 1;\n        }\n        long n1 = 0;\n       \
    \ long n2 = 1;\n        long k = 2;\n        while (k <= n) {\n            long\
    \ t = n1 + n2;\n            n1 = n2;\n            n2 = t;\n            k = k +\
    \ 1;\n        }\n        return n2;", "        var fib = new BigInteger[n + 1];\n\
    \        fib[0] = 0;\n        fib[1] = 1;\n        for (int i = 2; i <= n; i++)\
    \ {\n            fib[i] = fib[i - 1] + fib[i - 2];\n        }\n        return\
    \ (long)fib[n];", "        BigInteger a = 0;\n        BigInteger b = 1;\n    \
    \    BigInteger c = 0;\n        while (n > 0) {\n            c = a + b;\n    \
    \        a = b;\n            b = c;\n            n -= 1;\n        }\n        return\
    \ c;", '        return (n > 1) ? (Fib(n - 1) + Fib(n - 2)) : (n);', "        //\
    \ Your code goes here.\n        if (n == 0) return 0;\n        if (n == 1) return\
    \ 1;\n        long i = 0;\n        long j = 1;\n        for (long k = 2; k <=\
    \ n; k++) {\n            var temp = i + j;\n            i = j;\n            j\
    \ = temp;\n        }\n        return j;", "        if (n <= 1) return n;\n   \
    \     var v = Matrix<long>.One(2, 2);\n        v[1, 1] = 0;\n        var p = Matrix<long>.One(2,\
    \ 2);\n        for (; n > 0; n /= 2) {\n            if (n % 2 != 0) p *= v;\n\
    \            v *= v;\n        }\n        return p[0, 1];", "        if (n == 0)\
    \ {\n            return 0;\n        }\n        if (n == 1) {\n            return\
    \ 1;\n        }\n        var a = 0L;\n        var b = 1L;\n        while (n >\
    \ 1) {\n            var c = a + b;\n            a = b;\n            b = c;\n \
    \           n = n - 1;\n        }\n        return b;", "        long a = 0;\n\
    \        long b = 1;\n        for (int i = 0; i < n; i++) {\n            var c\
    \ = a + b;\n            a = b;\n            b = c;\n        }\n        return\
    \ a;", "        long a = 0;\n        long b = 1;\n        for (long i = 0; i <\
    \ n; i++) {\n            long temp = a;\n            a = b;\n            b = temp\
    \ + b;\n        }\n        return a;", "        if (n < 2) {\n            return\
    \ n;\n        }\n        long[] a = new long[2];\n        a[0] = 0;\n        a[1]\
    \ = 1;\n        long[] s = new long[2];\n        s[0] = 1;\n        s[1] = 1;\n\
    \        long[] t = new long[2];\n        t[0] = 1;\n        t[1] = 0;\n     \
    \   while (n > 0) {\n            if (n % 2 == 1) {\n                // Multiply\
    \ s with a.\n                long[] temp = new long[2];\n                temp[0]\
    \ = s[0] * a[0] + s[1] * a[1];\n                temp[1] = s[0] * a[1] + s[1] *\
    \ a[0];\n                s[0] = temp[0];\n                s[1] = temp[1];\n  \
    \          }\n            // Multiply a with a.\n            long[] temp2 = new\
    \ long[2];\n            temp2[0] = a[0] * a[0] + a[1] * a[1];\n            temp2[1]\
    \ = a[0] * a[1] + a[1] * a[0];\n            a[0] = temp2[0];\n            a[1]\
    \ = temp2[1];\n            n = n / 2;\n        }\n        return s[1];", "   \
    \     long a = 0;\n        long b = 1;\n        for (long i = 0; i < n; i++) {\n\
    \            long c = a + b;\n            a = b;\n            b = c;\n       \
    \ }\n        return a;", "        List<long> fib = new List<long>() {0, 1};\n\
    \        for (int i = 2; i <= n; i++) {\n            fib.Add(fib[i - 1] + fib[i\
    \ - 2]);\n        }\n        return fib[(int)n];", "        Matrix2x2 m = new\
    \ Matrix2x2(new long[] { 1, 1, 1, 0 });\n        Matrix2x2 mn = m.Power(n);\n\
    \        return mn.Data[0];", "        long a = 0;\n        long b = 1;\n    \
    \    while (n-- > 0) {\n            long tmp = a;\n            a = b;\n      \
    \      b += tmp;\n        }\n        return a;", "        var a = new BigInteger(0);\n\
    \        var b = new BigInteger(1);\n        var c = new BigInteger(1);\n    \
    \    for (long i = 1; i < n; i++) {\n            c = a + b;\n            a = b;\n\
    \            b = c;\n        }\n        return (long)c;", "        long fn0 =\
    \ 0;\n        long fn1 = 1;\n        long fn2 = 0;\n        long i = 2;\n    \
    \    while (i <= n) {\n            fn2 = fn0 + fn1;\n            fn0 = fn1;\n\
    \            fn1 = fn2;\n            i = i + 1;\n        }\n        return fn2;",
  "        BigInteger a = 1, b = 1;\n        for (long i = 0; i < n; i++) {\n    \
    \        BigInteger t = a;\n            a = b;\n            b = t + b;\n     \
    \   }\n        return (long)a;", "        long f1 = 1L;\n        long f2 = 1L;\n\
    \        for (int i = 0; i < n - 2; i++) {\n            long tmp = f1;\n     \
    \       f1 = f2;\n            f2 = tmp + f2;\n        }\n        return f2;",
  "        // Initial values\n        long f_prev = 0;\n        long f = 1;\n    \
    \    // Key invariant: f_prev + f = F_{n+1}\n        long i = 0;\n        while\
    \ (i < n) {\n            long f_next = f_prev + f;\n            f_prev = f;\n\
    \            f = f_next;\n            i = i + 1;\n        }\n        return f_prev;",
  "        // fib(n) = phi^n/sqrt(5)\n        // fib(n+1) = fib(n) * phi = phi^(n+1)/sqrt(5)\n\
    \        // fib(n+2) = fib(n+1) * phi = phi^(n+2)/sqrt(5)\n        // fib(n+3)\
    \ = fib(n+2) * phi = phi^(n+3)/sqrt(5)\n        // ...\n        // fib(n+k) =\
    \ phi^(n+k)/sqrt(5)\n        //\n        // fib(n+k) = fib(n+k-1) + fib(n+k-2)\n\
    \        // fib(n+k-1) = fib(n+k-2) + fib(n+k-3)\n        // fib(n+k-2) = fib(n+k-3)\
    \ + fib(n+k-4)\n        // ...\n        // fib(n+1) = fib(n) + fib(n-1)\n    \
    \    // fib(n) = fib(n-1) + fib(n-2)\n        //\n        // fib(n+k) = fib(n+k-1)\
    \ + fib(n+k-2)\n        // fib(n+k-1) = fib(n+k-2) + fib(n+k-3)\n        // fib(n+k-2)\
    \ = fib(n+k-3) + fib(n+k-4)\n        // ...\n        // fib(n+1) = fib(n) + fib(n-1)\n\
    \        // fib(n) = fib(n-1) + fib(n-2)\n        // = phi^(n-1)/sqrt(5) + phi^(n-2)/sqrt(5)\n\
    \        // = (phi^(n-1) + phi^(n-2))/sqrt(5)\n        // = phi^(n-2)*(phi + 1)/sqrt(5)\n\
    \        // = phi^(n-2)*(1/sqrt(5) + 1", "        long curr = 1;\n        long\
    \ next = 1;\n        for (long i = 2; i < n; i++) {\n            long temp = next;\n\
    \            next = next + curr;\n            curr = temp;\n        }\n      \
    \  return next;", "        var a = BigInteger.One;\n        var b = BigInteger.One;\n\
    \        while (n > 0) {\n            var c = a + b;\n            a = b;\n   \
    \         b = c;\n            n -= 1;\n        }\n        return (long)a;", " \
    \       if (n < 1)\n            throw new ArgumentException(\"n must be positive\"\
    );\n        if (n == 1 || n == 2)\n            return 1;\n        long cur = 1,\
    \ prev = 1;\n        for (long i = 3; i <= n; i++) {\n            long tmp = cur;\n\
    \            cur += prev;\n            prev = tmp;\n        }\n        return\
    \ cur;", "        var R = new long[3, 3] { { 1, 1, 0 }, { 1, 0, 1 }, { 1, 1, 1\
    \ } };\n        var V = new long[3, 1] { { 1 }, { 0 }, { 0 } };\n        var E\
    \ = new long[3, 3] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } };\n        while (n\
    \ > 0) {\n            if ((n & 1) == 1) {\n                E = Multiply(E, R);\n\
    \            }\n            R = Multiply(R, R);\n            n >>= 1;\n      \
    \  }\n        return Multiply(E, V)[0, 0];", "        long a = 0;\n        long\
    \ b = 1;\n        for (long i = 0; i < n; i++) {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return a;", "    \
    \    long a = 0;\n        long b = 1;\n        for (int i = 1; i < n; i++) {\n\
    \            long t = a + b;\n            a = b;\n            b = t;\n       \
    \ }\n        return b;", "        var x = BigInteger.One;\n        var y = BigInteger.Zero;\n\
    \        while (n > 0) {\n            var next = x + y;\n            x = y;\n\
    \            y = next;\n            n -= 1;\n        }\n        return (long)x;",
  "        long i = 1;\n        long j = 0;\n        while (n > 0) {\n           \
    \ if ((n & 1) == 1) {\n                j = i + j;\n                i = i + j;\n\
    \            } else {\n                i = i + j;\n            }\n           \
    \ n >>= 1;\n        }\n        return j;", "        long a = 0;\n        long\
    \ b = 1;\n        for (long i = 0; i < n; i++) {\n            long c = a + b;\n\
    \            a = b;\n            b = c;\n        }\n        return a;", "    \
    \    var a = BigInteger.Zero;\n        var b = BigInteger.One;\n        for (long\
    \ k = 0; k < n; k++) {\n            var c = a + b;\n            a = b;\n     \
    \       b = c;\n        }\n        return (long)a;", "        Debug.Assert(n >=\
    \ 0);\n        // Take care of the first two cases.\n        if (n <= 1) return\
    \ n;\n        // Initialize list.\n        var f = new List<long> { 1, 1 };\n\
    \        // Iterate.\n        for (long i = 2; i < n; i++) {\n            f.Add(f[i\
    \ - 1] + f[i - 2]);\n        }\n        // Return last number.\n        return\
    \ f[n - 1];", "        // TODO: Implement\n        return 0;", "        //if (n\
    \ == 0) {\n        //    return 1;\n        //}\n        //long a = 1;\n     \
    \   //long b = 1;\n        //for (long i = 2; i < n; i++) {\n        //    long\
    \ tmp = a;\n        //    a = b;\n        //    b = tmp + b;\n        //}\n  \
    \      //return b;\n        return (1 << n) - 1;", "        if (n < 0) {\n   \
    \         throw new ArgumentException(\"Parameter n must be non-negative.\");\n\
    \        }\n\n        BigInteger a = 1;\n        BigInteger b = 1;\n        BigInteger\
    \ c = 1;\n        BigInteger d = 0;\n        while (n > 0) {\n            if ((n\
    \ & 1) == 1) {\n                d = b * c + a * d;\n                b = b * c\
    \ + a * b;\n                a = a * c + a * b;\n            }\n            c =\
    \ b * b + a * c;\n            b = b * b + a * b;\n            a = a * b + a *\
    \ c;\n            n >>= 1;\n        }\n        return (long)b;", '        return
    n == 0L ? 0L : n == 1L ? 1L : Problem.Fib(n - 1L) + Problem.Fib(n - 2L);', " \
    \       if (n < 1)\n            throw new Exception(\"Fibonacci number has to\
    \ be greater than 0\");\n        if (n < 3)\n            return 1;\n        return\
    \ Fib(n - 1) + Fib(n - 2);", "        return new long[] {\n            0L, 1L,\
    \ 1L, 2L, 3L, 5L, 8L, 13L, 21L, 34L, 55L, 89L, 144L, 233L, 377L, 610L, 987L, 1597L,\
    \ 2584L, 4181L, 6765L, 10946L, 17711L, 28657L, 46368L, 75025L, 121393L, 196418L,\
    \ 317811L, 514229L, 832040L, 1346269L, 2178309L, 3524578L, 5702887L, 9227465L,\
    \ 14930352L, 24157817L, 39088169L, 63245986L, 102334155L, 165580141L, 267914296L,\
    \ 433494437L, 701408733L, 1134903170L, 1836311903L, 2971215073L, 4807526976L,\
    \ 7778742049L, 12586269025L, 20365011074L, 32951280099L, 53316291173L, 86267571272L,\
    \ 139583862445L, 225851433717L, 365435296162L, 591286729879L, 956722026041L, 1548008755920L,\
    \ 2504730781961L, 4052739537881L, 6557470319842L, 10610209857723L, 17167680177565L,\
    \ 27777890035288L, 44945570212853L, 72723460248141L, 117669030460994L, 190392490709135L,\
    \ 308061521170129L, 498454011879264L, 806515533049393L, 1304969544928657L, 2111485077978050L,\
    \ 3416454622906707L, 5527939700884757L, 8944394323791464L, 14472334024676221L,\
    \ 23416728348467685L, 37889062373143906L, 61305790721611591L, 99194853094755497L,\
    \ 16050064381636", '        return n < 3 ? n - 1 : Fib(n - 1) + Fib(n - 2);',
  "        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n\
    \            return 1;\n        }\n        var n_2 = 0L;\n        var n_1 = 1L;\n\
    \        for (var i = 2L; i <= n; i++) {\n            var sum = n_1 + n_2;\n \
    \           n_2 = n_1;\n            n_1 = sum;\n        }\n        return n_1;",
  "        var v2 = new long[] { 1L, 0L };\n        var v3 = new long[] { 0L, 1L };\n\
    \        for (long k = n; k > 0L; k >>= 1L) {\n            var tmp = v2[0] * (v3[0]\
    \ * 2L - v2[0]);\n            v2[0] = v2[0] * v2[0] + v3[0] * v3[0];\n       \
    \     v3[0] = tmp;\n            if ((k & 1L) == 1L) {\n                tmp = v2[0]\
    \ + v3[0];\n                v2[0] = v2[0] + v3[0] * 2L;\n                v3[0]\
    \ = tmp;\n            }\n        }\n        return v2[0];", '        return (n
    <= 1) ? 1 : Fib(n - 1) + Fib(n - 2);', "        if (n == 0) {\n            return\
    \ 1;\n        }\n        if (n == 1) {\n            return 1;\n        }\n   \
    \     return Fib(n - 1) + Fib(n - 2);", "        if (n < 1)\n            throw\
    \ new ArgumentException(\"n should be greater than zero.\");\n        if (n <\
    \ 3)\n            return 1;\n        long a = 1, b = 1, c = 1;\n        for (int\
    \ i = 3; i <= n; i++) {\n            c = a + b;\n            a = b;\n        \
    \    b = c;\n        }\n        return c;", "        BigInteger[] F = new BigInteger[n+1];\n\
    \        F[0] = 0;\n        F[1] = 1;\n        for (int i = 2; i <= n; i++) {\n\
    \            F[i] = F[i-1] + F[i-2];\n        }\n        return (long)F[n];",
  "        long a = 0L;\n        long b = 1L;\n        long c = 0L;\n        long\
    \ i = 0L;\n        while (i < n) {\n            c = a + b;\n            a = b;\n\
    \            b = c;\n            i = i + 1L;\n        }\n        return a;", " \
    \       BigInteger a = 1;\n        BigInteger b = 1;\n        for (long i = 3;\
    \ i <= n; i++) {\n            BigInteger c = a + b;\n            a = b;\n    \
    \        b = c;\n        }\n        return (long)b;", "        long a = 0L;\n\
    \        long b = 1L;\n        for (long i = 0L; i < n; i++) {\n            long\
    \ temp = a;\n            a = b;\n            b = temp + b;\n        }\n      \
    \  return a;", "        if (n == 0) return 0;\n        if (n == 1) return 1;\n\
    \        long a = 0;\n        long b = 1;\n        long c = 1;\n        while\
    \ (n-- > 1) {\n            c = a + b;\n            a = b;\n            b = c;\n\
    \        }\n        return c;", "        if (n <= 0) {\n            return 0;\n\
    \        }\n        if (n == 1) {\n            return 1;\n        }\n        long\
    \ a = 0;\n        long b = 1;\n        for (int i = 0; i < n; i++) {\n       \
    \     long temp = a;\n            a = b;\n            b = temp + b;\n        }\n\
    \        return a;", "        if (n == 0L)\n            return 0L;\n        long\
    \ a = 0L;\n        long b = 1L;\n        for (long i = 2L; i <= n; i++) {\n  \
    \          long c = a + b;\n            a = b;\n            b = c;\n        }\n\
    \        return b;", "        long f0 = 0L;\n        long f1 = 1L;\n        for\
    \ (long i = 0L; i < n; i++) {\n            long t = f0;\n            f0 = f1;\n\
    \            f1 = t + f1;\n        }\n        return f0;", "        // Fill here\n\
    \        if (n == 0) return 0;\n        if (n == 1) return 1;\n        long ret1\
    \ = 0;\n        long ret2 = 1;\n        long ret3 = 1;\n        while (n > 1)\
    \ {\n            ret3 = ret1 + ret2;\n            ret1 = ret2;\n            ret2\
    \ = ret3;\n            n--;\n        }\n        return ret3;", "        var (x,\
    \ y) = (BigInteger.One, BigInteger.Zero);\n        for (var i = 63 - n.LeadingZeroCount();\
    \ i >= 0; i--) {\n            var dx = x * (y * 2 - x);\n            var dy =\
    \ y * y + x * x;\n            x = dx;\n            y = dy;\n            if ((((ulong)n\
    \ >> i) & 1) != 0) {\n                var dx = x + y;\n                x = y;\n\
    \                y = dx;\n            }\n        }\n        return (long)x;",
  "        n = n + 1;\n        var ret = new[] { new[] { new BigInteger(1), new BigInteger(0)\
    \ }, new[] { new BigInteger(0), new BigInteger(1) } };\n        var p = new[]\
    \ { new[] { new BigInteger(1), new BigInteger(1) }, new[] { new BigInteger(1),\
    \ new BigInteger(0) } };\n        for (; n > 0; n /= 2) {\n            if (n %\
    \ 2 != 0) {\n                ret = Mult(ret, p);\n            }\n            p\
    \ = Mult(p, p);\n        }\n        return (long)ret[0][1];", "        if (n ==\
    \ 0) return 0;\n        if (n == 1) return 1;\n        return Fib(n - 1) + Fib(n\
    \ - 2);", "        if (n < 0)\n            throw new ArgumentException();\n  \
    \      if (n == 0)\n            return 0;\n        if (n == 1)\n            return\
    \ 1;\n        long a = 0;\n        long b = 1;\n        for (long i = 2; i <=\
    \ n; i++) {\n            var c = a + b;\n            a = b;\n            b = c;\n\
    \        }\n        return b;", "        long prevprev = 0;\n        long prev\
    \ = 1;\n        long result = n;\n        for (long i = 2; i <= n; i++) {\n  \
    \          result = prev + prevprev;\n            prevprev = prev;\n         \
    \   prev = result;\n        }\n        return result;", '        return (((n ==
    0L) || (n == 1L)) ? n : ((Fib((n - 1L)) + Fib((n - 2L))) % 1000000007L));']
stop_tokens:
- "\n    }\n"
