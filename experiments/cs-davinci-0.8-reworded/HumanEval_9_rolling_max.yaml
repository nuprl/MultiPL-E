name: HumanEval_9_rolling_max
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // From a given list of integers, generate a list of rolling maximum\
  \ element found until given moment\n    // in the sequence.\n    // >>> RollingMax((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L,\
  \ (long)2L})))\n    // (new List<long>(new long[]{(long)1L, (long)2L, (long)3L,\
  \ (long)3L, (long)3L, (long)4L, (long)4L}))\n    public static List<long> RollingMax(List<long>\
  \ numbers) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(RollingMax((new\
  \ List<long>())).Equals((new List<long>())));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L}))).Equals((new List<long>(new\
  \ long[]{(long)1L, (long)2L, (long)3L, (long)4L}))));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)4L, (long)3L, (long)2L, (long)1L}))).Equals((new List<long>(new\
  \ long[]{(long)4L, (long)4L, (long)4L, (long)4L}))));\n    Debug.Assert(RollingMax((new\
  \ List<long>(new long[]{(long)3L, (long)2L, (long)3L, (long)100L, (long)3L}))).Equals((new\
  \ List<long>(new long[]{(long)3L, (long)3L, (long)3L, (long)100L, (long)100L}))));\n\
  \    }\n\n}\n"
completions: ["        var max = numbers[0];\n        var result = new List<long>();\n\
    \        result.Add(max);\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            var current = numbers[i];\n            if (current > max) {\n   \
    \             max = current;\n            }\n            result.Add(max);\n  \
    \      }\n        return result;", "        var rollingMax = new List<long>();\n\
    \        rollingMax.Add(numbers[0]);\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            rollingMax.Add(Math.Max(rollingMax[i - 1], numbers[i]));\n\
    \        }\n        return rollingMax;", "        if (numbers.Count() == 0) {\n\
    \            return new List<long>();\n        }\n        if (numbers.Count()\
    \ == 1) {\n            return new List<long>(new long[]{ numbers[0] });\n    \
    \    }\n        long prevMax = numbers[0];\n        List<long> r = new List<long>();\n\
    \        r.Add(prevMax);\n        for (int i = 1; i < numbers.Count(); i++) {\n\
    \            if (numbers[i] > prevMax) {\n                prevMax = numbers[i];\n\
    \            }\n            r.Add(prevMax);\n        }\n        return r;", " \
    \       // Use a stack to keep track of maximum values we have seen so far.\n\
    \        // The idea here is that for each new number we can find out its maximum\
    \ by examining\n        // the numbers in our stack. We only need to insert a\
    \ number in our stack if it is\n        // larger than the top of the stack (as\
    \ a smaller number will never be used to calculate\n        // the maximum). But\
    \ we can't just insert it at the top, because if there's a larger\n        //\
    \ number already in the stack we don't want to forget about it.\n        // So\
    \ we pop of numbers larger than the current one until we either reach the stack's\n\
    \        // bottom or a number that is smaller or equal than the current number.\
    \ Now we know\n        // that if we insert the current number into the stack,\
    \ the top of the stack will give\n        // us the maximum value of all numbers\
    \ that have been processed so far.\n        // Then we simply step through the\
    \ original list and insert all numbers. Then we can\n        // just read the\
    \ top of the stack for each number, which gives us the maximum for that\n    \
    \    // number and all prior numbers.\n        Stack<long> stack = new Stack<long>();\n\
    \        List<long> result = new List<long>();\n        foreach (long number in\
    \ numbers) {\n            while (stack.Count > 0 && stack.Peek() < number) {\n\
    \                stack.Pop();\n            }\n            stack.Push(number);\n\
    \            result.Add(stack.Peek());\n        }\n        return result;", " \
    \       // >>> max1 = max2 = numbers[0]\n        long max1 = numbers[0];\n   \
    \     long max2 = numbers[0];\n        // >>> foreach n in numbers[1:]:\n    \
    \    var n = numbers.GetEnumerator();\n        n.MoveNext();\n        n.MoveNext();\n\
    \        while (n.MoveNext()) {\n            long n1 = n.Current;\n          \
    \  // >>> max1 = max(max1, n)\n            max1 = ((max1 > n1) ? max1 : n1);\n\
    \            // >>> max2 = max(max2, max1)\n            max2 = ((max2 > max1)\
    \ ? max2 : max1);\n        }\n        return numbers;", "        List<long> res\
    \ = new List<long>();\n        long max = numbers[0];\n        res.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i];\n            }\n            res.Add(max);\n\
    \        }\n        return res;", "        // >>> numbers\n        // (new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L}))\n\
    \        List<long> maxs = new List<long>();\n        // >>> maxs\n        //\
    \ (new List<long>(new long[]{}))\n        long curMax = numbers[0];\n        //\
    \ >>> curMax\n        // (long)1L\n        maxs.Add(curMax);\n        // >>> maxs\n\
    \        // (new List<long>(new long[]{(long)1L}))\n        int len = numbers.Count;\n\
    \        // >>> len\n        // (int)7\n        for (int i = 1; i < len; i++)\
    \ {\n            // >>> curMax\n            // (long)1L\n            // >>> numbers[i]\n\
    \            // (long)2L\n            if (numbers[i] > curMax) {\n           \
    \     // >>> numbers[i]\n                // (long)2L\n                curMax =\
    \ numbers[i];\n                // >>> curMax\n                // (long)2L\n  \
    \          }\n            // >>> curMax\n            // (long)2L\n           \
    \ maxs.Add(curMax);\n            // >>> maxs\n            // (new List<long>(new\
    \ long[]{(long)1L, (long)2L}))\n        }\n        // >>> maxs\n        // (new\
    \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)3L, (long)3L, (long)4L,\
    \ (long)4L}))\n        return maxs;", "        var rolling = new List<long>();\n\
    \        long currentMax = numbers[0];\n        rolling.Add(currentMax);\n   \
    \     for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i] >\
    \ currentMax) {\n                currentMax = numbers[i];\n            }\n   \
    \         rolling.Add(currentMax);\n        }\n        return rolling;", "   \
    \     List<long> result = new List<long>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            long maxUntilNow = numbers[i];\n            for (int j =\
    \ 0; j < i; j++) {\n                if (numbers[j] > maxUntilNow)\n          \
    \          maxUntilNow = numbers[j];\n            }\n            result.Add(maxUntilNow);\n\
    \        }\n        return result;", "        var rollingMax = new List<long>();\n\
    \        long maxSoFar = numbers[0];\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            maxSoFar = Math.Max(maxSoFar, numbers[i]);\n           \
    \ rollingMax.Add(maxSoFar);\n        }\n        return rollingMax;", '        return
    numbers.Select((cur,idx) => numbers.Take(idx+1).Max()).ToList();', "        //\
    \ >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L,\
    \ (long)3L, (long)4L, (long)2L})))\n        // (new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))\n        if (((numbers\
    \ == null) || ((numbers.Count) == (0)))) {\n            return (new List<long>(new\
    \ long[] { }));\n        } else {\n            var currentMax = numbers[0];\n\
    \            var result = new List<long> { };\n            foreach (var n in numbers)\
    \ {\n                result.Add(currentMax);\n                if ((n > currentMax))\
    \ {\n                    currentMax = n;\n                }\n            }\n \
    \           return result;\n        }", "        var output = new List<long>();\n\
    \        long currentMax = long.MinValue;\n        foreach (var number in numbers)\
    \ {\n            if (number > currentMax) {\n                currentMax = number;\n\
    \            }\n            output.Add(currentMax);\n        }\n        return\
    \ output;", "        List<long> res = new List<long>();\n        long curr = numbers[0];\n\
    \        res.Add(curr);\n        for (int i = 1; i < numbers.Count; i++) {\n \
    \           if (numbers[i] > curr) {\n                curr = numbers[i];\n   \
    \         }\n            res.Add(curr);\n        }\n        return res;", "  \
    \      var result = new List<long>();\n        var m = (long)0L;\n        foreach\
    \ (var i in numbers) {\n            if (i > m) {\n                m = i;\n   \
    \         }\n            result.Add(m);\n        }\n        return result;", " \
    \       List<long> result = new List<long>();\n        long currentMax = 0;\n\
    \        foreach (long number in numbers) {\n            currentMax = Math.Max(currentMax,\
    \ number);\n            result.Add(currentMax);\n        }\n        return result;",
  '        return numbers.Select((x, i) => numbers.Take(i + 1).Max()).ToList();',
  "        var max = new List<long>();\n        var maxValue = numbers[0];\n     \
    \   for (var i = 0; i < numbers.Count; i++) {\n            maxValue = Math.Max(maxValue,\
    \ numbers[i]);\n            max.Add(maxValue);\n        }\n        return max;",
  '        return RollingMax(numbers, 0, numbers.Count);', "        long max = numbers[0];\n\
    \        List<long> result = new List<long>();\n        result.Add(max);\n   \
    \     for (int i = 1; i < numbers.Count; i++) {\n            max = Math.Max(max,\
    \ numbers[i]);\n            result.Add(max);\n        }\n        return result;",
  "        long _rolling_max = numbers[0];\n        var solution = new List<long>\
    \ {_rolling_max};\n        for (int ix = 1; ix < numbers.Count; ix++) {\n    \
    \        _rolling_max = Math.Max(_rolling_max, numbers[ix]);\n            solution.Add(_rolling_max);\n\
    \        }\n        return solution;", "        List<long> maxes = new List<long>();\n\
    \        maxes.Add(numbers[0]);\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            long max = maxes[i - 1];\n            long candidate = numbers[i];\n\
    \            if (candidate > max) {\n                max = candidate;\n      \
    \      }\n            maxes.Add(max);\n        }\n        return maxes;", "  \
    \      List<long> results = new List<long>();\n        long maximum = numbers[0];\n\
    \        results.Add(maximum);\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            if (numbers[i] > maximum) {\n                maximum = numbers[i];\n\
    \            }\n            results.Add(maximum);\n        }\n        return results;",
  "        List<long> res = new List<long>();\n        long currMax = numbers[0];\n\
    \        res.Add(currMax);\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            currMax = Math.Max(currMax, numbers[i]);\n            res.Add(currMax);\n\
    \        }\n        return res;", "        List<long> maxSoFar = new List<long>();\n\
    \        long currentMax = long.MinValue;\n        foreach (long number in numbers)\
    \ {\n            currentMax = Math.Max(currentMax, number);\n            maxSoFar.Add(currentMax);\n\
    \        }\n        return maxSoFar;", "        var max = numbers[0];\n      \
    \  var res = new List<long>();\n        res.Add(max);\n        for (int i = 1;\
    \ i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n           \
    \     max = numbers[i];\n            }\n            res.Add(max);\n        }\n\
    \        return res;", "        List<long> result = new List<long>();\n      \
    \  long maximum = numbers[0];\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            if (numbers[i] > maximum) maximum = numbers[i];\n           \
    \ result.Add(maximum);\n        }\n        return result;", "        List<long>\
    \ maxes = new List<long>();\n        long best = 0;\n        numbers.ForEach(val\
    \ => {\n            best = Math.Max(best, val);\n            maxes.Add(best);\n\
    \        });\n        return maxes;", "        long mx = numbers[0];\n       \
    \ List<long> res = new List<long>();\n        res.Add(mx);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            if (numbers[i] > mx)\n         \
    \       mx = numbers[i];\n            res.Add(mx);\n        }\n        return\
    \ res;", "        long N = numbers.Count;\n        var maxs = new List<long>();\n\
    \        long max = numbers[0];\n        maxs.Add(max);\n        for (long i =\
    \ 1; i < N; i++) {\n            max = Math.Max(max, numbers[(int)i]);\n      \
    \      maxs.Add(max);\n        }\n        return maxs;", "        List<long> result\
    \ = new List<long>();\n        long currentMax = (long)0L;\n        for (int i\
    \ = 0; i < numbers.Count; i++) {\n            currentMax = Math.Max(currentMax,\
    \ numbers[i]);\n            result.Add(currentMax);\n        }\n        return\
    \ result;", "        var result = new List<long>();\n        long rollingMax =\
    \ long.MinValue;\n        for (int i = 0; i < numbers.Count; i++) {\n        \
    \    rollingMax = Math.Max(rollingMax, numbers[i]);\n            result.Add(rollingMax);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        long max = numbers[0];\n        result.Add(max);\n        for (long i\
    \ = (long)1L; i < numbers.Count; i++) {\n            if (numbers[(int)i] > max)\
    \ {\n                max = numbers[(int)i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var max_up_to = new List<long>();\n\
    \        long current_max = long.MinValue;\n        foreach (var num in numbers)\
    \ {\n            if (num > current_max) {\n                current_max = num;\n\
    \            }\n            max_up_to.Add(current_max);\n        }\n        return\
    \ max_up_to;", "        var result = new List<long>();\n        var max = numbers[0];\n\
    \        result.Add(max);\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            max = Math.Max(max, numbers[i]);\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> maximums = new List<long>();\n\
    \        long max = numbers[0];\n        maximums.Add(max);\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            max = Math.Max(max, numbers[i]);\n\
    \            maximums.Add(max);\n        }\n        return maximums;", "     \
    \   // Make a copy of the passed sequence\n        // >>> list_copy = (new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)3L, (long)2L, (long)3L, (long)4L, (long)2L}))\n\
    \        List<long> list_copy = numbers;\n        // Build a result array\n  \
    \      // >>> result = (new List<long>(new long[]{}))\n        List<long> result\
    \ = new List<long>();\n        // Iterate over the list\n        // >>> for ((long)iL\
    \ in (new List<long>(new long[]{(long)0L, (long)1L, (long)2L, (long)3L, (long)4L,\
    \ (long)5L, (long)6L})))\n        for (long iL = 0; iL < list_copy.Count; iL++)\
    \ {\n            // >>> result.add((long)Math.Max((long)list_copy[(long)iL], (long)list_copy[(long)0L]))\n\
    \            result.Add(Math.Max(list_copy[(int)iL], list_copy[0]));\n       \
    \     // >>> list_copy[(long)0L] = (long)Math.Max((long)list_copy[(long)0L], (long)list_copy[(long)iL])\n\
    \            list_copy[0] = Math.Max(list_copy[0], list_copy[(int)iL]);\n    \
    \    }\n        // >>> return result\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long max = 0;\n        foreach (long n in\
    \ numbers) {\n            max = Math.Max(max, n);\n            result.Add(max);\n\
    \        }\n        return result;", "        var rolling_max = new List<long>();\n\
    \        long max = numbers[0];\n        for (int j = 0; j < numbers.Count; j++)\
    \ {\n            if (numbers[j] > max) {\n                max = numbers[j];\n\
    \            }\n            rolling_max.Add(max);\n        }\n        return rolling_max;",
  "        long max = numbers[0];\n        List<long> maximums = new List<long>();\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            max = (long)Math.Max(max,\
    \ numbers[i]);\n            maximums.Add(max);\n        }\n        return maximums;",
  "        long max = numbers[0];\n        List<long> result = new List<long>();\n\
    \        result.Add(max);\n        foreach (long i in numbers.Skip(1)) {\n   \
    \         max = Math.Max(max, i);\n            result.Add(max);\n        }\n \
    \       return result;", "        var result = new List<long>();\n        long\
    \ currMax = 0;\n        foreach (var num in numbers) {\n            if (num >\
    \ currMax) {\n                currMax = num;\n            }\n            result.Add(currMax);\n\
    \        }\n        return result;", "        List<long> ret = new List<long>();\n\
    \        long max = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n  \
    \          max = Math.Max(max, numbers[i]);\n            ret.Add(max);\n     \
    \   }\n        return ret;", "        long maxSoFar = numbers[0];\n        List<long>\
    \ res = new List<long>();\n        res.Add(maxSoFar);\n        for (int i = 1;\
    \ i < numbers.Count; i++) {\n            maxSoFar = Math.Max(maxSoFar, numbers[i]);\n\
    \            res.Add(maxSoFar);\n        }\n        return res;", "        var\
    \ ret = new List<long>();\n        for (var i = 0; i < numbers.Count; i++) {\n\
    \            var max = numbers[i];\n            for (var j = 0; j <= i; j++) {\n\
    \                if (numbers[j] > max) {\n                    max = numbers[j];\n\
    \                }\n            }\n            ret.Add(max);\n        }\n    \
    \    return ret;", "        List<long> maxes = new List<long>();\n        long\
    \ max = numbers[0];\n        maxes.Add(max);\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            long n = numbers[i];\n            if (n > max) {\n     \
    \           max = n;\n            }\n            maxes.Add(max);\n        }\n\
    \        return maxes;", "        List<long> maximums = new List<long>();\n  \
    \      long max = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n    \
    \        max = Math.Max(max, numbers[i]);\n            maximums.Add(max);\n  \
    \      }\n        return maximums;", "        List<long> rolling = new List<long>();\n\
    \        long max = numbers[0];\n        rolling.Add(max);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            if (numbers[i] > max)\n        \
    \        max = numbers[i];\n            rolling.Add(max);\n        }\n       \
    \ return rolling;", "        var rollingMaximum = new List<long>();\n        rollingMaximum.Add(numbers[0]);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > rollingMaximum[i - 1]) {\n                rollingMaximum.Add(numbers[i]);\n\
    \            } else {\n                rollingMaximum.Add(rollingMaximum[i - 1]);\n\
    \            }\n        }\n        return rollingMaximum;", "        long n =\
    \ (long)numbers.Count;\n        List<long> result = new List<long>((int)n);\n\
    \        long currentMax = numbers[0];\n        result.Add(currentMax);\n    \
    \    for (long i = (long)1L; i < n; i++) {\n            currentMax = Math.Max(currentMax,\
    \ numbers[(int)i]);\n            result.Add(currentMax);\n        }\n        return\
    \ result;", "        var result = new List<long>();\n        long currentMaximum\
    \ = long.MinValue;\n        foreach (var number in numbers) {\n            if\
    \ (number > currentMaximum)\n                currentMaximum = number;\n      \
    \      result.Add(currentMaximum);\n        }\n        return result;", "    \
    \    List<long> ans = new List<long>();\n        long maxSoFar = numbers[0];\n\
    \        ans.Add(maxSoFar);\n        for (int i = 1; i < numbers.Count; i++) {\n\
    \            maxSoFar = Math.Max(maxSoFar, numbers[i]);\n            ans.Add(maxSoFar);\n\
    \        }\n        return ans;", "        // They are in non-decreasing order\n\
    \        List<long> result = new List<long>();\n        long max = long.MinValue;\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var cnt = numbers.Count;\n     \
    \   var maxs = new List<long>();\n        var max = numbers[0];\n        for (int\
    \ i = 0; i < cnt; i++) {\n            max = Math.Max(max, numbers[i]);\n     \
    \       maxs.Add(max);\n        }\n        return maxs;", "        List<long>\
    \ ans = new List<long>();\n        long m = numbers[0];\n        ans.Add(m);\n\
    \        foreach (long n in numbers.Skip(1)) {\n            if (n > m) {\n   \
    \             m = n;\n            }\n            ans.Add(m);\n        }\n    \
    \    return ans;", "        List<long> result = new List<long>();\n        long\
    \ previous = numbers[0];\n        result.Add(previous);\n        for (int i =\
    \ 1; i < numbers.Count; i++) {\n            if (numbers[i] > previous) {\n   \
    \             previous = numbers[i];\n            }\n            result.Add(previous);\n\
    \        }\n        return result;", "        long count = numbers.Count;\n  \
    \      List<long> rollingMax = new List<long>();\n        for (int i = 0; i <\
    \ count; i++) {\n            rollingMax.Add(Max(numbers.Take(i + 1)));\n     \
    \   }\n        return rollingMax;", "        var result = new List<long>();\n\
    \        if (numbers.Count == 0) {\n            return result;\n        }\n  \
    \      result.Add(numbers[0]);\n        for (long i = 1; i < numbers.Count; i++)\
    \ {\n            result.Add(Math.Max(result[(int)(i - 1)], numbers[(int)(i)]));\n\
    \        }\n        return result;", "        List<long> max = new List<long>();\n\
    \        long max_value = numbers[0];\n        max.Add(max_value);\n        int\
    \ n = numbers.Count;\n        for (int i = 1; i < n; i++) {\n            if (numbers[i]\
    \ > max_value) {\n                max_value = numbers[i];\n            }\n   \
    \         max.Add(max_value);\n        }\n        return max;", "        long\
    \ max = 0;\n        List<long> result = new List<long>();\n        foreach (long\
    \ number in numbers) {\n            max = Math.Max(max, number);\n           \
    \ result.Add(max);\n        }\n        return result;", "        var res = new\
    \ List<long>();\n        long max = 0;\n        foreach (var num in numbers) {\n\
    \            if (num > max) {\n                max = num;\n            }\n   \
    \         res.Add(max);\n        }\n        return res;", "        List<long>\
    \ result = new List<long>();\n        long max = numbers[0];\n        result.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            max = Math.Max(max,\
    \ numbers[i]);\n            result.Add(max);\n        }\n        return result;",
  "        var result = new List<long>();\n        var rolling_max = 0L;\n       \
    \ foreach (var i in numbers) {\n            rolling_max = Math.Max(rolling_max,\
    \ i);\n            result.Add(rolling_max);\n        }\n        return result;",
  "        var result = new List<long>();\n        var currentMax = numbers[0];\n\
    \        result.Add(currentMax);\n        foreach (var num in numbers.Skip(1))\
    \ {\n            if (num > currentMax) {\n                currentMax = num;\n\
    \            }\n            result.Add(currentMax);\n        }\n        return\
    \ result;", "        var N = numbers.Count;\n        List<long> res = new List<long>();\n\
    \        for (int i = 0; i < N; i++) {\n            var max = numbers[i];\n  \
    \          for (int j = 0; j <= i; j++) {\n                max = Math.Max(max,\
    \ numbers[j]);\n            }\n            res.Add(max);\n        }\n        return\
    \ res;", "        List<long> result = new List<long>();\n        long max = numbers[0];\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            max = Math.Max(max,\
    \ numbers[i]);\n            result.Add(max);\n        }\n        return result;",
  "        var rmax = new List<long>();\n        if (numbers.Count < 1) return rmax;\n\
    \        var maxsofar = numbers[0];\n        rmax.Add(maxsofar);\n        foreach\
    \ (var n in numbers.Skip(1)) {\n            maxsofar = Math.Max(maxsofar, n);\n\
    \            rmax.Add(maxsofar);\n        }\n        return rmax;", "        var\
    \ result = new List<long>();\n        var maxSoFar = numbers[0];\n        result.Add(maxSoFar);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > maxSoFar) {\n                maxSoFar = numbers[i];\n            }\n     \
    \       result.Add(maxSoFar);\n        }\n        return result;", "        //\
    \ https://cses.fi/problemset/task/1752/\n        var result = new List<long>();\n\
    \        var stack = new Stack<long>();\n        for (var i = 0; i < numbers.Count;\
    \ i++) {\n            var n = numbers[i];\n            if (stack.Count == 0) {\n\
    \                result.Add(n);\n                stack.Push(n);\n            }\
    \ else {\n                if (n >= stack.Peek()) {\n                    result.Add(n);\n\
    \                    stack.Push(n);\n                } else {\n              \
    \      while (stack.Count > 0 && n < stack.Peek()) {\n                       \
    \ stack.Pop();\n                    }\n                    if (stack.Count ==\
    \ 0) {\n                        result.Add(n);\n                        stack.Push(n);\n\
    \                    } else {\n                        result.Add(stack.Peek());\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ result;", "        var result = new List<long>();\n        long Max = long.MinValue;\n\
    \        foreach (var number in numbers) {\n            if (number > Max) {\n\
    \                Max = number;\n            }\n            result.Add(Max);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        result.Add(numbers[0]);\n        long max = numbers[0];\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n\
    \                max = numbers[i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        result.Add(numbers[0]);\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            long currentMax = result[i - 1];\n            if (numbers[i]\
    \ > currentMax) {\n                currentMax = numbers[i];\n            }\n \
    \           result.Add(currentMax);\n        }\n        return result;", "   \
    \     var result = new List<long>();\n        var max = long.MinValue;\n     \
    \   for (int i = 0; i < numbers.Count; i++) {\n            if (numbers[i] > max)\
    \ {\n                max = numbers[i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var max = numbers[0];\n        result.Add(max);\n        foreach (var\
    \ n in numbers.Skip(1)) {\n            if (n > max) {\n                max = n;\n\
    \            }\n            result.Add(max);\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        long currentMaximum = numbers[0];\n\
    \        result.Add(currentMaximum);\n        for (long i = 1; i < numbers.Count;\
    \ i++) {\n            if (numbers[(int)i] > currentMaximum) {\n              \
    \  currentMaximum = numbers[(int)i];\n            }\n            result.Add(currentMaximum);\n\
    \        }\n        return result;", "        var result = new List<long>();\n\
    \        var temp = new List<long>();\n        var numbersOrdered = numbers.OrderBy(x\
    \ => x).ToList();\n        foreach (var num in numbersOrdered) {\n           \
    \ while (temp.Count > 0 && temp[temp.Count - 1] <= num) {\n                temp.RemoveAt(temp.Count\
    \ - 1);\n            }\n            temp.Add(num);\n            result.Add(temp[0]);\n\
    \        }\n        return result;", "        var len = numbers.Count;\n     \
    \   var m   = numbers[0];\n        var rollingMax = new List<long> {m};\n    \
    \    for (var i = 1; i < len; i++) {\n            var n = numbers[i];\n      \
    \      rollingMax.Add(Math.Max(m, n));\n            m = rollingMax[i];\n     \
    \   }\n        return rollingMax;", "        long acc = long.MinValue;\n     \
    \   List<long> accs = new List<long>();\n        foreach (long v in numbers) {\n\
    \            acc = Math.Max(acc, v);\n            accs.Add(acc);\n        }\n\
    \        return accs;", "        List<long> result = new List<long>();\n     \
    \   long currentMax = numbers[0];\n        result.Add(currentMax);\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            currentMax = Math.Max(currentMax,\
    \ numbers[i]);\n            result.Add(currentMax);\n        }\n        return\
    \ result;", "        List<long> answer = new List<long>();\n        long max =\
    \ 0;\n        foreach (long number in numbers) {\n            max = Math.Max(max,\
    \ number);\n            answer.Add(max);\n        }\n        return answer;",
  "        if (numbers.Count == 0) {\n            return numbers;\n        }\n   \
    \     List<long> maxList = new List<long>();\n        maxList.Add(numbers[0]);\n\
    \        long max = numbers[0];\n        foreach (long num in numbers) {\n   \
    \         if (num > max) {\n                max = num;\n            }\n      \
    \      maxList.Add(max);\n        }\n        return maxList;", "        long curMax\
    \ = numbers[0];\n        List<long> maxUntil = new List<long>();\n        maxUntil.Add(curMax);\n\
    \        int n = numbers.Count;\n        for (int i = 1; i < n; i++) {\n     \
    \       curMax = Math.Max(curMax, numbers[i]);\n            maxUntil.Add(curMax);\n\
    \        }\n        return maxUntil;", "        var result = new List<long>();\n\
    \        long rollingMax = numbers[0];\n        result.Add(rollingMax);\n    \
    \    for (long j = 1L; j < numbers.Count; j++) {\n            rollingMax = Math.Max(rollingMax,\
    \ numbers[(int)j]);\n            result.Add(rollingMax);\n        }\n        return\
    \ result;", "        List<long> res = new List<long>();\n        foreach (var\
    \ i in numbers) {\n            var last = res.LastOrDefault();\n            if\
    \ (last < i) {\n                res.Add(i);\n            } else {\n          \
    \      res.Add(last);\n            }\n        }\n        return res;", "     \
    \   var list = new List<long>();\n        var maxValue = 0L;\n        foreach\
    \ (var number in numbers) {\n            if (number > maxValue) {\n          \
    \      maxValue = number;\n            }\n            list.Add(maxValue);\n  \
    \      }\n        return list;", "        List<long> rollingMax = new List<long>();\n\
    \        long currentMax = numbers[0];\n        rollingMax.Add(currentMax);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            currentMax = Math.Max(currentMax,\
    \ numbers[i]);\n            rollingMax.Add(currentMax);\n        }\n        return\
    \ rollingMax;", "        var retval = new List<long>();\n        long currMax\
    \ = 0;\n        foreach (var currNum in numbers) {\n            currMax = Math.Max(currNum,\
    \ currMax);\n            retval.Add(currMax);\n        }\n        return retval;",
  "        var result = new List<long>();\n        result.Add(numbers[0]);\n     \
    \   for (int i = 1; i < numbers.Count; i++) {\n            result.Add(Math.Max(result[i\
    \ - 1], numbers[i]));\n        }\n        return result;", "        long max =\
    \ numbers[0];\n        var result = new List<long>();\n        result.Add(max);\n\
    \        foreach (var num in numbers.Skip(1)) {\n            if (num > max) {\n\
    \                max = num;\n            }\n            result.Add(max);\n   \
    \     }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long maxValue = numbers[0];\n        result.Add(maxValue);\n        for\
    \ (long i = (long)1L; i < numbers.Count; i++) {\n            maxValue = Math.Max(maxValue,\
    \ numbers[(int)i]);\n            result.Add(maxValue);\n        }\n        return\
    \ result;", "        List<long> result = new List<long>();\n        long max =\
    \ numbers[0];\n        for (int i = 0; i < numbers.Count; i++) {\n           \
    \ if (numbers[i] > max) {\n                max = numbers[i];\n            }\n\
    \            result.Add(max);\n        }\n        return result;", "        //\
    \ >>> RollingMax((new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)2L,\
    \ (long)3L, (long)4L, (long)2L})))\n        // (new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)3L, (long)3L, (long)3L, (long)4L, (long)4L}))\n        List<long>\
    \ result = new List<long>();\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            long max = numbers[i];\n            for (int j = 0; j <= i; j++)\
    \ {\n                if (numbers[j] > max) {\n                    max = numbers[j];\n\
    \                }\n            }\n            result.Add(max);\n        }\n \
    \       return result;", "        List<long> answer = new List<long>();\n    \
    \    long maxElem = numbers[0];\n        answer.Add(maxElem);\n        for (int\
    \ i = 1; i < numbers.Count; i++) {\n            long nextElem = numbers[i];\n\
    \            maxElem = Math.Max(maxElem, nextElem);\n            answer.Add(maxElem);\n\
    \        }\n        return answer;", "        if (numbers.Count == 0) {\n    \
    \        return new List<long>();\n        }\n        List<long> ans = new List<long>();\n\
    \        ans.Add(numbers[0]);\n        long current = numbers[0];\n        for\
    \ (int i = 1; i < numbers.Count; i++) {\n            current = Math.Max(current,\
    \ numbers[i]);\n            ans.Add(current);\n        }\n        return ans;",
  "        var answer = new List<long>();\n        long max = 0;\n        foreach\
    \ (var i in numbers) {\n            max = Math.Max(max, i);\n            answer.Add(max);\n\
    \        }\n        return answer;", "        List<long> max = new List<long>();\n\
    \        // Fill out the max array\n        foreach (long num in numbers) {\n\
    \            if (max.Count == 0) {\n                max.Add(num);\n          \
    \  } else {\n                max.Add(Math.Max(max[max.Count - 1], num));\n   \
    \         }\n        }\n        return max;", "        var longest = new List<long>();\n\
    \        var max = numbers[0];\n        longest.Add(max);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n      \
    \          max = numbers[i];\n            }\n            longest.Add(max);\n \
    \       }\n        return longest;", "        // You need to replace this with\
    \ your code\n        return null;", "        long current = (long)0L;\n      \
    \  List<long> ret = new List<long>();\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            if (numbers[i] > current) {\n                current = numbers[i];\n\
    \            }\n            ret.Add(current);\n        }\n        return ret;",
  "        List<long> result = new List<long>();\n        var s = new Stack<Tuple<long,\
    \ long>>();\n        for (long i = 0; i < numbers.Count; i++) {\n            var\
    \ n = numbers[(int)i];\n            while (s.Count > 0 && s.Peek().Item1 < n)\
    \ {\n                s.Pop();\n            }\n            s.Push(Tuple.Create(n,\
    \ i));\n            result.Add(s.Peek().Item1);\n        }\n        return result;",
  "        return numbers.Select((number, idx) =>\n            numbers.Take(idx +\
    \ 1).Max()\n        ).ToList();", "        if(numbers.Count == 0) {\n        \
    \    return numbers;\n        }\n        List<long> results = new List<long>();\n\
    \        long max = numbers[0];\n        results.Add(max);\n        for(int i\
    \ = 1; i < numbers.Count; i++) {\n            max = Max(max, numbers[i]);\n  \
    \          results.Add(max);\n        }\n        return results;", "        List<long>\
    \ ret = new List<long>();\n        long maxx = numbers[0];\n        ret.Add(maxx);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            maxx = Math.Max(maxx,\
    \ numbers[i]);\n            ret.Add(maxx);\n        }\n        return ret;", " \
    \       var ret = new List<long>();\n        long max = numbers[0];\n        ret.Add(max);\n\
    \        foreach (var num in numbers.Skip(1)) {\n            if (num > max) {\n\
    \                max = num;\n            }\n            ret.Add(max);\n      \
    \  }\n        return ret;", "        long max = 0;\n        List<long> r = new\
    \ List<long>();\n        foreach (long n in numbers) {\n            max = Math.Max(max,\
    \ n);\n            r.Add(max);\n        }\n        return r;", "        var rolling\
    \ = new List<long>();\n        var max = numbers[0];\n        for (int i = 0;\
    \ i < numbers.Count; i++) {\n            max = Math.Max(max, numbers[i]);\n  \
    \          rolling.Add(max);\n        }\n        return rolling;", "        if\
    \ (numbers.Count == 0) {\n            return numbers;\n        }\n        List<long>\
    \ result = new List<long>();\n        result.Add(numbers[0]);\n        long max\
    \ = numbers[0];\n        for (int i = 1; i < numbers.Count; i++) {\n         \
    \   if (numbers[i] > max) {\n                max = numbers[i];\n            }\n\
    \            result.Add(max);\n        }\n        return result;", "        long\
    \ max = numbers[0];\n        List<long> result = new List<long>();\n        result.Add(max);\n\
    \        foreach (long e in numbers.Skip(1)) {\n            if (e > max) {\n \
    \               max = e;\n            }\n            result.Add(max);\n      \
    \  }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long largestSoFar = 0;\n        foreach (long x in numbers) {\n     \
    \       if (x > largestSoFar) {\n                largestSoFar = x;\n         \
    \   }\n            result.Add(largestSoFar);\n        }\n        return result;",
  "        var maxSoFar = new List<long>();\n        long? currentMax = null;\n  \
    \      foreach (var n in numbers) {\n            if (currentMax == null || n >\
    \ currentMax) {\n                currentMax = n;\n            }\n            maxSoFar.Add(currentMax.Value);\n\
    \        }\n        return maxSoFar;", "        var result = new List<long>();\n\
    \        var currentMax = numbers[0];\n        result.Add(currentMax);\n     \
    \   for (var i = 1; i < numbers.Count; i++) {\n            if (numbers[i] > currentMax)\
    \ {\n                currentMax = numbers[i];\n            }\n            result.Add(currentMax);\n\
    \        }\n        return result;", "        List<long> ans = new List<long>();\n\
    \        foreach (var n in numbers) {\n            if (ans.Count == 0) {\n   \
    \             ans.Add(n);\n            } else {\n                ans.Add(Math.Max(ans[ans.Count\
    \ - 1], n));\n            }\n        }\n        return ans;", "        List<long>\
    \ result = new List<long>();\n        long currentMax = long.MinValue;\n     \
    \   foreach (long n in numbers) {\n            currentMax = Math.Max(currentMax,\
    \ n);\n            result.Add(currentMax);\n        }\n        return result;",
  "        List<long> rolling = new List<long>();\n        long largest = long.MinValue;\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            largest = Math.Max(largest,\
    \ numbers[i]);\n            rolling.Add(largest);\n        }\n        return rolling;",
  "        var result = new List<long>();\n        foreach (var number in numbers)\
    \ {\n            if (result.Count == 0) {\n                result.Add(number);\n\
    \            } else {\n                result.Add(Math.Max(result[result.Count\
    \ - 1], number));\n            }\n        }\n        return result;", "      \
    \  long curMax = numbers[0];\n        List<long> res = new List<long>();\n   \
    \     res.Add(curMax);\n        for (int i = 1; i < numbers.Count; i++) {\n  \
    \          curMax = Math.Max(curMax, numbers[i]);\n            res.Add(curMax);\n\
    \        }\n        return res;", "        List<long> output = new List<long>();\n\
    \        long max = numbers[0];\n        output.Add(max);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n      \
    \          max = numbers[i];\n            }\n            output.Add(max);\n  \
    \      }\n        return output;", "        var rmax = new List<long>();\n   \
    \     long max = numbers[0];\n        rmax.Add(max);\n        for (int i = 1;\
    \ i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n           \
    \     max = numbers[i];\n            }\n            rmax.Add(max);\n        }\n\
    \        return rmax;", "        var result = new List<long>();\n        long\
    \ currentMax = long.MinValue;\n        foreach (var number in numbers) {\n   \
    \         if (number > currentMax) {\n                currentMax = number;\n \
    \           }\n            result.Add(currentMax);\n        }\n        return\
    \ result;", "        List<long> currentMaximum = new List<long>();\n        long\
    \ maximum = numbers[0];\n        currentMaximum.Add(maximum);\n        for (long\
    \ i = 1; i < numbers.Count; i++) {\n            if (numbers[(int)i] > maximum)\
    \ {\n                maximum = numbers[(int)i];\n            }\n            currentMaximum.Add(maximum);\n\
    \        }\n        return currentMaximum;", "        var n = numbers.Count;\n\
    \        var result = new List<long>(new long[n]);\n        var max = numbers[0];\n\
    \        result[0] = max;\n        for (int i = 1; i < n; i++) {\n           \
    \ max = Math.Max(max, numbers[i]);\n            result[i] = max;\n        }\n\
    \        return result;", "        var maxes = new List<long>();\n        long\
    \ currentMax = long.MinValue;\n        foreach (var n in numbers) {\n        \
    \    if (n > currentMax) {\n                currentMax = n;\n            }\n \
    \           maxes.Add(currentMax);\n        }\n        return maxes;", "     \
    \   List<long> result = new List<long>();\n        long best = numbers[0];\n \
    \       result.Add(best);\n        foreach (long number in numbers.Skip(1)) {\n\
    \            best = Math.Max(best, number);\n            result.Add(best);\n \
    \       }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long maximum = 0;\n        foreach (long num in numbers) {\n        \
    \    maximum = Math.Max(maximum, num);\n            result.Add(maximum);\n   \
    \     }\n        return result;", "        long maxSoFar = numbers[0];\n     \
    \   List<long> result = new List<long>();\n        foreach (long n in numbers)\
    \ {\n            maxSoFar = Math.Max(maxSoFar, n);\n            result.Add(maxSoFar);\n\
    \        }\n        return result;", "        var currentMax = numbers[0];\n \
    \       var result = new List<long>();\n        result.Add(currentMax);\n    \
    \    foreach (var n in numbers.Skip(1)) {\n            if (n > currentMax) {\n\
    \                currentMax = n;\n            }\n            result.Add(currentMax);\n\
    \        }\n        return result;", "        long max = numbers[0];\n       \
    \ for (long i = 1; i < numbers.Count; i++) {\n            max = Math.Max(max,\
    \ numbers[(int)i]);\n            numbers[(int)i] = max;\n        }\n        return\
    \ numbers;", "        var acc = (long)0L;\n        var final = new List<long>();\n\
    \        foreach (var n in numbers) {\n            acc = (long)Math.Max(acc, n);\n\
    \            final.Add(acc);\n        }\n        return final;", "        if(numbers.Count\
    \ == 0) return numbers;\n        List<long> result = new List<long>();\n     \
    \   long max = numbers[0];\n        result.Add(max);\n        for(int i = 1; i\
    \ < numbers.Count; i++) {\n            if(numbers[i] > max) max = numbers[i];\n\
    \            result.Add(max);\n        }\n        return result;", "        long\
    \ currMax = numbers[0];\n        var result = new List<long>();\n        result.Add(currMax);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > currMax) {\n                currMax = numbers[i];\n            }\n       \
    \     result.Add(currMax);\n        }\n        return result;", "        List<long>\
    \ rolling = new List<long>();\n        rolling.Add(numbers[0]);\n        foreach\
    \ (var number in numbers.Skip(1)) {\n            rolling.Add(Math.Max(rolling.Last(),\
    \ number));\n        }\n        return rolling;", "        List<long> result =\
    \ new List<long>();\n        long currentMax = numbers[0];\n        result.Add(currentMax);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > currentMax) {\n                currentMax = numbers[i];\n            }\n \
    \           result.Add(currentMax);\n        }\n        return result;", "   \
    \     var ret = new List<long>();\n        long max_value = numbers[0];\n    \
    \    for (long i = 0; i < numbers.Count; i++) {\n            if (numbers[(int)i]\
    \ > max_value) {\n                max_value = numbers[(int)i];\n            }\n\
    \            ret.Add(max_value);\n        }\n        return ret;", "        List<long>\
    \ result = new List<long>();\n        long max = numbers[0];\n        result.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        long currentMax = numbers[0];\n        for (int i = 0; i < numbers.Count;\
    \ i++) {\n            currentMax = Math.Max(currentMax, numbers[i]);\n       \
    \     result.Add(currentMax);\n        }\n        return result;", "        List<long>\
    \ result = new List<long>();\n        long m = numbers[0];\n        result.Add(m);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > m) {\n                m = numbers[i];\n            }\n            result.Add(m);\n\
    \        }\n        return result;", "        var n = numbers.Count;\n       \
    \ var ret = new List<long>();\n        ret.Add(numbers[0]);\n        for (var\
    \ i = 1; i < n; i++) {\n            ret.Add(System.Math.Max(ret[i - 1], numbers[i]));\n\
    \        }\n        return ret;", "        List<long> ret = new List<long>();\n\
    \        long maximum = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n\
    \            if (numbers[i] > maximum) {\n                maximum = numbers[i];\n\
    \            }\n            ret.Add(maximum);\n        }\n        return ret;",
  "        long m = (long)0L;\n        var rm = new List<long>();\n        foreach\
    \ (var _n in numbers)\n        {\n            if (_n > m)\n            {\n   \
    \             m = _n;\n            }\n\n            rm.Add(m);\n\n        }\n\n\
    \        return rm;\n", '        return numbers.Select((_, k) => numbers.Take(k
    + 1).Max()).ToList();', "        List<long> rollingMax = new List<long>();\n \
    \       for (int i = 0; i < numbers.Count; i++) {\n            long maxNumber\
    \ = numbers[i];\n            for (int j = 0; j <= i; j++) {\n                maxNumber\
    \ = Math.Max(maxNumber, numbers[j]);\n            }\n            rollingMax.Add(maxNumber);\n\
    \        }\n        return rollingMax;", "        List<long> result = new List<long>();\n\
    \        long m = long.MinValue;\n        foreach (long num in numbers) {\n  \
    \          m = Math.Max(m, num);\n            result.Add(m);\n        }\n    \
    \    return result;", "        List<long> rollingMax = new List<long>();\n   \
    \     long max = numbers[0];\n        rollingMax.Add(max);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            max = Math.Max(max, numbers[i]);\n\
    \            rollingMax.Add(max);\n        }\n        return rollingMax;", " \
    \       var result = new List<long>();\n        var maxSeen = -1L;\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            maxSeen = Math.Max(maxSeen,\
    \ numbers[i]);\n            result.Add(maxSeen);\n        }\n        return result;",
  "        long max = (long) 0L;\n        List<long> result = new List<long>();\n\
    \        foreach (long n in numbers) {\n            max = Math.Max(max, n);\n\
    \            result.Add(max);\n        }\n        return result;", "        long\
    \ max = 0;\n        List<long> result = new List<long>();\n        foreach (long\
    \ i in numbers) {\n            if (i > max) {\n                max = i;\n    \
    \        }\n            result.Add(max);\n        }\n        return result;",
  "        List<long> ret = new List<long>();\n        ret.Add(numbers[0]);\n    \
    \    for (int i = 1; i < numbers.Count; i++) {\n            ret.Add(Math.Max(ret[i\
    \ - 1], numbers[i]));\n        }\n        return ret;", "        List<long> result\
    \ = new List<long>();\n        long max = numbers[0];\n        result.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            long number =\
    \ numbers[i];\n            if (number > max) {\n                max = number;\n\
    \            }\n            result.Add(max);\n        }\n        return result;",
  "        List<long> maxes = new List<long>();\n        long currentMax = numbers[0];\n\
    \        maxes.Add(currentMax);\n        for (int i = 1; i < numbers.Count; i++)\
    \ {\n            if (numbers[i] > currentMax) {\n                currentMax =\
    \ numbers[i];\n            }\n            maxes.Add(currentMax);\n        }\n\
    \        return maxes;", "        var counts = new List<long>();\n        long\
    \ max = numbers[0];\n        for (int i = 0; i < numbers.Count; i++) {\n     \
    \       max = Math.Max(max, numbers[i]);\n            counts.Add(max);\n     \
    \   }\n        return counts;", "        var max = new List<long>();\n       \
    \ var current = numbers[0];\n        for (int i = 0; i < numbers.Count; i++) {\n\
    \            max.Add(current);\n            if (numbers[i] > current) {\n    \
    \            current = numbers[i];\n            }\n        }\n        return max;",
  "        List<long> res = new List<long>();\n        long max = 0;\n        foreach\
    \ (long num in numbers) {\n            max = (num > max) ? num : max;\n      \
    \      res.Add(max);\n        }\n        return res;", "        // Your code goes\
    \ here.\n        return numbers;", "        List<long> ret = new List<long>();\n\
    \        long max = numbers[0];\n        ret.Add(max);\n        for (int i = 1;\
    \ i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n           \
    \     max = numbers[i];\n            }\n            ret.Add(max);\n        }\n\
    \        return ret;", "        if (numbers.Count == 0) return numbers;\n    \
    \    var numbersRolling = new List<long>();\n        var currentMaximum = numbers[0];\n\
    \        numbersRolling.Add(currentMaximum);\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            var n = numbers[i];\n            if (n > currentMaximum)\
    \ {\n                currentMaximum = n;\n            }\n            numbersRolling.Add(currentMaximum);\n\
    \        }\n        return numbersRolling;", "        long currentMax = numbers[0];\n\
    \        List<long> result = new List<long>();\n        result.Add(currentMax);\n\
    \        int n = numbers.Count;\n        for (int i = 1; i < n; i++) {\n     \
    \       currentMax = Math.Max(currentMax, numbers[i]);\n            result.Add(currentMax);\n\
    \        }\n        return result;", "        long result = 0;\n        List<long>\
    \ storage = new List<long>();\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            if (numbers[i] > result) {\n                result = numbers[i];\n\
    \            }\n            storage.Add(result);\n        }\n        return storage;",
  "        List<long> maxs = new List<long>();\n        long max = numbers[0];\n \
    \       maxs.Add(max);\n        for (int i = 1; i < numbers.Count; i++) {\n  \
    \          long num = numbers[i];\n            if (num > max) {\n            \
    \    max = num;\n            }\n            maxs.Add(max);\n        }\n      \
    \  return maxs;", "        List<long> res = new List<long>();\n        long currentMax\
    \ = 0;\n        for (int i = 0; i < numbers.Count; i++) {\n            currentMax\
    \ = numbers[i] > currentMax ? numbers[i] : currentMax;\n            res.Add(currentMax);\n\
    \        }\n        return res;", "        List<long> max = new List<long>();\n\
    \        long currentMax = numbers[0];\n        max.Add(currentMax);\n       \
    \ for (int i = 1; i < numbers.Count; i++) {\n            currentMax = Math.Max(currentMax,\
    \ numbers[i]);\n            max.Add(currentMax);\n        }\n        return max;",
  "        var ret = new List<long>();\n        long curr_max = numbers[0];\n    \
    \    ret.Add(curr_max);\n        for (int i = 1; i < numbers.Count; i++) {\n \
    \           curr_max = numbers[i] > curr_max ? numbers[i] : curr_max;\n      \
    \      ret.Add(curr_max);\n        }\n        return ret;", "        var rollmax\
    \ = new List<long>();\n        long currentmax = numbers[0];\n        rollmax.Add(currentmax);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            currentmax = (long)Math.Max(currentmax,\
    \ numbers[i]);\n            rollmax.Add(currentmax);\n        }\n        return\
    \ rollmax;", "        List<long> result = new List<long>();\n        long max\
    \ = numbers[0];\n        result.Add(max);\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            max = Math.Max(max, numbers[i]);\n            result.Add(max);\n\
    \        }\n        return result;", "        var answer = new List<long>();\n\
    \        long max_number = 0;\n        foreach (var i in numbers) {\n        \
    \    max_number = Math.Max(max_number, i);\n            answer.Add(max_number);\n\
    \        }\n        return answer;", "        // We are going to generate new\
    \ list in reversed order, so we can use this\n        // list to always know what\
    \ is the current maximum element.\n        List<long> maximums = new List<long>();\n\
    \        maximums.Add(numbers[numbers.Count - 1]);\n        for (int i = numbers.Count\
    \ - 2; i >= 0; i--) {\n            maximums.Add(Math.Max(maximums[maximums.Count\
    \ - 1], numbers[i]));\n        }\n        // Now we can reverse this list and\
    \ append elements in correct order.\n        maximums.Reverse();\n        // If\
    \ a number is not equal to its maximum, we set it to 0.\n        for (int i =\
    \ 0; i < numbers.Count; i++) {\n            if (numbers[i] != maximums[i]) {\n\
    \                numbers[i] = 0;\n            }\n        }\n        return numbers;",
  "        var result = new List<long>();\n        var rollmax = 0L;\n        foreach\
    \ (var number in numbers) {\n            rollmax = Math.Max(rollmax, number);\n\
    \            result.Add(rollmax);\n        }\n        return result;", "     \
    \   return Enumerable.Range(0, numbers.Count).Select(\n            i => numbers.Skip(i).Max()\n\
    \        ).ToList();", "        List<long> res = new List<long>();\n        for\
    \ (int i = 0; i < numbers.Count; i++) {\n            res.Add(numbers.GetRange(0,\
    \ i + 1).Max());\n        }\n        return res;", "        var revNumbers = new\
    \ List<long>(numbers);\n        revNumbers.Reverse();\n        long previousMax\
    \ = long.MinValue;\n        List<long> result = new List<long>();\n        foreach\
    \ (var num in revNumbers) {\n            if (num > previousMax) {\n          \
    \      previousMax = num;\n            }\n            result.Add(previousMax);\n\
    \        }\n        result.Reverse();\n        return result;", "        var max\
    \ = new List<long>();\n        long m = 0;\n        foreach (var i in numbers)\
    \ {\n            if (i > m) {\n                m = i;\n            }\n       \
    \     max.Add(m);\n        }\n        return max;", "        var solution = new\
    \ List<long>();\n        var buffer = new List<long>();\n        long max = (long)-1L;\n\
    \        var j = 0;\n        foreach (var i in numbers) {\n            while (buffer.Count\
    \ > 0 && buffer[buffer.Count - 1] < i) {\n                buffer.RemoveAt(buffer.Count\
    \ - 1);\n            }\n            buffer.Add(i);\n            if (buffer[j]\
    \ == numbers[j]) {\n                solution.Add(buffer[j]);\n               \
    \ j += 1;\n            }\n        }\n        return solution;", "        if (numbers.Count\
    \ == 0) {\n            return new List<long>();\n        }\n        List<long>\
    \ ret = new List<long>();\n        long max_so_far = numbers[0];\n        ret.Add(max_so_far);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            max_so_far = Math.Max(max_so_far,\
    \ numbers[i]);\n            ret.Add(max_so_far);\n        }\n        return ret;",
  "        var rollingMax = new List<long>();\n        long currentMax = long.MinValue;\n\
    \        foreach (var number in numbers) {\n            if (number > currentMax)\
    \ {\n                currentMax = number;\n            }\n            rollingMax.Add(currentMax);\n\
    \        }\n        return rollingMax;", "        var rollingMax = new List<long>();\n\
    \        rollingMax.Add(numbers[0]);\n        for (long i = 1L; i < numbers.Count;\
    \ i++) {\n            rollingMax.Add(Math.Max(rollingMax[(int)(i - 1L)], numbers[(int)(i)]));\n\
    \        }\n        return rollingMax;", "        var result = new List<long>();\n\
    \        var currentMax = 0L;\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            if (numbers[i] > currentMax) {\n                currentMax =\
    \ numbers[i];\n            }\n            result.Add(currentMax);\n        }\n\
    \        return result;", "        List<long> rollingMax = new List<long>();\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            rollingMax.Add(0);\n\
    \        }\n        long max = numbers[0];\n        rollingMax[0] = max;\n   \
    \     for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i] >\
    \ max) {\n                max = numbers[i];\n            }\n            rollingMax[i]\
    \ = max;\n        }\n        return rollingMax;", "        long maximum = numbers[0];\n\
    \        List<long> result = new List<long>();\n        result.Add(maximum);\n\
    \        foreach (long num in numbers.Skip(1)) {\n            maximum = Math.Max(maximum,\
    \ num);\n            result.Add(maximum);\n        }\n        return result;",
  "        var rollingMax = new List<long>();\n        var currentMax = numbers[0];\n\
    \        rollingMax.Add(currentMax);\n        for (int i = 1; i < numbers.Count;\
    \ i++) {\n            if (numbers[i] > currentMax) {\n                currentMax\
    \ = numbers[i];\n            }\n            rollingMax.Add(currentMax);\n    \
    \    }\n        return rollingMax;", "        if (((numbers.Count) == (0L))) {\n\
    \            return numbers;\n        }\n        var ret = new List<long>();\n\
    \        ret.Add(numbers[0]);\n        var currentMax = numbers[0];\n        for\
    \ (var i = 1L; (i) < (numbers.Count); i += 1L) {\n            if ((numbers[i])\
    \ > (currentMax)) {\n                currentMax = numbers[i];\n            }\n\
    \            ret.Add(currentMax);\n        }\n        return ret;", "        List<long>\
    \ max_so_far = new List<long>();\n        long current_max = 0;\n        foreach\
    \ (long number in numbers) {\n            if (number > current_max) {\n      \
    \          current_max = number;\n            }\n            max_so_far.Add(current_max);\n\
    \        }\n        return max_so_far;", "        List<long> result = new List<long>();\n\
    \        long max = numbers[0];\n        result.Add(max);\n        for (int i\
    \ = 1; i < numbers.Count; i++) {\n            if (numbers[i] > max) {\n      \
    \          max = numbers[i];\n            }\n            result.Add(max);\n  \
    \      }\n        return result;", "        var max = numbers[0];\n        var\
    \ res = new List<long> {max};\n        foreach (var x in numbers.Skip(1)) {\n\
    \            max = Math.Max(max, x);\n            res.Add(max);\n        }\n \
    \       return res;", "        var max_numbers = new List<long>();\n        long\
    \ current_max = numbers[0];\n        max_numbers.Add(current_max);\n        foreach\
    \ (var n in numbers.Skip(1)) {\n            if (n > current_max) {\n         \
    \       current_max = n;\n            }\n            max_numbers.Add(current_max);\n\
    \        }\n        return max_numbers;", "        List<long> dp = new List<long>();\n\
    \        long max = numbers[0];\n        for (int i = 0; i < numbers.Count; i++)\
    \ {\n            max = Math.Max(max, numbers[i]);\n            dp.Add(max);\n\
    \        }\n        return dp;", "        List<long> r = new List<long>();\n \
    \       for (int i = 0; i < numbers.Count; i++) {\n            r.Add(numbers.GetRange(0,\
    \ i + 1).Max());\n        }\n        return r;", "        var m = numbers[0];\n\
    \        var r = new List<long>();\n        r.Add(m);\n        foreach (var n\
    \ in numbers.Skip(1)) {\n            if (n > m) {\n                m = n;\n  \
    \          }\n            r.Add(m);\n        }\n        return r;", "        List<long>\
    \ result = new List<long>();\n        long max = numbers[0];\n        result.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > max) {\n                max = numbers[i];\n            }\n            result.Add(max);\n\
    \        }\n        return result;", "        List<long> maxes = new List<long>();\n\
    \        long best = numbers[0];\n        maxes.Add(best);\n        for (long\
    \ i = 1; i < numbers.Count; i++) {\n            if (numbers[(int)i] > best) {\n\
    \                best = numbers[(int)i];\n            }\n            maxes.Add(best);\n\
    \        }\n        return maxes;", "        long max = numbers[0];\n        List<long>\
    \ res = new List<long>();\n        foreach (long num in numbers) {\n         \
    \   if (num > max) {\n                max = num;\n            }\n            res.Add(max);\n\
    \        }\n        return res;", "        var N = numbers.Count;\n        var\
    \ ret = new List<long>();\n        var currentMax = numbers[0];\n        for (int\
    \ i = 0; i < N; i++) {\n            currentMax = Math.Max(currentMax, numbers[i]);\n\
    \            ret.Add(currentMax);\n        }\n        return ret;", "        var\
    \ result = new List<long>();\n        long max = numbers[0];\n        result.Add(max);\n\
    \        for (int i = 1; i < numbers.Count; i++) {\n            max = Math.Max(max,\
    \ numbers[i]);\n            result.Add(max);\n        }\n        return result;",
  "        var maxes = new List<long>();\n        foreach (var number in numbers)\
    \ {\n            if (maxes.Count == 0) {\n                maxes.Add(number);\n\
    \            } else {\n                maxes.Add(Math.Max(maxes[maxes.Count -\
    \ 1], number));\n            }\n        }\n        return maxes;", "        List<long>\
    \ result = new List<long>();\n        long max = numbers[0];\n        for (int\
    \ i = 0; i < numbers.Count; i++) {\n            max = numbers[i] > max ? numbers[i]\
    \ : max;\n            result.Add(max);\n        }\n        return result;", " \
    \       long max = numbers[0];\n        List<long> result = new List<long>() {\
    \ (long)1L };\n        for (long i = (long)1L; i < numbers.Count; i++) {\n   \
    \         if (numbers[(int)i] > max) {\n                max = numbers[(int)i];\n\
    \            }\n            result.Add(max);\n        }\n        return result;",
  "        List<long> result = new List<long>();\n        long temp = numbers[0];\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            if (numbers[i]\
    \ > temp) {\n                temp = numbers[i];\n            }\n            result.Add(temp);\n\
    \        }\n        return result;", "        List<long> ret = new List<long>();\n\
    \        long max = 0;\n        foreach (long n in numbers) {\n            max\
    \ = Math.Max(max, n);\n            ret.Add(max);\n        }\n        return ret;",
  "        List<long> results = new List<long>();\n        long currentMax = numbers[0];\n\
    \        for (int i = 0; i < numbers.Count; i++) {\n            results.Add(currentMax);\n\
    \            if (numbers[i] > currentMax) {\n                currentMax = numbers[i];\n\
    \            }\n        }\n        return results;", "        var res = new List<long>();\n\
    \        var m = 0L;\n        foreach (var n in numbers) {\n            m = Math.Max(m,\
    \ n);\n            res.Add(m);\n        }\n        return res;", "        long\
    \ current = (long)0L;\n        var result = new List<long>();\n        var __enumerator1\
    \ = (numbers).GetEnumerator();\n        while (__enumerator1.MoveNext()) {\n \
    \           var number = (long)__enumerator1.Current;\n            if ((number\
    \ > current)) {\n                current = number;\n            }\n          \
    \  result.Add(current);\n        }\n        return result;", "        var max_so_far\
    \ = new List<long>();\n        long curr_max = long.MinValue;\n        foreach\
    \ (var number in numbers) {\n            if (number > curr_max) {\n          \
    \      curr_max = number;\n            }\n            max_so_far.Add(curr_max);\n\
    \        }\n        return max_so_far;"]
stop_tokens:
- "\n    }\n"
