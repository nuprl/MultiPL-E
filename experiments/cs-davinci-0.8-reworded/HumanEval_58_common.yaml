name: HumanEval_58_common
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return sorted unique common elements for two lists.\n    //\
  \ >>> Common((new List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L,\
  \ (long)653L, (long)2L, (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L,\
  \ (long)1L, (long)5L, (long)9L, (long)653L, (long)121L})))\n    // (new List<long>(new\
  \ long[]{(long)1L, (long)5L, (long)653L}))\n    // >>> Common((new List<long>(new\
  \ long[]{(long)5L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L,\
  \ (long)2L})))\n    // (new List<long>(new long[]{(long)2L, (long)3L}))\n    public\
  \ static List<long> Common(List<long> l1, List<long> l2) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Common((new\
  \ List<long>(new long[]{(long)1L, (long)4L, (long)3L, (long)34L, (long)653L, (long)2L,\
  \ (long)5L})), (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)5L,\
  \ (long)9L, (long)653L, (long)121L}))).Equals((new List<long>(new long[]{(long)1L,\
  \ (long)5L, (long)653L}))));\n    Debug.Assert(Common((new List<long>(new long[]{(long)5L,\
  \ (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L, (long)2L}))).Equals((new\
  \ List<long>(new long[]{(long)2L, (long)3L}))));\n    Debug.Assert(Common((new List<long>(new\
  \ long[]{(long)4L, (long)3L, (long)2L, (long)8L})), (new List<long>(new long[]{(long)3L,\
  \ (long)2L, (long)4L}))).Equals((new List<long>(new long[]{(long)2L, (long)3L, (long)4L}))));\n\
  \    Debug.Assert(Common((new List<long>(new long[]{(long)4L, (long)3L, (long)2L,\
  \ (long)8L})), (new List<long>())).Equals((new List<long>())));\n    }\n\n}\n"
completions: ["        var ret = new List<long>();\n        int i = 0;\n        int\
    \ j = 0;\n        l1.Sort();\n        l2.Sort();\n        while ((i < l1.Count())\
    \ && (j < l2.Count())) {\n            if (l1[i] == l2[j]) {\n                ret.Add(l1[i]);\n\
    \                i++;\n                j++;\n            } else if (l1[i] < l2[j])\
    \ {\n                i++;\n            } else {\n                j++;\n      \
    \      }\n        }\n        return ret;", "        List<long> ret = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        while ((i < l1.Count) && (j <\
    \ l2.Count)) {\n            if (l1[i] == l2[j]) {\n                ret.Add(l1[i]);\n\
    \                i += 1;\n                j += 1;\n            } else if (l1[i]\
    \ < l2[j]) {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n        return ret;", "        l1.Sort();\n\
    \        l2.Sort();\n        int i1 = 0;\n        int i2 = 0;\n        List<long>\
    \ r = new List<long>();\n        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n\
    \            long x1 = l1[i1];\n            long x2 = l2[i2];\n            if\
    \ (x1 == x2) {\n                r.Add(x1);\n                i1++;\n          \
    \      i2++;\n            } else if (x1 < x2) {\n                i1++;\n     \
    \       } else {\n                i2++;\n            }\n        }\n        return\
    \ r;", "        var c = new HashSet<long>(l1);\n        c.IntersectWith(l2);\n\
    \        var r = new List<long>(c);\n        r.Sort();\n        return r;", '        return
    l1.Intersect(l2).ToList();', "        // sort lists\n        l1.Sort();\n    \
    \    l2.Sort();\n        // get lenghts\n        var n1 = l1.Count;\n        var\
    \ n2 = l2.Count;\n        // common element\n        var common = (long)0L;\n\
    \        // result\n        var result = new List<long>();\n        // iterate\
    \ both lists\n        var i = (long)0L;\n        var j = (long)0L;\n        while\
    \ ((i < n1) && (j < n2)) {\n            if (l1[(int)i] < l2[(int)j]) {\n     \
    \           i += (long)1L;\n            } else if (l1[(int)i] > l2[(int)j]) {\n\
    \                j += (long)1L;\n            } else {\n                common\
    \ = l1[(int)i];\n                if ((result.Count == (int)0L) || (result[(int)(result.Count\
    \ - (long)1L)] != common)) {\n                    result.Add(common);\n      \
    \          }\n                i += (long)1L;\n                j += (long)1L;\n\
    \            }\n        }\n        return result;", "        List<long> l3 = new\
    \ List<long>();\n        l1.Sort();\n        l2.Sort();\n        int i = 0;\n\
    \        int j = 0;\n        while (i < l1.Count && j < l2.Count) {\n        \
    \    if (l1[i] == l2[j]) {\n                l3.Add(l1[i]);\n                i++;\n\
    \                j++;\n            } else if (l1[i] < l2[j]) {\n             \
    \   i++;\n            } else {\n                j++;\n            }\n        }\n\
    \        return l3;", "        if ((l1.Count == 0) || (l2.Count == 0)) {\n   \
    \         return new List<long>();\n        } else {\n            var res = new\
    \ List<long>();\n            l1.Sort();\n            l2.Sort();\n            long\
    \ last = 0;\n            long curr = 0;\n            var i1 = 0;\n           \
    \ var i2 = 0;\n            while ((i1 < l1.Count) && (i2 < l2.Count)) {\n    \
    \            curr = l1[i1];\n                if (curr < l2[i2]) {\n          \
    \          i1 += 1;\n                } else if (curr > l2[i2]) {\n           \
    \         i2 += 1;\n                } else {\n                    if (curr !=\
    \ last) {\n                        res.Add(curr);\n                        last\
    \ = curr;\n                    }\n                    i1 += 1;\n             \
    \       i2 += 1;\n                }\n            }\n            return res;\n\
    \        }", "        l1.Sort();\n        l2.Sort();\n        int ind1 = 0;\n\
    \        int ind2 = 0;\n        List<long> result = new List<long>();\n      \
    \  while ((ind1 < l1.Count) && (ind2 < l2.Count)) {\n            long val1 = l1[ind1];\n\
    \            long val2 = l2[ind2];\n            if (val1 == val2) {\n        \
    \        result.Add(val1);\n                ind1++;\n                ind2++;\n\
    \            } else if (val1 < val2) {\n                ind1++;\n            }\
    \ else {\n                ind2++;\n            }\n        }\n        return result;",
  "        List<long> r = new List<long>();\n        r.AddRange(l1);\n        r.AddRange(l2);\n\
    \        return r.GroupBy(e => e).Where(e => e.Count() > 1).Select(e => e.Key).OrderBy(e\
    \ => e).ToList();", "        l1.Sort();\n        l2.Sort();\n        var i1 =\
    \ 0;\n        var i2 = 0;\n        var res = new List<long>();\n        while\
    \ (i1 < l1.Count && i2 < l2.Count) {\n            if (l1[i1] == l2[i2]) {\n  \
    \              if (res.Count == 0 || res[res.Count - 1] != l1[i1]) {\n       \
    \             res.Add(l1[i1]);\n                }\n                i1++;\n   \
    \             i2++;\n            } else if (l1[i1] < l2[i2]) {\n             \
    \   i1++;\n            } else {\n                i2++;\n            }\n      \
    \  }\n        return res;", '        return l1.Intersect(l2).ToList();', "   \
    \     List<long> ret = new List<long>();\n        Dictionary<long, bool> seen\
    \ = new Dictionary<long, bool>();\n        foreach (long l in l1) {\n        \
    \    if (!seen.ContainsKey(l)) {\n                seen[l] = true;\n          \
    \  }\n        }\n        foreach (long l in l2) {\n            if (seen.ContainsKey(l))\
    \ {\n                ret.Add(l);\n            }\n        }\n        ret.Sort();\n\
    \        return ret;", '        return l1.Intersect(l2).OrderBy(i => i).ToList();',
  '        return (new List<long>(l1.Intersect(l2))).OrderBy(k => k).ToList();', " \
    \       List<long> c = new List<long>();\n        int i = 0;\n        int j =\
    \ 0;\n        while (i < len(l1) && j < len(l2)) {\n            if (l1[i] == l2[j])\
    \ {\n                c.Add(l1[i]);\n                i++;\n                j++;\n\
    \            } else if (l1[i] < l2[j]) {\n                i++;\n            }\
    \ else {\n                j++;\n            }\n        }\n        return c;",
  "        if (l1.Count > l2.Count) {\n            return Common(l2, l1);\n      \
    \  }\n        var s = new HashSet<long>(l1);\n        return l2.Where((long item)\
    \ => s.Contains(item)).ToList();", "        var hs = new HashSet<long>(l1);\n\
    \        hs.IntersectWith(l2);\n        var ret = new List<long>(hs);\n      \
    \  ret.Sort();\n        return ret;", '        return l1.Intersect(l2).ToList();',
  "        var c = new List<long>();\n        foreach (var i in l1) {\n          \
    \  if (l2.Contains(i)) {\n                c.Add(i);\n            }\n        }\n\
    \        c.Sort();\n        return c;", "        l1.Sort();\n        l2.Sort();\n\
    \        int i = 0;\n        int j = 0;\n        var ret = new List<long>();\n\
    \        while ((i < len(l1)) && (j < len(l2))) {\n            var a = l1[i];\n\
    \            var b = l2[j];\n            if (a < b) {\n                i += 1;\n\
    \            }\n            else if (a > b) {\n                j += 1;\n     \
    \       }\n            else {\n                ret.Add(a);\n                i\
    \ += 1;\n                j += 1;\n            }\n        }\n        return ret;",
  "        List<long> res = new List<long>();\n        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long it in l1) {\n            set.Add(it);\n        }\n    \
    \    foreach (long it in l2) {\n            if (set.Contains(it)) {\n        \
    \        res.Add(it);\n            }\n        }\n        res.Sort();\n       \
    \ return res;", "        var l3 = new List<long>();\n        foreach (var e in\
    \ l1) {\n            if (l2.Contains(e)) {\n                l3.Add(e);\n     \
    \       }\n        }\n        var l4 = new List<long>(l3.Distinct().ToList());\n\
    \        l4.Sort();\n        return l4;", "        Dictionary<long, long> d =\
    \ new Dictionary<long, long>();\n        for (long i = (long)0L; i < l1.Count;\
    \ i++) {\n            long elem = l1[(int)i];\n            if (!d.ContainsKey(elem))\
    \ {\n                d[elem] = (long)0L;\n            }\n            d[elem] =\
    \ d[elem] + (long)1L;\n        }\n        for (long i = (long)0L; i < l2.Count;\
    \ i++) {\n            long elem = l2[(int)i];\n            if (!d.ContainsKey(elem))\
    \ {\n                d[elem] = (long)0L;\n            }\n            d[elem] =\
    \ d[elem] + (long)1L;\n        }\n        List<long> res = new List<long>();\n\
    \        foreach (KeyValuePair<long, long> pair in d) {\n            if (pair.Value\
    \ > (long)1L) {\n                res.Add(pair.Key);\n            }\n        }\n\
    \        res.Sort();\n        return res;", "        l1.Sort();\n        l2.Sort();\n\
    \        long next = 0L;\n        List<long> ret = new List<long>();\n       \
    \ // Thanks to https://stackoverflow.com/questions/4648616/find-the-common-items-in-two-lists-in-linq\n\
    \        var both = l1.Intersect(l2);\n        ret.AddRange(both);\n        return\
    \ ret;", "        HashSet<long> result = new HashSet<long>();\n        foreach\
    \ (long i in l1) {\n            if (l2.Contains(i)) {\n                result.Add(i);\n\
    \            }\n        }\n        List<long> resultList = new List<long>(result);\n\
    \        resultList.Sort();\n        return resultList;", "        l1.Sort();\n\
    \        l2.Sort();\n        var n = l1.Count;\n        var m = l2.Count;\n  \
    \      var i = 0;\n        var j = 0;\n        var c = new List<long>();\n   \
    \     while ((i < n) && (j < m)) {\n            if (l1[i] == l2[j]) {\n      \
    \          c.Add(l1[i]);\n                i += 1;\n                j += 1;\n \
    \           } else if (l1[i] < l2[j]) {\n                i += 1;\n           \
    \ } else {\n                j += 1;\n            }\n        }\n        return\
    \ c;", "        var s1 = new SortedSet<long>(l1);\n        var s2 = new SortedSet<long>(l2);\n\
    \        s1.IntersectWith(s2);\n        return s1.ToList();", "        var set1\
    \ = new HashSet<long>(l1);\n        var set2 = new HashSet<long>(l2);\n      \
    \  set1.IntersectWith(set2);\n        var l = new List<long>(set1);\n        l.Sort();\n\
    \        return l;", "        Dictionary<long, long> c = new Dictionary<long,\
    \ long>();\n        foreach (long e in l1) {\n            if (!c.ContainsKey(e))\
    \ {\n                c[e] = 0L;\n            }\n            c[e] = (long)(c[e]\
    \ + 1L);\n        }\n        foreach (long e in l2) {\n            if (!c.ContainsKey(e))\
    \ {\n                c[e] = 0L;\n            }\n            c[e] = (long)(c[e]\
    \ + 1L);\n        }\n        List<long> l = new List<long>();\n        foreach\
    \ (KeyValuePair<long, long> elem in c) {\n            if (elem.Value >= 2L) {\n\
    \                l.Add(elem.Key);\n            }\n        }\n        l.Sort();\n\
    \        return l;", "        var ret = l1.Intersect(l2).ToList();\n        ret.Sort();\n\
    \        return ret;", "        l1.Sort();\n        l2.Sort();\n        long i1\
    \ = 0L;\n        long i2 = 0L;\n        List<long> commons = new List<long>();\n\
    \        while ((i1 < (l1.Count)) && (i2 < (l2.Count))) {\n            if ((l1[(int)(i1)]\
    \ > l2[(int)(i2)])) {\n                i2 += 1L;\n            } else if ((l1[(int)(i1)]\
    \ < l2[(int)(i2)])) {\n                i1 += 1L;\n            } else {\n     \
    \           commons.Add(l1[(int)(i1)]);\n                i1 += 1L;\n         \
    \       i2 += 1L;\n            }\n        }\n        return commons;", "     \
    \   List<long> s1 = l1.Distinct().ToList();\n        List<long> s2 = l2.Distinct().ToList();\n\
    \        return s1.Intersect(s2).ToList();", "        var l = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        while (i < l1.Count && j < l2.Count)\
    \ {\n            if (l1[i] == l2[j]) {\n                l.Add(l1[i]);\n      \
    \          i += 1;\n                j += 1;\n            } else if (l1[i] < l2[j])\
    \ {\n                i += 1;\n            } else {\n                j += 1;\n\
    \            }\n        }\n        return l;", "        var s1 = new HashSet<long>(l1);\n\
    \        var s2 = new HashSet<long>(l2);\n        var union = new HashSet<long>(s1);\n\
    \        union.IntersectWith(s2);\n        return union.ToList();", "        List<long>\
    \ commonList = new List<long>();\n        l1.Sort();\n        l2.Sort();\n   \
    \     foreach (long var_0 in l1) {\n            if ((l2.BinarySearch(var_0) >=\
    \ (long)0L)) {\n                if (!(commonList.Contains(var_0))) {\n       \
    \             commonList.Add(var_0);\n                }\n            }\n     \
    \   }\n        return commonList;", "        l1.Sort();\n        l2.Sort();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        int len1 = l1.Count;\n    \
    \    int len2 = l2.Count;\n        List<long> l = new List<long>();\n        while\
    \ (i1 < len1 && i2 < len2) {\n            long n1 = l1[i1];\n            long\
    \ n2 = l2[i2];\n            if (n1 == n2) {\n                if (l.Count == 0\
    \ || l[l.Count - 1] != n1) {\n                    l.Add(n1);\n               \
    \ }\n                i1++;\n                i2++;\n            } else if (n1 <\
    \ n2) {\n                i1++;\n            } else {\n                i2++;\n\
    \            }\n        }\n        return l;", "        HashSet<long> set = new\
    \ HashSet<long>();\n        List<long> res = new List<long>();\n        foreach\
    \ (long a in l1)\n            set.Add(a);\n        foreach (long a in l2)\n  \
    \          if (set.Contains(a))\n                res.Add(a);\n        res.Sort();\n\
    \        return res;", "        List<long> s1 = l1.OrderBy(x => x).ToList();\n\
    \        List<long> s2 = l2.OrderBy(x => x).ToList();\n        List<long> res\
    \ = new List<long>();\n        int i1 = 0;\n        int i2 = 0;\n        while\
    \ ((i1 < (s1.Count)) && (i2 < (s2.Count))) {\n            long n1 = s1[i1];\n\
    \            long n2 = s2[i2];\n            if (n1 < n2) {\n                i1\
    \ += 1;\n            } else if (n1 > n2) {\n                i2 += 1;\n       \
    \     } else {\n                res.Add(n1);\n                i1 += 1;\n     \
    \           i2 += 1;\n            }\n        }\n        return res;", "      \
    \  l1.Sort();\n        l2.Sort();\n        var cmn = new List<long>();\n     \
    \   int i1 = 0;\n        int i2 = 0;\n        while (i1 < l1.Count && i2 < l2.Count)\
    \ {\n            if (l1[i1] == l2[i2]) {\n                cmn.Add(l1[i1]);\n \
    \               i1 += 1;\n                i2 += 1;\n            } else if (l1[i1]\
    \ < l2[i2]) {\n                i1 += 1;\n            } else {\n              \
    \  i2 += 1;\n            }\n        }\n        return cmn;", "        var common\
    \ = l1.Intersect(l2);\n        return common.ToList();", "        var s1 = new\
    \ HashSet<long>(l1);\n        var s2 = new HashSet<long>(l2);\n        s1.IntersectWith(s2);\n\
    \        return new List<long>(s1);", "        var s1 = l1.Distinct().ToList();\n\
    \        var s2 = l2.Distinct().ToList();\n        s1.Sort();\n        s2.Sort();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        var l = new List<long>();\n\
    \        while ((i1 < s1.Count) && (i2 < s2.Count)) {\n            var v1 = s1[i1];\n\
    \            var v2 = s2[i2];\n            if (v1 == v2) {\n                l.Add(v1);\n\
    \                i1++;\n                i2++;\n            } else if (v1 < v2)\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return l;", '        return l1.Where(l => l2.Contains(l)).ToList();',
  "        l1.Sort();\n        l2.Sort();\n        var res = new List<long>();\n \
    \       int i = 0;\n        int j = 0;\n        while ((i < l1.Count) && (j <\
    \ l2.Count)) {\n            if (l1[i] == l2[j]) {\n                res.Add(l1[i]);\n\
    \                i += 1;\n                j += 1;\n            } else if (l1[i]\
    \ < l2[j]) {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n        return res;", "        l1.Sort();\n\
    \        l2.Sort();\n        List<long> result = new List<long>();\n        for\
    \ (int i = 0; (i) < (l1.Count); i++) {\n            for (int j = 0; (j) < (l2.Count);\
    \ j++) {\n                if ((l1[i]) == (l2[j])) {\n                    result.Add(l1[i]);\n\
    \                    l2.RemoveAt(j);\n                    break;\n           \
    \     }\n            }\n        }\n        return result;", "        l1.Sort();\n\
    \        l2.Sort();\n        List<long> ret = new List<long>();\n        for (int\
    \ i = 0, j = 0; i < l1.Count && j < l2.Count; ) {\n            if (l1[i] == l2[j])\
    \ {\n                ret.Add(l1[i]);\n                i++;\n                j++;\n\
    \            } else if (l1[i] < l2[j]) {\n                i++;\n            }\
    \ else {\n                j++;\n            }\n        }\n        return ret;",
  "        var result = l1.Intersect(l2).ToList();\n        result.Sort();\n     \
    \   return result;", "        l1.Sort();\n        l2.Sort();\n        int p1 =\
    \ 0;\n        int p2 = 0;\n        var res = new List<long>();\n        while\
    \ ((p1 < l1.Count) && (p2 < l2.Count)) {\n            if (l1[p1] == l2[p2]) {\n\
    \                res.Add(l1[p1]);\n                p1++;\n                p2++;\n\
    \            } else if (l1[p1] < l2[p2]) {\n                p1++;\n          \
    \  } else {\n                p2++;\n            }\n        }\n        return res;",
  "        if (l1.Count == 0 || l2.Count == 0) {\n            return new List<long>();\n\
    \        }\n        l1.Sort();\n        l2.Sort();\n        var l1i = 0;\n   \
    \     var l2i = 0;\n        var res = new List<long>();\n        while (l1i <\
    \ l1.Count && l2i < l2.Count) {\n            var v1 = l1[l1i];\n            var\
    \ v2 = l2[l2i];\n            if (v1 == v2) {\n                res.Add(v1);\n \
    \               l1i++;\n                l2i++;\n            } else if (v1 < v2)\
    \ {\n                l1i++;\n            } else {\n                l2i++;\n  \
    \          }\n        }\n        return res;", "        var l = new List<long>();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        while ((i1 < l1.Count) && (i2\
    \ < l2.Count)) {\n            var n1 = l1[i1];\n            var n2 = l2[i2];\n\
    \            if (n1 == n2) {\n                l.Add(n1);\n                i1 +=\
    \ 1;\n                i2 += 1;\n            } else if (n1 < n2) {\n          \
    \      i1 += 1;\n            } else {\n                i2 += 1;\n            }\n\
    \        }\n        return l;", "        var l3 = new List<long>();\n        foreach\
    \ (var x in l1) {\n            if (l2.Contains(x)) {\n                l3.Add(x);\n\
    \            }\n        }\n        l3.Sort();\n        return l3;", '        return
    l1.Intersect(l2).OrderBy(n => n).ToList();', "        l1.Sort();\n        l2.Sort();\n\
    \        var l3 = new List<long>();\n        for (int i1 = 0; i1 < l1.Count; i1++)\
    \ {\n            for (int i2 = 0; i2 < l2.Count; i2++) {\n                if (l1[i1]\
    \ == l2[i2]) {\n                    l3.Add(l1[i1]);\n                    break;\n\
    \                }\n            }\n        }\n        return l3;", "        List<long>\
    \ ret = new List<long>();\n        int i1 = 0;\n        int i2 = 0;\n        while\
    \ ((i1 < l1.Count) && (i2 < l2.Count)) {\n            long t1 = l1[i1];\n    \
    \        long t2 = l2[i2];\n            if (t1 == t2) {\n                ret.Add(t1);\n\
    \                i1 += 1;\n                i2 += 1;\n            } else if (t1\
    \ < t2) {\n                i1 += 1;\n            } else {\n                i2\
    \ += 1;\n            }\n        }\n        return ret;", "        var l3 = new\
    \ List<long>();\n        foreach (var v in l1) {\n            if (l2.Contains(v))\
    \ {\n                l3.Add(v);\n            }\n        }\n        foreach (var\
    \ v in l2) {\n            if (l1.Contains(v)) {\n                l3.Add(v);\n\
    \            }\n        }\n        l3.Sort();\n        var l4 = new List<long>();\n\
    \        foreach (var v in l3) {\n            if (l4.Count == 0 || l4[l4.Count\
    \ - 1] != v) {\n                l4.Add(v);\n            }\n        }\n       \
    \ return l4;", "        List<long> ret = new List<long>();\n        int l1_cursor\
    \ = 0;\n        int l2_cursor = 0;\n        while (l1_cursor < l1.Count && l2_cursor\
    \ < l2.Count) {\n            var l1_item = l1[l1_cursor];\n            var l2_item\
    \ = l2[l2_cursor];\n            if (l1_item == l2_item) {\n                ret.Add(l1_item);\n\
    \                l1_cursor++;\n                l2_cursor++;\n            } else\
    \ if (l1_item < l2_item) {\n                l1_cursor++;\n            } else {\n\
    \                l2_cursor++;\n            }\n        }\n        return ret;",
  "        l1.Sort();\n        l2.Sort();\n        var L = new List<long>();\n   \
    \     var i = 0;\n        while ((i) < len(l1)) {\n            var j = 0;\n  \
    \          while ((j) < len(l2)) {\n                if ((l1[i]) == (l2[j])) {\n\
    \                    L.Add(l1[i]);\n                    break;\n             \
    \   }\n                j += 1;\n            }\n            i += 1;\n        }\n\
    \        return L;", "        List<long> output = new List<long>();\n        for\
    \ (int i = 0; i < l1.Count; i++) {\n            if (l2.Contains(l1[i])) {\n  \
    \              output.Add(l1[i]);\n            }\n        }\n        return output.Distinct().OrderBy(x\
    \ => x).ToList();", "        var l3 = new List<long>();\n        foreach (var\
    \ n in l1) {\n            if (l2.Contains(n)) {\n                l3.Add(n);\n\
    \            }\n        }\n        return l3.Distinct().OrderBy(n => n).ToList();",
  "        List<long> r = new List<long>();\n        // >>> r.Add(5L)\n        //\
    \ >>> r.Add(7L)\n        // >>> r.Add(1L)\n        // >>> r.Add(5L)\n        //\
    \ >>> r.Add(9L)\n        // >>> r.Add(653L)\n        // >>> r.Add(121L)\n    \
    \    // >>> r\n        // (new List<long>(new long[]{(long)5L, (long)7L, (long)1L,\
    \ (long)5L, (long)9L, (long)653L, (long)121L}))\n        // >>> r.Distinct()\n\
    \        // (new List<long>(new long[]{(long)5L, (long)7L, (long)1L, (long)9L,\
    \ (long)653L, (long)121L}))\n        // >>> l1.Intersect(l2)\n        // (new\
    \ List<long>(new long[]{(long)5L, (long)3L, (long)2L}))\n        // >>> r.Intersect(l2)\n\
    \        // (new List<long>(new long[]{(long)5L, (long)3L, (long)2L}))\n     \
    \   // >>> l1.Intersect(l2).Distinct()\n        // (new List<long>(new long[]{(long)5L,\
    \ (long)3L, (long)2L}))\n        // >>> l1.Intersect(l2).Distinct().OrderBy(n\
    \ => n)\n        // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))\n\
    \        // >>> l1.Intersect(l2).Distinct().OrderBy(n => n).ToList()\n       \
    \ // (new List<long>(new long[]{(long)2L, (long)3L, (long)5L}))\n        // >>>\
    \ l1.Intersect(l2).Distinct().OrderBy(n => n).ToList()\n        // (new List<long>(new\
    \ long[]{(long)2L, (long)3L,", "        List<long> ret = new List<long>();\n \
    \       l1.Sort();\n        l2.Sort();\n        int l1ind = 0;\n        int l2ind\
    \ = 0;\n        while ((l1ind < l1.Count) && (l2ind < l2.Count)) {\n         \
    \   if (l1[l1ind] == l2[l2ind]) {\n                ret.Add(l1[l1ind]);\n     \
    \           l1ind += 1;\n                l2ind += 1;\n            } else if (l1[l1ind]\
    \ < l2[l2ind]) {\n                l1ind += 1;\n            } else {\n        \
    \        l2ind += 1;\n            }\n        }\n        return ret;", "      \
    \  List<long> result = new List<long>();\n        l1.Sort();\n        l2.Sort();\n\
    \        int i = 0;\n        int j = 0;\n        while (i < l1.Count && j < l2.Count)\
    \ {\n            if (l1[i] == l2[j]) {\n                result.Add(l1[i]);\n \
    \               i++;\n                j++;\n            } else if (l1[i] < l2[j])\
    \ {\n                i++;\n            } else {\n                j++;\n      \
    \      }\n        }\n        return result;", "        List<long> res = new List<long>();\n\
    \        foreach (long i in l1) {\n            if (l2.Contains(i)) {\n       \
    \         res.Add(i);\n            }\n        }\n        res.Sort();\n       \
    \ return res;", "        l1.Sort();\n        l2.Sort();\n        long[] a1 = l1.ToArray();\n\
    \        long[] a2 = l2.ToArray();\n        List<long> l3 = new List<long>();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        while ((i1 < l1.Count) && (i2\
    \ < l2.Count)) {\n            if (a1[i1] < a2[i2]) {\n                i1 += 1;\n\
    \            } else if (a1[i1] > a2[i2]) {\n                i2 += 1;\n       \
    \     } else {\n                l3.Add(a1[i1]);\n                i1 += 1;\n  \
    \              i2 += 1;\n            }\n        }\n        return l3;", "    \
    \    l1.Sort();\n        l2.Sort();\n        long i = 0L;\n        long j = 0L;\n\
    \        List<long> res = new List<long>();\n        while (true) {\n        \
    \    if ((i >= l1.Count)) {\n                break;\n            }\n         \
    \   if ((j >= l2.Count)) {\n                break;\n            }\n          \
    \  long x = l1[(int)i];\n            long y = l2[(int)j];\n            if ((x\
    \ == y)) {\n                res.Add(x);\n                i += 1L;\n          \
    \      j += 1L;\n            }\n            else if ((x < y)) {\n            \
    \    i += 1L;\n            }\n            else {\n                j += 1L;\n \
    \           }\n        }\n        return res;", "        l1.Sort();\n        l2.Sort();\n\
    \        var i1 = 0;\n        var i2 = 0;\n        var list = new List<long>();\n\
    \        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            if (l1[i1]\
    \ == l2[i2]) {\n                list.Add(l1[i1]);\n                i1 += 1;\n\
    \                i2 += 1;\n            } else if (l1[i1] < l2[i2]) {\n       \
    \         i1 += 1;\n            } else {\n                i2 += 1;\n         \
    \   }\n        }\n        return list;", "        l1.Sort();\n        l2.Sort();\n\
    \        var a = 0;\n        var b = 0;\n        var res = new List<long>();\n\
    \        while ((a < l1.Count) && (b < l2.Count)) {\n            if (l1[a] ==\
    \ l2[b]) {\n                res.Add(l1[a]);\n                a++;\n          \
    \      b++;\n            } else if (l1[a] < l2[b]) {\n                a++;\n \
    \           } else {\n                b++;\n            }\n        }\n       \
    \ return res;", "        l1.Sort();\n        l2.Sort();\n        List<long> res\
    \ = new List<long>();\n        int p1 = 0;\n        int p2 = 0;\n        while\
    \ (p1 < l1.Count && p2 < l2.Count) {\n            if (l1[p1] == l2[p2]) {\n  \
    \              res.Add(l1[p1]);\n                p1++;\n                p2++;\n\
    \            } else if (l1[p1] < l2[p2]) {\n                p1++;\n          \
    \  } else {\n                p2++;\n            }\n        }\n        return res;",
  "        l1.Sort();\n        l2.Sort();\n        var output = new List<long>();\n\
    \        foreach (var x in l1) {\n            if (l2.BinarySearch(x) >= 0) {\n\
    \                output.Add(x);\n            }\n        }\n        return output;",
  "        // Remove duplicates from each of l1 and l2\n        List<long> l1u = Enumerable.Distinct(l1).ToList();\n\
    \        List<long> l2u = Enumerable.Distinct(l2).ToList();\n        // Get common\
    \ elements.\n        List<long> common = l1u.Intersect(l2u).ToList();\n      \
    \  // Sort and return common elements.\n        common.Sort();\n        return\
    \ common;", "        if ((l1.Count == 0L) || (l2.Count == 0L)) {\n           \
    \ return new List<long>();\n        }\n        List<long> ret = new List<long>();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        int c1 = l1.Count;\n      \
    \  int c2 = l2.Count;\n        long cur1 = l1[i1];\n        long cur2 = l2[i2];\n\
    \        while ((i1 < c1) && (i2 < c2)) {\n            if (cur1 == cur2) {\n \
    \               ret.Add(cur1);\n                i1++;\n                i2++;\n\
    \                if ((i1 >= c1) || (i2 >= c2)) {\n                    break;\n\
    \                }\n                cur1 = l1[i1];\n                cur2 = l2[i2];\n\
    \            }\n            else if (cur1 < cur2) {\n                i1++;\n \
    \               if (i1 >= c1) {\n                    break;\n                }\n\
    \                cur1 = l1[i1];\n            }\n            else {\n         \
    \       i2++;\n                if (i2 >= c2) {\n                    break;\n \
    \               }\n                cur2 = l2[i2];\n            }\n        }\n\
    \        return ret;", '        return l1.Intersect(l2).OrderBy(i => i).ToList();',
  "        List<long> list = new List<long>();\n        foreach (long n in l1) {\n\
    \            if (l2.Contains(n)) {\n                list.Add(n);\n           \
    \ }\n        }\n        list.Sort();\n        return list;", '        return l1.Intersect(l2).ToList();',
  '        return l1.Intersect(l2).OrderBy(a => a).ToList();', "        // Use set\
    \ intersection algorithm.\n        return l1.Intersect(l2).ToList();", "     \
    \   int i1 = 0;\n        int i2 = 0;\n        int L1 = l1.Count;\n        int\
    \ L2 = l2.Count;\n        List<long> Common = new List<long>();\n        while\
    \ ((i1 < L1) && (i2 < L2)) {\n            long v1 = l1[i1];\n            long\
    \ v2 = l2[i2];\n            if (v1 == v2) {\n                Common.Add(v1);\n\
    \                i1++;\n                i2++;\n            } else if (v1 < v2)\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return Common;", "        l1.Sort();\n        l2.Sort();\n\
    \        List<long> res = new List<long>();\n        int i1 = 0;\n        int\
    \ i2 = 0;\n        while (i1 < l1.Count && i2 < l2.Count) {\n            long\
    \ v1 = l1[i1];\n            long v2 = l2[i2];\n            if (v1 == v2) {\n \
    \               res.Add(v1);\n                i1++;\n                i2++;\n \
    \           } else if (v1 < v2) {\n                i1++;\n            } else {\n\
    \                i2++;\n            }\n        }\n        return res;", "    \
    \    List<long> l3 = l1.Intersect(l2).ToList();\n        l3.Sort();\n        return\
    \ l3;", "        l1.Sort();\n        l2.Sort();\n        List<long> result = new\
    \ List<long>();\n        int l1_i = 0;\n        int l2_i = 0;\n        while (l1_i\
    \ < l1.Count && l2_i < l2.Count) {\n            if (l1[l1_i] == l2[l2_i]) {\n\
    \                result.Add(l1[l1_i]);\n                l1_i++;\n            \
    \    l2_i++;\n            } else if (l1[l1_i] < l2[l2_i]) {\n                l1_i++;\n\
    \            } else {\n                l2_i++;\n            }\n        }\n   \
    \     return result;", '        return l1.Intersect(l2).ToList();', "        Dictionary<long,\
    \ long> dic = new Dictionary<long, long>();\n        foreach (long l in l1) {\n\
    \            if (!dic.ContainsKey(l)) {\n                dic[l] = (long)0L;\n\
    \            }\n            dic[l] = dic[l] + (long)1L;\n        }\n        foreach\
    \ (long l in l2) {\n            if (!dic.ContainsKey(l)) {\n                dic[l]\
    \ = (long)0L;\n            }\n            dic[l] = dic[l] + (long)1L;\n      \
    \  }\n        List<long> res = new List<long>();\n        foreach (long l in dic.Keys)\
    \ {\n            if (dic[l] == (long)2L) {\n                res.Add(l);\n    \
    \        }\n        }\n        res.Sort();\n        return res;", "        Dictionary<long,\
    \ int> d = new Dictionary<long, int>();\n        foreach (long x in l1) {\n  \
    \          if (d.ContainsKey(x)) {\n                d[x]++;\n            } else\
    \ {\n                d[x] = 1;\n            }\n        }\n        foreach (long\
    \ x in l2) {\n            if (d.ContainsKey(x)) {\n                d[x]++;\n \
    \           } else {\n                d[x] = 1;\n            }\n        }\n  \
    \      List<long> ret = new List<long>();\n        foreach (KeyValuePair<long,\
    \ int> kv in d) {\n            if (kv.Value == 2) {\n                ret.Add(kv.Key);\n\
    \            }\n        }\n        ret.Sort();\n        return ret;", "      \
    \  HashSet<long> l1Set = new HashSet<long>(l1);\n        List<long> result = new\
    \ List<long>();\n        foreach (long v in l2) {\n            if (l1Set.Contains(v))\
    \ {\n                result.Add(v);\n            }\n        }\n        result.Sort();\n\
    \        return result;", "        l1.Sort();\n        l2.Sort();\n        List<long>\
    \ ret = new List<long>();\n        int l1_pos = 0;\n        int l2_pos = 0;\n\
    \        while ((l1_pos < l1.Count) && (l2_pos < l2.Count)) {\n            long\
    \ v1 = l1[l1_pos];\n            long v2 = l2[l2_pos];\n            if (v1 < v2)\
    \ {\n                l1_pos++;\n            } else if (v1 > v2) {\n          \
    \      l2_pos++;\n            } else {\n                if ((ret.Count == 0) ||\
    \ (ret[ret.Count - 1] != v1)) {\n                    ret.Add(v1);\n          \
    \      }\n                l1_pos++;\n                l2_pos++;\n            }\n\
    \        }\n        return ret;", "        l1.Sort();\n        l2.Sort();\n  \
    \      List<long> l3 = new List<long>();\n        for (int i = 0; i < l1.Count;\
    \ i++) {\n            for (int j = 0; j < l2.Count; j++) {\n                if\
    \ (l1[i] == l2[j]) {\n                    l3.Add(l1[i]);\n                   \
    \ break;\n                }\n            }\n        }\n        l3.Sort();\n  \
    \      List<long> l4 = new List<long>();\n        long prev = l3[0];\n       \
    \ l4.Add(prev);\n        for (int i = 1; i < l3.Count; i++) {\n            if\
    \ (l3[i] != prev) {\n                l4.Add(l3[i]);\n                prev = l3[i];\n\
    \            }\n        }\n        return l4;", "        l1.Sort();\n        l2.Sort();\n\
    \        long j = 0L;\n        long i = 0L;\n        List<long> res = new List<long>();\n\
    \        while ((i < l1.Count) && (j < l2.Count)) {\n            if (l1[(int)i]\
    \ == l2[(int)j]) {\n                res.Add(l1[(int)i]);\n                i +=\
    \ 1L;\n                j += 1L;\n            } else if (l1[(int)i] < l2[(int)j])\
    \ {\n                i += 1L;\n            } else {\n                j += 1L;\n\
    \            }\n        }\n        return res;", "        List<long> nl = new\
    \ List<long>();\n        Dictionary<long, long> d = new Dictionary<long, long>();\n\
    \        foreach (long l in l1) {\n            if (!d.ContainsKey(l)) {\n    \
    \            d[l] = 0L;\n            }\n            d[l] = d[l] + 1L;\n      \
    \  }\n        foreach (long l in l2) {\n            if (!d.ContainsKey(l)) {\n\
    \                d[l] = 0L;\n            }\n            d[l] = d[l] + 1L;\n  \
    \      }\n        foreach (KeyValuePair<long, long> entry in d) {\n          \
    \  if (entry.Value > 1L) {\n                nl.Add(entry.Key);\n            }\n\
    \        }\n        nl.Sort();\n        return nl;", "        Dictionary<long,\
    \ bool> items = new Dictionary<long, bool>();\n        foreach (long item in l1)\
    \ {\n            items[item] = true;\n        }\n        List<long> ret = new\
    \ List<long>();\n        foreach (long item in l2) {\n            if (items.ContainsKey(item))\
    \ {\n                ret.Add(item);\n            }\n        }\n        ret.Sort();\n\
    \        return ret;", "        // >>> l1.Intersect(l2).ToList().Count\n     \
    \   // 3\n        // >>> l1.Intersect(l2).ToList()\n        // (new List<long>(new\
    \ long[]{(long)1L, (long)5L, (long)653L}))\n        // >>> l1.Intersect(l2).ToList().Sort()\n\
    \        // (new List<long>(new long[]{(long)1L, (long)5L, (long)653L}))\n   \
    \     return l1.Intersect(l2).ToList().Sort();", "        var common = l1.Intersect(l2);\n\
    \        var res = new List<long>(common);\n        res.Sort();\n        return\
    \ res;", "        List<long> res = new List<long>();\n        l1.Sort();\n   \
    \     l2.Sort();\n        long i = 0L;\n        long j = 0L;\n        while ((i\
    \ < len(l1)) && (j < len(l2))) {\n            if (l1[(int)i] < l2[(int)j]) {\n\
    \                i += 1L;\n            }\n            else if (l1[(int)i] > l2[(int)j])\
    \ {\n                j += 1L;\n            }\n            else {\n           \
    \     res.Add(l1[(int)i]);\n                i += 1L;\n                j += 1L;\n\
    \            }\n        }\n        return res;", "        var l = new List<long>();\n\
    \        l1.Sort();\n        l2.Sort();\n        var i1 = 0;\n        var i2 =\
    \ 0;\n        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            var t1\
    \ = l1[i1];\n            var t2 = l2[i2];\n            if (t1 == t2) {\n     \
    \           l.Add(t1);\n                i1++;\n                i2++;\n       \
    \     } else if (t1 < t2) {\n                i1++;\n            } else {\n   \
    \             i2++;\n            }\n        }\n        return l;", '        return
    l1.Intersect(l2).ToList();', "        l1.Sort();\n        l2.Sort();\n       \
    \ List<long> res = new List<long>();\n        for (int i = 0; i < l1.Count; i++)\
    \ {\n            if (l1[i] == l2[i]) {\n                res.Add(l1[i]);\n    \
    \        }\n        }\n        return res;", "        l1.Sort();\n        l2.Sort();\n\
    \        List<long> common = new List<long>();\n        for (int i = 0; i < l1.Count;\
    \ i++) {\n            long v = l1[i];\n            int j = 0;\n            while\
    \ (j < l2.Count && l2[j] < v) {\n                j++;\n            }\n       \
    \     if (j < l2.Count && l2[j] == v) {\n                common.Add(v);\n    \
    \        }\n        }\n        return common;", "        List<long> intersection\
    \ = new List<long>();\n        l1.Sort();\n        l2.Sort();\n        int i1\
    \ = 0;\n        int i2 = 0;\n        while (((i1 < l1.Count) && (i2 < l2.Count)))\
    \ {\n            if (l1[i1] == l2[i2]) {\n                intersection.Add(l1[i1]);\n\
    \                i1 += 1;\n                i2 += 1;\n            } else if (l1[i1]\
    \ < l2[i2]) {\n                i1 += 1;\n            } else {\n              \
    \  i2 += 1;\n            }\n        }\n        return intersection;", "      \
    \  var res = new List<long>();\n        var map = new Dictionary<long, int>();\n\
    \        foreach (var item in l1) {\n            if (!map.ContainsKey(item)) {\n\
    \                map[item] = 0;\n            }\n            map[item] += 1;\n\
    \        }\n        foreach (var item in l2) {\n            if (map.ContainsKey(item))\
    \ {\n                map[item] -= 1;\n                if (map[item] == 0) {\n\
    \                    map.Remove(item);\n                }\n                res.Add(item);\n\
    \            }\n        }\n        res.Sort();\n        return res;", "      \
    \  List<long> result = new List<long>();\n        l1.Sort();\n        l2.Sort();\n\
    \        long ind1 = 0L;\n        long ind2 = 0L;\n        while ((ind1 < l1.Count)\
    \ && (ind2 < l2.Count)) {\n            if (l1[(int)ind1] < l2[(int)ind2]) {\n\
    \                ind1 += 1L;\n            }\n            else if (l1[(int)ind1]\
    \ > l2[(int)ind2]) {\n                ind2 += 1L;\n            }\n           \
    \ else {\n                result.Add(l1[(int)ind1]);\n                ind1 +=\
    \ 1L;\n                ind2 += 1L;\n            }\n        }\n        return result;",
  "        Dictionary<long, bool> hash = new Dictionary<long, bool>();\n        List<long>\
    \ output = new List<long>();\n        foreach (long i in l1) {\n            hash[i]\
    \ = true;\n        }\n        foreach (long i in l2) {\n            if (hash.ContainsKey(i))\
    \ {\n                output.Add(i);\n            }\n        }\n        output.Sort();\n\
    \        return output;", "        l1.Sort();\n        l2.Sort();\n        long\
    \ i1 = 0L;\n        long i2 = 0L;\n        List<long> result = new List<long>();\n\
    \        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            if (l1[(int)i1]\
    \ == l2[(int)i2]) {\n                result.Add(l1[(int)i1]);\n              \
    \  i1++;\n                i2++;\n            } else if (l1[(int)i1] < l2[(int)i2])\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return result;", "        l1.Sort();\n        l2.Sort();\n\
    \        List<long> common = new List<long>();\n        int i1 = 0;\n        int\
    \ i2 = 0;\n        int l1_len = l1.Count;\n        int l2_len = l2.Count;\n  \
    \      while (i1 < l1_len && i2 < l2_len) {\n            if (l1[i1] == l2[i2])\
    \ {\n                common.Add(l1[i1]);\n                i1++;\n            \
    \    i2++;\n            } else if (l1[i1] < l2[i2]) {\n                i1++;\n\
    \            } else {\n                i2++;\n            }\n        }\n     \
    \   return common;", "        l1.Sort();\n        l2.Sort();\n        int p1 =\
    \ 0;\n        int p2 = 0;\n        List<long> r = new List<long>();\n        while\
    \ ((p1 < l1.Count) && (p2 < l2.Count)) {\n            if (l1[p1] == l2[p2]) {\n\
    \                r.Add(l1[p1]);\n                p1 += 1;\n                p2\
    \ += 1;\n            } else if (l1[p1] < l2[p2]) {\n                p1 += 1;\n\
    \            } else {\n                p2 += 1;\n            }\n        }\n  \
    \      return r;", "        // Sort two lists.\n        l1.Sort();\n        l2.Sort();\n\
    \        List<long> ret = new List<long>();\n        // Merge two lists.\n   \
    \     int i = 0;\n        int j = 0;\n        int k = 0;\n        while (i < l1.Count\
    \ && j < l2.Count) {\n            if (l1[i] == l2[j]) {\n                if (k\
    \ == 0 || ret[k - 1] != l1[i]) {\n                    ret.Add(l1[i]);\n      \
    \              k++;\n                }\n                i++;\n               \
    \ j++;\n            } else if (l1[i] < l2[j]) {\n                i++;\n      \
    \      } else {\n                j++;\n            }\n        }\n        return\
    \ ret;", "        l1.Sort();\n        l2.Sort();\n        var res = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        long last = 0;\n        for (;\
    \ i < l1.Count && j < l2.Count; ) {\n            if (l1[i] == l2[j]) {\n     \
    \           if (last != l1[i]) {\n                    res.Add(l1[i]);\n      \
    \              last = l1[i];\n                }\n                i++;\n      \
    \          j++;\n            } else if (l1[i] < l2[j]) {\n                i++;\n\
    \            } else {\n                j++;\n            }\n        }\n      \
    \  return res;", "        l1.Sort();\n        l2.Sort();\n        List<long> result\
    \ = new List<long>();\n        int pos1 = 0;\n        int pos2 = 0;\n        int\
    \ len1 = l1.Count;\n        int len2 = l2.Count;\n        while (pos1 < len1 &&\
    \ pos2 < len2) {\n            long x1 = l1[pos1];\n            long x2 = l2[pos2];\n\
    \            if (x1 == x2) {\n                result.Add(x1);\n              \
    \  pos1++;\n                pos2++;\n            } else if (x1 < x2) {\n     \
    \           pos1++;\n            } else {\n                pos2++;\n         \
    \   }\n        }\n        return result;", "        List<long> result = new List<long>();\n\
    \        foreach (long el in l1) {\n            if (l2.Contains(el)) {\n     \
    \           result.Add(el);\n            }\n        }\n        result.Sort();\n\
    \        return result;", "        l1.Sort();\n        l2.Sort();\n        List<long>\
    \ rl = new List<long>();\n        int li1 = 0;\n        int li2 = 0;\n       \
    \ while (li1 < l1.Count && li2 < l2.Count) {\n            if (l1[li1] == l2[li2])\
    \ {\n                rl.Add(l1[li1]);\n                li1 += 1;\n           \
    \     li2 += 1;\n            } else if (l1[li1] < l2[li2]) {\n               \
    \ li1 += 1;\n            } else {\n                li2 += 1;\n            }\n\
    \        }\n        return rl;", "        List<long> res = new List<long>();\n\
    \        if ((l1.Count < l2.Count)) {\n            {\n                int __loop1_iteration\
    \ = 0;\n                var __loop1_result =\n                    (from __loop1_tmp_item___noname1\
    \ in EnumerableExtensions.Enumerate((Index: 0,Source: l1))\n                 \
    \   from __loop1_tmp_item___noname2 in EnumerableExtensions.Enumerate((Index:\
    \ 0,Source: l2))\n                    select\n                        new\n  \
    \                      {\n                            __loop1_item___noname1 =\
    \ __loop1_tmp_item___noname1,\n                            __loop1_item___noname2\
    \ = __loop1_tmp_item___noname2,\n                        }).ToArray();\n     \
    \           foreach (var __loop1_item in __loop1_result)\n                {\n\
    \                    var __noname1 = __loop1_item.__loop1_item___noname1;\n  \
    \                  var __noname2 = __loop1_item.__loop1_item___noname2;\n    \
    \                ++__loop1_iteration;\n                    if ((__noname1.Source\
    \ == __noname2.Source)) {\n                        res.Add(__noname1.Source);\n\
    \                    }\n                }\n            }\n        }\n        else\
    \ {\n            {\n                int __loop2_iteration = 0;\n             \
    \   var __loop2_result =\n                    (from __loop2_tmp_item___noname3\
    \ in EnumerableExtensions.Enumerate((Index: 0,Source: l2))\n                 \
    \   from __loop2_tmp_item___noname4 in EnumerableExtensions.Enumerate((Index:\
    \ 0,Source: l1))\n                    select\n                        new\n  \
    \                      {\n                            __loop2_item___noname3 =\
    \ __loop2_tmp_item___noname3,\n                            __loop2_item___noname4\
    \ = __loop2_tmp_item___noname4,\n                        }).ToArray();\n     \
    \           foreach (var __loop2_item in __loop2_result)\n                {\n\
    \                    var __noname3 = __loop2_item.__loop2_item___non", '        return
    l1.Intersect(l2).ToList();', "        List<long> res = new List<long>();\n   \
    \     if (l1.Count > l2.Count) {\n            l1.Sort();\n            l2.Sort();\n\
    \            foreach (long x in l2) {\n                if (l1.BinarySearch(x)\
    \ >= 0) {\n                    res.Add(x);\n                }\n            }\n\
    \        } else {\n            l1.Sort();\n            l2.Sort();\n          \
    \  foreach (long x in l1) {\n                if (l2.BinarySearch(x) >= 0) {\n\
    \                    res.Add(x);\n                }\n            }\n        }\n\
    \        return res;", "        if (l1.Count == 0 || l2.Count == 0) {\n      \
    \      return new List<long>();\n        }\n        List<long> output = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        while (i < l1.Count && j < l2.Count)\
    \ {\n            if (l1[i] == l2[j]) {\n                output.Add(l1[i]);\n \
    \               i += 1;\n                j += 1;\n            } else if (l1[i]\
    \ < l2[j]) {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n        return output;", "        var l = new\
    \ List<long>();\n        foreach (var item in l1) {\n            if (l2.Contains(item))\
    \ {\n                l.Add(item);\n            }\n        }\n        l.Sort();\n\
    \        var lr = new List<long>();\n        long last = -1L;\n        foreach\
    \ (var item in l) {\n            if (item != last) {\n                lr.Add(item);\n\
    \            }\n            last = item;\n        }\n        return lr;", "  \
    \      l1.Sort();\n        l2.Sort();\n        var c = new List<long>();\n   \
    \     var i1 = 0;\n        var i2 = 0;\n        while ((i1 < l1.Count()) && (i2\
    \ < l2.Count())) {\n            if (l1[i1] == l2[i2]) {\n                c.Add(l1[i1]);\n\
    \                i1++;\n                i2++;\n            } else if (l1[i1] <\
    \ l2[i2]) {\n                i1++;\n            } else {\n                i2++;\n\
    \            }\n        }\n        return c;", "        // Convert to HashSets.\n\
    \        HashSet<long> h1 = new HashSet<long>(l1);\n        HashSet<long> h2 =\
    \ new HashSet<long>(l2);\n        // Intersect HashSets.\n        h1.IntersectWith(h2);\n\
    \        // Convert to List.\n        List<long> l = new List<long>(h1);\n   \
    \     // Sort List.\n        l.Sort();\n        return l;", "        var r = new\
    \ List<long>();\n        var dict = new Dictionary<long, long>();\n        for\
    \ (int x = 0; x < l1.Count; x++) {\n            dict[l1[x]] = 0L;\n        }\n\
    \        for (int x = 0; x < l2.Count; x++) {\n            if (dict.ContainsKey(l2[x]))\
    \ {\n                dict[l2[x]] = 1L;\n            }\n        }\n        foreach\
    \ (KeyValuePair<long, long> kvp in dict) {\n            if (kvp.Value == 1L) {\n\
    \                r.Add(kvp.Key);\n            }\n        }\n        r.Sort();\n\
    \        return r;", "        l1.Sort();\n        l2.Sort();\n        var common\
    \ = new List<long>();\n        var i1 = 0;\n        var i2 = 0;\n        while\
    \ (i1 < l1.Count && i2 < l2.Count) {\n            var c1 = l1[i1];\n         \
    \   var c2 = l2[i2];\n            if (c1 == c2) {\n                common.Add(c1);\n\
    \                i1++;\n                i2++;\n            } else if (c1 < c2)\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return common;", '        return l1.Intersect(l2).OrderBy(x
    => x).ToList();', "        l1.Sort();\n        l2.Sort();\n        int i1 = 0;\n\
    \        int i2 = 0;\n        int l1c = l1.Count;\n        int l2c = l2.Count;\n\
    \        List<long> result = new List<long>();\n        while ((i1 < l1c) && (i2\
    \ < l2c)) {\n            long e1 = l1[i1];\n            long e2 = l2[i2];\n  \
    \          if (e1 == e2) {\n                result.Add(e1);\n                i1++;\n\
    \                i2++;\n            } else if (e1 < e2) {\n                i1++;\n\
    \            } else {\n                i2++;\n            }\n        }\n     \
    \   return result;", "        var d = new Dictionary<long, long>();\n        foreach\
    \ (var i in l1) {\n            if (d.ContainsKey(i)) {\n                d[i] =\
    \ d[i] + (long)1L;\n            }\n            else {\n                d[i] =\
    \ (long)1L;\n            }\n        }\n        var r = new List<long>();\n   \
    \     foreach (var i in l2) {\n            if (d.ContainsKey(i)) {\n         \
    \       if (d[i] > (long)0L) {\n                    r.Add(i);\n              \
    \      d[i] = d[i] - (long)1L;\n                }\n            }\n        }\n\
    \        r.Sort();\n        return r;", "        long[] a1 = l1.ToArray();\n \
    \       long[] a2 = l2.ToArray();\n        Array.Sort(a1);\n        Array.Sort(a2);\n\
    \        List<long> res = new List<long>();\n        long i1 = 0;\n        long\
    \ i2 = 0;\n        long n1 = a1.Length;\n        long n2 = a2.Length;\n      \
    \  while ((i1 < n1) && (i2 < n2)) {\n            if (a1[i1] == a2[i2]) {\n   \
    \             if ((res.Count == 0) || (res[(int)(res.Count - 1)] != a1[i1])) {\n\
    \                    res.Add(a1[i1]);\n                }\n                i1++;\n\
    \                i2++;\n            } else if (a1[i1] < a2[i2]) {\n          \
    \      i1++;\n            } else {\n                i2++;\n            }\n   \
    \     }\n        return res;", "        l1.Sort();\n        l2.Sort();\n     \
    \   var la = l1.ToArray();\n        var lb = l2.ToArray();\n        var res =\
    \ new List<long>();\n        for (int i = 0, j = 0; i < la.Length && j < lb.Length;\
    \ ) {\n            if (la[i] == lb[j]) {\n                res.Add(la[i]);\n  \
    \              i++;\n                j++;\n            } else if (la[i] < lb[j])\
    \ {\n                i++;\n            } else {\n                j++;\n      \
    \      }\n        }\n        return res;", "        // Fastest way: sort both,\
    \ then walk through and find common.\n        l1.Sort();\n        l2.Sort();\n\
    \        List<long> res = new List<long>();\n        int i1 = 0;\n        int\
    \ i2 = 0;\n        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            if\
    \ (l1[i1] == l2[i2]) {\n                res.Add(l1[i1]);\n                i1++;\n\
    \                i2++;\n            } else if (l1[i1] < l2[i2]) {\n          \
    \      i1++;\n            } else {\n                i2++;\n            }\n   \
    \     }\n        return res;", "        var h = new HashSet<long>(l1);\n     \
    \   h.IntersectWith(l2);\n        return new List<long>(h);", "        l1.Sort();\n\
    \        l2.Sort();\n        long ll1 = (long)l1.Count;\n        long ll2 = (long)l2.Count;\n\
    \        long i1 = (long)0L;\n        long i2 = (long)0L;\n        List<long>\
    \ res = new List<long>();\n        while (i1 < ll1 && i2 < ll2) {\n          \
    \  long v1 = l1[(int)i1];\n            long v2 = l2[(int)i2];\n            if\
    \ (v1 == v2) {\n                res.Add(v1);\n                i1++;\n        \
    \        i2++;\n            }\n            else if (v1 < v2) {\n             \
    \   i1++;\n            }\n            else {\n                i2++;\n        \
    \    }\n        }\n        return res;", "        List<long> res = new List<long>();\n\
    \        if (l1.Count == 0 || l2.Count == 0) {\n            return res;\n    \
    \    }\n        l1.Sort();\n        l2.Sort();\n        int len1 = l1.Count;\n\
    \        int len2 = l2.Count;\n        long n1 = l1[0];\n        long n2 = l2[0];\n\
    \        int i1 = 0;\n        int i2 = 0;\n        while (i1 < len1 && i2 < len2)\
    \ {\n            n1 = l1[i1];\n            n2 = l2[i2];\n            if (n1 ==\
    \ n2) {\n                res.Add(n1);\n                i1 += 1;\n            \
    \    i2 += 1;\n            } else if (n1 < n2) {\n                i1 += 1;\n \
    \           } else {\n                i2 += 1;\n            }\n        }\n   \
    \     return res;", "        List<long> result = new List<long>();\n        var\
    \ n1 = l1.Count;\n        var n2 = l2.Count;\n        var i1 = 0;\n        var\
    \ i2 = 0;\n        while (i1 < n1 && i2 < n2) {\n            var v1 = l1[i1];\n\
    \            var v2 = l2[i2];\n            if (v1 == v2) {\n                result.Add(v1);\n\
    \                i1++;\n                i2++;\n            } else if (v1 < v2)\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return result;", "        l1.Sort();\n        l2.Sort();\n\
    \        var r = new List<long>();\n        var i1 = 0;\n        var i2 = 0;\n\
    \        var n1 = l1.Count;\n        var n2 = l2.Count;\n        while ((i1 <\
    \ n1) && (i2 < n2)) {\n            var x1 = l1[i1];\n            var x2 = l2[i2];\n\
    \            if (x1 == x2) {\n                r.Add(x1);\n                while\
    \ ((i1 < n1) && (l1[i1] == x1)) {\n                    i1++;\n               \
    \ }\n                while ((i2 < n2) && (l2[i2] == x2)) {\n                 \
    \   i2++;\n                }\n            } else if (x1 < x2) {\n            \
    \    while ((i1 < n1) && (l1[i1] == x1)) {\n                    i1++;\n      \
    \          }\n            } else {\n                while ((i2 < n2) && (l2[i2]\
    \ == x2)) {\n                    i2++;\n                }\n            }\n   \
    \     }\n        return r;", "        List<long> tmp = new List<long>();\n   \
    \     l1.Sort();\n        l2.Sort();\n        foreach (long elem in l1) {\n  \
    \          if (l2.Contains(elem)) {\n                tmp.Add(elem);\n        \
    \    }\n        }\n        return tmp.Distinct().ToList();", "        var ret\
    \ = new List<long>();\n        foreach (var i in l1) {\n            if (l2.Contains(i))\
    \ {\n                ret.Add(i);\n            }\n        }\n        ret.Sort();\n\
    \        return ret;", "        l1.Sort();\n        l2.Sort();\n        int len1\
    \ = l1.Count;\n        int len2 = l2.Count;\n        int i = 0;\n        int j\
    \ = 0;\n        List<long> res = new List<long>();\n        while (i < len1 &&\
    \ j < len2) {\n            if (l1[i] == l2[j]) {\n                res.Add(l1[i]);\n\
    \                i++;\n                j++;\n            } else if (l1[i] < l2[j])\
    \ {\n                i++;\n            } else {\n                j++;\n      \
    \      }\n        }\n        return res;", "        var l = new List<long>();\n\
    \        // >>> l1.Sort()\n        // >>> l1\n        // (new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)3L, (long)4L, (long)5L, (long)34L, (long)653L}))\n        l1.Sort();\n\
    \        // >>> l2.Sort()\n        // >>> l2\n        // (new List<long>(new long[]{(long)1L,\
    \ (long)5L, (long)7L, (long)9L, (long)121L, (long)653L}))\n        l2.Sort();\n\
    \        // >>> int c1 = 0;\n        // >>> int c2 = 0;\n        int c1 = 0;\n\
    \        int c2 = 0;\n        // >>> while c1 < len(l1) and c2 < len(l2):\n  \
    \      while (c1 < l1.Count && c2 < l2.Count) {\n            // >>> if l1[c1]\
    \ == l2[c2]:\n            if (l1[c1] == l2[c2]) {\n                // >>> l.append(l1[c1])\n\
    \                l.Add(l1[c1]);\n                // >>> c1 += 1\n            \
    \    c1 += 1;\n                // >>> c2 += 1\n                c2 += 1;\n    \
    \        } else if (l1[c1] < l2[c2]) {\n                // >>> elif l1[c1] < l2[c2]:\n\
    \                // >>> c1 += 1\n                c1 += 1;\n            } else\
    \ {\n                // >>> else:\n                // >>> c2 += 1\n          \
    \      c2 += 1;\n            }\n        }\n        // >>> return l\n        return\
    \ l;", "        var dict = new Dictionary<long, bool>();\n        var result =\
    \ new List<long>();\n        foreach (var element in l1) {\n            dict[element]\
    \ = true;\n        }\n        foreach (var element in l2) {\n            if (dict.ContainsKey(element))\
    \ {\n                result.Add(element);\n            }\n        }\n        result.Sort();\n\
    \        return result;", "        l1.Sort();\n        l2.Sort();\n        int\
    \ i = 0;\n        int j = 0;\n        var r = new List<long>();\n        while\
    \ ((i < l1.Count) && (j < l2.Count)) {\n            if (l1[i] == l2[j]) {\n  \
    \              r.Add(l1[i]);\n                i++;\n                j++;\n   \
    \         } else if (l1[i] < l2[j]) {\n                i++;\n            } else\
    \ {\n                j++;\n            }\n        }\n        return r;", "   \
    \     var result = l1.Intersect(l2).ToList();\n        result.Sort();\n      \
    \  return result;", "        var l = new List<long>();\n        int i = 0;\n \
    \       int j = 0;\n        while (i < l1.Count && j < l2.Count) {\n         \
    \   long r = l1[i].CompareTo(l2[j]);\n            if (r == 0) {\n            \
    \    l.Add(l1[i]);\n                i += 1;\n                j += 1;\n       \
    \     } else if (r < 0) {\n                i += 1;\n            } else {\n   \
    \             j += 1;\n            }\n        }\n        return l;", "       \
    \ Dictionary<long, long> dict = new Dictionary<long, long>();\n        foreach\
    \ (long item in l1) {\n            if (!dict.ContainsKey(item)) {\n          \
    \      dict[item] = (long)0L;\n            }\n            dict[item] = dict[item]\
    \ + (long)1L;\n        }\n        foreach (long item in l2) {\n            if\
    \ (!dict.ContainsKey(item)) {\n                dict[item] = (long)0L;\n      \
    \      }\n            dict[item] = dict[item] + (long)1L;\n        }\n       \
    \ List<long> items = new List<long>();\n        foreach (KeyValuePair<long, long>\
    \ item in dict) {\n            if (item.Value > (long)1L) {\n                items.Add(item.Key);\n\
    \            }\n        }\n        items.Sort();\n        return items;", "  \
    \      List<long> result = new List<long>();\n        for (int i = 0; i < l1.Count;\
    \ i++) {\n            if (l2.Contains(l1[i])) {\n                result.Add(l1[i]);\n\
    \            }\n        }\n        result.Sort();\n        return result;", " \
    \       List<long> result = new List<long>();\n        l1.Sort();\n        l2.Sort();\n\
    \        long i = 0L;\n        long j = 0L;\n        while ((i < (l1.Count)) &&\
    \ (j < (l2.Count))) {\n            if ((l1[(int)(i)] == l2[(int)(j)])) {\n   \
    \             if (((result.Count) == 0L) || ((result[(int)(((result.Count) - 1L))])\
    \ != (l1[(int)(i)]))) {\n                    result.Add(l1[(int)(i)]);\n     \
    \           }\n                i += 1L;\n                j += 1L;\n          \
    \  }\n            else if ((l1[(int)(i)] < l2[(int)(j)])) {\n                i\
    \ += 1L;\n            }\n            else {\n                j += 1L;\n      \
    \      }\n        }\n        return result;", "        l1.Sort();\n        l2.Sort();\n\
    \        var l = new List<long>();\n        long i = 0L;\n        long j = 0L;\n\
    \        while (i < len(l1) && j < len(l2))\n        {\n            if (l1[(int)i]\
    \ < l2[(int)j])\n            {\n                i += 1L;\n            }\n    \
    \        else if (l1[(int)i] > l2[(int)j])\n            {\n                j +=\
    \ 1L;\n            }\n            else\n            {\n                l.Add(l1[(int)i]);\n\
    \                i += 1L;\n                j += 1L;\n            }\n\n       \
    \ }\n\n        return l;\n", "        // Sort l1 and l2 and walk through both\
    \ lists keeping track of:\n        // 1. The last element in l1 that's less than\
    \ or equal to the current element in l2.\n        // 2. The last element in l2\
    \ that's less than or equal to the current element in l1.\n        // If the current\
    \ elements are equal then add it to the list of common elements.\n        // Return\
    \ the sorted list of common elements.\n        l1.Sort();\n        l2.Sort();\n\
    \        long i1 = (long)0L;\n        long i2 = (long)0L;\n        List<long>\
    \ common = new List<long>();\n        while (i1 < (long)l1.Count && i2 < (long)l2.Count)\n\
    \        {\n            var e1 = l1[(int)i1];\n            var e2 = l2[(int)i2];\n\
    \            if (e1 == e2)\n            {\n                common.Add(e1);\n \
    \               i1++;\n                i2++;\n            }\n            else\
    \ if (e1 < e2)\n            {\n                i1++;\n            }\n        \
    \    else\n            {\n                i2++;\n            }\n\n        }\n\n\
    \        return common;\n", "        var temp = new Dictionary<long, long>();\n\
    \        var res = new List<long>();\n        foreach (var item in l1) {\n   \
    \         if (!temp.ContainsKey(item)) {\n                temp[item] = (long)1L;\n\
    \            }\n        }\n        foreach (var item in l2) {\n            if\
    \ (temp.ContainsKey(item)) {\n                res.Add(item);\n            }\n\
    \        }\n        res.Sort();\n        return res;", "        l1.Sort();\n \
    \       l2.Sort();\n        return l1.Intersect(l2).ToList();", "        var output\
    \ = new List<long>();\n        foreach (var num in l1) {\n            if (l2.Contains(num))\
    \ {\n                output.Add(num);\n            }\n        }\n        output.Sort();\n\
    \        output = output.Distinct().ToList();\n        return output;", '        return
    l1.Intersect(l2).OrderBy(x => x).ToList();', "        var l = new List<long>();\n\
    \        foreach (var e in l1)\n            if (l2.Contains(e))\n            \
    \    l.Add(e);\n        l.Sort();\n        var res = new List<long>();\n     \
    \   foreach (var e in l)\n            if (res.Count == 0 || res[res.Count - 1]\
    \ != e)\n                res.Add(e);\n        return res;", "        l1.Sort();\n\
    \        l2.Sort();\n        var res = new List<long>();\n        int l1_pos =\
    \ 0;\n        int l2_pos = 0;\n        while ((l1_pos < l1.Count) && (l2_pos <\
    \ l2.Count)) {\n            long d1 = l1[l1_pos];\n            long d2 = l2[l2_pos];\n\
    \            if (d1 < d2) {\n                l1_pos++;\n            } else if\
    \ (d1 > d2) {\n                l2_pos++;\n            } else {\n             \
    \   res.Add(d1);\n                l1_pos++;\n                l2_pos++;\n     \
    \       }\n        }\n        return res;", "        List<long> s1 = l1.Distinct().ToList();\n\
    \        List<long> s2 = l2.Distinct().ToList();\n        List<long> res = new\
    \ List<long>();\n        int j = 0;\n        for (int i = 0; i < s1.Count; i++)\
    \ {\n            if (j >= s2.Count)\n                break;\n            if (s1[i]\
    \ == s2[j]) {\n                res.Add(s1[i]);\n                j++;\n       \
    \     } else if (s1[i] > s2[j]) {\n                while (j < s2.Count && s1[i]\
    \ > s2[j])\n                    j++;\n                if (j < s2.Count && s1[i]\
    \ == s2[j]) {\n                    res.Add(s1[i]);\n                    j++;\n\
    \                }\n            }\n        }\n        return res;", "        l1.Sort();\n\
    \        l2.Sort();\n        var l3 = new List<long>();\n        foreach (var\
    \ e in l1) {\n            if (l2.BinarySearch(e) >= 0) {\n                l3.Add(e);\n\
    \            }\n        }\n        return l3;", '        return l1.Intersect(l2).OrderBy(x
    => x).ToList();', "        List<long> result = new List<long>();\n        int\
    \ i1 = 0;\n        int i2 = 0;\n        while (i1 < l1.Count && i2 < l2.Count)\
    \ {\n            long a = l1[i1];\n            long b = l2[i2];\n            if\
    \ (a == b) {\n                result.Add(a);\n                i1 += 1;\n     \
    \           i2 += 1;\n            } else if (a < b) {\n                i1 += 1;\n\
    \            } else {\n                i2 += 1;\n            }\n        }\n  \
    \      return result;", "        l1.Sort();\n        l2.Sort();\n        var res\
    \ = new List<long>();\n        int i = 0;\n        int j = 0;\n        while (i\
    \ < l1.Count && j < l2.Count) {\n            var v1 = l1[i];\n            var\
    \ v2 = l2[j];\n            if (v1 < v2) {\n                i += 1;\n         \
    \   } else if (v1 > v2) {\n                j += 1;\n            } else {\n   \
    \             res.Add(v1);\n                i += 1;\n                j += 1;\n\
    \            }\n        }\n        return res;", "        l1.Sort();\n       \
    \ l2.Sort();\n        var ret = new List<long>();\n        foreach (var i in l1)\
    \ {\n            if (l2.BinarySearch(i) >= 0) {\n                ret.Add(i);\n\
    \            }\n        }\n        return ret;", "        l1.Sort();\n       \
    \ l2.Sort();\n        long i1 = 0L;\n        long i2 = 0L;\n        List<long>\
    \ res = new List<long>();\n        while ((i1 < l1.Count) && (i2 < l2.Count))\
    \ {\n            long e1 = l1[(int)i1];\n            long e2 = l2[(int)i2];\n\
    \            if (e1 == e2) {\n                res.Add(e1);\n                i1++;\n\
    \                i2++;\n            } else if (e1 < e2) {\n                i1++;\n\
    \            } else {\n                i2++;\n            }\n        }\n     \
    \   return res;", "        l1.Sort();\n        l2.Sort();\n        int p1 = 0;\n\
    \        int p2 = 0;\n        List<long> l = new List<long>();\n        while\
    \ ((p1 < l1.Count) && (p2 < l2.Count)) {\n            if (l1[p1] == l2[p2]) {\n\
    \                if ((l.Count == 0) || (l.Last() != l1[p1])) {\n             \
    \       l.Add(l1[p1]);\n                }\n                p1 += 1;\n        \
    \        p2 += 1;\n            } else if (l1[p1] < l2[p2]) {\n               \
    \ p1 += 1;\n            } else {\n                p2 += 1;\n            }\n  \
    \      }\n        return l;", '        return l1.Where(x => l2.Contains(x)).Distinct().OrderBy(x
    => x).ToList();', "        l1.Sort();\n        l2.Sort();\n        var i1 = 0;\n\
    \        var i2 = 0;\n        var result = new List<long>();\n        while ((i1\
    \ < l1.Count) && (i2 < l2.Count)) {\n            var e1 = l1[i1];\n          \
    \  var e2 = l2[i2];\n            if (e1 < e2) {\n                i1++;\n     \
    \       } else if (e1 > e2) {\n                i2++;\n            } else {\n \
    \               result.Add(e1);\n                i1++;\n                i2++;\n\
    \            }\n        }\n        return result;", "        // Your code here\n\
    \        l1.Sort();\n        l2.Sort();\n        List<long> result = new List<long>();\n\
    \        int i = 0;\n        int j = 0;\n        while(i < l1.Count && j < l2.Count)\
    \ {\n            long a = l1[i];\n            long b = l2[j];\n            if(a\
    \ < b) {\n                i++;\n            } else if(a > b) {\n             \
    \   j++;\n            } else {\n                result.Add(a);\n             \
    \   i++;\n                j++;\n            }\n        }\n        return result;",
  "        l1.Sort();\n        l2.Sort();\n        var l3 = new List<long>();\n  \
    \      long v;\n        int i = 0;\n        int j = 0;\n        while ((i < len(l1))\
    \ && (j < len(l2))) {\n            if (l1[i] == l2[j]) {\n                v =\
    \ l1[i];\n                l3.Add(v);\n                i++;\n                j++;\n\
    \            }\n            else if (l1[i] < l2[j]) {\n                i++;\n\
    \            }\n            else {\n                j++;\n            }\n    \
    \    }\n        return l3;", "        l1.Sort();\n        l2.Sort();\n       \
    \ List<long> res = new List<long>();\n        int i1 = 0;\n        int i2 = 0;\n\
    \        while (i1 < l1.Count && i2 < l2.Count) {\n            if (l1[i1] == l2[i2])\
    \ {\n                res.Add(l1[i1]);\n                i1 += 1;\n            \
    \    i2 += 1;\n            } else if (l1[i1] < l2[i2]) {\n                i1 +=\
    \ 1;\n            } else {\n                i2 += 1;\n            }\n        }\n\
    \        return res;", "        l1.Sort();\n        l2.Sort();\n        long i1\
    \ = 0L;\n        long i2 = 0L;\n        List<long> ans = new List<long>();\n \
    \       while ((i1 < (l1.Count)) && (i2 < (l2.Count))) {\n            long v1\
    \ = l1[(int)(i1)];\n            long v2 = l2[(int)(i2)];\n            if (v1 <\
    \ v2) {\n                i1 += 1L;\n            }\n            else if (v1 > v2)\
    \ {\n                i2 += 1L;\n            }\n            else {\n          \
    \      ans.Add(v1);\n                i1 += 1L;\n                i2 += 1L;\n  \
    \          }\n        }\n        return ans;", "        var t1 = (new HashSet<long>(l1));\n\
    \        var t2 = (new HashSet<long>(l2));\n        t1.IntersectWith(t2);\n  \
    \      var r = t1.ToList();\n        r.Sort();\n        return r;", "        var\
    \ s1 = new HashSet<long>(l1);\n        var s2 = new HashSet<long>(l2);\n     \
    \   s1.IntersectWith(s2);\n        return new List<long>(s1.OrderBy((long x) =>\
    \ x));", "        List<long> sortedUniqueCommonElements = new List<long>();\n\
    \        var e1 = l1.GetEnumerator();\n        var e2 = l2.GetEnumerator();\n\
    \        bool b1 = e1.MoveNext();\n        bool b2 = e2.MoveNext();\n        long\
    \ v1 = 0;\n        long v2 = 0;\n        long prev = 0;\n        while (b1 &&\
    \ b2) {\n            v1 = e1.Current;\n            v2 = e2.Current;\n        \
    \    if (v1 == v2) {\n                if (prev != v1) {\n                    sortedUniqueCommonElements.Add(v1);\n\
    \                    prev = v1;\n                }\n                b1 = e1.MoveNext();\n\
    \                b2 = e2.MoveNext();\n            } else if (v1 < v2) {\n    \
    \            b1 = e1.MoveNext();\n            } else {\n                b2 = e2.MoveNext();\n\
    \            }\n        }\n        return sortedUniqueCommonElements;", "    \
    \    Dictionary<long, object> d = new Dictionary<long, object>();\n        foreach\
    \ (long x in l1) {\n            if (!d.ContainsKey(x)) {\n                d[x]\
    \ = null;\n            }\n        }\n        List<long> res = new List<long>();\n\
    \        foreach (long x in l2) {\n            if (d.ContainsKey(x)) {\n     \
    \           res.Add(x);\n            }\n        }\n        res.Sort();\n     \
    \   return res;", "        var l2set = new HashSet<long>(l2);\n        var res\
    \ = new List<long>();\n        foreach (var x in l1) {\n            if (l2set.Contains(x))\
    \ res.Add(x);\n        }\n        res.Sort();\n        return res;", "       \
    \ l1.Sort();\n        l2.Sort();\n        long i = 0L;\n        long j = 0L;\n\
    \        List<long> result = new List<long>();\n        while (i < l1.Count &&\
    \ j < l2.Count) {\n            if (l1[(int)i] == l2[(int)j]) {\n             \
    \   result.Add(l1[(int)i]);\n                i += 1L;\n                j += 1L;\n\
    \            }\n            else if (l1[(int)i] < l2[(int)j]) {\n            \
    \    i += 1L;\n            }\n            else {\n                j += 1L;\n \
    \           }\n        }\n        return result;", "        List<long> c = new\
    \ List<long>();\n        l1.Sort();\n        l2.Sort();\n        int i1 = 0;\n\
    \        int i2 = 0;\n        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n \
    \           long v1 = l1[i1];\n            long v2 = l2[i2];\n            if (v1\
    \ == v2) {\n                c.Add(v1);\n                i1 += 1;\n           \
    \     i2 += 1;\n            } else if (v1 < v2) {\n                i1 += 1;\n\
    \            } else {\n                i2 += 1;\n            }\n        }\n  \
    \      return c;", "        l1.Sort();\n        l2.Sort();\n        List<long>\
    \ mergedList = new List<long>();\n        int i = 0;\n        int j = 0;\n   \
    \     for (; i < l1.Count && j < l2.Count; ) {\n            if (l1[i] < l2[j])\
    \ {\n                i++;\n            } else if (l1[i] > l2[j]) {\n         \
    \       j++;\n            } else {\n                mergedList.Add(l1[i]);\n \
    \               i++;\n                j++;\n            }\n        }\n       \
    \ return mergedList;", "        Dictionary<long, long> d1 = new Dictionary<long,\
    \ long>();\n        Dictionary<long, long> d2 = new Dictionary<long, long>();\n\
    \        foreach (long l in l1) {\n            if (d1.ContainsKey(l)) {\n    \
    \            d1[l] = d1[l] + (long)1L;\n            }\n            else {\n  \
    \              d1[l] = (long)1L;\n            }\n        }\n        foreach (long\
    \ l in l2) {\n            if (d2.ContainsKey(l)) {\n                d2[l] = d2[l]\
    \ + (long)1L;\n            }\n            else {\n                d2[l] = (long)1L;\n\
    \            }\n        }\n        List<long> keys = new List<long>();\n     \
    \   foreach (long l in d1.Keys) {\n            if (d2.ContainsKey(l)) {\n    \
    \            keys.Add(l);\n            }\n        }\n        keys.Sort();\n  \
    \      return keys;", "        List<long> result = new List<long>();\n       \
    \ l1.Sort();\n        l2.Sort();\n        long i = 0L;\n        long j = 0L;\n\
    \        long length = l1.Count;\n        long length2 = l2.Count;\n        while\
    \ ((i < length) && (j < length2)) {\n            if (l1[(int)i] == l2[(int)j])\
    \ {\n                result.Add(l1[(int)i]);\n                i++;\n         \
    \       j++;\n            } else if (l1[(int)i] < l2[(int)j]) {\n            \
    \    i++;\n            } else {\n                j++;\n            }\n       \
    \ }\n        return result;", "        var common = new List<long>();\n      \
    \  var l1u = new HashSet<long>(l1);\n        var l2u = new HashSet<long>(l2);\n\
    \        var l1u2 = new HashSet<long>(l1u);\n        l1u2.IntersectWith(l2u);\n\
    \        common.AddRange(l1u2);\n        common.Sort();\n        return common;",
  "        var l = new List<long>();\n        var i1 = 0;\n        var i2 = 0;\n \
    \       while (i1 < l1.Count && i2 < l2.Count) {\n            if (l1[i1] == l2[i2])\
    \ {\n                l.Add(l1[i1]);\n                i1 += 1;\n              \
    \  i2 += 1;\n            } else if (l1[i1] < l2[i2]) {\n                i1 +=\
    \ 1;\n            } else {\n                i2 += 1;\n            }\n        }\n\
    \        return l;", '        return l1.Intersect(l2).ToList();', '        return
    l1.Intersect(l2).ToList();', "        // Test cases:\n        // l1=[5,3,2,8],\
    \ l2=[3,2]\n        // l1=[1,4,3,34,653,2,5], l2=[5,7,1,5,9,653,121]\n       \
    \ var x = l1.Intersect(l2);\n        return x.ToList();", "        var l3 = new\
    \ List<long>();\n        l1.Sort();\n        l2.Sort();\n        int i = 0;\n\
    \        int j = 0;\n        while ((i < l1.Count) && (j < l2.Count)) {\n    \
    \        if (l1[i] == l2[j]) {\n                l3.Add(l1[i]);\n             \
    \   i++;\n                j++;\n            } else if (l1[i] < l2[j]) {\n    \
    \            i++;\n            } else {\n                j++;\n            }\n\
    \        }\n        return l3;", "        var lookup = new HashSet<long>(l1);\n\
    \        lookup.IntersectWith(l2);\n        return lookup.ToList();", "      \
    \  List<long> l3 = l1.Intersect(l2).ToList();\n        l3.Sort();\n        return\
    \ l3;", "        List<long> res = new List<long>();\n        long[] a1 = l1.ToArray();\n\
    \        long[] a2 = l2.ToArray();\n        Array.Sort(a1);\n        Array.Sort(a2);\n\
    \        long p1 = 0L;\n        long p2 = 0L;\n        while ((p1 < a1.Length)\
    \ && (p2 < a2.Length)) {\n            if (a1[p1] == a2[p2]) {\n              \
    \  res.Add(a1[p1]);\n                p1++;\n                p2++;\n          \
    \  } else if (a1[p1] < a2[p2]) {\n                p1++;\n            } else {\n\
    \                p2++;\n            }\n        }\n        return res;", '        return
    l1.Intersect(l2).OrderBy(x => x).ToList();', "        var set1 = new HashSet<long>(l1);\n\
    \        var set2 = new HashSet<long>(l2);\n        set1.IntersectWith(set2);\n\
    \        return new List<long>(set1);", "        l1.Sort();\n        l2.Sort();\n\
    \        List<long> result = new List<long>();\n        int i1 = 0;\n        int\
    \ i2 = 0;\n        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            if\
    \ (l1[i1] == l2[i2]) {\n                result.Add(l1[i1]);\n                i1++;\n\
    \                i2++;\n            } else if (l1[i1] < l2[i2]) {\n          \
    \      i1++;\n            } else {\n                i2++;\n            }\n   \
    \     }\n        return result;", "        if (l1.Count == 0 || l2.Count == 0)\
    \ {\n            return new List<long>();\n        }\n        else {\n       \
    \     l1.Sort();\n            l2.Sort();\n            var i1 = (long)0L;\n   \
    \         var i2 = (long)0L;\n            var ret = new List<long>();\n      \
    \      while (i1 < l1.Count && i2 < l2.Count) {\n                if (l1[(int)i1]\
    \ == l2[(int)i2]) {\n                    ret.Add(l1[(int)i1]);\n             \
    \       i1++;\n                    i2++;\n                }\n                else\
    \ if (l1[(int)i1] < l2[(int)i2]) {\n                    i1++;\n              \
    \  }\n                else {\n                    i2++;\n                }\n \
    \           }\n            return ret;\n        }", "        List<long> res =\
    \ new List<long>();\n        l1.Sort();\n        l2.Sort();\n        int i = 0;\n\
    \        int j = 0;\n        while (i < l1.Count && j < l2.Count) {\n        \
    \    if (l1[i] == l2[j]) {\n                res.Add(l1[i]);\n                i++;\n\
    \                j++;\n            } else if (l1[i] < l2[j]) {\n             \
    \   i++;\n            } else {\n                j++;\n            }\n        }\n\
    \        return res;", "        var l = l1.Intersect(l2).ToList();\n        l.Sort();\n\
    \        return l;", "        var h = new HashSet<long>(l1);\n        h.IntersectWith(l2);\n\
    \        return new List<long>(h);", "        List<long> result = new List<long>();\n\
    \        Dictionary<long, long> d1 = new Dictionary<long, long>();\n        Dictionary<long,\
    \ long> d2 = new Dictionary<long, long>();\n        foreach (long item in l1)\
    \ {\n            if (d1.ContainsKey(item)) {\n                d1[item] = d1[item]\
    \ + (long)1L;\n            }\n            else {\n                d1[item] = (long)1L;\n\
    \            }\n        }\n        foreach (long item in l2) {\n            if\
    \ (d2.ContainsKey(item)) {\n                d2[item] = d2[item] + (long)1L;\n\
    \            }\n            else {\n                d2[item] = (long)1L;\n   \
    \         }\n        }\n        foreach (KeyValuePair<long, long> pair in d1)\
    \ {\n            if (d2.ContainsKey(pair.Key)) {\n                long min = (long)0L;\n\
    \                if (pair.Value < d2[pair.Key]) {\n                    min = pair.Value;\n\
    \                }\n                else {\n                    min = d2[pair.Key];\n\
    \                }\n                for (long i = (long)0L; i < min; i++) {\n\
    \                    result.Add(pair.Key);\n                }\n            }\n\
    \        }\n        result.Sort();\n        return result;", "        var dict\
    \ = new Dictionary<long, int>();\n        foreach (var x in l1) {\n          \
    \  if (dict.ContainsKey(x)) {\n                dict[x]++;\n            } else\
    \ {\n                dict[x] = 1;\n            }\n        }\n        foreach (var\
    \ x in l2) {\n            if (dict.ContainsKey(x)) {\n                dict[x]++;\n\
    \            } else {\n                dict[x] = 1;\n            }\n        }\n\
    \        var result = new List<long>();\n        foreach (var x in dict.Keys)\
    \ {\n            if (dict[x] > 1) {\n                result.Add(x);\n        \
    \    }\n        }\n        result.Sort();\n        return result;", "        List<long>\
    \ l0 = new List<long>();\n        l1.Sort();\n        l2.Sort();\n        long\
    \ i = 0L;\n        long j = 0L;\n        while (((i < (l1.Count)) && (j < (l2.Count))))\
    \ {\n            long x = l1[(int)(i)];\n            long y = l2[(int)(j)];\n\
    \            if ((x == y)) {\n                l0.Add(x);\n                i =\
    \ (i + 1L);\n                j = (j + 1L);\n            }\n            else if\
    \ ((x < y)) {\n                i = (i + 1L);\n            }\n            else\
    \ {\n                j = (j + 1L);\n            }\n        }\n        return l0;",
  "        var result = new List<long>();\n        foreach (var x in l1) {\n     \
    \       if ((l2.Contains(x))) {\n                result.Add(x);\n            }\n\
    \        }\n        result.Sort();\n        return result;", "        List<long>\
    \ res = new List<long>();\n        long cur = (long)0L;\n        for (long k =\
    \ (long)0L; k < 2L; k++) {\n            var tmp = l1;\n            l1 = l2;\n\
    \            l2 = tmp;\n            tmp = null;\n        }\n        for (long\
    \ i = (long)0L; i < len(l1); i++) {\n            if (l1[i] != cur) {\n       \
    \         res.Add(l1[i]);\n                cur = l1[i];\n            }\n     \
    \   }\n        return res;", "        List<long> uniq = new List<long>();\n  \
    \      // TODO: Fix this to be a one-liner.\n        foreach (long i in l1) {\n\
    \            if (l2.Contains(i)) {\n                uniq.Add(i);\n           \
    \ }\n        }\n        uniq.Sort();\n        return uniq;", "        // Sort\
    \ both lists.\n        l1.Sort();\n        l2.Sort();\n        // Loop over both\
    \ lists:\n        int i = 0;\n        int j = 0;\n        List<long> out_ = new\
    \ List<long>();\n        while ((i < l1.Count) && (j < l2.Count)) {\n        \
    \    if (l1[i] < l2[j]) {\n                i += 1;\n            } else if (l1[i]\
    \ > l2[j]) {\n                j += 1;\n            } else {\n                out_.Add(l1[i]);\n\
    \                i += 1;\n                j += 1;\n            }\n        }\n\
    \        return out_;", "        List<long> res = l1.Distinct().ToList();\n  \
    \      res.Sort();\n        foreach (long a in l2.Distinct()) {\n            if\
    \ (res.BinarySearch(a) < 0) {\n                res.Add(a);\n            }\n  \
    \      }\n        res.Sort();\n        return res;", "        var res = new List<long>();\n\
    \        l1.Sort();\n        l2.Sort();\n        int i = 0;\n        int j = 0;\n\
    \        while (i < l1.Count && j < l2.Count) {\n            if (l1[i] == l2[j])\
    \ {\n                res.Add(l1[i]);\n                i++;\n                j++;\n\
    \            } else if (l1[i] < l2[j]) {\n                i++;\n            }\
    \ else {\n                j++;\n            }\n        }\n        return res;",
  "        HashSet<long> set1 = new HashSet<long>(l1);\n        HashSet<long> set2\
    \ = new HashSet<long>(l2);\n        set1.IntersectWith(set2);\n        List<long>\
    \ result = new List<long>(set1);\n        result.Sort();\n        return result;",
  "        l1.Sort();\n        l2.Sort();\n        List<long> res = new List<long>();\n\
    \        int i1 = 0;\n        int i2 = 0;\n        int n1 = l1.Count;\n      \
    \  int n2 = l2.Count;\n        while ((i1 < n1) && (i2 < n2)) {\n            if\
    \ (l1[i1] == l2[i2]) {\n                res.Add(l1[i1]);\n                i1++;\n\
    \                i2++;\n            } else if (l1[i1] < l2[i2]) {\n          \
    \      i1++;\n            } else {\n                i2++;\n            }\n   \
    \     }\n        return res;", "        l1.Sort();\n        l2.Sort();\n     \
    \   int i1 = 0;\n        int i2 = 0;\n        List<long> result = new List<long>();\n\
    \        while ((i1 < l1.Count) && (i2 < l2.Count)) {\n            long e1 = l1[i1];\n\
    \            long e2 = l2[i2];\n            if (e1 == e2) {\n                result.Add(e1);\n\
    \                i1++;\n                i2++;\n            } else if (e1 < e2)\
    \ {\n                i1++;\n            } else {\n                i2++;\n    \
    \        }\n        }\n        return result;"]
stop_tokens:
- "\n    }\n"
