name: HumanEval_90_next_smallest
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a list of integers.\n    // Write a function next_smallest()\
  \ that returns the 2nd smallest element of the list.\n    // Return null if there\
  \ is no such element.\n    // >>> NextSmallest((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)4L, (long)5L})))\n    // 2L\n    // >>> NextSmallest((new\
  \ List<long>(new long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L})))\n \
  \   // 2L\n    // >>> NextSmallest((new List<long>()))\n    // null\n    // >>>\
  \ NextSmallest((new List<long>(new long[]{(long)1L, (long)1L})))\n    // null\n\
  \    public static Nullable<long> NextSmallest(List<long> lst) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))).Equals(2L));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)5L, (long)1L, (long)4L,\
  \ (long)3L, (long)2L}))).Equals(2L));\n    Debug.Assert(NextSmallest((new List<long>())).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L}))).Equals(null));\n\
  \    Debug.Assert(NextSmallest((new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L, (long)0L}))).Equals(1L));\n    Debug.Assert(NextSmallest((new List<long>(new\
  \ long[]{(long)1L, (long)1L}))).Equals(null));\n    Debug.Assert(NextSmallest((new\
  \ List<long>(new long[]{(long)-35L, (long)34L, (long)12L, (long)-45L}))).Equals(-35L));\n\
  \    }\n\n}\n"
completions: ["        // Fill in the body of this function\n        return null;",
  '        return null;', "        long second = long.MaxValue;\n        long smallest\
    \ = long.MaxValue;\n        for (int i = 0; i < lst.Count; i++) {\n          \
    \  if (lst[i] < smallest) {\n                second = smallest;\n            \
    \    smallest = lst[i];\n            } else if (lst[i] < second) {\n         \
    \       second = lst[i];\n            }\n        }\n        if (second == long.MaxValue)\
    \ {\n            return null;\n        }\n        return second;", "        if\
    \ (lst.Count < 2) {\n            return null;\n        }\n        long nextSmallest\
    \ = long.MaxValue;\n        long min = long.MaxValue;\n        foreach (long i\
    \ in lst) {\n            if (i < min) {\n                nextSmallest = min;\n\
    \                min = i;\n            } else if (i < nextSmallest) {\n      \
    \          nextSmallest = i;\n            }\n        }\n        if (nextSmallest\
    \ == long.MaxValue) {\n            return null;\n        }\n        return nextSmallest;",
  "        long? nextSmallest = null;\n        lst.Sort();\n        for (int i = 0;\
    \ i < lst.Count; i++) {\n            if (lst[i] != lst[0]) {\n               \
    \ nextSmallest = lst[i];\n                break;\n            }\n        }\n \
    \       return nextSmallest;", "        if (lst.Count == 0) {\n            return\
    \ null;\n        } else if (lst.Count == 1) {\n            return null;\n    \
    \    } else {\n            long smallest = lst[0];\n            long n_smallest\
    \ = lst[1];\n            if (smallest > n_smallest) {\n                smallest\
    \ = n_smallest;\n                n_smallest = lst[0];\n            }\n       \
    \     for (int i = 2; i < lst.Count; i++) {\n                if (lst[i] < smallest)\
    \ {\n                    n_smallest = smallest;\n                    smallest\
    \ = lst[i];\n                } else if (lst[i] < n_smallest) {\n             \
    \       n_smallest = lst[i];\n                }\n            }\n            return\
    \ n_smallest;\n        }", "        if (lst.Count == 0) return null;\n       \
    \ long min = lst[0];\n        for (int i = 1; i < lst.Count; i++)\n          \
    \  if (lst[i] < min)\n                min = lst[i];\n        long nmin = long.MaxValue;\n\
    \        bool isValid = false;\n        for (int i = 0; i < lst.Count; i++)\n\
    \            if (lst[i] > min && lst[i] < nmin) {\n                nmin = lst[i];\n\
    \                isValid = true;\n            }\n        if (isValid) return nmin;\n\
    \        return null;", "        if (lst.Count <= 1) {\n            return null;\n\
    \        }\n        long min1 = lst[0];\n        long min2 = lst[1];\n       \
    \ if (min1 < min2) {\n            min2 = min1;\n            min1 = lst[1];\n \
    \       }\n        for (int i = 2; i < lst.Count; i++) {\n            long x =\
    \ lst[i];\n            if (x < min1) {\n                min2 = min1;\n       \
    \         min1 = x;\n            } else if (x < min2) {\n                min2\
    \ = x;\n            }\n        }\n        return min2;", "        // We can implement\
    \ a search algorithm that performs worst case \n        // O(n + 1) comparisons,\
    \ and O(1) swaps.\n        long s1 = long.MaxValue;\n        long s2 = long.MaxValue;\n\
    \        foreach (long l in lst) {\n            if (l < s1) {\n              \
    \  s2 = s1;\n                s1 = l;\n            } else if (l < s2) {\n     \
    \           s2 = l;\n            }\n        }\n        if (s2 == long.MaxValue)\
    \ {\n            return null;\n        }\n        return s2;", "        lst.Sort();\n\
    \        Nullable<long> previous = null;\n        long current = 0;\n        foreach\
    \ (long element in lst) {\n            if (previous == null) {\n             \
    \   previous = element;\n            } else {\n                current = element;\n\
    \                if (current != previous) {\n                    return current;\n\
    \                }\n                previous = current;\n            }\n     \
    \   }\n        return null;", "        var s = lst.OrderBy(x => x).Distinct().Skip(1).FirstOrDefault();\n\
    \        return s == 0 ? (Nullable<long>)null : s;", "        // Use double-buffering\
    \ to avoid allocating new lists with each iteration.\n        List<long> s0 =\
    \ new List<long>();\n        List<long> s1 = new List<long>();\n        List<long>\
    \ t;\n        foreach (long x in lst) {\n            if (s0.Count == 0 || x <\
    \ s0[0]) {\n                s0.Clear();\n                s0.Add(x);\n        \
    \    } else if (x == s0[0]) {\n                s0.Add(x);\n            } else\
    \ if (s1.Count == 0 || x < s1[0]) {\n                s1.Clear();\n           \
    \     s1.Add(x);\n            } else if (x == s1[0]) {\n                s1.Add(x);\n\
    \            }\n        }\n        if (s1.Count > 0) {\n            return s1[0];\n\
    \        } else {\n            return null;\n        }", "        // Your code\
    \ here!\n        if (lst.Count < 2)\n            return null;\n        long min1\
    \ = long.MaxValue;\n        long min2 = long.MaxValue;\n        foreach (long\
    \ i in lst) {\n            if (i < min1) {\n                min2 = min1;\n   \
    \             min1 = i;\n            } else if (i < min2) {\n                min2\
    \ = i;\n            }\n        }\n        if (min2 == long.MaxValue)\n       \
    \     return null;\n        return min2;", "        if (lst.Count < 2) {\n   \
    \         return null;\n        }\n        var min = lst[0];\n        var next\
    \ = lst[1];\n        if (next < min) {\n            min = next;\n            next\
    \ = lst[0];\n        }\n        for (int i = 2; i < lst.Count; i++) {\n      \
    \      var n = lst[i];\n            if (n < min) {\n                next = min;\n\
    \                min = n;\n            } else if (n < next) {\n              \
    \  next = n;\n            }\n        }\n        return next;", "        Nullable<long>\
    \ nextSmallest = null;\n        // your code here\n        return nextSmallest;",
  "        if (lst.Count == 0) {\n            return null;\n        }\n        if\
    \ (lst.Count == 1) {\n            return null;\n        }\n        if (lst.Count\
    \ == 2) {\n            if (lst[0] != lst[1]) {\n                return lst[1];\n\
    \            }\n            return null;\n        }\n        long min = lst[0];\n\
    \        long max = lst[0];\n        int i = 0;\n        while (i < lst.Count)\
    \ {\n            if (lst[i] < min) {\n                min = lst[i];\n        \
    \    }\n            if (lst[i] > max) {\n                max = lst[i];\n     \
    \       }\n            i = i + 1;\n        }\n        long next = max;\n     \
    \   i = 0;\n        while (i < lst.Count) {\n            if (lst[i] > min && lst[i]\
    \ < next) {\n                next = lst[i];\n            }\n            i = i\
    \ + 1;\n        }\n        if (next == max) {\n            return null;\n    \
    \    }\n        return next;", "        // Insert your code here.\n        return\
    \ null;", '        throw new NotImplementedException();', "        // Your code\
    \ goes here\n        var smallest = long.MaxValue;\n        var nextSmallest =\
    \ long.MaxValue;\n        foreach (var n in lst) {\n            if (n < smallest)\
    \ {\n                nextSmallest = smallest;\n                smallest = n;\n\
    \            } else if (n < nextSmallest) {\n                nextSmallest = n;\n\
    \            }\n        }\n        if (nextSmallest == long.MaxValue) {\n    \
    \        return null;\n        }\n        return nextSmallest;", "        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n        var sorted = lst.OrderBy((long\
    \ _p0) => _p0).ToList();\n        var cur_elm = sorted[0];\n        for (var i\
    \ = 1; i < sorted.Count; i++) {\n            if (sorted[i] > cur_elm) {\n    \
    \            return sorted[i];\n            }\n            cur_elm = sorted[i];\n\
    \        }\n        return null;", "        // use a dictionary to keep track\
    \ of all counts for each value\n        Dictionary<long, long> allCounts = new\
    \ Dictionary<long, long>();\n        long minVal = long.MaxValue;\n        long\
    \ min2Val = long.MaxValue;\n        long minCount = long.MaxValue;\n        long\
    \ min2Count = long.MaxValue;\n        // iterate through list\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            long val = lst[i];\n            //\
    \ if value is smaller than current minimum,\n            //    make it the new\
    \ minimum\n            if (val < minVal) {\n                min2Val = minVal;\n\
    \                min2Count = minCount;\n                minVal = val;\n      \
    \          minCount = 1;\n            }\n            // if value is smaller than\
    \ current 2nd minimum,\n            //    make it the new 2nd minimum\n      \
    \      else if (val < min2Val) {\n                min2Val = val;\n           \
    \     min2Count = 1;\n            }\n            // if value is equal to current\
    \ minimum,\n            //    increase minimum count\n            else if (val\
    \ == minVal) {\n                minCount++;\n            }\n            // if\
    \ value is equal to current 2nd minimum,\n            //    increase 2nd minimum\
    \ count\n            else if (val == min2Val) {\n                min2Count++;\n\
    \            }\n            // for bookkeeping, add one to value's count\n   \
    \         //    if value not in dictionary, insert\n            if (!allCounts.ContainsKey(val))\
    \ {\n                allCounts.Add(val, 1);\n            }\n            //   \
    \ if value in dictionary, increment\n            else {\n                allCounts[val]++;\n\
    \            }\n        }\n        // if there's only one unique value, return\
    \ null\n        if (allCounts.Count == 1) {\n            return null;\n      \
    \  }\n        // there's only one minimum\n        else if (minCount == 1) {\n\
    \            // and no 2nd minimums\n            if (min2Count == long.MaxValue)\
    \ {\n                return null;\n            }\n            // or a bunch of\
    \ 2nd minimums\n            else {\n                return min2Val;\n        \
    \    }\n        }", "        long min = long.MaxValue;\n        long second =\
    \ long.MaxValue;\n        for (int i = 0; i < lst.Count; i++) {\n            long\
    \ val = lst[i];\n            if (val < min) {\n                second = min;\n\
    \                min = val;\n            } else if (val < second) {\n        \
    \        second = val;\n            }\n        }\n        if (second == long.MaxValue)\
    \ {\n            return null;\n        }\n        return second;", "        //\
    \ YOUR CODE HERE\n        return null;", "        // Your code here\n        return\
    \ null;", "        // Your code goes here.\n        return null;", "        if\
    \ (lst.Count == 0) {\n            return null;\n        } else if (lst.Count ==\
    \ 1) {\n            return null;\n        } else {\n            long minValue\
    \ = long.MaxValue;\n            long secondMinValue = long.MaxValue;\n       \
    \     for (int i = 0; i < lst.Count; i++) {\n                if (lst[i] < minValue)\
    \ {\n                    secondMinValue = minValue;\n                    minValue\
    \ = lst[i];\n                } else if (lst[i] < secondMinValue && lst[i] != minValue)\
    \ {\n                    secondMinValue = lst[i];\n                }\n       \
    \     }\n            if (secondMinValue == long.MaxValue) {\n                return\
    \ null;\n            } else {\n                return secondMinValue;\n      \
    \      }\n        }", "        if (lst.Count <= 2)\n            return null;\n\
    \        return lst.OrderBy(x => x).ToList()[1];", "        long? nextSmallest\
    \ = null;\n        if (lst.Count > 1) {\n            lst.Sort();\n           \
    \ long smallest = lst[0];\n            int i = 1;\n            while (nextSmallest\
    \ == null && i < lst.Count) {\n                if (lst[i] != smallest) {\n   \
    \                 nextSmallest = lst[i];\n                }\n                i++;\n\
    \            }\n        }\n        return nextSmallest;", "        long? nextSmallest=null;\n\
    \        for (int i=0; i<lst.Count; i++) {\n            bool found=false;\n  \
    \          for (int j=0; j<lst.Count; j++) {\n                if (i==j) continue;\n\
    \                if (lst[i]<lst[j]) {\n                    found=true;\n     \
    \               break;\n                }\n            }\n            if (!found)\
    \ {\n                nextSmallest=lst[i];\n                break;\n          \
    \  }\n        }\n        return nextSmallest;", "        // BEGIN SOLUTION\n \
    \       long small = lst[0];\n        long next = long.MaxValue;\n        for\
    \ (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < small) {\n     \
    \           next = small;\n                small = lst[i];\n            } else\
    \ if (lst[i] < next) {\n                next = lst[i];\n            }\n      \
    \  }\n        if (next == long.MaxValue) {\n            return null;\n       \
    \ }\n        return next;\n        // END SOLUTION", "        if (lst.Count <\
    \ 2) {\n            return null;\n        }\n        else {\n            lst.Sort();\n\
    \            return lst[1];\n        }", "        if (lst.Count == 0) {\n    \
    \        return null;\n        } else if (lst.Count == 1) {\n            return\
    \ null;\n        } else {\n            long smallest = long.MaxValue;\n      \
    \      long small = long.MaxValue;\n            foreach (long item in lst) {\n\
    \                if (item < smallest) {\n                    small = smallest;\n\
    \                    smallest = item;\n                } else if (item < small)\
    \ {\n                    small = item;\n                }\n            }\n   \
    \         if (small == long.MaxValue) {\n                return null;\n      \
    \      } else {\n                return small;\n            }\n        }", " \
    \       long? ans = null;\n        long? min = null;\n        foreach (long x\
    \ in lst) {\n            if (min == null || x < min) {\n                min =\
    \ x;\n            }\n            else if (ans == null || x < ans) {\n        \
    \        ans = x;\n            }\n        }\n        return ans;", "        if\
    \ (lst.Count < 2) return null;\n        long min = long.MaxValue;\n        long\
    \ next = long.MaxValue;\n        foreach (long val in lst) {\n            if (val\
    \ < min) {\n                next = min;\n                min = val;\n        \
    \    } else if (val > min && val < next) {\n                next = val;\n    \
    \        }\n        }\n        if (next == long.MaxValue) return null;\n     \
    \   return next;", "        long? nextSmallest = null;\n        long? min = null;\n\
    \        foreach (long item in lst) {\n            if (min == null || item < min)\
    \ {\n                nextSmallest = min;\n                min = item;\n      \
    \      } else if (nextSmallest == null || item < nextSmallest) {\n           \
    \     nextSmallest = item;\n            }\n        }\n        return nextSmallest;",
  "        long? result = null;\n        long smallest = lst[0];\n        foreach\
    \ (long l in lst) {\n            if (l < smallest) {\n                smallest\
    \ = l;\n            }\n        }\n        foreach (long l in lst) {\n        \
    \    if (l != smallest) {\n                if (result == null) {\n           \
    \         result = l;\n                } else if (l < result) {\n            \
    \        result = l;\n                }\n            }\n        }\n        return\
    \ result;", "        long smallest = lst[0];\n        long secondSmallest = -1;\n\
    \        int j = 0;\n        while (secondSmallest == -1 && j < lst.Count) {\n\
    \            if (lst[j] > smallest) {\n                secondSmallest = lst[j];\n\
    \            }\n            j++;\n        }\n        while (j < lst.Count) {\n\
    \            if (lst[j] < secondSmallest && lst[j] > smallest) {\n           \
    \     secondSmallest = lst[j];\n            }\n            j++;\n        }\n \
    \       if (secondSmallest == -1) {\n            return null;\n        }\n   \
    \     return secondSmallest;", "        if (lst.Count == 0) return null;\n   \
    \     var r = lst.OrderBy(x => x).ToList();\n        if (r.Count < 2) return null;\n\
    \        return r[1];", '        return lst.Count < 2 ? null : lst.Distinct().OrderBy(x
    => x).ElementAt(1);', "        Nullable<long> smallest = null;\n        Nullable<long>\
    \ next_smallest = null;\n        foreach (long i in lst) {\n            if (!smallest.HasValue\
    \ || i < smallest.Value) {\n                next_smallest = smallest;\n      \
    \          smallest = i;\n            } else if (!next_smallest.HasValue || i\
    \ < next_smallest.Value) {\n                next_smallest = i;\n            }\n\
    \        }\n        return next_smallest;", '        return lst.Distinct().OrderBy(e
    => e).Skip(1).FirstOrDefault();', "        // We could use the .Min() function\
    \ to find the smallest element,\n        // and then iterate over the array to\
    \ find the next smallest element.\n        // That would work. But, both of those\
    \ operations would be O(n) operations,\n        // which is slower than we can\
    \ do it.\n        // \n        // Instead, we use the fact that the only way to\
    \ find the 2nd smallest element\n        // is to have at least 2 elements. So,\
    \ we can keep track of the smallest 2 elements\n        // that we have seen,\
    \ and at the end, return the 2nd one.\n        // This is an O(n) algorithm in\
    \ the worst case, but it is O(1) in the best case,\n        // when the first\
    \ two elements are the smallest and 2nd smallest elements.\n        if (lst.Count\
    \ < 2) return null;\n        var first = lst[0];\n        var second = lst[1];\n\
    \        if (first > second) {\n            first = lst[1];\n            second\
    \ = lst[0];\n        }\n        for (int i = 2; i < lst.Count; i++) {\n      \
    \      if (lst[i] < first) {\n                second = first;\n              \
    \  first = lst[i];\n            } else if (lst[i] < second) {\n              \
    \  second = lst[i];\n            }\n        }\n        return second;", "    \
    \    // Your code here\n        return null;", "        long? maxValue = null;\n\
    \        long? minValue = null;\n        foreach (long item in lst) {\n      \
    \      if (maxValue == null || maxValue.Value < item) {\n                maxValue\
    \ = item;\n            }\n            if (minValue == null || minValue.Value >\
    \ item) {\n                minValue = item;\n            }\n        }\n      \
    \  if (maxValue == minValue) {\n            return null;\n        }\n        long\
    \ max = minValue.Value;\n        long min = maxValue.Value;\n        long item2\
    \ = min;\n        foreach (long item in lst) {\n            if (item < max &&\
    \ item > item2) {\n                item2 = item;\n            }\n        }\n \
    \       return item2;", "        long smallest = long.MaxValue;\n        long\
    \ secondSmallest = long.MaxValue;\n        foreach (long i in lst) {\n       \
    \     if (i < smallest) {\n                secondSmallest = smallest;\n      \
    \          smallest = i;\n            } else if (i < secondSmallest && i != smallest)\
    \ {\n                secondSmallest = i;\n            }\n        }\n        if\
    \ (secondSmallest == long.MaxValue)\n            return null;\n        return\
    \ secondSmallest;", "        // There is only one solution that passes on the\
    \ first try.\n        // Solution 1: A naive approach is to sort the list and\
    \ return lst[1].\n        // lst.Sort();\n        // return lst.Count >= 2 ? lst[1]\
    \ : null;\n        // Solution 2: Sort as we go.\n        // Keep two lists: sorted\
    \ and unsorted.\n        // Add elements to the sorted list in the right position\
    \ to maintain sort.\n        // When we come across an element smaller than the\
    \ first in the sorted list,\n        // we move the first element in the sorted\
    \ list to the unsorted list and\n        // add the new element to the sorted\
    \ list.\n        List<long> sorted = new List<long>();\n        List<long> unsorted\
    \ = new List<long>();\n        for (int i = 0; i < lst.Count; i++) {\n       \
    \     bool foundPos = false;\n            for (int j = 0; j < sorted.Count; j++)\
    \ {\n                if (lst[i] < sorted[j]) {\n                    unsorted.Add(sorted[j]);\n\
    \                    sorted[j] = lst[i];\n                    foundPos = true;\n\
    \                    break;\n                }\n            }\n            if\
    \ (!foundPos) {\n                sorted.Add(lst[i]);\n            }\n        }\n\
    \        return sorted.Count >= 2 ? sorted[1] : null;", "        // Implement\
    \ me\n        return null;", "        long? min1 = null;\n        long? min2 =\
    \ null;\n        foreach (long x in lst) {\n            if (min1 == null || x\
    \ < min1) {\n                min2 = min1;\n                min1 = x;\n       \
    \     } else if (min2 == null || x < min2) {\n                min2 = x;\n    \
    \        }\n        }\n        return min2;", "        // Your code goes here.\n\
    \        return null;", "        // Min and second min, initialize to large values\n\
    \        long min = long.MaxValue;\n        long min2 = long.MaxValue;\n     \
    \   foreach (long elem in lst) {\n            if (elem < min) {\n            \
    \    min2 = min;\n                min = elem;\n            } else if (elem < min2)\
    \ {\n                min2 = elem;\n            }\n        }\n        if (min2\
    \ == long.MaxValue) {\n            return null;\n        } else {\n          \
    \  return min2;\n        }", "        // Replace the following line with your\
    \ solution.\n        if (lst.Count <= 1) {\n            return null;\n       \
    \ }\n        long min = lst[0];\n        long secondMin = lst[1];\n        if\
    \ (secondMin < min) {\n            min = secondMin;\n            secondMin = lst[0];\n\
    \        }\n        for (int i = 2; i < lst.Count; i++) {\n            if (lst[i]\
    \ < min) {\n                secondMin = min;\n                min = lst[i];\n\
    \            } else if (lst[i] < secondMin) {\n                secondMin = lst[i];\n\
    \            }\n        }\n        if (min == secondMin) {\n            return\
    \ null;\n        }\n        return secondMin;", "        // TODO: Fill me in.\n\
    \        return null;", '        return null;', '        throw new NotImplementedException();',
  "        if (lst.Count <= 1) {\n            return null;\n        }\n        long\
    \ min = lst[0];\n        long nextSmallest = lst[0];\n        for (int i = 1;\
    \ i < lst.Count; i++) {\n            long val = lst[i];\n            if (val <\
    \ min) {\n                nextSmallest = min;\n                min = val;\n  \
    \          } else if (val < nextSmallest) {\n                nextSmallest = val;\n\
    \            }\n        }\n        if (nextSmallest == min) {\n            return\
    \ null;\n        }\n        return nextSmallest;", "        if (lst.Count < 2)\
    \ return null;\n        long firstMin = long.MaxValue;\n        long secondMin\
    \ = long.MaxValue;\n        foreach (long x in lst) {\n            if (x < firstMin)\
    \ {\n                secondMin = firstMin;\n                firstMin = x;\n  \
    \          } else if (x < secondMin && x != firstMin) {\n                secondMin\
    \ = x;\n            }\n        }\n        if (secondMin == long.MaxValue) return\
    \ null;\n        return secondMin;", "        var arr = lst.ToArray();\n     \
    \   if (arr.Length < 2) return null;\n        Array.Sort(arr);\n        for (int\
    \ i = 1; i < arr.Length; i++) {\n            if (arr[i] != arr[i - 1]) return\
    \ arr[i];\n        }\n        return null;", "        if (lst.Count < 2) {\n \
    \           return null;\n        }\n        long min1 = lst[0];\n        long\
    \ min2 = lst[1];\n        for (int i = 2; i < lst.Count; i++) {\n            if\
    \ (lst[i] < min1) {\n                min2 = min1;\n                min1 = lst[i];\n\
    \            } else if (lst[i] > min1 && lst[i] < min2) {\n                min2\
    \ = lst[i];\n            }\n        }\n        if (min1 == min2) {\n         \
    \   return null;\n        }\n        return min2;", "        long smallest = lst[0];\n\
    \        long nextSmallest = lst[0];\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            if (lst[i] < smallest) {\n                nextSmallest = smallest;\n\
    \                smallest = lst[i];\n            } else if (lst[i] < nextSmallest)\
    \ {\n                nextSmallest = lst[i];\n            }\n        }\n      \
    \  if (nextSmallest == smallest) {\n            return null;\n        }\n    \
    \    return nextSmallest;", "        if (lst.Count() <= 1) {\n            return\
    \ null;\n        }\n        lst.Sort();\n        long smallest = lst[0];\n   \
    \     for (int i = 1; i < lst.Count(); i++) {\n            if (lst[i] != smallest)\
    \ {\n                return lst[i];\n            }\n        }\n        return\
    \ null;", "        Nullable<long> curr = new Nullable<long>();\n        foreach\
    \ (long i in lst) {\n            if (!curr.HasValue) {\n                curr =\
    \ i;\n            } else if (i < curr.Value) {\n                return curr.Value;\n\
    \            } else {\n                curr = i;\n            }\n        }\n \
    \       return null;", "        long smallest = lst[0];\n        long next_smallest\
    \ = long.MaxValue;\n        for (int i = 1; i < lst.Count; i++) {\n          \
    \  if (lst[i] < smallest) {\n                next_smallest = smallest;\n     \
    \           smallest = lst[i];\n            } else if (lst[i] < next_smallest)\
    \ {\n                next_smallest = lst[i];\n            }\n        }\n     \
    \   if (next_smallest == long.MaxValue) {\n            return null;\n        }\n\
    \        return next_smallest;", "        if (lst.Count == 0) return null;\n \
    \       var lst2 = lst.OrderBy((long x) => x).ToList();\n        if (lst2[0] ==\
    \ lst2[1]) return null;\n        return lst2[1];", "        // your code here\n\
    \        if (lst.Count < 2) {\n            return null;\n        }\n        int\
    \ pos = 1;\n        long current = lst[0];\n        long second = lst[1];\n  \
    \      while (pos < lst.Count) {\n            long elem = lst[pos];\n        \
    \    if (elem < current) {\n                if (elem < second) {\n           \
    \         second = elem;\n                }\n                current = elem;\n\
    \            } else if (elem < second) {\n                second = elem;\n   \
    \         }\n            pos++;\n        }\n        if (second == lst[0]) {\n\
    \            return null;\n        }\n        return second;", "        // Solution:\n\
    \        // there are 2 ways to solve this problem\n        // 1. sort the list\
    \ and return the 2nd smallest element\n        // 2. walk through the list once,\
    \ maintaning the smallest element, and the 2nd smallest element, if there is one\n\
    \        //    if we find a smaller element than the current smallest element,\
    \ we set that to be the 2nd smallest element, and the current smallest element\
    \ to be the new smallest element\n        //    else if we find an element that\
    \ is larger than the smallest element but smaller than the 2nd smallest element,\
    \ we set the 2nd smallest element to be that\n        //    else we keep walking\
    \ through the list\n        //\n        // since we are trying to optimize for\
    \ readability, i will use the first solution\n        // this will cost O(n log\
    \ n) time, but in the worst case only return the 2nd element from the list\n \
    \       //\n        // if the list has less than 2 elements, return null\n   \
    \     if (lst.Count < 2) {\n            return null;\n        }\n        // sort\
    \ the list\n        lst.Sort();\n        // return the 2nd element\n        return\
    \ lst[1];", '        throw new NotImplementedException();', "        // Write\
    \ your code here.\n        return null;", "        if (lst.Count < 2) return null;\n\
    \        long min = long.MaxValue;\n        long min2 = long.MaxValue;\n     \
    \   for (int i = 0; i < lst.Count; i++) {\n            long value = lst[i];\n\
    \            if (value < min) {\n                min2 = min;\n               \
    \ min = value;\n            } else if (value < min2) {\n                min2 =\
    \ value;\n            }\n        }\n        if (min2 == long.MaxValue) return\
    \ null;\n        return min2;", "        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n        if (lst.Count == 1) {\n            return null;\n\
    \        }\n        if (lst.Count == 2) {\n            if (lst[0] == lst[1]) {\n\
    \                return null;\n            }\n        }\n        long[] temp_lst\
    \ = new long[lst.Count];\n        lst.CopyTo(temp_lst);\n        Array.Sort(temp_lst);\n\
    \        return temp_lst[1];", "        if (lst.Count < 2) return null;\n    \
    \    // TODO: Write your code here.\n        return null;", "        // Your code\
    \ goes here\n        throw new NotImplementedException();", "        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n        long max = lst[0];\n \
    \       long next = long.MaxValue;\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            if (lst[i] < max) {\n                max = lst[i];\n        \
    \    }\n            if (lst[i] < next && lst[i] > max) {\n                next\
    \ = lst[i];\n            }\n        }\n        if (next == long.MaxValue) {\n\
    \            return null;\n        }\n        return next;", "        // Your\
    \ code goes here.\n        return null;", "        Nullable<long> result = null;\n\
    \        long min = long.MaxValue;\n        foreach (long num in lst) {\n    \
    \        if (num < min) {\n                min = num;\n            }\n       \
    \ }\n        foreach (long num in lst) {\n            if (num > min && num < result)\
    \ {\n                result = num;\n            }\n        }\n        return result;",
  "        var lst_ = lst.OrderBy(e => e).ToList();\n        if (lst_.Count < 2) {\n\
    \            return null;\n        }\n        var res = lst_[1];\n        if (res\
    \ == lst_[0]) {\n            return null;\n        }\n        return res;", " \
    \       // Your code here...\n        lst.Sort();\n        var val=lst[0];\n \
    \       foreach(var n in lst){\n            if(n>val){\n                return\
    \ n;\n            }\n        }\n        return null;", "        if (lst.Count\
    \ < 2) {\n            return null;\n        }\n        long min = lst[0];\n  \
    \      long small = Int64.MaxValue;\n        foreach (long elem in lst) {\n  \
    \          if (elem < min) {\n                small = min;\n                min\
    \ = elem;\n            } else if (elem < small) {\n                small = elem;\n\
    \            }\n        }\n        if (small == Int64.MaxValue) {\n          \
    \  return null;\n        }\n        return small;", "        if (lst.Count < 2)\
    \ {\n            return null;\n        }\n        lst.Sort();\n        if (lst[0]\
    \ == lst[1]) {\n            return null;\n        }\n        return lst[1];",
  "        if (lst.Count < 2) {\n            return null;\n        }\n        Nullable<long>\
    \ result = null;\n        long currentMin = long.MaxValue;\n        long secondMin\
    \ = long.MaxValue;\n        foreach (long curr in lst) {\n            if (curr\
    \ < currentMin) {\n                secondMin = currentMin;\n                currentMin\
    \ = curr;\n            } else if (curr < secondMin) {\n                secondMin\
    \ = curr;\n            }\n        }\n        if (secondMin < long.MaxValue) {\n\
    \            result = secondMin;\n        }\n        return result;", "      \
    \  long Min = 0;\n        long Min2 = 0;\n        if (lst.Count == 0)\n      \
    \      return null;\n        if (lst.Count == 1)\n            return null;\n \
    \       if (lst.Count == 2)\n            if (lst[0] == lst[1])\n             \
    \   return null;\n            else if (lst[0] < lst[1])\n                return\
    \ lst[0];\n            else\n                return lst[1];\n        Min = lst[0];\n\
    \        for (int i = 1; i < lst.Count; i++)\n            if (lst[i] < Min)\n\
    \                Min = lst[i];\n        for (int i = 0; i < lst.Count; i++)\n\
    \            if (lst[i] > Min)\n                if (Min2 == 0)\n             \
    \       Min2 = lst[i];\n                else if (lst[i] < Min2)\n            \
    \        Min2 = lst[i];\n        return Min2;", "        lst.Sort();\n       \
    \ var last = lst[0];\n        foreach (var x in lst) {\n            if (x != last)\
    \ {\n                return x;\n            }\n            last = x;\n       \
    \ }\n        return null;", "        if (lst.Count < 2) {\n            return\
    \ null;\n        }\n        long min = long.MaxValue;\n        long min2 = long.MaxValue;\n\
    \        foreach (long n in lst) {\n            if (n < min) {\n             \
    \   min2 = min;\n                min = n;\n            } else if (n < min2) {\n\
    \                min2 = n;\n            }\n        }\n        if (min2 == long.MaxValue)\
    \ {\n            return null;\n        }\n        return min2;", '        return
    null;', "        if (lst.Count <= 1) return null;\n        long smallest = long.MaxValue;\n\
    \        long nextSmallest = long.MaxValue;\n        foreach (long element in\
    \ lst) {\n            if (element < smallest) {\n                nextSmallest\
    \ = smallest;\n                smallest = element;\n            } else if (element\
    \ < nextSmallest) {\n                nextSmallest = element;\n            }\n\
    \        }\n        if (nextSmallest == long.MaxValue) {\n            return null;\n\
    \        } else {\n            return nextSmallest;\n        }", '        throw
    new NotImplementedException();', "        if (lst.Count < 2) {\n            return\
    \ null;\n        }\n        long first = lst[0];\n        long second = lst[1];\n\
    \        if (first < second) {\n            first = second;\n            second\
    \ = lst[0];\n        }\n        for (int i = 2; i < lst.Count; i++) {\n      \
    \      if (lst[i] < first) {\n                second = first;\n              \
    \  first = lst[i];\n            } else if (lst[i] < second) {\n              \
    \  second = lst[i];\n            }\n        }\n        return second;", "    \
    \    long curr = long.MaxValue;\n        long nxt = long.MaxValue;\n        bool\
    \ isSecondSmallestFound = false;\n        foreach (long l in lst) {\n        \
    \    if (l < curr) {\n                nxt = curr;\n                curr = l;\n\
    \            } else if (l < nxt) {\n                nxt = l;\n               \
    \ isSecondSmallestFound = true;\n            }\n        }\n        if (isSecondSmallestFound)\n\
    \            return nxt;\n        else\n            return null;", "        if\
    \ (lst.Count < 2) {\n            return null;\n        }\n        // bubble sort\
    \ the list\n        for (int i = 0; i < lst.Count; i++) {\n            for (int\
    \ j = i; j < lst.Count; j++) {\n                if (lst[i] > lst[j]) {\n     \
    \               long t = lst[i];\n                    lst[i] = lst[j];\n     \
    \               lst[j] = t;\n                }\n            }\n        }\n   \
    \     // linearly scan the list for second smallest element\n        long last\
    \ = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i]\
    \ != last) {\n                return lst[i];\n            }\n        }\n     \
    \   return null;", "        long min = lst[0];\n        long second = long.MaxValue;\n\
    \        foreach (long num in lst) {\n            if (num < min) {\n         \
    \       second = min;\n                min = num;\n            } else if (num\
    \ < second && num != min) {\n                second = num;\n            }\n  \
    \      }\n        if (second == long.MaxValue) {\n            return null;\n \
    \       }\n        return second;", '        throw new NotImplementedException();',
  "        // 1. Do the easy check first\n        if (lst.Count == 0) {\n        \
    \    return null;\n        }\n        if (lst.Count == 1) {\n            return\
    \ null;\n        }\n        // 2. Sort the list\n        lst.Sort();\n       \
    \ // 3. Check if there is a 2nd smallest element\n        if (lst[0] == lst[1])\
    \ {\n            return null;\n        }\n        // 4. Return the 2nd smallest\
    \ element\n        return lst[1];", "        HashSet<long> seen = new HashSet<long>();\n\
    \        long min = lst[0];\n        long secondMin = long.MaxValue;\n       \
    \ for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] < min) {\n   \
    \             secondMin = min;\n                min = lst[i];\n            } else\
    \ if (lst[i] < secondMin && lst[i] != min) {\n                secondMin = lst[i];\n\
    \            }\n        }\n        if (secondMin == long.MaxValue) {\n       \
    \     return null;\n        }\n        return secondMin;", "        if (lst.Count\
    \ <= 1) {\n            return null;\n        }\n        var min = long.MaxValue;\n\
    \        long min2 = long.MaxValue;\n        for (int i = 0; i < lst.Count; i++)\
    \ {\n            var item = lst[i];\n            if (item < min) {\n         \
    \       min2 = min;\n                min = item;\n            } else if (item\
    \ < min2) {\n                min2 = item;\n            }\n        }\n        if\
    \ (min2 == long.MaxValue) {\n            return null;\n        }\n        return\
    \ min2;", "        long sm = lst[0];\n        long nsm = lst[0];\n        for\
    \ (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < sm) {\n        \
    \        nsm = sm;\n                sm = lst[i];\n            } else if (lst[i]\
    \ < nsm) {\n                nsm = lst[i];\n            }\n        }\n        if\
    \ (sm == nsm)\n            return null;\n        return nsm;", "        if (lst.Count()\
    \ < 2) {\n            return null;\n        }\n        var min1 = (long)long.MaxValue;\n\
    \        var min2 = (long)long.MaxValue;\n        foreach (var i in lst) {\n \
    \           if (i < min1) {\n                min2 = min1;\n                min1\
    \ = i;\n            } else if (i < min2) {\n                min2 = i;\n      \
    \      }\n        }\n        if (min2 == long.MaxValue) {\n            return\
    \ null;\n        }\n        return min2;", "        if (lst.Count < 2) {\n   \
    \         return null;\n        }\n        HashSet<long> s = new HashSet<long>();\n\
    \        long minimum = lst[0];\n        long second_minimum = lst[1];\n     \
    \   for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < minimum) {\n\
    \                second_minimum = minimum;\n                minimum = lst[i];\n\
    \            } else if (lst[i] < second_minimum) {\n                second_minimum\
    \ = lst[i];\n            }\n        }\n        if (second_minimum == minimum)\
    \ {\n            return null;\n        }\n        return second_minimum;", " \
    \       // Your code here\n        return null;", "        // Initialize min to\
    \ minimum, min2 to null.\n        Nullable<long> min = long.MinValue;\n      \
    \  Nullable<long> min2 = null;\n        // For each element in lst,\n        foreach\
    \ (long elem in lst) {\n            // If elem < min,\n            if (elem <\
    \ min) {\n                // Set min2 to min, min to elem.\n                min2\
    \ = min;\n                min = elem;\n            }\n            // Else if min2\
    \ is null, or elem < min2,\n            else if (min2 == null || elem < min2)\
    \ {\n                // Set min2 to elem.\n                min2 = elem;\n    \
    \        }\n        }\n        // Return min2.\n        return min2;", "     \
    \   long? result = null;\n        long? smallest = null;\n        long? second_smallest\
    \ = null;\n        for (long i = 0; i < lst.Count; i++) {\n            if (smallest\
    \ == null) {\n                smallest = lst[(int)i];\n            } else if (lst[(int)i]\
    \ < smallest) {\n                second_smallest = smallest;\n               \
    \ smallest = lst[(int)i];\n            } else if (second_smallest == null || lst[(int)i]\
    \ < second_smallest) {\n                second_smallest = lst[(int)i];\n     \
    \       }\n        }\n        result = second_smallest;\n        return result;",
  "        long min1 = long.MaxValue;\n        long min2 = long.MaxValue;\n      \
    \  foreach (long x in lst) {\n            if (x <= min1) {\n                min2\
    \ = min1;\n                min1 = x;\n            } else if (x < min2) {\n   \
    \             min2 = x;\n            }\n        }\n        if (min2 == long.MaxValue)\
    \ {\n            return null;\n        } else {\n            return min2;\n  \
    \      }", "        if (lst.Count == 0) {\n            return null;\n        }\n\
    \        lst.Sort();\n        long val = lst[0];\n        for (int i = 1; i <\
    \ lst.Count; i++) {\n            if (lst[i] > val) {\n                return lst[i];\n\
    \            }\n        }\n        return null;", "        if (lst.Count == 0)\
    \ return null;\n        long smallest = lst[0];\n        long second_smallest\
    \ = long.MaxValue;\n        foreach (long i in lst) {\n            if (i < smallest)\
    \ {\n                second_smallest = smallest;\n                smallest = i;\n\
    \            } else if (i < second_smallest) {\n                second_smallest\
    \ = i;\n            }\n        }\n        if (second_smallest == long.MaxValue)\
    \ return null;\n        return second_smallest;", "        // your code here\n\
    \        return null;", "        var r = lst.OrderBy(x => x).Skip(1).FirstOrDefault();\n\
    \        return r != 0 ? r : (Nullable<long>)null;", "        long min = lst[0];\n\
    \        long second = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n\
    \            if (lst[i] < min) {\n                second = min;\n            \
    \    min = lst[i];\n            } else if (lst[i] < second) {\n              \
    \  second = lst[i];\n            }\n        }\n        if (second == min) {\n\
    \            return null;\n        }\n        return second;", "        // FIXME:\
    \ implement\n        return null;", "        if (lst.Count < 2) {\n          \
    \  return null;\n        }\n        long smallest = long.MaxValue;\n        long\
    \ nextSmallest = long.MaxValue;\n        foreach (long x in lst) {\n         \
    \   if (x < smallest) {\n                nextSmallest = smallest;\n          \
    \      smallest = x;\n            } else if (x < nextSmallest) {\n           \
    \     nextSmallest = x;\n            }\n        }\n        if (nextSmallest ==\
    \ long.MaxValue) {\n            return null;\n        }\n        return nextSmallest;",
  "        // your code goes here\n        return null;", "        long[] ar = lst.ToArray();\n\
    \        if (ar.Length < 2) {\n            return null;\n        }\n        Array.Sort(ar);\n\
    \        for (int i = 1; i < ar.Length; i++) {\n            if (ar[i] != ar[0])\
    \ {\n                return ar[i];\n            }\n        }\n        return null;",
  "        if (lst.Count() == 0) {\n            return null;\n        }\n        long\
    \ smallest = lst[0];\n        long nextSmallest = lst[0];\n        foreach (long\
    \ elem in lst) {\n            if (elem < smallest) {\n                nextSmallest\
    \ = smallest;\n                smallest = elem;\n            } else if (elem <\
    \ nextSmallest) {\n                nextSmallest = elem;\n            }\n     \
    \   }\n        if (nextSmallest == smallest) {\n            return null;\n   \
    \     }\n        return nextSmallest;", '        throw new NotImplementedException();',
  "        long min = lst[0];\n        long second = 0;\n        for (int i = 1; i\
    \ < lst.Count; i++) {\n            if (lst[i] < min) {\n                second\
    \ = min;\n                min = lst[i];\n            } else if (lst[i] < second\
    \ || second == 0) {\n                second = lst[i];\n            }\n       \
    \ }\n        if (second == 0) return null;\n        return second;", "       \
    \ // *** YOUR CODE HERE ***\n        return null;", "        long min = lst[0];\n\
    \        long smallest = long.MaxValue;\n        bool flag = false;\n        foreach\
    \ (long item in lst) {\n            if (item < min) {\n                smallest\
    \ = min;\n                min = item;\n                flag = true;\n        \
    \    } else if (item < smallest && item != min) {\n                smallest =\
    \ item;\n                flag = true;\n            }\n        }\n        if (flag)\
    \ {\n            return smallest;\n        } else {\n            return null;\n\
    \        }", "        var ordered = lst.OrderBy(e => e).ToList();\n        if\
    \ (ordered.Count < 2) {\n            return null;\n        }\n        else {\n\
    \            return ordered[1];\n        }", '        throw new NotImplementedException();',
  "        long x = lst[0];\n        for (int i = 1; i < lst.Count; i++) {\n     \
    \       if (lst[i] == x) {\n                continue;\n            }\n       \
    \     if (lst[i] < x) {\n                x = lst[i];\n            }\n        }\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] == x) {\n\
    \                continue;\n            }\n            if (lst[i] < x) {\n   \
    \             return lst[i];\n            }\n        }\n        return null;",
  '        throw new NotImplementedException();', "        // Get the smallest and\
    \ second smallest\n        long? smallest = null;\n        long? secondSmallest\
    \ = null;\n        for (int i = 0; i < lst.Count; i++) {\n            if (smallest\
    \ == null || lst[i] < smallest) {\n                secondSmallest = smallest;\n\
    \                smallest = lst[i];\n            } else if (secondSmallest ==\
    \ null || lst[i] < secondSmallest) {\n                secondSmallest = lst[i];\n\
    \            }\n        }\n        return secondSmallest;", '        throw new
    NotImplementedException();', "        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n        if (lst.Count == 1) {\n            return null;\n\
    \        }\n        var result = long.MaxValue;\n        var first = lst[0];\n\
    \        for (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < first)\
    \ {\n                result = first;\n                first = lst[i];\n      \
    \      } else if (lst[i] < result) {\n                result = lst[i];\n     \
    \       }\n        }\n        if (result == long.MaxValue) {\n            return\
    \ null;\n        }\n        return result;", "        if (lst.Count == 0) return\
    \ null;\n        long min = lst[0];\n        long nextMin = lst[0];\n        foreach\
    \ (long i in lst) {\n            if (i < min) {\n                nextMin = min;\n\
    \                min = i;\n            } else if (i < nextMin) {\n           \
    \     nextMin = i;\n            }\n        }\n        if (nextMin == min) return\
    \ null;\n        return nextMin;", "        //return lst.Where(x => x != lst.Min()).Min();\n\
    \        return lst.Select(x => {\n            return new {\n                Elem\
    \ = x,\n                IsSmallest = x == lst.Min()\n            };\n        }).Where(x\
    \ => !x.IsSmallest).Min().Elem;", "        List<long> sorted_lst = new List<long>(lst);\n\
    \        sorted_lst.Sort();\n        if (sorted_lst.Count == 0) {\n          \
    \  return null;\n        }\n        long smallest = sorted_lst[0];\n        long\
    \ smaller_than_smallest = 0;\n        foreach (long elem in sorted_lst) {\n  \
    \          if (elem > smallest) {\n                smaller_than_smallest = elem;\n\
    \                break;\n            }\n        }\n        if (smaller_than_smallest\
    \ == 0) {\n            return null;\n        }\n        return smaller_than_smallest;",
  "        // YOUR CODE HERE\n        return null;", "        // see if there are\
    \ duplicates\n        HashSet<long> checkedNumbers = new HashSet<long>();\n  \
    \      for (int i = 0; i < lst.Count; i++) {\n            if (checkedNumbers.Contains(lst[i]))\
    \ {\n                return null;\n            }\n            checkedNumbers.Add(lst[i]);\n\
    \        }\n        long min = long.MaxValue;\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < min) {\n                min = lst[i];\n   \
    \         }\n        }\n        long min2 = long.MaxValue;\n        for (int i\
    \ = 0; i < lst.Count; i++) {\n            if (lst[i] > min && lst[i] < min2) {\n\
    \                min2 = lst[i];\n            }\n        }\n        if (min2 ==\
    \ long.MaxValue) {\n            return null;\n        }\n        return min2;",
  "        if (lst.Count < 2) {\n            return null;\n        }\n        long\
    \ i = (long)1L;\n        long m = (long)lst[(int)0L];\n        long n = (long)lst[(int)1L];\n\
    \        for (; i < (long)lst.Count; i++) {\n            long cur = (long)lst[(int)i];\n\
    \            if (cur < m) {\n                n = m;\n                m = cur;\n\
    \            }\n            else if (cur < n) {\n                n = cur;\n  \
    \          }\n        }\n        if (m == n) {\n            return null;\n   \
    \     }\n        return n;", "        long[] lstSorted = lst.OrderBy(x => x).ToArray();\n\
    \        for (int i = 0; i < lstSorted.Length - 1; i++) {\n            if (lstSorted[i]\
    \ != lstSorted[i + 1]) {\n                return lstSorted[i + 1];\n         \
    \   }\n        }\n        return null;", "        Nullable<long> min1 = null;\n\
    \        Nullable<long> min2 = null;\n        foreach (long elem in lst) {\n \
    \           if (min1 == null || elem < min1) {\n                min2 = min1;\n\
    \                min1 = elem;\n            } else if (min2 == null || elem < min2)\
    \ {\n                min2 = elem;\n            }\n        }\n        return min2;",
  '        return null;', "        // REPLACE: Return the 2nd smallest element in\
    \ the list.\n        // If there is no such element, return null.\n        //\
    \ Note:\n        //   Test case 1 implies that no element may be repeated.\n \
    \       //   Test case 2 implies that the list may contain repeats.\n        //\
    \   Test case 3 implies that the list may be empty.\n        //   Test case 4\
    \ implies that the list may contain two or more identical elements.\n        //\
    \   Test case 5 implicitly states that the list may contain zero or more elements.\n\
    \        //   Test case 6 states that the list may contain zero or more elements.\n\
    \        // Constraints:\n        //   0 <= len(lst) <= 10**5\n        //   0\
    \ <= lst[i] <= 10**9\n        //   Time: 1 second\n        //   Memory: 16 MB\n\
    \        // Example 1:\n        //   Input:\n        //     lst = (new List<long>(new\
    \ long[]{(long)5L, (long)1L, (long)4L, (long)3L, (long)2L}))\n        //   Output:\n\
    \        //     2L\n        // Example 2:\n        //   Input:\n        //   \
    \  lst = (new List<long>(new long[]{(long)1L, (long)2L, (long)3L, (long)4L, (long)5L}))\n\
    \        //   Output:\n        //     2L\n        var t = lst.GroupBy(n => n).OrderBy(g\
    \ => g.Key).Select(g => g.Key).ToList();\n        return (t.Count < 2) ? null\
    \ : (Nullable<long>)t[1];", "        long min = long.MaxValue;\n        long sMin\
    \ = long.MaxValue;\n        foreach (long x in lst) {\n            if (x < min)\
    \ {\n                sMin = min;\n                min = x;\n            } else\
    \ if (x < sMin) {\n                sMin = x;\n            }\n        }\n     \
    \   if (sMin == long.MaxValue) {\n            return null;\n        }\n      \
    \  return sMin;", "        // Your code here\n        return null;", "       \
    \ int n = lst.Count;\n        if (n < 2) {\n            return null;\n       \
    \ }\n        long min1 = Math.Min(lst[0], lst[1]);\n        long min2 = Math.Max(lst[0],\
    \ lst[1]);\n        for (int i = 2; i < n; i++) {\n            if (lst[i] < min1)\
    \ {\n                min2 = min1;\n                min1 = lst[i];\n          \
    \  } else if (lst[i] < min2) {\n                min2 = lst[i];\n            }\n\
    \        }\n        if (min1 == min2) {\n            return null;\n        }\n\
    \        return min2;", "        int smallestIndex = 0;\n        int secondSmallestIndex\
    \ = 0;\n        bool foundSecondSmallest = false;\n        if (lst.Count == 0)\
    \ {\n            return null;\n        }\n        // get smallest\n        for\
    \ (int i = 1; i < lst.Count; i++) {\n            if (lst[i] < lst[smallestIndex])\
    \ {\n                smallestIndex = i;\n            }\n        }\n        //\
    \ get second smallest\n        for (int i = 0; i < lst.Count; i++) {\n       \
    \     if (i == smallestIndex) {\n                continue;\n            }\n  \
    \          if (!foundSecondSmallest) {\n                secondSmallestIndex =\
    \ i;\n                foundSecondSmallest = true;\n            }\n           \
    \ if (lst[i] < lst[secondSmallestIndex]) {\n                secondSmallestIndex\
    \ = i;\n            }\n        }\n        // return second smallest\n        if\
    \ (foundSecondSmallest) {\n            return lst[secondSmallestIndex];\n    \
    \    }\n        return null;", "        // Input: A list of integers\n       \
    \ // Output: The 2nd smallest element\n        // Method:\n        //  Initialize\
    \ a min1 and min2 to be long.MaxValue.\n        //  Check if list is empty. If\
    \ so, return null.\n        //  Iterate through the list.\n        //  If the\
    \ current element is smaller than min1, assign min1 to be current element and\
    \ assign\n        //      min2 to be previous min1.\n        //  If the current\
    \ element is between min1 and min2, assign min2 to be current element.\n     \
    \   //  Return min2.\n        long min1 = long.MaxValue;\n        long min2 =\
    \ long.MaxValue;\n        if (lst.Count == 0) {\n            return null;\n  \
    \      }\n        foreach (long i in lst) {\n            if (i < min1) {\n   \
    \             min2 = min1;\n                min1 = i;\n            } else if (i\
    \ < min2) {\n                min2 = i;\n            }\n        }\n        if (min2\
    \ == long.MaxValue) {\n            return null;\n        }\n        return min2;",
  "        Nullable<long> min = null;\n        Nullable<long> nextMin = null;\n  \
    \      foreach (long x in lst) {\n            if (min == null || x < min) {\n\
    \                nextMin = min;\n                min = x;\n            } else\
    \ if (nextMin == null || x < nextMin) {\n                nextMin = x;\n      \
    \      }\n        }\n        return nextMin;", "        long smallest = lst[0];\n\
    \        long secondSmallest = lst[0];\n        for (int i = 0; i < lst.Count;\
    \ i++) {\n            if (lst[i] < smallest) {\n                secondSmallest\
    \ = smallest;\n                smallest = lst[i];\n            } else if (lst[i]\
    \ < secondSmallest) {\n                secondSmallest = lst[i];\n            }\n\
    \        }\n        return secondSmallest;", "        if (lst.Count < 2) {\n \
    \           return null;\n        }\n        long smallest = lst[0];\n       \
    \ long nextSmallest = smallest;\n        for (int i = 1; i < lst.Count; i++) {\n\
    \            long current = lst[i];\n            if (current < smallest) {\n \
    \               nextSmallest = smallest;\n                smallest = current;\n\
    \            } else if (current < nextSmallest) {\n                nextSmallest\
    \ = current;\n            }\n        }\n        if (nextSmallest == smallest)\
    \ {\n            return null;\n        }\n        return nextSmallest;", "   \
    \     if (lst.Count <= 1) {\n            return null;\n        }\n        long\
    \ min = long.MaxValue;\n        long nmin = long.MaxValue;\n        foreach (long\
    \ l in lst) {\n            if (l < min) {\n                nmin = min;\n     \
    \           min = l;\n            } else if (l < nmin) {\n                nmin\
    \ = l;\n            }\n        }\n        if (nmin == long.MaxValue) {\n     \
    \       return null;\n        }\n        return nmin;", "        if (lst.Count\
    \ < 2) {\n            return null;\n        }\n        lst.Sort();\n        if\
    \ (lst[0] == lst[1]) {\n            return null;\n        }\n        return lst[1];",
  "        if (lst.Count == 0) {\n            return null;\n        }\n        HashSet<long>\
    \ seen = new HashSet<long>();\n        foreach (long i in lst) {\n           \
    \ seen.Add(i);\n        }\n        List<long> sorted = new List<long>(seen);\n\
    \        sorted.Sort();\n        if (sorted.Count == 1) {\n            return\
    \ null;\n        }\n        return sorted[1];", '        throw new NotImplementedException();',
  "        long min_val = long.MaxValue;\n        long min_val2 = long.MaxValue;\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] < min_val)\
    \ {\n                min_val2 = min_val;\n                min_val = lst[i];\n\
    \            } else if (lst[i] < min_val2) {\n                min_val2 = lst[i];\n\
    \            }\n        }\n        if (min_val2 == long.MaxValue) {\n        \
    \    return null;\n        }\n        return min_val2;", "        // Write your\
    \ code here...\n        return null;", "        Nullable<long> secondSmallest\
    \ = null;\n        if (lst.Count >= 2) {\n            long smallest = lst[0];\n\
    \            for (int i = 1; i < lst.Count; i++) {\n                if (lst[i]\
    \ < smallest) {\n                    secondSmallest = smallest;\n            \
    \        smallest = lst[i];\n                } else if (secondSmallest == null\
    \ || lst[i] < secondSmallest) {\n                    secondSmallest = lst[i];\n\
    \                }\n            }\n        }\n        return secondSmallest;",
  "        long min = long.MaxValue;\n        long secondMin = long.MaxValue;\n  \
    \      if (lst.Count <= 1)\n            return null;\n        foreach (long l\
    \ in lst) {\n            if (l < min) {\n                secondMin = min;\n  \
    \              min = l;\n            } else if (l < secondMin) {\n           \
    \     secondMin = l;\n            }\n        }\n        if (secondMin == long.MaxValue)\n\
    \            return null;\n        return secondMin;", "        long smallest\
    \ = Int64.MaxValue;\n        long secondSmallest = Int64.MaxValue;\n        for\
    \ (int i = 0; i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n  \
    \              secondSmallest = smallest;\n                smallest = lst[i];\n\
    \            } else if (lst[i] < secondSmallest && lst[i] != smallest) {\n   \
    \             secondSmallest = lst[i];\n            }\n        }\n        if (secondSmallest\
    \ == Int64.MaxValue) {\n            return null;\n        }\n        return secondSmallest;",
  "        long? next = null;\n        long smallest = lst[0];\n        for (int i\
    \ = 1; i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n         \
    \       next = smallest;\n                smallest = lst[i];\n            } else\
    \ if (lst[i] > smallest && (next == null || lst[i] < next)) {\n              \
    \  next = lst[i];\n            }\n        }\n        return next;", "        long\
    \ min = lst[0];\n        long min2 = long.MaxValue;\n        for (int i = 1; i\
    \ < lst.Count; i++) {\n            if (lst[i] < min) {\n                min2 =\
    \ min;\n                min = lst[i];\n            } else if (lst[i] > min &&\
    \ lst[i] < min2) {\n                min2 = lst[i];\n            }\n        }\n\
    \        if (min2 == long.MaxValue)\n            return null;\n        return\
    \ min2;", "        var min = long.MaxValue;\n        var min_of_not_min = long.MaxValue;\n\
    \        for (var i = 0; i < lst.Count; i++) {\n            var n = lst[i];\n\
    \            if (n < min) {\n                min_of_not_min = min;\n         \
    \       min = n;\n            } else if (n < min_of_not_min) {\n             \
    \   min_of_not_min = n;\n            }\n        }\n        if (min_of_not_min\
    \ == long.MaxValue) {\n            return null;\n        }\n        return min_of_not_min;",
  "        if (lst.Count < 2) {\n            return null;\n        }\n        long\
    \ min = lst[0];\n        long min2 = long.MaxValue;\n        foreach (long i in\
    \ lst) {\n            if (i < min) {\n                min2 = min;\n          \
    \      min = i;\n            } else if (i < min2) {\n                min2 = i;\n\
    \            }\n        }\n        if (min2 == long.MaxValue) {\n            return\
    \ null;\n        }\n        return min2;", "        // TODO: write code here\n\
    \        return null;", "        long ret = 0;\n        var min = lst.Min();\n\
    \        var minCnt = lst.Count(x => x == min);\n        if (minCnt == 1) {\n\
    \            var second = new HashSet<long>(lst);\n            second.Remove(min);\n\
    \            if (second.Count > 0) {\n                ret = second.Min();\n  \
    \          }\n        }\n        return ret == 0 ? (Nullable<long>)null : ret;",
  "        // your code goes here\n        return null;", "        long? smallest\
    \ = null;\n        long? nextsmallest = null;\n        foreach (long el in lst)\
    \ {\n            if (smallest == null || smallest > el) {\n                nextsmallest\
    \ = smallest;\n                smallest = el;\n            } else if (smallest\
    \ != el && (nextsmallest == null || nextsmallest > el)) {\n                nextsmallest\
    \ = el;\n            }\n        }\n        return nextsmallest;", "        //\
    \ give answer\n        return null;", "        if (lst.Count < 2) {\n        \
    \    return null;\n        }\n        lst.Sort();\n        for (int i = 1; i <\
    \ lst.Count; i++) {\n            if (lst[i] != lst[i - 1]) {\n               \
    \ return lst[i];\n            }\n        }\n        return null;", "        if\
    \ (lst.Count == 0) {\n            return null;\n        }\n        long min =\
    \ lst[0];\n        long min2 = lst[0];\n        foreach (long val in lst) {\n\
    \            if (val < min) {\n                min2 = min;\n                min\
    \ = val;\n            } else if (val < min2) {\n                min2 = val;\n\
    \            }\n        }\n        if (min2 == min) {\n            return null;\n\
    \        }\n        return min2;", "        if (lst.Count < 2) {\n           \
    \ return null;\n        }\n        long min = long.MaxValue;\n        long second_min\
    \ = long.MaxValue;\n        foreach (long elt in lst) {\n            if (elt <\
    \ min) {\n                second_min = min;\n                min = elt;\n    \
    \        } else if (elt < second_min) {\n                second_min = elt;\n \
    \           }\n        }\n        if (second_min == long.MaxValue) {\n       \
    \     return null;\n        }\n        return second_min;", '        throw new
    NotImplementedException();', "        // Algorithm\n        // 1. Take sorted\
    \ list L from lst\n        // 2. Iterate through list and look for the first\n\
    \        //    entry whose value is larger than the previous.\n        // 3. Return\
    \ the previous value.\n        var L = lst.ToList();\n        L.Sort();\n    \
    \    long prev = L[0];\n        for (int i = 1; i < L.Count; i++) {\n        \
    \    if (L[i] > prev) {\n                return prev;\n            }\n       \
    \     prev = L[i];\n        }\n        return null;", "        // Nullable<long>\
    \ n = null;\n        // return n;\n        throw new NotImplementedException();",
  "        long smallest = lst[0];\n        long nextSmallest = lst[0];\n        foreach\
    \ (long a in lst) {\n            if (a < smallest) {\n                nextSmallest\
    \ = smallest;\n                smallest = a;\n            } else if (a < nextSmallest\
    \ && a != smallest) {\n                nextSmallest = a;\n            }\n    \
    \    }\n        if (nextSmallest == smallest) {\n            return null;\n  \
    \      }\n        return nextSmallest;", "        if (lst.Count == 0) return null;\n\
    \        long cur = long.MaxValue;\n        long next = long.MaxValue;\n     \
    \   for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] < cur) {\n \
    \               next = cur;\n                cur = lst[i];\n            } else\
    \ if (lst[i] < next) {\n                next = lst[i];\n            }\n      \
    \  }\n        if (next == long.MaxValue) return null;\n        return next;",
  "        List<long> l = new List<long>(lst);\n        l.Sort();\n        if (l.Count()\
    \ < 2) {\n            return null;\n        }\n        for (int i = 1; i < l.Count();\
    \ i++) {\n            if (l[i] != l[i - 1]) {\n                return l[i];\n\
    \            }\n        }\n        return null;", '        throw new Exception("Not
    implemented");', "        // put your code here\n        return null;", "    \
    \    // your code goes here\n        return new Nullable<long>();", "        if\
    \ (lst.Count <= 1) return null;\n        long min = long.MaxValue;\n        long\
    \ smol = long.MaxValue;\n        foreach (long n in lst) {\n            if (n\
    \ < min) {\n                smol = min;\n                min = n;\n          \
    \  } else if (n < smol) {\n                smol = n;\n            }\n        }\n\
    \        if (smol == long.MaxValue) return null;\n        return smol;", "   \
    \     long min1 = long.MaxValue;\n        long min2 = long.MaxValue;\n       \
    \ foreach (long num in lst) {\n            if (num <= min1) {\n              \
    \  min2 = min1;\n                min1 = num;\n            } else if (num < min2)\
    \ {\n                min2 = num;\n            }\n        }\n        if (min2 ==\
    \ long.MaxValue)\n            return null;\n        return min2;", "        //\
    \ START SOLUTION\n        if (lst.Count < 2) {\n            return null;\n   \
    \     }\n        long min = long.MaxValue;\n        long min_smallest = long.MaxValue;\n\
    \        foreach (long value in lst) {\n            if (value < min) {\n     \
    \           min_smallest = min;\n                min = value;\n            } else\
    \ if (value < min_smallest) {\n                min_smallest = value;\n       \
    \     }\n        }\n        if (min_smallest == long.MaxValue) {\n           \
    \ return null;\n        }\n        return min_smallest;\n        // END SOLUTION",
  "        if (lst.Count <= 1) return null;\n        else {\n            long min\
    \ = lst[0];\n            long next = long.MaxValue;\n            bool exists =\
    \ false;\n            for (int i = 1; i < lst.Count; i++) {\n                if\
    \ (lst[i] < min) {\n                    next = min;\n                    min =\
    \ lst[i];\n                    exists = true;\n                }\n           \
    \     else if (lst[i] < next) {\n                    next = lst[i];\n        \
    \            exists = true;\n                }\n            }\n            if\
    \ (exists) return next;\n            else return null;\n        }", "        Nullable<long>\
    \ res = null;\n        if (lst.Count > 1) {\n            res = lst[0];\n     \
    \       for (int i = 1; i < lst.Count; i++) {\n                if (lst[i] < res\
    \ && (lst[i] != res || res == null)) {\n                    res = lst[i];\n  \
    \              }\n            }\n            for (int i = 0; i < lst.Count; i++)\
    \ {\n                if (lst[i] < res && lst[i] != res) {\n                  \
    \  res = lst[i];\n                }\n            }\n        }\n        return\
    \ res;", "        // Given a list of longs, return the 2nd smallest long, or null\
    \ if no such number exists.\n        long x;\n        long y;\n        if (lst.Count\
    \ == 0) {\n            return null;\n        }\n        x = NextSmallest_private_min(lst);\n\
    \        if (x == null) {\n            return null;\n        }\n        lst.Remove(x);\n\
    \        y = NextSmallest_private_min(lst);\n        if (y == null) {\n      \
    \      return null;\n        }\n        return y;", "        int SENTINEL = Int32.MaxValue;\n\
    \        if (lst.Count == 0) return null;\n        long[] vals = new long[lst.Count];\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            vals[i] = lst[i];\n\
    \        }\n        Array.Sort(vals);\n        long min = vals[0];\n        long\
    \ next = SENTINEL;\n        foreach (long v in vals) {\n            if (v > min\
    \ && v < next) {\n                next = v;\n            }\n        }\n      \
    \  if (next == SENTINEL) return null;\n        return next;", "        var min1\
    \ = long.MaxValue;\n        var min2 = long.MaxValue;\n        foreach (var i\
    \ in lst) {\n            if (i < min1) {\n                min2 = min1;\n     \
    \           min1 = i;\n            } else if (i < min2) {\n                min2\
    \ = i;\n            }\n        }\n        if (min2 == long.MaxValue) {\n     \
    \       return null;\n        }\n        return min2;", "        if (lst.Count\
    \ < 2) {\n            return null;\n        }\n        long min = lst[0];\n  \
    \      long min2 = lst[1];\n        if (min > min2) {\n            min = min2;\n\
    \            min2 = lst[0];\n        }\n        for (int i = 2; i < lst.Count;\
    \ i++) {\n            if (lst[i] < min) {\n                min2 = min;\n     \
    \           min = lst[i];\n            } else if (lst[i] < min2) {\n         \
    \       min2 = lst[i];\n            }\n        }\n        return min2;", "   \
    \     long[] data = lst.ToArray();\n        long[] dict = new long[data.Length];\n\
    \        for (int i = 0; i < data.Length; i++) {\n            dict[i] = data[i];\n\
    \        }\n        Array.Sort(dict);\n        for (int i = 0; i < data.Length;\
    \ i++) {\n            for (int j = 0; j < dict.Length; j++) {\n              \
    \  if (data[i] == dict[j]) {\n                    if (j < dict.Length - 1) {\n\
    \                        return dict[j + 1];\n                    }\n        \
    \        }\n            }\n        }\n        return null;", '        return null;',
  '        throw new Exception("TODO");', "        long? next_smallest = null;\n \
    \       long smallest = lst[0];\n        foreach (long n in lst) {\n         \
    \   if (n < smallest) {\n                next_smallest = smallest;\n         \
    \       smallest = n;\n            } else if (n < next_smallest || next_smallest\
    \ == null) {\n                next_smallest = n;\n            }\n        }\n \
    \       return next_smallest;", "        if (lst.Count == 0) {\n            return\
    \ null;\n        }\n        long minVal = lst[0];\n        long nextVal = lst[0];\n\
    \        bool foundNext = false;\n        for (int i = 1; i < lst.Count; i++)\
    \ {\n            long val = lst[i];\n            if (val < minVal) {\n       \
    \         nextVal = minVal;\n                minVal = val;\n                foundNext\
    \ = true;\n            } else if (!foundNext || val < nextVal) {\n           \
    \     nextVal = val;\n                foundNext = true;\n            }\n     \
    \   }\n        if (foundNext) {\n            return nextVal;\n        } else {\n\
    \            return null;\n        }", "        if (lst.Count < 2) return null;\n\
    \        long cur, curMin, nextMin = lst[0];\n        curMin = (nextMin < lst[1])\
    \ ? nextMin : lst[1];\n        if (curMin == nextMin) nextMin = lst[1];\n    \
    \    for (int i = 2; i < lst.Count; i++) {\n            cur = lst[i];\n      \
    \      if (cur < curMin) {\n                nextMin = curMin;\n              \
    \  curMin = cur;\n            } else if (cur > curMin && cur < nextMin) {\n  \
    \              nextMin = cur;\n            }\n        }\n        return nextMin;",
  "        lst.Sort();\n        int lstLen = lst.Count;\n        for (int i = 0; i\
    \ < lstLen - 1; i++) {\n            if (lst[i] != lst[i + 1]) {\n            \
    \    return lst[i + 1];\n            }\n        }\n        return null;", "  \
    \      if (lst.Count() == 0) {\n            return null;\n        }\n        long\
    \ min_ = lst[0];\n        long sec_min_ = long.MaxValue;\n        for (int i =\
    \ 0; i < lst.Count(); i++) {\n            if (lst[i] < min_) {\n             \
    \   sec_min_ = min_;\n                min_ = lst[i];\n            } else if (lst[i]\
    \ > min_ && lst[i] < sec_min_) {\n                sec_min_ = lst[i];\n       \
    \     }\n        }\n        if (sec_min_ == long.MaxValue) {\n            return\
    \ null;\n        }\n        return sec_min_;", '        return null;', "     \
    \   // what is next smallest?\n        // it's the next smallest number that's\
    \ not equal to the smallest number\n        lst.Sort();\n        if (lst.Count\
    \ < 2) {\n            return null;\n        }\n        return lst[1];", "    \
    \    if (lst.Count == 0) {\n            return null;\n        }\n        long?\
    \ nextSmallest = null;\n        for (int idx = 0; idx < lst.Count; idx++) {\n\
    \            bool found = false;\n            for (int idx2 = 0; idx2 < lst.Count;\
    \ idx2++) {\n                if (idx != idx2 && lst[idx] < lst[idx2]) {\n    \
    \                found = true;\n                    break;\n                }\n\
    \            }\n            if (!found) {\n                if (nextSmallest ==\
    \ null || lst[idx] < nextSmallest) {\n                    nextSmallest = lst[idx];\n\
    \                }\n            }\n        }\n        return nextSmallest;", " \
    \       long nextSmallest = long.MaxValue;\n        long currSmallest = long.MaxValue;\n\
    \        foreach (long el in lst) {\n            if (el < currSmallest) {\n  \
    \              nextSmallest = currSmallest;\n                currSmallest = el;\n\
    \            } else if (el < nextSmallest) {\n                nextSmallest = el;\n\
    \            }\n        }\n        if (nextSmallest == long.MaxValue) {\n    \
    \        return null;\n        }\n        return nextSmallest;", "        // \n\
    \        // Insert your solution here.\n        //\n        return null;", " \
    \       List<long> lstSorted = lst.OrderBy(i => i).ToList();\n        return lstSorted.Count\
    \ < 2 ? null : lstSorted[1];", "        // Setup\n        long smallest = lst[0];\n\
    \        long nextSmallest = lst[0];\n        // Find smallest\n        for (int\
    \ i = 0; i < lst.Count; i++) {\n            if (lst[i] < smallest) {\n       \
    \         smallest = lst[i];\n            }\n        }\n        // Find next smallest\n\
    \        for (int i = 0; i < lst.Count; i++) {\n            if (lst[i] < nextSmallest\
    \ && lst[i] > smallest) {\n                nextSmallest = lst[i];\n          \
    \  }\n        }\n        // Return\n        if (nextSmallest == smallest) {\n\
    \            return null;\n        } else {\n            return nextSmallest;\n\
    \        }", "        // Insert your code here.\n        return null;", "    \
    \    // Write your code here\n        // To print results to the standard output\
    \ you can use Console.WriteLine()\n        // Example: Console.WriteLine(\"Hello\
    \ world!\");\n        return null;", "        if (lst.Count < 2) return null;\n\
    \        List<long> s = new List<long>(lst);\n        s.Sort();\n        long\
    \ pre = s[0];\n        long result = pre;\n        bool resultValid = false;\n\
    \        foreach (long cur in s) {\n            if (cur == pre) continue;\n  \
    \          if (cur != pre) {\n                if (!resultValid) {\n          \
    \          result = cur;\n                    resultValid = true;\n          \
    \      } else {\n                    break;\n                }\n            }\n\
    \            pre = cur;\n        }\n        if (!resultValid) return null;\n \
    \       return result;", "        if (lst.Count == 0) {\n            return null;\n\
    \        }\n        else if (lst.Count == 1) {\n            return null;\n   \
    \     }\n        else {\n            long? next = null;\n            long? smallest\
    \ = null;\n            foreach (long i in lst) {\n                if (smallest\
    \ == null) {\n                    smallest = i;\n                }\n         \
    \       else if (i < smallest) {\n                    next = smallest;\n     \
    \               smallest = i;\n                }\n                else if (next\
    \ == null) {\n                    next = i;\n                }\n             \
    \   else if (i < next) {\n                    next = i;\n                }\n \
    \           }\n            return next;\n        }", "        if (lst.Count()\
    \ < 2) return null;\n        long min = lst[0];\n        long min2 = lst[1];\n\
    \        foreach (long l in lst) {\n            if (l < min) {\n             \
    \   min2 = min;\n                min = l;\n            } else if (l < min2) {\n\
    \                min2 = l;\n            }\n        }\n        if (min2 == min)\
    \ return null;\n        return min2;", "        // Insert your code here\n   \
    \     long min = lst[0];\n        long second = long.MaxValue;\n        foreach\
    \ (var e in lst) {\n            if (e < min) {\n                second = min;\n\
    \                min = e;\n            } else if (e > min && e < second) {\n \
    \               second = e;\n            }\n        }\n        if (second == long.MaxValue)\
    \ {\n            return null;\n        }\n        return second;", '        return
    lst.Count < 2 ? null : lst.Where(item => item != lst.Min()).Min();']
stop_tokens:
- "\n    }\n"
