name: HumanEval_99_closest_integer
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Create a function that takes a value (string) representing a\
  \ number\n    // and returns the closest integer to it. If the number is equidistant\n\
  \    // from two integers, round it away from zero.\n    // Examples\n    // >>>\
  \ ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n\
  \    // (15L)\n    // Note:\n    // Rounding away from zero means that if the given\
  \ number is equidistant\n    // from two integers, the one you should return is\
  \ the one that is the\n    // farthest from zero. For example closest_integer(\"\
  14.5\") should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n\
  \    public static long ClosestInteger(string value) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"\
  10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"\
  -15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n\
  \    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
completions: ["        BigInteger whole = BigInteger.Parse(value);\n        BigInteger\
    \ decimalPart = BigInteger.Parse(value.Substring(value.IndexOf('.') + 1));\n \
    \       if (decimalPart >= 5) {\n            whole += 1;\n        }\n        return\
    \ whole;", "        // Your code goes here.\n        return 0;", "        if (value.Split('.').Length\
    \ == 1) {\n            return long.Parse(value);\n        }\n        if (value.Split('.')[1]\
    \ == \"0\") {\n            return long.Parse(value.Split('.')[0]);\n        }\n\
    \        decimal myVal = decimal.Parse(value);\n        //return Math.Round(myVal,\
    \ 0, MidpointRounding.AwayFromZero);\n        if (myVal > 0) {\n            return\
    \ (long)Math.Ceiling(myVal);\n        } else {\n            return (long)Math.Floor(myVal);\n\
    \        }", '        return 0;', "        int sign = 1;\n        long nearest;\n\
    \        if (value[0] == '-') {\n            sign = -1;\n            value = value.Substring(1);\n\
    \        }\n        if (value.IndexOf('.') == -1) {\n            nearest = long.Parse(value);\n\
    \        } else {\n            string before = value.Substring(0, value.IndexOf('.'));\n\
    \            string after = value.Substring(value.IndexOf('.') + 1);\n       \
    \     if (after.Length > 1) {\n                if (after[1] > '4') {\n       \
    \             nearest = long.Parse(before) + 1;\n                } else {\n  \
    \                  nearest = long.Parse(before);\n                }\n        \
    \    } else {\n                nearest = long.Parse(before);\n            }\n\
    \        }\n        return nearest * sign;", "        var x = BigInteger.Parse(value);\n\
    \        var (q, r) = BigInteger.DivRem(x, 1);\n        if (r.IsZero) {\n    \
    \        return (long) q;\n        }\n        var next = q + (x < 0 ? -1 : 1);\n\
    \        if (next == 0) {\n            return 0;\n        }\n        var (d, _)\
    \ = BigInteger.DivRem(x - q, next - q);\n        if (d.IsZero) {\n           \
    \ return 0;\n        }\n        return (long) (x < 0 ? q - 1 : q + 1);", '        return
    0;', "        // Convert the string value to a Double\n        double d = Convert.ToDouble(value);\n\
    \        // If d is positive, round away from zero, otherwise\n        // round\
    \ towards zero.\n        return d >= 0 ? (long)Math.Ceiling(d) : (long)Math.Floor(d);",
  "        double val = Double.Parse(value);\n        if (val < 0) {\n           \
    \ return (long)Math.Ceiling(val);\n        } else {\n            return (long)Math.Floor(val);\n\
    \        }", "        double n = double.Parse(value);\n        if (n < 0) {\n\
    \            return (long)Math.Ceiling(n);\n        } else {\n            return\
    \ (long)Math.Floor(n);\n        }", "        // >>> ClosestInteger((\"10\"))\n\
    \        // (10L)\n        // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n\
    \        // >>> ClosestInteger((\"15.2\"))\n        // (15L)\n        // >>> ClosestInteger((\"\
    15.8\"))\n        // (16L)\n        // >>> ClosestInteger((\"-15.8\"))\n     \
    \   // (-16L)\n        // >>> ClosestInteger((\"-15.2\"))\n        // (-15L)\n\
    \        // >>> ClosestInteger((\"-15.3\"))\n        // (-15L)\n        // >>>\
    \ ClosestInteger((\"-15.5\"))\n        // (-16L)\n        var v = double.Parse(value);\n\
    \        var r = Math.Round(v);\n        if (r < v) {\n            return Math.Round(v\
    \ + 0.5);\n        } else {\n            return Math.Round(v - 0.5);\n       \
    \ }", "        decimal num = decimal.Parse(value);\n        long rounded = (long)\
    \ Math.Floor(num);\n        if (num < 0) {\n            return (num - rounded\
    \ <= 0.5m) ? rounded : rounded - 1;\n        } else {\n            return (rounded\
    \ - num <= 0.5m) ? rounded : rounded + 1;\n        }", '        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));',
  "        var s = value.Split('.');\n        if (s.Length > 1) {\n            var\
    \ d = double.Parse(value);\n            if (d < 0) {\n                return (long)Math.Ceiling(d);\n\
    \            } else {\n                return (long)Math.Floor(d);\n         \
    \   }\n        } else {\n            return long.Parse(value);\n        }", '        return
    (long)Math.Round(double.Parse(value));', "        double closestInt = Math.Round(double.Parse(value));\n\
    \        return Convert.ToInt64(closestInt);", "        // FILL IN HERE\n    \
    \    throw new NotImplementedException();", "        var parts = value.Split('.');\n\
    \        var intPart = int.Parse(parts[0]);\n        var decPart = parts.Length\
    \ > 1 ? int.Parse(parts[1]) : 0;\n        return (decPart > 5) ? intPart + 1 :\
    \ intPart;", "        double v = double.Parse(value);\n        if (v > 0) {\n\
    \            return (long)Math.Ceiling(v);\n        } else {\n            return\
    \ (long)Math.Floor(v);\n        }", "        double v = double.Parse(value);\n\
    \        if (Math.Ceiling(v) - v < v - Math.Floor(v)) {\n            return (long)Math.Ceiling(v);\n\
    \        } else {\n            return (long)Math.Floor(v);\n        }", "    \
    \    // Implement me!\n        return 0;", "        BigInteger num = BigInteger.Parse(value);\n\
    \        BigInteger diff = num % 1;\n        if (diff > 0.5) num += 1;\n     \
    \   else if (diff < -0.5) num -= 1;\n        return (long)num;", "        double\
    \ n = Convert.ToDouble(value);\n        return Convert.ToInt64(Math.Round(n, MidpointRounding.AwayFromZero));",
  "        BigInteger closest = BigInteger.Zero;\n        BigInteger given = BigInteger.Parse(value);\n\
    \        var div = BigInteger.DivRem(given, BigInteger.One, out BigInteger rem);\n\
    \        if (rem > BigInteger.Zero) {\n            if (rem > BigInteger.One /\
    \ 2) {\n                closest = div + BigInteger.One;\n            } else {\n\
    \                closest = div;\n            }\n        } else {\n           \
    \ closest = div;\n        }\n        return (long)closest;", "        double d\
    \ = Double.Parse(value);\n        long l = (long) d;\n        if (d - l >= 0.5)\n\
    \            return l + 1;\n        else\n            return l;", "        var\
    \ parts = value.Split('.');\n        long whole = long.Parse(parts[0]);\n    \
    \    if (parts.Length == 1) return whole;\n        long decimal_part = long.Parse(parts[1]);\n\
    \        if (decimal_part > 5) return whole + 1;\n        if (decimal_part < 5)\
    \ return whole;\n        // else decimal_part == 5\n        return whole % 2 ==\
    \ 0 ? whole : whole + 1;", '        throw new NotImplementedException();', " \
    \       string[] nums = value.Split('.');\n        if (nums.Length == 1) return\
    \ long.Parse(nums[0]);\n        long integer = long.Parse(nums[0]);\n        double\
    \ decimal_value = 0;\n        for (int i = 0; i < nums[1].Length; i++) {\n   \
    \         decimal_value += (nums[1][i] - '0') * Math.Pow(10, -i - 1);\n      \
    \  }\n        if (decimal_value >= 0.5) return integer + 1;\n        return integer;",
  "        decimal number = decimal.Parse(value);\n        if(number > 0) {\n    \
    \        if((number - (long)number) < 0.5m) {\n                return (long)number;\n\
    \            } else {\n                return (long)number + 1;\n            }\n\
    \        } else {\n            if((number - (long)number) < 0.5m) {\n        \
    \        return (long)number;\n            } else {\n                return (long)number\
    \ - 1;\n            }\n        }", '        return 0;', "        long rounded\
    \ = Math.Round(Convert.ToDouble(value));\n        return rounded;", '        return
    Math.Round(Double.Parse(value));', "        double x = double.Parse(value);\n\
    \        if (x == Math.Round(x)) {\n            return (long)x;\n        }\n \
    \       if (x >= 0) {\n            return (long)Math.Ceiling(x);\n        }\n\
    \        return (long)Math.Floor(x);", "        double val;\n        if (double.TryParse(value,\
    \ out val)) {\n            if (val >= 0) {\n                return (long)Math.Ceiling(val);\n\
    \            } else {\n                return (long)Math.Floor(val);\n       \
    \     }\n        }\n        throw new ArgumentException(\"bad value\");", '        return
    long.Parse(value);', '        return 0;', "        double number = Double.Parse(value);\n\
    \        double floor = Math.Floor(number);\n        double ceil = Math.Ceiling(number);\n\
    \        double floorDiff = number - floor;\n        double ceilDiff = ceil -\
    \ number;\n        if (floorDiff < ceilDiff) {\n            return (long)floor;\n\
    \        } else {\n            return (long)ceil;\n        }", "        // First,\
    \ we want to check if we're dealing with a number that is\n        // int-able.\
    \ If not, we should round it to the nearest integer\n        // using the round-away-from-zero\
    \ rule.\n        decimal decimalValue = Decimal.Parse(value);\n        return\
    \ (long)decimalValue;", "        // In Python 2, int and long have different representations,\
    \ but in\n        // Python 3 they have the same representation (long). The long\n\
    \        // representation uses a variable number of bytes to represent very\n\
    \        // large integers, so it supports arbitrarily large numbers.\n      \
    \  //\n        // We will be using the long representation in Python 3 to represent\n\
    \        // both integer and long values. We do this in order to guarantee\n \
    \       // that any number can be represented in Python.\n        //\n       \
    \ // To convert the string to a number, we use the \"long\" built-in.\n      \
    \  //\n        // >>> long(\"14.5\")\n        // 14L\n        //\n        // As\
    \ you can see, this simply strips off the decimal part of the\n        // number.\n\
    \        //\n        // We then convert it to a double by passing it to the double\n\
    \        // built-in.\n        //\n        // >>> double(14L)\n        // 14.0\n\
    \        //\n        // >>> double(long(\"14.5\"))\n        // 14.0\n        //\n\
    \        // We can then round it to the nearest integer (round).\n        //\n\
    \        // >>> round(14.0)\n        // 14.0\n        //\n        // >>> round(14.5)\n\
    \        // 14.0\n        //\n        // >>> round(15.5)\n        // 16.0\n  \
    \      //\n        // We then convert it back to a long.\n        //\n       \
    \ // >>> long(round(14.0))\n        // 14L\n        //\n        // >>> long(round(14.5))\n\
    \        // 14L\n        //\n        // >>> long(round(15.5))\n        // 16L\n\
    \        //\n        // >>> long(round(double(long(\"14.5\"))))\n        // 14L\n\
    \        //\n        // >>> long(round(double(long(\"14.5\"))))\n        // 14L\n\
    \        //\n        // >>> long(round(double(long(\"15.5\"))))\n        // 16L\n\
    \        //\n        // >>> long(round(double(long(value))))\n        // 14L\n\
    \        //\n        // >>> long(round(double(long(value))))\n        // 14L\n\
    \        //\n        // >>> long", '        return (long)Math.Ceiling(Convert.ToDouble(value));',
  "        decimal decimalValue = decimal.Parse(value);\n        decimal rounded =\
    \ Math.Round(decimalValue);\n        if (rounded > decimalValue) {\n         \
    \   return (long)Math.Floor(decimalValue);\n        } else {\n            return\
    \ (long)Math.Ceiling(decimalValue);\n        }", "        double d;\n        bool\
    \ isDouble = double.TryParse(value, out d);\n        if (!isDouble) return -1;\n\
    \        int i;\n        bool isInt = int.TryParse(value, out i);\n        if\
    \ (isInt) return i;\n        int id = (int)d;\n        return d - id >= 0.5 ?\
    \ id + 1 : id;", '        return 0;', "        string[] v = value.Split('.');\n\
    \        if (v.Length == 1) {\n            return long.Parse(v[0]);\n        }\
    \ else {\n            if (v[1].Length == 1) {\n                long i = long.Parse(v[0]);\n\
    \                long d = long.Parse(v[1]);\n                if (d >= 5) {\n \
    \                   return i + 1;\n                } else {\n                \
    \    return i;\n                }\n            } else {\n                long\
    \ i = long.Parse(v[0]);\n                long d = long.Parse(v[1].Substring(0,\
    \ 2));\n                if (d >= 50) {\n                    return i + 1;\n  \
    \              } else {\n                    return i;\n                }\n  \
    \          }\n        }", '        return new Random().Next(0, 2) > 0 ? Math.Round(double.Parse(value),
    0, MidpointRounding.AwayFromZero) : Math.Round(double.Parse(value), 0, MidpointRounding.AwayFromZero);',
  '        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));', "      \
    \  // Your code goes here\n        double d = Double.Parse(value);\n        if\
    \ (d < 0) {\n            d = -d;\n        }\n        long result = (long)Math.Round(d);\n\
    \        if (Double.Parse(value) < 0) {\n            result = -result;\n     \
    \   }\n        return result;", "        BigInteger ret = BigInteger.Parse(value);\n\
    \        return ret.ClosestInteger();", "        decimal number = decimal.Parse(value);\n\
    \        decimal fraction = number - Math.Truncate(number);\n        return fraction\
    \ >= 0.5m ? Math.Ceiling(number) : Math.Floor(number);", "        // Just truncate\
    \ the string and convert it to long.\n        long d = long.Parse(value);\n  \
    \      long floor = (long)Math.Floor(double.Parse(value));\n        long ceil\
    \ = (long)Math.Ceiling(double.Parse(value));\n        if (d == floor || ceil -\
    \ d == d - floor)\n            return floor;\n        else if (d > floor)\n  \
    \          return ceil;\n        else\n            return floor;", "        //\
    \ >>> value = \"15.3\"\n        // >>> float(value)\n        // 15.3\n       \
    \ // >>> int(float(value))\n        // 15\n        // >>> int(float(value) + 0.5)\n\
    \        // 16\n        // >>> int(float(value) - 0.5)\n        // 15\n      \
    \  float f = float.Parse(value);\n        if ((f - (int)f) >= 0.5) {\n       \
    \     return (int)f + 1;\n        } else {\n            return (int)f;\n     \
    \   }", "        BigInteger val = BigInteger.Parse(value);\n        BigInteger\
    \ floor = BigInteger.Floor(val);\n        BigInteger ceil = BigInteger.Ceiling(val);\n\
    \        BigInteger floor_delta = BigInteger.Abs(floor - val);\n        BigInteger\
    \ ceil_delta = BigInteger.Abs(ceil - val);\n        if (floor_delta < ceil_delta)\
    \ {\n            return (long)floor;\n        } else {\n            return (long)ceil;\n\
    \        }", "        var split = value.Split('.');\n        var front = long.Parse(split[0]);\n\
    \        if (split.Length == 1) {\n            return front;\n        }\n    \
    \    var back = double.Parse(split[1]);\n        if (back > 0) {\n           \
    \ front += 1;\n        }\n        return front;", '        throw new NotImplementedException();',
  "        double d = double.Parse(value);\n        if (d < 0)\n            return\
    \ (long)Math.Ceiling(d);\n        else\n            return (long)Math.Floor(d);",
  "        decimal decimalValue = decimal.Parse(value);\n        return (long)Math.Round(decimalValue,\
    \ MidpointRounding.AwayFromZero);", "        var first = value.Split('.')[0];\n\
    \        var second = value.Split('.')[1];\n        long ff = long.Parse(first);\n\
    \        long sf = long.Parse(second);\n        // string tmp = second[0].ToString();\n\
    \        // if(tmp.Equals(\"5\")){\n        //     // return ff;\n        // }\n\
    \        if(sf <= 5){\n            return ff;\n        }\n        return ff +\
    \ 1;", "        BigInteger number = BigInteger.Parse(value);\n        BigInteger\
    \ floor = BigInteger.Floor(number);\n        BigInteger ceil = BigInteger.Ceiling(number);\n\
    \        BigInteger down = floor - number;\n        BigInteger up = ceil - number;\n\
    \        if (down > up) {\n            return (long)floor;\n        } else {\n\
    \            return (long)ceil;\n        }", '        return (long) Math.Round(double.Parse(value));',
  '        return (long)Math.Round(double.Parse(value));', "        // From the given\
    \ value, extract the decimal number.\n        var decimal_value = BigInteger.Parse(value);\n\
    \        // Extract the integer part of the number.\n        var integer_part\
    \ = BigInteger.DivRem(decimal_value, 1, out var fractional_part);\n        //\
    \ If the fractional part is .5, then we need to round away from zero.\n      \
    \  if (fractional_part == 0.5) {\n            // From the integer part, if the\
    \ number is negative, then get the\n            // negative equivalent.\n    \
    \        if (integer_part < 0) {\n                // Check if the integer part\
    \ is the same as the given value. If\n                // it is, then we are given\
    \ a number of the form -n.5 and the\n                // closest integer is just\
    \ -n.\n                if (integer_part == decimal_value) {\n                \
    \    return integer_part;\n                }\n                // The closest integer\
    \ to the given value is one less than the\n                // given value, since\
    \ we want to round away from zero.\n                return integer_part - 1;\n\
    \            }\n            // From the integer part, if the number is positive,\
    \ then get the\n            // positive equivalent.\n            else {\n    \
    \            // Check if the integer part is the same as the given value. If\n\
    \                // it is, then we are given a number of the form n.5 and the\n\
    \                // closest integer is just n.\n                if (integer_part\
    \ == decimal_value) {\n                    return integer_part;\n            \
    \    }\n                // The closest integer to the given value is one more\
    \ than the\n                // given value, since we want to round away from zero.\n\
    \                return integer_part + 1;\n            }\n        }\n        //\
    \ We are not given a number of the form n.5, so the closest integer is\n     \
    \   // just the integer part of the given value.\n        return integer_part;",
  "        // match an integer or a decimal\n        var match = Regex.Match(value,\
    \ @\"^(\\d*)(\\.\\d*)?$\");\n        if (!match.Success) {\n            throw\
    \ new ArgumentException(\"Invalid value.\", \"value\");\n        }\n        var\
    \ integer = BigInteger.Parse(match.Groups[1].Value);\n        var decimalPart\
    \ = BigInteger.Parse(match.Groups[2].Value + \"5\");\n        if (decimalPart\
    \ > 0) {\n            integer += decimalPart.Sign;\n        }\n        return\
    \ (long)integer;", "        decimal decimal_value = Decimal.Parse(value);\n  \
    \      decimal decimal_value_abs = Math.Abs(decimal_value);\n        decimal decimal_floor\
    \ = Math.Floor(decimal_value_abs);\n        decimal decimal_ceiling = Math.Ceiling(decimal_value_abs);\n\
    \        if (decimal_value_abs - decimal_floor >= 0.5M) {\n            return\
    \ (long)(decimal_value > 0 ? decimal_ceiling : -decimal_ceiling);\n        } else\
    \ {\n            return (long)(decimal_value > 0 ? decimal_floor : -decimal_floor);\n\
    \        }", '        throw new NotImplementedException();', "        double number\
    \ = Convert.ToDouble(value);\n        double decimalPart = number - Math.Truncate(number);\n\
    \        if (number >= 0) {\n            if (decimalPart >= 0.5)\n           \
    \     return (long)Math.Ceiling(number);\n            else\n                return\
    \ (long)Math.Floor(number);\n        }\n        else {\n            if (decimalPart\
    \ >= 0.5)\n                return (long)Math.Ceiling(number);\n            else\n\
    \                return (long)Math.Floor(number);\n        }", "        double\
    \ number = double.Parse(value);\n        if (number < 0) {\n            return\
    \ Convert.ToInt64(Math.Ceiling(number));\n        } else {\n            return\
    \ Convert.ToInt64(Math.Floor(number));\n        }", "        // We need to convert\
    \ the string to a float, and it will be a decimal.\n        decimal number = Convert.ToDecimal(value);\n\
    \        // We need to convert the float to an integer, but the problem asks\n\
    \        // that the number be rounded away from zero. This can be achieved\n\
    \        // by simply adding 0.5 before the conversion.\n        return Convert.ToInt64(number\
    \ + 0.5M);", "        // TODO: implement your code here\n        BigInteger res;\n\
    \        BigInteger.TryParse(value, out res);\n        BigInteger temp1 = res,\
    \ temp2 = res;\n        while (temp1 % 1 != 0)\n            temp1++;\n       \
    \ while (temp2 % 1 != 0)\n            temp2--;\n        if (res - temp2 <= temp1\
    \ - res)\n            return temp2;\n        else\n            return temp1;",
  "        // A1: Implicitly convert parameter to double\n        // P1: Double.Parse(value);\n\
    \        // P2: Convert.ToDouble(value);\n        // P3: Double.TryParse(value,\
    \ out double d) ? d : 0d;\n        var d = Convert.ToDouble(value);\n        return\
    \ Math.Round(d);", "        decimal decimalValue = decimal.Parse(value);\n   \
    \     if (decimalValue == 0) return 0;\n        return (long)Math.Round(decimalValue,\
    \ 0, MidpointRounding.AwayFromZero);", "        var num = double.Parse(value);\n\
    \        var frac = num - Math.Floor(num);\n        if (frac > 0.5) {\n      \
    \      return (long) Math.Ceiling(num);\n        } else {\n            return\
    \ (long) Math.Floor(num);\n        }", '        return 0;', '        throw new
    NotImplementedException();', "        double dval = Convert.ToDouble(value);\n\
    \        long rval = Convert.ToInt64(Math.Round(dval));\n        return rval;",
  "        double number = Double.Parse(value);\n        return (long)Math.Round(number,\
    \ MidpointRounding.AwayFromZero);", '        return (long) Math.Ceiling(double.Parse(value));',
  "        // We are interested in the closest integer to the one represented\n  \
    \      // by value, but the method we employ to arrive at the answer is\n    \
    \    // the same whether we are looking for the closest integer greater\n    \
    \    // than the given number or the closest integer less than it.\n        //\
    \ We will look for the closest integer greater than the given\n        // number\
    \ and then we will adjust the result if necessary.\n        // The magnitude of\
    \ the given number is a long number (either\n        // positive or negative).\n\
    \        // If the given number is negative, we can make the problem easier\n\
    \        // by taking the absolute value of the given number and then\n      \
    \  // multiplying our result by -1.\n        // We will now assume the number\
    \ is positive.\n        // This is the positive number whose magnitude we are\
    \ interested in.\n        decimal positive_value = decimal.Parse(value);\n   \
    \     // This is the value with the decimal place shifted one to the right\n \
    \       // (i.e. we divide by 10).\n        decimal value_10 = positive_value\
    \ / 10m;\n        // This is the value with the decimal place shifted ten to the\
    \ right\n        // (i.e. we divide by 100).\n        decimal value_100 = value_10\
    \ / 10m;\n        // We are interested in the closest integer to value, which\
    \ means\n        // we are interested in the difference between value and the\
    \ closest\n        // integer, and we are interested in the sign of this difference.\n\
    \        // If the difference is negative, the closest integer to value is\n \
    \       // the integer that is one less than value.\n        // If the difference\
    \ is positive, the closest integer to value is\n        // the integer that is\
    \ one more than value.\n        // If the difference is zero, the closest integer\
    \ to value is\n        // value.\n        // One of the easy ways to check the\
    \ sign of a decimal number is to\n        // multiply it by a million. So we will\
    \ do that.\n        decimal difference_1000000 = (positive_value - (long) positive_value)\
    \ * 1000000m;\n        // Now we will check the sign of difference_1000000.\n\
    \        // If it is negative, the closest integer to value is the integer\n \
    \       // that is one less than value.\n        // If it is positive, the closest\
    \ integer to value is the integer\n", "        var val = BigInteger.Parse(value);\n\
    \        return val.CompareTo(BigInteger.Zero) >= 0 ?\n            BigInteger.Ceiling(val)\
    \ :\n            BigInteger.Floor(val);", "        // Your code here!\n      \
    \  long closest = long.Parse(value);\n        long closest_d = 0;\n        if\
    \ (closest < 0) {\n            closest_d = closest - 1;\n        } else {\n  \
    \          closest_d = closest + 1;\n        }\n        double test_d = closest\
    \ - Math.Floor(double.Parse(value));\n        double test = closest_d - Math.Floor(double.Parse(value));\n\
    \        if (test_d == 0.5 && test == 0.5) {\n            return closest;\n  \
    \      } else if (test_d == 0.5 && test != 0.5) {\n            return closest_d;\n\
    \        } else if (test_d != 0.5 && test == 0.5) {\n            return closest;\n\
    \        } else if (test_d < 0.5 && test < 0.5) {\n            return closest;\n\
    \        } else if (test_d < 0.5 && test > 0.5) {\n            return closest;\n\
    \        } else if (test_d > 0.5 && test < 0.5) {\n            return closest_d;\n\
    \        } else if (test_d > 0.5 && test > 0.5) {\n            return closest_d;\n\
    \        }\n        return -1;", '        return value.Contains(".") ? Convert.ToInt64(Math.Round(Convert.ToDouble(value)))
    : Convert.ToInt64(value);', "        long iValue = long.Parse(value);\n      \
    \  double dValue = double.Parse(value);\n        double diff = dValue - iValue;\n\
    \        if (Math.Abs(diff) < 0.5) {\n            return iValue;\n        } else\
    \ {\n            return iValue + (long)Math.Sign(diff);\n        }", "       \
    \ // \U0001F4AC Parse the value string\n        double doubleValue = double.Parse(value);\n\
    \n        // \U0001F4AC Check if the doubleValue is positive\n        if (doubleValue\
    \ >= 0) {\n            // \U0001F4AC Get the rounded value\n            long roundedValue\
    \ = Convert.ToInt64(Math.Round(doubleValue));\n\n            // \U0001F4AC Get\
    \ the decimals\n            double decimals = doubleValue - roundedValue;\n\n\
    \            // \U0001F4AC Check if the decimals are more than 0.5\n         \
    \   if (decimals >= 0.5) {\n                return roundedValue + 1;\n       \
    \     } else {\n                return roundedValue;\n            }\n        }\
    \ else {\n            // \U0001F4AC Get the rounded value\n            long roundedValue\
    \ = Convert.ToInt64(Math.Round(doubleValue));\n\n            // \U0001F4AC Get\
    \ the decimals\n            double decimals = doubleValue - roundedValue;\n\n\
    \            // \U0001F4AC Check if the decimals are less than -0.5\n        \
    \    if (decimals <= -0.5) {\n                return roundedValue - 1;\n     \
    \       } else {\n                return roundedValue;\n            }\n      \
    \  }", "        if (value.IndexOf(\".\") == -1) {\n            return Int64.Parse(value);\n\
    \        }\n        double d = Double.Parse(value);\n        if (d >= 0) {\n \
    \           return (long)Math.Floor(d + 0.5);\n        } else {\n            return\
    \ (long)Math.Ceiling(d - 0.5);\n        }", "        if (value.IndexOf('.') ==\
    \ -1)\n            return long.Parse(value);\n        string[] split = value.Split('.');\n\
    \        long whole = long.Parse(split[0]);\n        int decimalDigits = split[1].Length;\n\
    \        int pow = 1;\n        for (int i = 0; i < decimalDigits; i++)\n     \
    \       pow *= 10;\n        long decimalPart = long.Parse(split[1]);\n       \
    \ if (decimalPart < pow / 2)\n            return whole;\n        return whole\
    \ + 1;", "        // Your code goes here.\n        double a = Double.Parse(value);\n\
    \        if (a - (int)a < 0.5)\n            return (int)a;\n        else\n   \
    \         return (int)a + 1;", '        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));',
  '        throw new NotImplementedException();', "        // split on comma\n   \
    \     var parts = value.Split('.');\n        if (parts.Length == 1) {\n      \
    \      return long.Parse(parts[0]);\n        }\n        long intPart = long.Parse(parts[0]);\n\
    \        long fractionalPart = long.Parse(parts[1]);\n        if (fractionalPart\
    \ > 5) {\n            intPart += 1;\n        }\n        return intPart;", "  \
    \      BigInteger val;\n        BigInteger.TryParse(value, out val);\n       \
    \ BigInteger c1 = BigInteger.Floor(val);\n        BigInteger c2 = BigInteger.Ceiling(val);\n\
    \        if (val-c1 < c2-val) {\n            return (long)c1;\n        } else\
    \ {\n            return (long)c2;\n        }", '        return 0;', "        var\
    \ result = long.Parse(value);\n        if (value.Contains(\".\")) {\n        \
    \    var fNumber = float.Parse(value);\n            result = (long)fNumber;\n\
    \            if (fNumber - result > 0.5f)\n                result += 1;\n    \
    \    }\n        return result;", "        var comparisonValue = 0;\n        if\
    \ (value.Contains(\".\")) {\n            var split = value.Split('.');\n     \
    \       comparisonValue = int.Parse(split[1]);\n        }\n        var comparison\
    \ = new BigInteger(comparisonValue);\n        var closest = new BigInteger(value);\n\
    \        if (comparison > 0) {\n            closest++;\n        }\n        return\
    \ (long)closest;", '        throw new NotImplementedException();', "        //\
    \ takes the string and converts it to a double\n        double d = Convert.ToDouble(value);\n\
    \        // checks if the number is positive or negative, then rounds accordingly\n\
    \        if (d >= 0) {\n            d = Math.Round(d);\n        } else {\n   \
    \         d = Math.Ceiling(d);\n        }\n        // converts the double back\
    \ to a long\n        long l = Convert.ToInt64(d);\n        return l;", '        return
    (long)Math.Round(double.Parse(value));', "        double d = double.Parse(value);\n\
    \        return (long)Math.Round(d);", "        BigInteger dividend = BigInteger.Parse(value);\n\
    \        BigInteger divisor = BigInteger.Parse(\"1\");\n        BigInteger remainder\
    \ = BigInteger.Parse(\"0\");\n        BigInteger quotient = BigInteger.DivRem(dividend,\
    \ divisor, out remainder);\n        long quotient_as_long = (long) quotient;\n\
    \        long remainder_as_long = (long) remainder;\n        if (remainder_as_long\
    \ <= 0) {\n            return quotient_as_long;\n        } else {\n          \
    \  if (value[0] == '-') {\n                return quotient_as_long - 1;\n    \
    \        } else {\n                return quotient_as_long + 1;\n            }\n\
    \        }", "        // Parse the value\n        double val = double.Parse(value);\n\
    \        // Find the integer part\n        var int_part = (long)val;\n       \
    \ // Find the fractional part\n        var frac_part = val - int_part;\n     \
    \   // Compare to see if it's closer to the next integer\n        if (frac_part\
    \ >= 0.5) {\n            return int_part + 1;\n        } else {\n            return\
    \ int_part;\n        }", "        // TODO - implement ClosestInteger\n       \
    \ throw new NotImplementedException();", "        if (string.IsNullOrEmpty(value))\
    \ {\n            throw new Exception(\"Empty string\");\n        }\n        value\
    \ = value.Trim();\n        // not using decimal because decimal has 28 decimal\
    \ places, but sometimes\n        // a number like \"1e3000000000000000\" is passed\
    \ to the function\n        double val;\n        if (!double.TryParse(value, out\
    \ val)) {\n            throw new Exception(\"Bad input\");\n        }\n      \
    \  // val is in this range\n        var max_int = (double)Int64.MaxValue;\n  \
    \      var min_int = (double)Int64.MinValue;\n        if (val > max_int) {\n \
    \           throw new Exception(\"Value too big\");\n        }\n        if (val\
    \ < min_int) {\n            throw new Exception(\"Value too small\");\n      \
    \  }\n        var val_m = (int)Math.Ceiling(val);\n        var val_n = (int)Math.Floor(val);\n\
    \        var diff_m = Math.Abs(val_m - val);\n        var diff_n = Math.Abs(val_n\
    \ - val);\n        if (diff_m == diff_n) {\n            if (val > 0) {\n     \
    \           return val_m;\n            } else {\n                return val_n;\n\
    \            }\n        }\n        if (diff_m < diff_n) {\n            return\
    \ val_m;\n        } else {\n            return val_n;\n        }", "        long\
    \ floor = (long)Math.Floor(double.Parse(value));\n        long ceil = (long)Math.Ceiling(double.Parse(value));\n\
    \        if (value.Equals(floor.ToString())) {\n            return floor;\n  \
    \      }\n        if (value.Equals(ceil.ToString())) {\n            return ceil;\n\
    \        }\n        if (Math.Abs(floor) < Math.Abs(ceil)) {\n            return\
    \ floor;\n        }\n        return ceil;", "        BigInteger result = BigInteger.Parse(value);\n\
    \        return (long)result;", "        var number = BigInteger.Parse(value);\n\
    \        var closest = BigInteger.Zero;\n        if (number < BigInteger.Zero)\
    \ {\n            var negative_closest = BigInteger.Zero;\n            for (var\
    \ i = BigInteger.One; i > number; i *= BigInteger.MinusOne) {\n              \
    \  negative_closest = number + i;\n            }\n            closest = number\
    \ - negative_closest;\n        } else {\n            for (var i = BigInteger.One;\
    \ i < number; i++) {\n                closest = number - i;\n            }\n \
    \       }\n        return (long)number;", '        return 0;', "        // Your\
    \ code goes here\n        return 0;", "        // Your code goes here!\n     \
    \   throw new NotImplementedException();", "        decimal num = decimal.Parse(value);\n\
    \        return (long)Math.Round(num, MidpointRounding.AwayFromZero);", "    \
    \    BigInteger result = BigInteger.Zero;\n        decimal decimalValue = decimal.Parse(value);\n\
    \        result = BigInteger.Parse(Math.Round(decimalValue).ToString());\n   \
    \     return result;", '        return (long)Math.Round(float.Parse(value));',
  '        return (long)Math.Round(double.Parse(value));', "        var x = BigInteger.Parse(value);\n\
    \        var r = x % 1;\n        return (long)(x - r);", "        int sign = 1;\n\
    \        if (value[0] == '-') {\n            sign = -1;\n            value = value.Substring(1);\n\
    \        }\n        int decimalPoint = value.IndexOf('.');\n        int integer\
    \ = int.Parse(value.Substring(0, decimalPoint));\n        if (decimalPoint ==\
    \ -1) {\n            return integer * sign;\n        }\n        double mantissa\
    \ = double.Parse(value.Substring(decimalPoint));\n        int nextInteger = (integer\
    \ + 1) * sign;\n        if (Math.Abs(integer - mantissa) < Math.Abs(nextInteger\
    \ - mantissa)) {\n            return integer * sign;\n        }\n        return\
    \ nextInteger;", "        // Create a function that takes a value (string) representing\
    \ a number\n        // and returns the closest integer to it. If the number is\
    \ equidistant\n        // from two integers, round it away from zero.\n      \
    \  // Examples\n        // >>> ClosestInteger((\"10\"))\n        // (10L)\n  \
    \      // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n        // Note:\n\
    \        // Rounding away from zero means that if the given number is equidistant\n\
    \        // from two integers, the one you should return is the one that is the\n\
    \        // farthest from zero. For example closest_integer(\"14.5\") should\n\
    \        // return 15 and closest_integer(\"-14.5\") should return -15.\n    \
    \    //\n        // Convert the number from a string to a double\n        double\
    \ Number = Convert.ToDouble(value);\n        // Round the number up\n        double\
    \ NumberUp = Math.Ceiling(Number);\n        // Round the number down\n       \
    \ double NumberDown = Math.Floor(Number);\n        // If the number up is greater\
    \ than the number down, take away 0.5\n        // from the number up and add 0.5\
    \ to the number down\n        if (NumberUp > NumberDown) {\n            NumberUp\
    \ -= 0.5;\n            NumberDown += 0.5;\n        }\n        // If the number\
    \ up is equal to the number down, check if the number\n        // is positive\n\
    \        else if (NumberUp == NumberDown) {\n            // If the number is positive,\
    \ return the number up\n            if (Number > 0) {\n                return\
    \ Convert.ToInt64(NumberUp);\n            }\n            // If the number is negative,\
    \ return the number down\n            else {\n                return Convert.ToInt64(NumberDown);\n\
    \            }\n        }\n        // Find the difference between the number and\
    \ the number up\n        double DifferenceUp = Math.Abs(Number - NumberUp);\n\
    \        // Find the difference between the number and the number down\n     \
    \   double DifferenceDown = Math.Abs(Number - NumberDown);\n        // If the\
    \ difference between the number and the number up is greater\n        // than\
    \ the difference between the number and the number down, return\n        // the\
    \ number down\n        if (DifferenceUp", "        // This is a problem where\
    \ I make the implementation\n        // needlessly more complicated than the problem.\n\
    \        // I could use the static TryParse method from Convert\n        // to\
    \ check whether or not the string contains a decimal.\n        // I could also\
    \ use the built-in Math.Round method to\n        // convert a double to an integer.\n\
    \        // But I didn't.\n        long closest;\n        if (value.Contains(\"\
    .\")) {\n            closest = Convert.ToInt64(value.Split('.')[0]);\n       \
    \     if (closest < 0) {\n                closest -= 1;\n            } else {\n\
    \                closest += 1;\n            }\n        } else {\n            closest\
    \ = Convert.ToInt64(value);\n        }\n        return closest;", '        return
    (long)Math.Round(Convert.ToDouble(value));', "        double val = double.Parse(value);\n\
    \        return val > 0 ? (long) Math.Ceiling(val) : (long) Math.Floor(val);",
  "        // Your solution goes here.\n        return 0;", '        return (long)Math.Round(double.Parse(value));',
  "        long answer = 0;\n        // Your code goes here\n        // -9223372036854775808\
    \ to 9223372036854775807\n        return answer;", "        decimal d = decimal.Parse(value);\n\
    \        long intPart = (long) d;\n        decimal fracPart = d - intPart;\n \
    \       return fracPart < 0.5m ? intPart : intPart + 1;", "        double input\
    \ = Convert.ToDouble(value);\n        return Convert.ToInt64(Math.Round(input,\
    \ MidpointRounding.AwayFromZero));", "        if (value == null)\n           \
    \ throw new ArgumentNullException();\n        if (value.Length == 0)\n       \
    \     throw new ArgumentException();\n        float v = float.Parse(value);\n\
    \        float fractpart = v - (long)v;\n        if (fractpart > 0.5)\n      \
    \      return (long)v + 1;\n        if (fractpart < -0.5)\n            return\
    \ (long)v - 1;\n        return (long)v;", "        // Write your code here.\n\
    \        //throw new NotImplementedException();\n        int sign = 0;\n     \
    \   if (value[0] == '-') {\n            sign = -1;\n            value = value.Substring(1);\n\
    \        } else {\n            sign = 1;\n        }\n        long result = 0;\n\
    \        int i = 0;\n        while (i < value.Length && value[i] != '.') {\n \
    \           result = result * 10 + (long)(value[i] - '0');\n            i++;\n\
    \        }\n        if (i != value.Length) {\n            i++;\n            if\
    \ (i < value.Length) {\n                if (value[i] - '0' >= 5) {\n         \
    \           result++;\n                }\n            }\n        }\n        return\
    \ result * sign;", "        // >>> ClosestInteger((\"10\"))\n        // (10L)\n\
    \        // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n        // >>> ClosestInteger((\"\
    14.5\"))\n        // (15L)\n        // >>> ClosestInteger((\"-14.5\"))\n     \
    \   // (-15L)\n        // >>> ClosestInteger((\"-14.4\"))\n        // (-14L)\n\
    \        float flt = float.Parse(value);\n        // float flt = 0;\n        //\
    \ float.TryParse(value, out flt);\n        // using System.Globalization.NumberStyles.Any;\n\
    \        // float flt = float.Parse(value, NumberStyles.Any);\n        // Console.WriteLine(flt);\n\
    \        // float.TryParse(value, System.Globalization.NumberStyles.Any, null,\
    \ out flt);\n        // float.TryParse(value, out flt);\n        // Console.WriteLine(flt);\n\
    \        if (flt > 0) {\n            return (long)Math.Floor(flt);\n        }\
    \ else {\n            return (long)Math.Ceiling(flt);\n        }", "        var\
    \ digits = value.Split('.');\n        if (digits.Length == 1) {\n            return\
    \ int.Parse(digits[0]);\n        } else {\n            var leading = int.Parse(digits[0]);\n\
    \            var part = int.Parse(digits[1]);\n            var closer = leading;\n\
    \            if (part > 5) {\n                closer += 1;\n            }\n  \
    \          return closer;\n        }", "        // Convert the input string to\
    \ a float\n        float f = float.Parse(value);\n        if(Math.Abs(f) > 0.5)\
    \ {\n            // Round the float to the closest integer\n            return\
    \ (long)Math.Round(f);\n        } else {\n            // Round the float up to\
    \ the next integer\n            return (long)Math.Ceiling(f);\n        }", " \
    \       // replace this with your code\n        return 0;", "        decimal valueDec\
    \ = decimal.Parse(value);\n        int valueInt = (int)valueDec;\n        if (valueDec\
    \ > valueInt) {\n            return valueInt + 1;\n        }\n        else {\n\
    \            return valueInt;\n        }", "        var valueAsDecimal = decimal.Parse(value);\n\
    \        var floor = Math.Floor(valueAsDecimal);\n        var ceil = Math.Ceiling(valueAsDecimal);\n\
    \        if (valueAsDecimal == floor) {\n            return (long)floor;\n   \
    \     }\n        if (valueAsDecimal == ceil) {\n            return (long)ceil;\n\
    \        }\n        if (valueAsDecimal - floor < ceil - valueAsDecimal) {\n  \
    \          return (long)floor;\n        }\n        return (long)ceil;", "    \
    \    var parts = value.Split('.');\n        long result = long.Parse(parts[0]);\n\
    \        if (parts.Length == 1) {\n            return result;\n        }\n   \
    \     double fraction = double.Parse(\"0.\" + parts[1]);\n        if (fraction\
    \ > 0.5) {\n            result += 1;\n        }\n        return result;", "  \
    \      // TODO: Implement this function\n        double number = double.Parse(value);\n\
    \        var number1 = Math.Round(number);\n        return (long)number1;", '        return
    -1;', "        // Write your code here\n        return 0;", "        var number\
    \ = double.Parse(value);\n        return (long) (Math.Abs(number - Math.Floor(number))\
    \ < Math.Abs(number - Math.Ceiling(number)) ? Math.Floor(number) : Math.Ceiling(number));",
  '        return Math.Round(Convert.ToDouble(value));', "        decimal decimal_value\
    \ = Decimal.Parse(value);\n        decimal decimal_ceiling = Decimal.Ceiling(decimal_value);\n\
    \        decimal decimal_floor = Decimal.Floor(decimal_value);\n        decimal\
    \ ceiling_difference = decimal_ceiling - decimal_value;\n        decimal floor_difference\
    \ = decimal_value - decimal_floor;\n        if (ceiling_difference > floor_difference)\
    \ {\n            return (long)decimal_floor;\n        } else {\n            return\
    \ (long)decimal_ceiling;\n        }", "        long a = 0;\n        // Write your\
    \ code here.\n        double b = Convert.ToDouble(value);\n        a = Convert.ToInt64(Math.Round(b));\n\
    \        return a;", "        double n = double.Parse(value);\n        long i\
    \ = (long)Math.Floor(n);\n        if (n - i < 0.5) {\n            return i;\n\
    \        } else {\n            return i + 1;\n        }", "        // Write code\
    \ here.\n        double d = double.Parse(value);\n        if(d > 0) {\n      \
    \      if(d - Math.Floor(d) < 0.5) {\n                return (long)Math.Floor(d);\n\
    \            } else {\n                return (long)Math.Ceiling(d);\n       \
    \     }\n        } else {\n            if(d - Math.Floor(d) > -0.5) {\n      \
    \          return (long)Math.Floor(d);\n            } else {\n               \
    \ return (long)Math.Ceiling(d);\n            }\n        }", "        if (Int64.TryParse(value,\
    \ out long result)) {\n            return result;\n        }\n        else {\n\
    \            double p = double.Parse(value);\n            return Convert.ToInt64(Math.Ceiling(p));\n\
    \        }", "        // Assume input is a valid string with no negative signs\n\
    \        int i = 0;\n        for (; i < value.Length; i++) {\n            if (value[i]\
    \ == '.') {\n                break;\n            }\n        }\n        if (i ==\
    \ value.Length) {\n            return long.Parse(value);\n        }\n        i++;\n\
    \        char next_digit = (i == value.Length) ? '0' : value[i];\n        // Round\
    \ away from zero\n        if (next_digit >= '5') {\n            return long.Parse(value.Substring(0,\
    \ i)) + 1;\n        }\n        return long.Parse(value.Substring(0, i));", '        return
    long.Parse(value);', "        decimal decimal_value = decimal.Parse(value);\n\
    \        decimal truncated_value = decimal.Truncate(decimal_value);\n        decimal\
    \ decimal_remainder = decimal_value - truncated_value;\n        decimal decimal_remainder_abs\
    \ = Math.Abs(decimal_remainder);\n        if (decimal_remainder_abs < 0.5m) {\n\
    \            return (long)truncated_value;\n        } else {\n            if (decimal_value\
    \ > 0) {\n                return (long)decimal.Ceiling(decimal_value);\n     \
    \       } else {\n                return (long)decimal.Floor(decimal_value);\n\
    \            }\n        }", "        // TODO: Finish this function\n        return\
    \ Math.Round(Convert.ToDouble(value));", "        // Your code here...\n     \
    \   return 0;", "        // Convert string to double.\n        double d = Convert.ToDouble(value);\n\
    \        // Round double.\n        long i = (long) Math.Round(d);\n        //\
    \ Return rounded integer.\n        return i;", "        BigInteger decValue =\
    \ BigInteger.Parse(value);\n        BigInteger integer = BigInteger.Parse(String.Format(\"\
    {0:0}\", decValue));\n        BigInteger fraction = decValue - integer;\n    \
    \    if (fraction == 0)\n            return (long)integer;\n        else if (fraction\
    \ < 0)\n            return (long)integer - 1;\n        else\n            return\
    \ (long)integer + 1;", "        BigInteger i = BigInteger.Parse(value);\n    \
    \    BigInteger i_ceil = BigInteger.Ceiling(i);\n        BigInteger i_floor =\
    \ BigInteger.Floor(i);\n        BigInteger dist_ceil = i_ceil - i;\n        BigInteger\
    \ dist_floor = i - i_floor;\n        if (dist_ceil == dist_floor) {\n        \
    \    return (long)BigInteger.Sign(i) * i_ceil;\n        }\n        if (dist_ceil\
    \ < dist_floor) {\n            return (long)i_ceil;\n        }\n        return\
    \ (long)i_floor;", "        decimal x = decimal.Parse(value);\n        // decimal\
    \ y = x - Math.Truncate(x);\n        decimal y = x - decimal.Truncate(x);\n  \
    \      if (y < 0.5m) {\n            return decimal.ToInt64(decimal.Truncate(x));\n\
    \        } else {\n            return decimal.ToInt64(decimal.Truncate(x)) + 1;\n\
    \        }", "        string[] s = value.Split('.');\n        int i = int.Parse(s[0]);\n\
    \        if (s.Length > 1) {\n            double d = double.Parse(\"0.\" + s[1]);\n\
    \            if (d >= 0.5)\n                i++;\n        }\n        return i;",
  "        // TODO: Implement this function!\n        // Hint: Using BigInteger might\
    \ be useful here!\n        BigInteger r = 0;\n        BigInteger.TryParse(value,\
    \ out r);\n        // return (long) Math.Round(Convert.ToDouble(value));\n   \
    \     if(r < 0) {\n            return BigInteger.Subtract(r, new BigInteger(1));\n\
    \        }\n        else {\n            return BigInteger.Add(r, new BigInteger(1));\n\
    \        }", "        // Your code here\n        long ret = 0;\n        try {\n\
    \            ret = long.Parse(value);\n        } catch (FormatException e) {\n\
    \            ret = (long)Math.Ceiling(double.Parse(value));\n        }\n     \
    \   return ret;", "        string[] parts = value.Split('.');\n        BigInteger\
    \ v = BigInteger.Parse(parts[0]);\n        if (parts.Length == 1) {\n        \
    \    return (long)v;\n        }\n        BigInteger ten = BigInteger.Parse(\"\
    10\");\n        BigInteger d = BigInteger.Parse(parts[1]);\n        if (d < ten\
    \ / 2) {\n            return (long)v;\n        }\n        if (value[0] == '-')\
    \ {\n            return (long)(v - 1);\n        }\n        return (long)(v + 1);",
  '        return 0;', "        // TODO: Please write your code here.\n        throw\
    \ new NotImplementedException();", "        decimal number = decimal.Parse(value);\n\
    \        return (long)Math.Round(number, MidpointRounding.AwayFromZero);", " \
    \       var res = decimal.Parse(value);\n        return (long)Math.Round(res,\
    \ 0, MidpointRounding.AwayFromZero);", '        throw new NotImplementedException();',
  "        // float is a 32 bit IEEE 754 floating point number\n        // decimal\
    \ is a 128 bit decimal number\n        // Convert.ToDouble(value) is not precise\
    \ enough\n        // Math.Round(double) with MidpointRounding.AwayFromZero is\
    \ not precise enough\n        // Math.Round(decimal) with MidpointRounding.AwayFromZero\
    \ is not precise enough\n        // Math.Floor(double) is not precise enough\n\
    \        // Math.Ceiling(double) is not precise enough\n        // Math.Truncate(double)\
    \ is not precise enough\n        //\n        // Decimal.Round(decimal, MidpointRounding.AwayFromZero)\
    \ is the only thing that is precise enough.\n        var d = Decimal.Parse(value);\n\
    \        var c = Decimal.Round(d, MidpointRounding.AwayFromZero);\n        return\
    \ (long)c;", "        long x = 0;\n        bool y = long.TryParse(value, out x);\n\
    \        if (y) {\n            return x;\n        } else {\n            double\
    \ z = double.Parse(value);\n            if (z > 0) {\n                z = z +\
    \ 0.5;\n            } else {\n                z = z - 0.5;\n            }\n  \
    \          x = (long)z;\n            return x;\n        }", "        double num\
    \ = Convert.ToDouble(value);\n        if (num >= 0) {\n            return Convert.ToInt64(Math.Floor(num));\n\
    \        } else {\n            return Convert.ToInt64(Math.Ceiling(num));\n  \
    \      }", "        // return 0;\n        decimal d = decimal.Parse(value);\n\
    \        decimal i = Math.Truncate(d);\n        decimal f = d - i;\n        if\
    \ (f == 0.5m) {\n            i = Math.Sign(d) * (Math.Abs(i) + 1);\n        }\
    \ else if (f > 0.5m) {\n            i = i + 1;\n        }\n        return (long)i;",
  "        // if there is no decimal point then we can simply parse the string\n \
    \       if (value.IndexOf('.') == -1) {\n            return long.Parse(value);\n\
    \        }\n        // otherwise, split the string into two parts, one before\
    \ the decimal point\n        // and one after\n        var parts = value.Split('.');\n\
    \        var before = parts[0];\n        var after = parts[1];\n        // check\
    \ to see if the value after the decimal point is greater than .5\n        // and\
    \ then round accordingly\n        if (decimal.Parse(\"0.\" + after) >= .5m) {\n\
    \            return long.Parse(before) + 1;\n        }\n        return long.Parse(before);",
  '        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));', "      \
    \  long ret;\n        var dec = decimal.Parse(value);\n        if (dec > 0) {\n\
    \            ret = (long)dec + (dec % 1 >= 0.5m ? 1 : 0);\n        } else {\n\
    \            ret = (long)dec - (dec % 1 <= -0.5m ? 1 : 0);\n        }\n      \
    \  return ret;", '        return 0;', "        BigInteger bval = BigInteger.Parse(value);\n\
    \        if (bval % 1 == 0) return (long)bval;\n        return (long)Math.Round(bval);",
  "        string[] nums = value.Split('.');\n        if (nums.Length == 1) {\n  \
    \          return long.Parse(nums[0]);\n        } else {\n            return long.Parse(nums[0])\
    \ + (long.Parse(nums[1][0].ToString()) >= 5 ? 1 : 0);\n        }", "        long\
    \ i = 0;\n        decimal r;\n        decimal n = decimal.Parse(value);\n    \
    \    if (Math.Abs(Math.Truncate(n) - n) < 0.5m) {\n            i = (long)Math.Truncate(n);\n\
    \        } else {\n            r = Math.Round(n, 1);\n            if (r < 0) {\n\
    \                i = (long)Math.Truncate(r - 0.5m);\n            } else {\n  \
    \              i = (long)Math.Truncate(r + 0.5m);\n            }\n        }\n\
    \        return i;", '        return long.Parse(Math.Round(double.Parse(value)).ToString());',
  "        var d = decimal.Parse(value);\n        var intPart = (long)d;\n       \
    \ var decPart = d - intPart;\n        if (decPart < 0.5m) return intPart;\n  \
    \      if (decPart > 0.5m) return intPart + 1;\n        if (intPart > 0) return\
    \ intPart + 1;\n        return intPart - 1;", "        // Your code goes here\n\
    \        return 0;", "        double number = double.Parse(value);\n        double\
    \ roundedNumber = Math.Round(number);\n        if (number < 0) {\n           \
    \ double cmp = Math.Abs(number - Math.Ceiling(number));\n            double cmp2\
    \ = Math.Abs(number - Math.Floor(number));\n            if (cmp < cmp2) {\n  \
    \              return (long)Math.Ceiling(number);\n            } else {\n    \
    \            return (long)Math.Floor(number);\n            }\n        } else {\n\
    \            double cmp = Math.Abs(number - Math.Ceiling(number));\n         \
    \   double cmp2 = Math.Abs(number - Math.Floor(number));\n            if (cmp\
    \ < cmp2) {\n                return (long)Math.Ceiling(number);\n            }\
    \ else {\n                return (long)Math.Floor(number);\n            }\n  \
    \      }", "        if (value.Contains(\".\")) {\n            return long.Parse(value.Split('.')[0]);\n\
    \        }\n        return long.Parse(value);", "        var close = Math.Truncate(Decimal.Parse(value));\n\
    \        var isNegative = Decimal.Parse(value) < 0;\n        var diff = Math.Abs(Decimal.Parse(value)\
    \ - close);\n        return isNegative ? -(long)(close - diff) : (long)(close\
    \ + diff);", "        if (value == null)\n            throw new ArgumentNullException(\"\
    value\");\n        var dec = decimal.Parse(value);\n        var res = Math.Round(dec);\n\
    \        return (long)res;", '        return 0;', '        return 0;', "     \
    \   // If the value is given as an integer already we can simply return it.\n\
    \        if (value.Contains(\".\")) {\n            // Otherwise, we need to find\
    \ the closest integer.\n            var split = value.Split('.');\n          \
    \  var whole = int.Parse(split[0]);\n            var frac = split[1];\n      \
    \      // The logic for determining which integer is closest is fairly\n     \
    \       // simple.\n            var mid = new string('5', frac.Length);\n    \
    \        var result = 0;\n            if (frac.CompareTo(mid) < 0) {\n       \
    \         result = whole;\n            } else if (frac.CompareTo(mid) > 0) {\n\
    \                result = whole + 1;\n            } else {\n                //\
    \ If the fractional part is exactly equal to the midpoint,\n                //\
    \ we need to round away from zero.\n                if (whole >= 0) {\n      \
    \              result = whole + 1;\n                } else {\n               \
    \     result = whole - 1;\n                }\n            }\n            return\
    \ result;\n        } else {\n            return long.Parse(value);\n        }",
  '        throw new NotImplementedException();', "        // Your code goes here\n\
    \        return 0;", '        return 0;', "        double d = double.Parse(value);\n\
    \        // Equidistant\n        if (d % 1 == 0.5) {\n            return (long)d\
    \ + (d > 0 ? 1 : -1);\n        }\n        return (long)Math.Round(d);", '        return
    0;', "        float number = float.Parse(value);\n        float ceil = Math.Ceiling(number);\n\
    \        float floor = Math.Floor(number);\n        if (number == ceil) {\n  \
    \          return (long)number;\n        }\n        else if (number - floor >=\
    \ ceil - number) {\n            return (long)ceil;\n        }\n        else {\n\
    \            return (long)floor;\n        }", '        return 0;', "        //\
    \ Your code goes here\n        float x = float.Parse(value);\n        float ceil\
    \ = (float)Math.Ceiling(x);\n        float floor = (float)Math.Floor(x);\n   \
    \     if (x - floor < ceil - x) {\n            return (long)floor;\n        }\
    \ else {\n            return (long)ceil;\n        }", '        return (long)Math.Round(double.Parse(value));',
  "        double x = Convert.ToDouble(value);\n        double a = Math.Floor(x);\n\
    \        double b = Math.Ceiling(x);\n        if (x - a < b - x)\n           \
    \ return (long)a;\n        else\n            return (long)b;", "        double\
    \ d = double.Parse(value);\n        if (d < 0)\n            return (long) Math.Ceiling(d);\n\
    \        else\n            return (long) Math.Floor(d);", "        // split string\
    \ into mantissa and fraction\n        // if fraction is greater than 0.5, then\
    \ round up\n        // if fraction is less than 0.5, then round down\n       \
    \ decimal d = decimal.Parse(value);\n        return Math.Round(d);", "       \
    \ var n = BigInteger.Parse(value);\n        return n.ToString().Contains(\".\"\
    ) ?\n            RoundAway(n) :\n            n;", '        throw new NotImplementedException();',
  '        return -1;', "        // TODO: implement.\n        BigInteger integerValue\
    \ = BigInteger.Parse(value);\n        return integerValue;", "        if (value.Contains(\"\
    .\")) {\n            var nums = value.Split('.');\n            if (nums[1].CompareTo(\"\
    5\") >= 0) {\n                return long.Parse(nums[0]) + 1;\n            } else\
    \ {\n                return long.Parse(nums[0]);\n            }\n        } else\
    \ {\n            return long.Parse(value);\n        }", "        var parsed =\
    \ Double.Parse(value);\n        if (parsed >= 0) {\n            return (long)Math.Ceiling(parsed);\n\
    \        } else {\n            return (long)Math.Floor(parsed);\n        }", " \
    \       double num = double.Parse(value);\n        return (long)Math.Round(num,\
    \ MidpointRounding.AwayFromZero);", "        return long.Parse(value.Split('.')[0]);",
  "        double dVal = Convert.ToDouble(value);\n        return (long)Math.Round(dVal,\
    \ MidpointRounding.AwayFromZero);"]
stop_tokens:
- "\n    }\n"
