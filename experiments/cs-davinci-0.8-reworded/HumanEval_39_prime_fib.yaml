name: HumanEval_39_prime_fib
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // prime_fib returns n-th number that is a Fibonacci number and\
  \ it's also prime.\n    // >>> PrimeFib((1L))\n    // (2L)\n    // >>> PrimeFib((2L))\n\
  \    // (3L)\n    // >>> PrimeFib((3L))\n    // (5L)\n    // >>> PrimeFib((4L))\n\
  \    // (13L)\n    // >>> PrimeFib((5L))\n    // (89L)\n    public static long PrimeFib(long\
  \ n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(PrimeFib((1L))\
  \ == (2L));\n    Debug.Assert(PrimeFib((2L)) == (3L));\n    Debug.Assert(PrimeFib((3L))\
  \ == (5L));\n    Debug.Assert(PrimeFib((4L)) == (13L));\n    Debug.Assert(PrimeFib((5L))\
  \ == (89L));\n    Debug.Assert(PrimeFib((6L)) == (233L));\n    Debug.Assert(PrimeFib((7L))\
  \ == (1597L));\n    Debug.Assert(PrimeFib((8L)) == (28657L));\n    Debug.Assert(PrimeFib((9L))\
  \ == (514229L));\n    Debug.Assert(PrimeFib((10L)) == (433494437L));\n    }\n\n\
  }\n"
completions: ["        long a = 2;\n        long b = 3;\n        if (n == 1) {\n \
    \           return a;\n        }\n        if (n == 2) {\n            return b;\n\
    \        }\n        for (long i = 3; i <= n; i++) {\n            var tmp = a +\
    \ b;\n            a = b;\n            b = tmp;\n            if (IsPrime(b)) {\n\
    \                continue;\n            }\n            i--;\n        }\n     \
    \   return b;", "        // n-th number must be larger than n-th Fibonacci number\n\
    \        long fib = Fib(n);\n        // fib is always even except the first one\n\
    \        if (n >= 2) fib += fib & 1;\n        // loop until we find n-th prime\
    \ Fibonacci number\n        while (!IsPrime(fib)) fib += 2;\n        return fib;",
  "        var f = new Dictionary<long, BigInteger>();\n        BigInteger a = 2;\n\
    \        BigInteger b = 3;\n        BigInteger c = 0;\n        f[1] = a;\n   \
    \     f[2] = b;\n        long i = 2;\n        long ret = 0;\n        while (ret\
    \ == 0) {\n            c = a + b;\n            i++;\n            a = b;\n    \
    \        b = c;\n            if (isPrime(c)) {\n                ret = c;\n   \
    \         }\n        }\n        return ret;", "        long f1 = 2;\n        long\
    \ f2 = 3;\n        long m = 1;\n        while (m < n) {\n            long f3 =\
    \ f1 + f2;\n            f1 = f2;\n            f2 = f3;\n            if (f3 % 2\
    \ != 0 && IsPrime(f3)) {\n                m++;\n            }\n        }\n   \
    \     return f2;", "        long a = 2;\n        long b = 3;\n        long k =\
    \ 2;\n        for (int i = 0; i < n - 2; i++) {\n            var tmp = a + b;\n\
    \            a = b;\n            b = tmp;\n            if (IsPrime(b)) {\n   \
    \             k++;\n            }\n        }\n        return b;", "        long[]\
    \ f = new long[2000];\n        long s;\n        long i;\n        long j;\n   \
    \     long fn;\n        int count;\n        int c;\n        c = 0;\n        count\
    \ = 0;\n        fn = 1;\n        f[0] = 1;\n        f[1] = 1;\n        while (count\
    \ < n) {\n            fn = f[c] + f[c + 1];\n            f[c + 2] = fn;\n    \
    \        if (fn % 2 == 0) {\n                s = 2;\n                for (i =\
    \ 2; i < fn; i++) {\n                    if (fn % i == 0) {\n                \
    \        s = s + i;\n                    }\n                }\n              \
    \  if (s == fn) {\n                    j = f[c];\n                    f[c] = fn;\n\
    \                    f[c + 1] = j;\n                    count = count + 1;\n \
    \               }\n            }\n            c = c + 1;\n        }\n        return\
    \ f[c - 1];", "        long i;\n        for (i = 0; i < n; i++) {\n          \
    \  long a = i;\n            long b = i;\n            if (Fib(a, b).IsPrime())\
    \ {\n                break;\n            }\n        }\n        return Fib(i, i);",
  "        long a = 2;\n        long b = 3;\n        long c = 5;\n        int i =\
    \ 1;\n        while (i < n) {\n            // Advance c\n            if (IsPrime(c))\
    \ {\n                i++;\n            }\n            // Advance a, b, c\n   \
    \         a = b;\n            b = c;\n            c = a + b;\n        }\n    \
    \    return c;", "        var fib = new Fibonacci();\n        var primes = new\
    \ Primes();\n        long i = 1;\n        long fibnum = 0;\n        long primenum\
    \ = 0;\n        while (i <= n) {\n            fibnum = fib.Fib(i);\n         \
    \   if (primes.IsPrime(fibnum)) {\n                primenum = fibnum;\n      \
    \          i += 1;\n            }\n        }\n        return primenum;", "   \
    \     if (n < 1) {\n            throw new System.ArgumentException(\"n must be\
    \ greater than 0\", \"n\");\n        }\n        long found = 0;\n        long\
    \ f = 1;\n        long f_prev = 1;\n        while (found < n) {\n            var\
    \ next = f + f_prev;\n            f_prev = f;\n            f = next;\n       \
    \     if (IsPrime(f)) {\n                found += 1;\n            }\n        }\n\
    \        return f;", "        long index = 0;\n        long fn = 1;\n        long\
    \ fns = 1;\n        for (long i = 0; index < n; i++) {\n            fn = fn +\
    \ fns;\n            fns = fn - fns;\n            if (IsPrime(fn)) {\n        \
    \        index = index + 1;\n            }\n        }\n        return fn;", " \
    \       var Fib = new List<BigInteger>();\n        Fib.Add(0);\n        Fib.Add(1);\n\
    \        Fib.Add(1);\n        int count = 2;\n        while (count < n + 1) {\n\
    \            Fib.Add(Fib[count - 1] + Fib[count]);\n            if (BigInteger.ModPow(Fib[count],\
    \ 2, Fib[count + 1]) == 1) {\n                count++;\n            }\n      \
    \  }\n        return (long)Fib[count];", "        var fibIt = Fibonacci().GetEnumerator();\n\
    \        fibIt.MoveNext(); // move 1\n        fibIt.MoveNext(); // move 2\n  \
    \      long count = 0;\n        while (true) {\n            var fib = fibIt.Current;\n\
    \            fibIt.MoveNext();\n            if (IsPrime(fib))\n              \
    \  count++;\n            if (count == n)\n                return fib;\n      \
    \  }", "        long primefib = 0;\n        List<BigInteger> fiblist = new List<BigInteger>();\n\
    \        fiblist.Add(1);\n        fiblist.Add(1);\n        for (int i = 2; primefib\
    \ < n; i++) {\n            fiblist.Add(fiblist[i - 1] + fiblist[i - 2]);\n   \
    \         if (BigInteger.IsProbablePrime(fiblist[i])) {\n                primefib++;\n\
    \            }\n        }\n        return (long)fiblist[fiblist.Count - 1];",
  "        List<long> pl = PrimeNumbers();\n        var fibs = FibonacciNumbers();\n\
    \        var r = from f in fibs\n                from p in pl\n              \
    \  where f == p\n                select f;\n        return r.Skip((int)n - 1).First();",
  '        throw new NotImplementedException();', "        Func<BigInteger, BigInteger>\
    \ modpow = (x, y, m) => {\n            BigInteger res = 1, p = x;\n          \
    \  for (int i = 0; i < y; i++) {\n                res = (res * p) % m;\n     \
    \       }\n            return res;\n        };\n        Func<long, bool> isPrime\
    \ = (x) => {\n            if (x <= 1) {\n                return false;\n     \
    \       }\n            for (long i = 2; i * i <= x; i++) {\n                if\
    \ (x % i == 0) {\n                    return false;\n                }\n     \
    \       }\n            return true;\n        };\n        Func<long, long> Fib\
    \ = (x) => {\n            BigInteger nMinus1 = 1;\n            BigInteger nMinus2\
    \ = 0;\n            BigInteger n = 0;\n            for (long i = 1; i <= x; i++)\
    \ {\n                n = nMinus1 + nMinus2;\n                nMinus2 = nMinus1;\n\
    \                nMinus1 = n;\n            }\n            return (long)n;\n  \
    \      };\n        long counter = 0;\n        for (long i = 0; i < long.MaxValue;\
    \ i++) {\n            long f = Fib(i);\n            if (isPrime(f)) {\n      \
    \          counter++;\n                if (counter == n) {\n                 \
    \   return f;\n                }\n            }\n        }\n        return -1;",
  "        var p = new BigInteger[] { 2, 3 };\n        var k = 1;\n        var i =\
    \ 2;\n        while (k < n) {\n            var pp = p[0] + p[1];\n           \
    \ if (pp.IsProbablePrime(10)) {\n                p[i] = pp;\n                k\
    \ += 1;\n            }\n            i = (i + 1) % 2;\n        }\n        return\
    \ (long)p[i];", "        if (n <= 0) {\n            throw new ArgumentException(\"\
    n must be positive\");\n        }\n        if (n == 1) {\n            return 2;\n\
    \        }\n        if (n == 2) {\n            return 3;\n        }\n        long\
    \ f1 = 2;\n        long f2 = 3;\n        for (int i = 3; i <= n; i++) {\n    \
    \        long f3 = f1 + f2;\n            f1 = f2;\n            f2 = f3;\n    \
    \        while (!IsPrime(f2)) {\n                f2 += f1;\n            }\n  \
    \      }\n        return f2;", "        if (n < 1) {\n            throw new System.ArgumentException(\"\
    n must be greater than 0\", \"n\");\n        }\n        if (n == 1) {\n      \
    \      return 2;\n        }\n        if (n == 2) {\n            return 3;\n  \
    \      }\n        int count = 2;\n        BigInteger cur = 0;\n        BigInteger\
    \ prv = 2;\n        BigInteger old_prv = 1;\n        for (; ; ) {\n          \
    \  cur = prv + old_prv;\n            if (isPrime(cur)) {\n                count++;\n\
    \                if (count == n) {\n                    return (long)cur;\n  \
    \              }\n            }\n            old_prv = prv;\n            prv =\
    \ cur;\n        }", "        // we can memoize the result of this function because\
    \ the number of calls to it is at most\n        // len(input).\n        if (_memo.ContainsKey(n))\
    \ {\n            return _memo[n];\n        }\n        long result = -1;\n    \
    \    if (n == 1) {\n            result = 2;\n        } else if (n == 2) {\n  \
    \          result = 3;\n        } else {\n            int i = 2;\n           \
    \ long p1 = 2;\n            long p2 = 3;\n            while (true) {\n       \
    \         long cur = p1 + p2;\n                if (cur > 10000000000000000) {\n\
    \                    break;\n                }\n                if (is_prime(cur))\
    \ {\n                    i += 1;\n                    if (i == n) {\n        \
    \                result = cur;\n                        break;\n             \
    \       }\n                }\n                p1 = p2;\n                p2 = cur;\n\
    \            }\n        }\n        _memo[n] = result;\n        return result;",
  "        var list = new List<long>() { 2L, 3L };\n        var f1 = 2L;\n       \
    \ var f2 = 3L;\n        var f3 = 5L;\n        while (list.Count < n) {\n     \
    \       if (isPrime(f3)) {\n                list.Add(f3);\n            }\n   \
    \         f1 = f2;\n            f2 = f3;\n            f3 = f1 + f2;\n        }\n\
    \        return list[(int)n - 1];", "        var nthPrime = Primes.NthPrime(n);\n\
    \        return nthPrime;", "        long[] fib = new long[3];\n        fib[0]\
    \ = 1;\n        fib[1] = 1;\n        int i = 2;\n        while (true) {\n    \
    \        fib[i % 3] = fib[(i + 1) % 3] + fib[(i + 2) % 3];\n            if (IsPrime(fib[i\
    \ % 3])) {\n                n--;\n                if (n == 0) {\n            \
    \        return fib[i % 3];\n                }\n            }\n            i++;\n\
    \        }", "        BigInteger prev2 = 1;\n        BigInteger prev1 = 1;\n \
    \       BigInteger next;\n        for (var i = 3L; i <= n; i++) {\n          \
    \  next = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = next;\n\
    \        }\n        // prev1 = F(n), prev2 = F(n-1)\n        return (prev1 - prev2)\
    \ * (prev1 + prev2) - 1;", "        // Your code goes here\n        return 0;",
  "        long a = 1, b = 1, c;\n        for (long i = 0; i < n - 1; i++) {\n   \
    \         c = a + b;\n            a = b;\n            b = c;\n            if (!c.IsPrime())\
    \ {\n                continue;\n            }\n            yield return c;\n \
    \       }", "        long result = 0;\n        long a = 2;\n        long b = 3;\n\
    \        long c = 5;\n        while (n > 0) {\n            if (c.IsPrime()) {\n\
    \                n -= 1;\n                result = c;\n            }\n       \
    \     a = b;\n            b = c;\n            c = a + b;\n        }\n        return\
    \ result;", "        long a = 2;\n        long b = 3;\n        long c = 0;\n \
    \       for (int i = 3; i <= n; i++) {\n            c = a + b;\n            a\
    \ = b;\n            b = c;\n            while (c % 2 == 0) {\n               \
    \ c = a + b;\n                a = b;\n                b = c;\n            }\n\
    \        }\n        return c;", "        long a = 2;\n        long b = 3;\n  \
    \      long c = 5;\n        int i = 3;\n        while (true) {\n            if\
    \ (i == n) {\n                return c;\n            }\n            a = b;\n \
    \           b = c;\n            c = a + b;\n            i = i + 1;\n        }",
  "        long[] F = new long[10000];\n        F[0] = 1;\n        F[1] = 1;\n   \
    \     int i = 2;\n        while (i < 10000) {\n            F[i] = F[i - 1] + F[i\
    \ - 2];\n            i++;\n        }\n        i = 0;\n        long count = 0;\n\
    \        while (count < n) {\n            if (isPrime(F[i])) {\n             \
    \   count++;\n            }\n            i++;\n        }\n        return F[i -\
    \ 1];", "        Debug.Assert(n > 0L);\n        BigInteger a = 1L;\n        BigInteger\
    \ b = 1L;\n        BigInteger c = 2L;\n        BigInteger d = a + b;\n       \
    \ BigInteger i = 2L;\n        for (; ; ) {\n            if (i == n) {\n      \
    \          break;\n            }\n            if (d % c == 0L) {\n           \
    \     d += b;\n            }\n            else {\n                a = b;\n   \
    \             b = c;\n                c = d;\n                d = a + b;\n   \
    \             i += 1L;\n            }\n        }\n        return (long)c;", " \
    \       if (n < 0)\n            throw new Exception(\"n must be greater than 0\"\
    );\n        if (n == 0)\n            return 2;\n        long f1 = 1;\n       \
    \ long f2 = 2;\n        long fib = 3;\n        long counter = 2;\n        while\
    \ (counter < n) {\n            if (Euler.IsPrime(fib))\n                counter++;\n\
    \            long temp = f1;\n            f1 = f2;\n            f2 = fib;\n  \
    \          fib = f1 + temp;\n        }\n        return fib;", "        long[]\
    \ f = FibSeq(n);\n        long i = 0;\n        foreach (long x in f) {\n     \
    \       if (IsPrime(x)) {\n                if (i == n) {\n                   \
    \ return x;\n                }\n                i++;\n            }\n        }\n\
    \        return -1;", '        return _PrimeFib.nth(n);', "        long a = 2;\n\
    \        long b = 3;\n        long c = 5;\n        if (n < 3)\n            return\
    \ n > 0 ? 1 : 0;\n        while (n > 3) {\n            a = b;\n            b =\
    \ c;\n            c = a + b;\n            while (!IsPrime(c))\n              \
    \  c += b;\n            n--;\n        }\n        return c;", "        long Fib(long\
    \ n) {\n            BigInteger a = 0;\n            BigInteger b = 1;\n       \
    \     for (long i = 1; i < n; i++) {\n                BigInteger c = a + b;\n\
    \                a = b;\n                b = c;\n            }\n            return\
    \ (long)b;\n        }\n        long i = 1;\n        while (true) {\n         \
    \   long f = Fib(i);\n            if (f > 1000000000) {\n                throw\
    \ new Exception(\"f is too big\");\n            }\n            if (IsPrime(f))\
    \ {\n                n--;\n                if (n == 0) {\n                   \
    \ return f;\n                }\n            }\n            i++;\n        }", " \
    \       long i = 1;\n        long k = 0;\n        long j = 1;\n        for (long\
    \ h = 0; h < n; h++) {\n            var t = i + j;\n            i = j;\n     \
    \       j = t;\n            if (IsPrime(j)) {\n                k++;\n        \
    \    }\n        }\n        return j;", "        long a = 1;\n        long b =\
    \ 1;\n        while (n > 0) {\n            (a, b) = (b, a + b);\n            if\
    \ (Utils.IsPrime(b)) {\n                n -= 1;\n            }\n        }\n  \
    \      return b;", "        long f1 = 1;\n        long f2 = 1;\n        long temp;\n\
    \        long count = 0;\n        while (count < n) {\n            temp = f1;\n\
    \            f1 = f2;\n            f2 = temp + f2;\n            if (IsPrime(f1))\n\
    \                count++;\n        }\n        return f1;", "        if (n == 1)\
    \ return 2;\n        if (n == 2) return 3;\n        long i = 1;\n        long\
    \ k = 1;\n        while (n > 0) {\n            i += k;\n            k = i - k;\n\
    \            if (is_prime(i)) {\n                n -= 1;\n            }\n    \
    \    }\n        return i;", "        Fibonacci fib = new Fibonacci();\n      \
    \  long f = 0;\n        long i = 0;\n        while (true) {\n            f = fib.Next();\n\
    \            if (IsPrime(f)) {\n                i++;\n                if (i ==\
    \ n) {\n                    return f;\n                }\n            }\n    \
    \    }", "        if (n <= 0) {\n            throw new ArgumentException(\"Argument\
    \ must be > 0\", \"n\");\n        }\n        long f1 = 2;\n        long f2 = 3;\n\
    \        long cnt = 2;\n        while (cnt < n) {\n            long sum = f1 +\
    \ f2;\n            f1 = f2;\n            f2 = sum;\n            cnt++;\n     \
    \       while (!IsPrime(f2)) {\n                f2 += f1;\n                cnt++;\n\
    \            }\n        }\n        return f2;", "        long count = 0;\n   \
    \     long a = 2;\n        long b = 3;\n        while (true) {\n            long\
    \ c = a + b;\n            if (c % 2 == 0) {\n                count += 1;\n   \
    \             if (count == n) {\n                    return b;\n             \
    \   }\n            }\n            a = b;\n            b = c;\n        }", "  \
    \      // Make a function that returns the n-th fibonacci number and it's also\
    \ prime.\n        // A Fibonacci number is a number in the sequence: 1, 1, 2,\
    \ 3, 5, 8, 13, 21, ...\n        // Every third number in the sequence is even,\
    \ so you only need to test the odd numbers for being prime.\n        // NOTE:\
    \ The first two numbers are 1, but 1 is not prime (it's a unit), so it is not\
    \ counted as a prime fibonacci number.\n        // Hint: The sequence is increasing,\
    \ so you don't need to test all numbers. Just test the candidate numbers.\n  \
    \      // Hint: Only check for prime-ness if the number is bigger than the biggest\
    \ prime you've seen so far.\n        long a = 1;\n        long b = 1;\n      \
    \  long c = 2;\n        for (int i = 0; i < 100; i++) {\n            if (i ==\
    \ n) return c;\n            c = a + b;\n            a = b;\n            b = c;\n\
    \        }\n        return -1;", "        List<long> F = new List<long>();\n \
    \       F.Add(2);\n        F.Add(3);\n        while (true) {\n            long\
    \ next = F[F.Count - 1] + F[F.Count - 2];\n            if (IsPrime(next)) {\n\
    \                F.Add(next);\n            }\n            if (F.Count == n) {\n\
    \                return F[F.Count - 1];\n            }\n        }", "        var\
    \ calc = new Fibonacci();\n        var count = 0L;\n        while (count < n)\
    \ {\n            var result = calc.Next();\n            if (IsPrime(result)) {\n\
    \                count += 1;\n            }\n        }\n        return calc.Current();",
  "        BigInteger p, q, s;\n        long i = 0;\n        for (p = 2, q = 3, s\
    \ = 5; ; p = q, q = s, s = p + q) {\n            if (is_prime(s)) {\n        \
    \        i += 1;\n                if (i == n)\n                    return (long)s;\n\
    \            }\n        }", "        if (n < 0) {\n            throw new ArgumentException(\"\
    The argument must be non-negative integer\");\n        }\n\n        long a = 2;\n\
    \        long b = 3;\n        long c = 5;\n        long i = 4;\n        while\
    \ (true) {\n            if (i == n) {\n                return c;\n           \
    \ }\n\n            if (EulerUtil.IsPrime(c)) {\n                a = b;\n     \
    \           b = c;\n                c = a + b;\n                i++;\n       \
    \     } else {\n                c = b + c;\n            }\n        }", "     \
    \   // Step1: Let's find all Fibonacci numbers that are less than n.\n       \
    \ // Step2: Let's generate all Fibonacci numbers greater than sqrt(MAX_LONG).\n\
    \        // Step3: Let's test if they are prime.\n        var sqrtMaxLong = (long)Math.Ceiling(Math.Sqrt(long.MaxValue));\n\
    \        long n_1 = 0, n_2 = 1;\n        long current = 1;\n        var fibonacci\
    \ = new List<long>();\n        while (current < n) {\n            fibonacci.Add(current);\n\
    \            current = n_1 + n_2;\n            n_2 = n_1;\n            n_1 = current;\n\
    \        }\n        n_1 = 0;\n        n_2 = 1;\n        current = 1;\n       \
    \ while (current < sqrtMaxLong) {\n            var temp = n_1 + n_2;\n       \
    \     n_2 = n_1;\n            n_1 = temp;\n            current = n_1 + n_2;\n\
    \            if (current < sqrtMaxLong) {\n                fibonacci.Add(current);\n\
    \            }\n        }\n        fibonacci.Sort();\n        // Step4: Let's\
    \ sort them.\n        // Step5: Let's eliminate duplicates.\n        int p = 0;\n\
    \        while (p < fibonacci.Count - 1) {\n            if (fibonacci[p] == fibonacci[p\
    \ + 1]) {\n                fibonacci.RemoveAt(p);\n            } else {\n    \
    \            p++;\n            }\n        }\n        // Step6: Let's test if they\
    \ are prime.\n        int i = 0;\n        while (i < fibonacci.Count) {\n    \
    \        if (!IsPrime(fibonacci[i])) {\n                fibonacci.RemoveAt(i);\n\
    \            } else {\n                i++;\n            }\n        }\n      \
    \  return fibonacci[(int)n - 1];", "        long f1 = 2;\n        long f2 = 3;\n\
    \        long c = 1;\n        while (c < n) {\n            long f3 = f1 + f2;\n\
    \            f1 = f2;\n            f2 = f3;\n            if (IsPrime(f2)) {\n\
    \                c++;\n            }\n        }\n        return f2;", "      \
    \  // The sequence of F(n) is uniquely determined by two simple facts:\n     \
    \   //     1. F(n) = p * q where p and q are primes\n        //     2. F(n+1)\
    \ = F(n) + F(n-1)\n        // The first fact holds for Fibonacci number that is\
    \ also prime\n        // The second fact holds for all Fibonacci numbers\n   \
    \     // Here we will make use of both.\n        // First we will use the second\
    \ fact to generate some Fibonacci numbers\n        // Then we will use the first\
    \ fact to find out all the numbers that match the criteria.\n        // Our initial\
    \ value is F(3) = 2, F(4) = 3\n        // We will use F(4) as the first number\
    \ we use to generate other Fibonacci numbers\n        // and add it to our list\
    \ of prime-fib candidates.\n        List<long> fib = new List<long>() {\n    \
    \        2, // This is F(3), we don't need it to generate other Fibonacci numbers,\n\
    \               // but we will add it to our list of prime-fib candidates\n  \
    \          3  // This is F(4), we will use it to generate other Fibonacci numbers\n\
    \        };\n        // We will generate fibonacci numbers until we have enough\
    \ candidates\n        // such that one of them must be the n-th prime-fib\n  \
    \      while (fib.Count < n) {\n            // F(n+1) = F(n) + F(n-1)\n      \
    \      fib.Add(fib[fib.Count - 1] + fib[fib.Count - 2]);\n        }\n        //\
    \ Now we have a list of potential prime-fib\n        // But not all of them are\
    \ actually prime-fib\n        // We will filter out these candidates to find the\
    \ actual prime-fib\n        // First we will declare our filter function:\n  \
    \      Func<long, bool> filter = number => {\n            // Use trial division\
    \ to filter out non-prime\n            foreach (long prime in PrimeSieve(number))\
    \ {\n                if (number % prime == 0) {\n                    // A prime\
    \ number divides the given number\n                    // The given number is\
    \ not prime\n                    return false;\n                }\n", "      \
    \  var l = new List<long>();\n        long a = 2;\n        long b = 3;\n     \
    \   l.Add(a);\n        l.Add(b);\n        while (true) {\n            var sum\
    \ = a + b;\n            a = b;\n            b = sum;\n            if (Lib.IsPrime(sum))\
    \ {\n                l.Add(sum);\n            }\n            if (l.Count >= n)\
    \ {\n                return l[(int)n - 1];\n            }\n        }", "     \
    \   long x = 0;\n        long y = 1;\n        long c = 0;\n        for (long i\
    \ = 0; c < n; i++) {\n            long z = (x + y) % m;\n            x = y;\n\
    \            y = z;\n            if (isPrime(y)) {\n                c += 1;\n\
    \            }\n        }\n        return y;", "        if (n == 1) {\n      \
    \      return 2;\n        }\n        long a = 2;\n        long b = 3;\n      \
    \  for (long i = 2; i < n; i++) {\n            var next = a + b;\n           \
    \ a = b;\n            b = next;\n        }\n        return b;", '        return
    PrimeFibIter(new BigInteger(0), new BigInteger(1), new BigInteger(1), n).Item1;',
  "        long a = 1;\n        long b = 1;\n        long i = 1;\n        long res\
    \ = 0;\n        while (i < n) {\n            long next = a + b;\n            a\
    \ = b;\n            b = next;\n            if (is_prime(b)) {\n              \
    \  i += 1;\n                res = b;\n            }\n        }\n        return\
    \ res;", "        long a = 2, b = 3, t = 2;\n        for (; t <= n; a = b, b =\
    \ t) {\n            t = a + b;\n            for (long p = 2; p * p <= t; p++)\n\
    \                if (t % p == 0) {\n                    t++;\n               \
    \     p = 1;\n                }\n        }\n        return a;", "        if (n\
    \ == 1) return 2;\n        if (n == 2) return 3;\n        long i = 2;\n      \
    \  long nx = 1;\n        long ny = 2;\n        long nz = 3;\n        while (i\
    \ < n) {\n            nx = ny;\n            ny = nz;\n            nz = nx + ny;\n\
    \            if (nz.IsPrime()) i++;\n        }\n        return nz;", "       \
    \ long n0 = 0;\n        long n1 = 1;\n        long n2 = 1;\n        long nth =\
    \ 1;\n        while (nth < n) {\n            n0 = n1;\n            n1 = n2;\n\
    \            n2 = n0 + n1;\n            if (IsPrime(n2)) {\n                nth++;\n\
    \            }\n        }\n        return n2;", "        n += 2; // because we\
    \ skip the first two numbers\n        long a = 1, b = 1;\n        while (n-- >\
    \ 0) {\n            long temp = a;\n            a = b;\n            b = temp +\
    \ b;\n            while (!IsPrime(b)) {\n                temp = a;\n         \
    \       a = b;\n                b = temp + b;\n            }\n        }\n    \
    \    return b;", "        var fibs = new long[] { 2, 3, 5, 13, 89 };\n       \
    \ return fibs[n - 1];", '        return Solution.PrimeFib(n);', "        long\
    \ p = 2;\n        long f1 = 2;\n        long f2 = 3;\n        for (long i = 1;\
    \ i < n; i++) {\n            // f1: n-th Fibonacci number\n            // f2:\
    \ (n+1)-th Fibonacci number\n            // p: n-th prime number\n           \
    \ long t = f2;\n            f2 = f1 + f2;\n            f1 = t;\n            while\
    \ (f2 > p) {\n                p = Prime(p + 1);\n            }\n        }\n  \
    \      return p;", "        int c = 1;\n        foreach (long p in Fib()) {\n\
    \            if (IsPrime(p)) {\n                if (c == n) return p;\n      \
    \          c += 1;\n            }\n        }\n        throw new Exception(\"Should\
    \ not be reached.\");", "        if (n == 1) return 2;\n        if (n == 2) return\
    \ 3;\n        BigInteger a = 2;\n        BigInteger b = 3;\n        for (int i\
    \ = 0; i < n-2; i++) {\n            BigInteger c = a + b;\n            if (b.IsPrime())\
    \ {\n                return (long)b;\n            }\n            a = b;\n    \
    \        b = c;\n        }\n        return -1;", "        long[] Fibs = Enumerable.Range(1,\
    \ (int)n)\n                                .Select(x => Fib(x))\n            \
    \                    .Where(x => IsPrime(x))\n                               \
    \ .ToArray();\n        return Fibs[Fibs.Length - 1];", "        if (n < 1) {\n\
    \            throw new ArgumentException(\"n must be a positive integer\", \"\
    n\");\n        }\n        var fibs = FibonacciGenerator();\n        long x = 0;\n\
    \        foreach (var i in fibs) {\n            if (IsPrime(i)) {\n          \
    \      x += 1;\n                if (x == n) {\n                    return i;\n\
    \                }\n            }\n        }\n        return -1;", "        if\
    \ (n <= 1) return n;\n        long n0 = 1, n1 = 1;\n        n--;\n        while\
    \ (n-- > 0) {\n            long t = n0 + n1;\n            n0 = n1;\n         \
    \   n1 = t;\n            while (!IsPrime(n1)) n1 += n0;\n        }\n        return\
    \ n1;", "        long f = 2;\n        long s = 3;\n        long i = 0;\n     \
    \   while (true) {\n            i += 1;\n            long next = (f + s);\n  \
    \          f = s;\n            s = next;\n            if (i >= n) {\n        \
    \        break;\n            }\n        }\n        return s;", "        long[]\
    \ F = new long[3];\n        F[0] = 2;\n        F[1] = 3;\n        F[2] = 5;\n\
    \        long i = 2;\n        while (i < n) {\n            long k = F[0] + F[1];\n\
    \            if (BigInteger.Pow(k, 3) < F[2]) {\n                F[0] = F[1];\n\
    \                F[1] = F[2];\n                F[2] = k;\n                i++;\n\
    \            } else {\n                F[0] = F[1];\n                F[1] = F[2];\n\
    \                F[2] = NextPrime(F[2]);\n            }\n        }\n        return\
    \ F[2];", "        var F = new List<long>();\n        F.Add(2);\n        F.Add(3);\n\
    \        int i = 2;\n        while (true) {\n            long f = F[i - 1] + F[i\
    \ - 2];\n            if (f > int.MaxValue)\n                break;\n         \
    \   F.Add(f);\n            i += 1;\n        }\n        return F.Where(f => is_prime(f)).ElementAt((int)n\
    \ - 1);", "        // Start with an initial value\n        long fib = 2;\n   \
    \     long pre = 1;\n        long tmp;\n        // Then iterate until nth number\n\
    \        for (long i = 0; i < n; i++) {\n            tmp = fib;\n            fib\
    \ += pre;\n            pre = tmp;\n            // Skip the case that the number\
    \ is prime\n            if (IsPrime(fib)) {\n                n++;\n          \
    \  }\n        }\n        return fib;", "        long[] primes = PrimeSieve.PrimeSieveOfEratosthenes(1000000);\n\
    \        long[] fib = Fibonacci.FibonacciNLessThan((long)primes[primes.Length\
    \ - 1]);\n        int fibi = 0;\n        int primei = 0;\n        while (primei\
    \ < primes.Length && fibi < fib.Length) {\n            if (primes[primei] == fib[fibi])\
    \ {\n                if (n == 1) {\n                    return primes[primei];\n\
    \                }\n                n--;\n                primei++;\n        \
    \        fibi++;\n            } else if (primes[primei] < fib[fibi]) {\n     \
    \           primei++;\n            } else {\n                fibi++;\n       \
    \     }\n        }\n        return 0;", "        var fibs = new Dictionary<long,\
    \ BigInteger>();\n        long i = 1;\n        var fib = BigInteger.One;\n   \
    \     for (; i <= n; i++) {\n            fibs[i] = fib;\n            var fibprev\
    \ = fib;\n            fib = fib + fibprev;\n            if (IsPrime(fib)) {\n\
    \                n--;\n            }\n        }\n        return fibs[i - 1];",
  "        if (n < 1) {\n            throw new ArgumentException(\"n must be greater\
    \ than 0.\", \"n\");\n        }\n        n = n - 1;\n        long i = 0;\n   \
    \     long j = 1;\n        long k = 0;\n        while (n > 0) {\n            k\
    \ = i + j;\n            i = j;\n            j = k;\n            n = n - 1;\n \
    \           while (IsPrime(j) == false) {\n                k = i + j;\n      \
    \          i = j;\n                j = k;\n                n = n - 1;\n      \
    \      }\n        }\n        return j;", "        var t0 = DateTime.Now;\n   \
    \     long i = 2;\n        long count = 0;\n        while (true) {\n         \
    \   if (Utils.IsPrime(i) && Utils.IsFibonacci(i)) {\n                if (++count\
    \ == n) {\n                    break;\n                }\n            }\n    \
    \        i++;\n        }\n        Utils.PrintTime(\"Problem.PrimeFib()\", t0);\n\
    \        return i;", "        var primeFibNumber = (BigInteger) 0;\n        var\
    \ nextFibNumber = (BigInteger) 1;\n        var fibNumber = (BigInteger) 1;\n \
    \       var counter = 0;\n        for (var i = 0; i < n; i++) {\n            if\
    \ (IsPrime(fibNumber)) {\n                counter += 1;\n                primeFibNumber\
    \ = fibNumber;\n            }\n            fibNumber = nextFibNumber + fibNumber;\n\
    \            nextFibNumber = fibNumber - nextFibNumber;\n        }\n        return\
    \ (long) primeFibNumber;", "        var FibSeq = FibonacciSequence(BigInteger.Parse(\"\
    10602096016136321736931\"));\n        foreach (var fib in FibSeq) {\n        \
    \    if (fib.IsPrime()) {\n                n--;\n                if (n == 0) {\n\
    \                    return (long)fib;\n                }\n            }\n   \
    \     }\n        return -1;", "        // calculate the first n prime numbers\n\
    \        List<long> primes = Util.Primes(n * 2);\n        // remove the first\
    \ 2 numbers since they are not Fibonacci numbers\n        primes.RemoveAt(0);\n\
    \        primes.RemoveAt(0);\n        // calculate Fibonacci numbers\n       \
    \ List<long> fibs = new List<long>();\n        long a = 1, b = 1;\n        while\
    \ (b < primes[primes.Count - 1]) {\n            fibs.Add(b);\n            long\
    \ temp = a;\n            a = b;\n            b = temp + b;\n        }\n      \
    \  // remove duplicates from Fibonacci numbers, then calculate intersection\n\
    \        fibs = fibs.Distinct().ToList();\n        return fibs.Intersect(primes).ElementAt((int)n\
    \ - 1);", "        long f;\n        long p;\n        while (true) {\n        \
    \    // Compute Fibonacci number.\n            (f, p) = Fib(n);\n            if\
    \ (IsPrime(f)) {\n                break;\n            }\n            n++;\n  \
    \      }\n        return f;", "        List<long> fib = new List<long>();\n  \
    \      long a, b;\n        int i = 0;\n        a = 1;\n        b = 1;\n      \
    \  while (a < (1L << (1L << (1L << (1L << (1L << 10L)))))) {\n            fib.Add(a);\n\
    \            i += 1;\n            long c = a + b;\n            a = b;\n      \
    \      b = c;\n        }\n        return fib.Where(x => is_prime(x)).ToList()[(int)n];",
  "        long a = 2, b = 3, c = 0;\n        while (n > 1) {\n            c = a +\
    \ b;\n            a = b;\n            b = c;\n            if (IsPrime(c)) {\n\
    \                n--;\n            }\n        }\n        return c;", "       \
    \ // long fib_a = 2L; long fib_b = 3L; long fib_c = 5L; long fib_i = 2L;\n   \
    \     // while (fib_i != n) {\n        //     fib_c = fib_a + fib_b;\n       \
    \ //     fib_a = fib_b;\n        //     fib_b = fib_c;\n        //     fib_i++;\n\
    \        // }\n        // return fib_c;\n        // This will take forever to\
    \ compute.\n        //\n        // fib_a and fib_b are two last numbers in the\
    \ Fibonacci sequence.\n        // fib_c = fib_a + fib_b is the next number in\
    \ the sequence.\n        // fib_i is index of the current number in the sequence.\n\
    \        //\n        // We check the current number (fib_c) for primality,\n \
    \       // and increase the index only if we know that this number is prime.\n\
    \        // First two numbers (2 and 3) are already prime, and if the next number\n\
    \        // is a product of two primes (x * y), than it will be divisible by\n\
    \        // one of the prime numbers: 2, 3, 5, ..., less or equal to x.\n    \
    \    //\n        // So we will check for primality only for numbers:\n       \
    \ // 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79,\n\
    \        // 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\
    \ 157,\n        // 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233,\n        // 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313,\n        // 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\
    \ 383, 389, 397, 401,\n        // 409, 419, 421, 431, 433, 439, 443, 449, 457,\
    \ 461, 463, 467, 479, 487,\n        // 491, 499", "        // YOUR CODE HERE\n\
    \        throw new NotImplementedException();", "        // v1 = (0L, 1L)\n  \
    \      // v2 = (1L, 1L)\n        long v1 = 0;\n        long v2 = 1;\n        long\
    \ v3 = 1;\n        int count = 1;\n        while (true) {\n            if (count\
    \ == n) {\n                return v3;\n            }\n            // v1 = v2\n\
    \            // v2 = v3\n            // v3 = v1 + v2\n            v1 = v2;\n \
    \           v2 = v3;\n            v3 = v1 + v2;\n            if (EulerUtil.IsPrime(v3))\
    \ {\n                count += 1;\n            }\n        }", "        BigInteger\
    \ p0 = 2, p1 = 3, p2;\n        long i = 2;\n        for (;;) {\n            p2\
    \ = p0 + p1;\n            if (Prime(p2)) {\n                if (i == n)\n    \
    \                return (long)p2;\n                i++;\n            }\n     \
    \       p0 = p1;\n            p1 = p2;\n        }", "        if (n <= 0) throw\
    \ new Exception(\"n must be positive integer\");\n        long f1 = 2;\n     \
    \   long f2 = 3;\n        long i = 2;\n        long tmp;\n        while (i < n)\
    \ {\n            tmp = f2;\n            f2 = f1 + f2;\n            f1 = tmp;\n\
    \            if (EulerUtil.IsPrime(f2))\n                i++;\n        }\n   \
    \     return f2;", "        long f1 = 2;\n        long f2 = 3;\n        long temp;\n\
    \        for (int i = 1; i < n; i++) {\n            temp = f1;\n            f1\
    \ = f2;\n            f2 = f1 + temp;\n            while (!FibonacciPrime.isPrime(f2))\n\
    \                f2 += f1;\n        }\n        return f2;", "        long f0 =\
    \ 0;\n        long f1 = 1;\n        long i = 0;\n        for (;;) {\n        \
    \    var tmp = f0 + f1;\n            f0 = f1;\n            f1 = tmp;\n       \
    \     if (f1 % 2 == 0) {\n                continue;\n            }\n         \
    \   if (f1 % 3 == 0) {\n                continue;\n            }\n           \
    \ if (f1 % 5 == 0) {\n                continue;\n            }\n            if\
    \ (f1 % 7 == 0) {\n                continue;\n            }\n            if (f1\
    \ % 11 == 0) {\n                continue;\n            }\n            if (f1 %\
    \ 13 == 0) {\n                continue;\n            }\n            if (f1 % 17\
    \ == 0) {\n                continue;\n            }\n            if (f1 % 19 ==\
    \ 0) {\n                continue;\n            }\n            if (f1 % 23 == 0)\
    \ {\n                continue;\n            }\n            if (f1 % 29 == 0) {\n\
    \                continue;\n            }\n            if (f1 % 31 == 0) {\n \
    \               continue;\n            }\n            if (f1 % 37 == 0) {\n  \
    \              continue;\n            }\n            if (f1 % 41 == 0) {\n   \
    \             continue;\n            }\n            if (f1 % 43 == 0) {\n    \
    \            continue;\n            }\n            if (f1 % 47 == 0) {\n     \
    \           continue;\n            }\n            if (f1 % 53 == 0) {\n      \
    \          continue;\n            }\n            if (f1 % 59 == 0) {\n       \
    \         continue;\n            }\n            if (f1 % 61 == 0) {\n        \
    \        continue;\n            }\n            if (f1 % 67 == 0) {\n         \
    \       continue;\n            }\n            if (f1 % 71 == 0) {\n          \
    \      continue;\n            }\n            if (f1 % 73 == 0) {\n           \
    \     continue;\n            }\n            if (f1 % 79 == 0) {\n            \
    \    continue;\n            }\n            if (f1 % 83 == 0) {\n             \
    \   continue;\n            }\n            if (f1 % 89 == 0) {\n              \
    \  continue;\n            }", "        long a = 1;\n        long b = 1;\n    \
    \    while (n > 0) {\n            var t = a + b;\n            a = b;\n       \
    \     b = t;\n            if (Prime(a)) {\n                n--;\n            }\n\
    \        }\n        return a;", "        if (n <= 0) {\n            throw new\
    \ ArgumentException(\"n must be positive.\");\n        }\n        long c = 0;\n\
    \        for (long i = 1; i < long.MaxValue; i++) {\n            if (isPrimeFib(i))\
    \ {\n                c++;\n                if (c == n) {\n                   \
    \ return i;\n                }\n            }\n        }\n        return 0;",
  "        long a = 2;\n        long b = 3;\n        while (n > 1) {\n           \
    \ long c = a + b;\n            a = b;\n            b = c;\n            if (b %\
    \ 2 != 0 && IsPrime(b))\n                n -= 1;\n        }\n        return b;",
  "        List<long> fibs = new List<long>();\n        fibs.Add(2);\n        fibs.Add(3);\n\
    \        // Here n starts from 2, since we already have 2 and 3 as a Fibonacci\
    \ prime\n        for (long i = 2; i < n; i++) {\n            fibs.Add(fibs[i -\
    \ 1] + fibs[i - 2]);\n            for (long j = fibs.Count - 1; j >= 0; j--) {\n\
    \                if (is_prime(fibs[(int)j])) {\n                    if (i == n\
    \ - 1) {\n                        return fibs[(int)j];\n                    }\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return 0;", "        long f_n = 0;\n        long f_n_1 = 0;\n        long\
    \ f_n_2 = 1;\n        long count = 0;\n        while (count < n) {\n         \
    \   f_n = f_n_1 + f_n_2;\n            f_n_2 = f_n_1;\n            f_n_1 = f_n;\n\
    \            if (BigInteger.Parse(f_n.ToString()).IsProbablePrime(100)) {\n  \
    \              count += 1;\n            }\n        }\n        return f_n;", " \
    \       long[] fibs = new long[10000];\n        fibs[0] = 1;\n        fibs[1]\
    \ = 2;\n        long fn = 3;\n        int ind = 2;\n        while (n > 0) {\n\
    \            fibs[ind] = fn;\n            ind++;\n            fn = fibs[ind -\
    \ 1] + fibs[ind - 2];\n            if (isPrime(fn))\n                n--;\n  \
    \      }\n        return fn;", "        int i = 0;\n        long curr = 1, prev\
    \ = 0;\n        // big value for n\n        for (i = 0; i < n; i++) {\n      \
    \      if (curr % 2 == 0) {\n                prev = curr;\n                curr\
    \ = curr + prev;\n            } else {\n                if (IsPrime(curr)) {\n\
    \                    prev = curr;\n                    curr = curr + prev;\n \
    \               } else {\n                    while (!IsPrime(curr)) {\n     \
    \                   prev = curr;\n                        curr = curr + prev;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ curr;", "        var s = new StreamReader(\"prime_fib_numbers.txt\");\n    \
    \    var line = \"\";\n        while (n > 0) {\n            n -= 1;\n        \
    \    line = s.ReadLine();\n        }\n        return long.Parse(line);", "   \
    \     var Fibs = new List<long>();\n        Fibs.Add(2);\n        Fibs.Add(3);\n\
    \        long i = 2;\n        while (Fibs.Count < n) {\n            long a = Fibs[i\
    \ - 1];\n            long b = Fibs[i - 2];\n            long c = a + b;\n    \
    \        if (IsPrime(c)) {\n                Fibs.Add(c);\n            }\n    \
    \        i++;\n        }\n        return Fibs[(int)n - 1];", "        var f0 =\
    \ 2L;\n        var f1 = 3L;\n        for (long i = 2; i < n; i++) {\n        \
    \    long tmp = f1;\n            f1 = f0 + f1;\n            f0 = tmp;\n      \
    \  }\n        return f1;", "        // n==1 => Fib(1) == 2\n        if (n == 1)\
    \ return 2;\n        // n==2 => Fib(2) == 3\n        if (n == 2) return 3;\n \
    \       // n==3 => Fib(3) == 5\n        if (n == 3) return 5;\n        long Fn\
    \ = 5;\n        long Fnm1 = 3;\n        long Fnm2 = 2;\n        long FnLastPrime\
    \ = 5;\n        long primeFibs = 3;\n        while (primeFibs < n) {\n       \
    \     long tmpFnm1 = Fnm1;\n            Fnm1 = Fn;\n            Fn = Fnm1 + Fnm2;\n\
    \            Fnm2 = tmpFnm1;\n            if (IsPrime(Fn)) {\n               \
    \ FnLastPrime = Fn;\n                primeFibs += 1;\n            }\n        }\n\
    \        return FnLastPrime;", "        Debug.Assert(n > 0);\n        long a,\
    \ b;\n        int cnt = 0;\n        for (a = 1, b = 1; ; a = b, b = c) {\n   \
    \         long c = a + b;\n            if (c % 2 == 0) continue;\n           \
    \ if (Library.IsPrime(c)) {\n                cnt++;\n                if (cnt ==\
    \ n) return c;\n            }\n        }", "        var fibs = FibonacciNumbersGenerator.Create(1000000);\n\
    \        foreach (var fib in fibs) {\n            if (fib % 2 == 0) {\n      \
    \          continue;\n            }\n            if (IsPrime(fib)) {\n       \
    \         n -= 1;\n                if (n == 0) {\n                    return fib;\n\
    \                }\n            }\n        }\n        throw new Exception(\"fuck\"\
    );", "        // First four Fibonacci numbers are: 2, 3, 5, 13.\n        // The\
    \ last one is prime number and also it's a Fibonacci number.\n        long[] first_fibs\
    \ = new long[] { 2, 3, 5, 13 };\n        if (n <= first_fibs.Length) {\n     \
    \       return first_fibs[n - 1];\n        }\n        // We can assume that the\
    \ n-th prime Fibonacci number is greater than\n        // first_fibs[-1].\n  \
    \      long prev = first_fibs[first_fibs.Length - 1];\n        // p, q, r are\
    \ three consecutive Fibonacci numbers.\n        long p = 0, q = 1, r = 1;\n  \
    \      long fib = 0;\n        for (long i = first_fibs.Length; ; i++) {\n    \
    \        // Compute the next Fibonacci number.\n            fib = p + q;\n   \
    \         p = q;\n            q = r;\n            r = fib;\n            // The\
    \ next Fibonacci number.\n            if (fib < prev) {\n                continue;\n\
    \            }\n            // The next Fibonacci number is greater than the previous\
    \ prime\n            // Fibonacci number.\n            if (fib.IsPrime()) {\n\
    \                n--;\n                if (n == 0) {\n                    return\
    \ fib;\n                }\n                prev = fib;\n            }\n      \
    \  }", "        long x = 1;\n        long y = 1;\n        long idx = 1;\n    \
    \    while (true) {\n            long z = (x + y) % 100000;\n            x = y;\n\
    \            y = z;\n            idx += 1;\n            if (idx >= n && miller_rabin(y))\
    \ {\n                return y;\n            }\n        }", "        // Pre-compute\
    \ Fibonacci numbers.\n        var fibs = new List<long> {\n            1L,\n \
    \           2L,\n        };\n        while (fibs.Count < n) {\n            var\
    \ a = fibs[fibs.Count - 1];\n            var b = fibs[fibs.Count - 2];\n     \
    \       fibs.Add(a + b);\n        }\n        // Find the n-th prime Fibonacci\
    \ number.\n        long res = 0;\n        int cnt = 0;\n        for (int i = 0;\
    \ i < fibs.Count; i++) {\n            if (fibs[i] > long.MaxValue) {\n       \
    \         // When fibs[i] overflows,\n                // there is no way that\
    \ we can go further.\n                break;\n            }\n            var m\
    \ = (long) fibs[i];\n            if (IsPrime(m)) {\n                cnt++;\n \
    \               if (cnt == n) {\n                    res = m;\n              \
    \      break;\n                }\n            }\n        }\n        return res;",
  "        long i = 0;\n        BigInteger f = 0;\n        BigInteger f_prev = 0;\n\
    \        BigInteger f_next = 1;\n        while (i < n) {\n            f = f_next;\n\
    \            f_next = f_next + f_prev;\n            f_prev = f;\n            if\
    \ (Utils.IsPrime(f))\n                i++;\n        }\n        return (long)f;",
  "        BigInteger n2, n1, n0, last;\n        n2 = n1 = n0 = 1;\n        last =\
    \ 0;\n        int count = 0;\n        long i = 2;\n        while (count < n) {\n\
    \            if (isPrime(i)) {\n                count++;\n                last\
    \ = i;\n            }\n            i++;\n            n0 = n1;\n            n1\
    \ = n2;\n            n2 = n1 + n0;\n        }\n        return last;", "      \
    \  BigInteger a = 1, b = 1, c = 0;\n        for (long i = 0; i < n; i++) {\n \
    \           c = a + b;\n            a = b;\n            b = c;\n            while\
    \ (!IsPrime(c)) {\n                c = a + b;\n                a = b;\n      \
    \          b = c;\n            }\n        }\n        return (long)c;", "     \
    \   var a = BigInteger.Zero;\n        var b = BigInteger.One;\n        var c =\
    \ BigInteger.Zero;\n        while (n > 0) {\n            if (Euler.IsPrime(b))\
    \ {\n                n--;\n            }\n            c = a + b;\n           \
    \ a = b;\n            b = c;\n        }\n        return (long)b;", "        if\
    \ (n == 1) return 2;\n        if (n == 2) return 3;\n        return 5;", "   \
    \     var sieve = new Sieve(long.MaxValue);\n        BigInteger f1 = 2;\n    \
    \    BigInteger f2 = 3;\n        BigInteger nf;\n        long k = 1;\n       \
    \ for (; k < n; ++k) {\n            nf = f1 + f2;\n            if (sieve.Check(nf))\n\
    \                break;\n            f1 = f2;\n            f2 = nf;\n        }\n\
    \        return f2;", "        long i;\n        long fib = 1;\n        long next\
    \ = 1;\n        long prev = 0;\n        long counter = 1;\n        for (i = 1;\
    \ i < n; i++) {\n            fib = next + prev;\n            prev = next;\n  \
    \          next = fib;\n            if (fib % 2 == 0) {\n                continue;\n\
    \            }\n            if (BigInteger.ModPow(2, fib-1, fib) == 1) {\n   \
    \             counter++;\n            }\n            if (counter == n) {\n   \
    \             break;\n            }\n        }\n        return fib;", "      \
    \  if (n <= 1) {\n            return 2;\n        } else if (n == 2) {\n      \
    \      return 3;\n        }\n        long a = 2;\n        long b = 3;\n      \
    \  long i = 3;\n        while (true) {\n            long c = a + b;\n        \
    \    if (isPrime(c)) {\n                i += 1;\n                if (i == n) {\n\
    \                    return c;\n                }\n            }\n           \
    \ a = b;\n            b = c;\n        }", "        // TODO: Implement this method\n\
    \        return 0;", "        long current = 0L;\n        long next = 1L;\n  \
    \      long i = 1L;\n        while (i < n) {\n            long temp = next;\n\
    \            next = current + next;\n            current = temp;\n           \
    \ if (IsPrime(next)) {\n                i = i + 1L;\n            }\n        }\n\
    \        return next;", "        long f1 = 2;\n        long f2 = 3;\n        long\
    \ i = 3;\n        long f3 = f1 + f2;\n        while (true) {\n            if (i\
    \ == n) {\n                return f3;\n            }\n            if (IsPrime(f3))\
    \ {\n                i += 1;\n            }\n            f1 = f2;\n          \
    \  f2 = f3;\n            f3 = f1 + f2;\n        }", "        if (n == 1) return\
    \ 2;\n        if (n == 2) return 3;\n        if (n == 3) return 5;\n        long\
    \ a = 1;\n        long b = 1;\n        long c = 2;\n        long d = 3;\n    \
    \    long i = 4;\n        while (true) {\n            var t = a + b;\n       \
    \     a = b;\n            b = c;\n            c = d;\n            d = t;\n   \
    \         if (isPrime(d)) {\n                if (i == n) return d;\n         \
    \       i += 1;\n            }\n        }", "        BigInteger a = 0, b = 1,\
    \ c = 0;\n        long count = 0;\n        while (count < n) {\n            a\
    \ = b;\n            b = c;\n            c = a + b;\n            if (c.IsPrime())\
    \ {\n                count++;\n            }\n        }\n        return (long)c;",
  "        var x = 2L;\n        var y = 3L;\n        for (var i = 0L; i < n; i++)\
    \ {\n            var z = x + y;\n            x = y;\n            y = z;\n    \
    \        while (!IsPrime(y)) {\n                y += 2;\n            }\n     \
    \   }\n        return x;", '        return FastFib(2 * n + 1);', "        var\
    \ p = new Primes(1000000);\n        var f = new Fibonacci();\n        long i =\
    \ 2;\n        while (n > 0) {\n            long fi = f.Next();\n            if\
    \ (p.IsPrime(fi)) {\n                n--;\n            }\n            i++;\n \
    \       }\n        return f.Last();", "        long nfib = 0; // number of fibonacci\
    \ numbers seen\n        long last_fib = 0; // stores last fibonacci number\n \
    \       long next_fib = 1; // stores next fibonacci number\n        while (nfib\
    \ < n) {\n            long fib = next_fib;\n            next_fib = last_fib +\
    \ next_fib;\n            last_fib = fib;\n            if (fib > 2L && MillerRabin(fib))\
    \ {\n                nfib += 1L;\n            }\n        }\n        return last_fib;",
  "        long a = 1, b = 1, i = 0;\n        while (i < n) {\n            long c\
    \ = a + b;\n            a = b;\n            b = c;\n            if (b.IsPrime())\
    \ {\n                i++;\n            }\n        }\n        return b;", "   \
    \     long i = 0L;\n        long f = 0L;\n        while (i < n) {\n          \
    \  f = fib(i);\n            if (isPrime(f)) {\n                i++;\n        \
    \    }\n        }\n        return f;", "        if (n < 1) {\n            throw\
    \ new ArgumentException(\"Argument must be 1 or greater\");\n        }\n     \
    \   long p = 1;\n        long q = 1;\n        long r = 0;\n        long i = 0;\n\
    \        while (true) {\n            i += 1;\n            r = p + q;\n       \
    \     if (i == n) {\n                break;\n            }\n            if (IsPrime(r))\
    \ {\n                i += 1;\n                if (i == n) {\n                \
    \    break;\n                }\n            }\n            p = q;\n          \
    \  q = r;\n        }\n        return r;", "        BigInteger a = 2;\n       \
    \ BigInteger b = 3;\n        BigInteger c = 0;\n        long counter = 2;\n  \
    \      while (counter < n) {\n            c = a + b;\n            a = b;\n   \
    \         b = c;\n            if (BigInteger.Pow(c, 2) > n)\n                break;\n\
    \            if (isPrime(c))\n                counter++;\n        }\n        return\
    \ (long) c;", "        List<long> primes = new List<long>();\n        primes.Add(2);\n\
    \        primes.Add(3);\n        long fib = 0;\n        long prevFib = 1;\n  \
    \      long temp = 0;\n        long i = 0;\n        while (primes.Count < n) {\n\
    \            temp = fib;\n            fib += prevFib;\n            prevFib = temp;\n\
    \            if (fib > primes[primes.Count - 1]) {\n                primes.Add(fib);\n\
    \            }\n            else {\n                for (i = 0; i < primes.Count;\
    \ i++) {\n                    if (fib % primes[i] == 0) {\n                  \
    \      break;\n                    }\n                }\n                if (i\
    \ == primes.Count) {\n                    primes.Add(fib);\n                }\n\
    \            }\n        }\n        return primes[(int)n - 1];", "        long\
    \ a = 1;\n        long b = 1;\n        long m = 0;\n        long i = 2;\n    \
    \    while (m != n) {\n            if (BigInteger.Remainder(BigInteger.Parse(a.ToString()),\
    \ BigInteger.Parse(\"2\")) == 0) {\n                a = a + b;\n             \
    \   b = a - b;\n            } else {\n                if (IsPrime(a)) {\n    \
    \                m = m + 1;\n                }\n                a = a + b;\n \
    \               b = a - b;\n            }\n            i = i + 1;\n        }\n\
    \        return a;", "        long a = 1, b = 1, c = 1;\n        for (long i =\
    \ 2; i < n; i++) {\n            a = b;\n            b = c;\n            c = a\
    \ + b;\n            if (IsPrime(c)) {\n                n++;\n            }\n \
    \       }\n        return c;", "        long p = 0;\n        long q = 1;\n   \
    \     for (int i = 1; i < n; i++) {\n            long r = p + q;\n           \
    \ p = q;\n            q = r;\n        }\n        return q;", "        long a =\
    \ 2, b = 3, c = 5;\n        if (n == 1) return a;\n        if (n == 2) return\
    \ b;\n        if (n == 3) return c;\n        while (true) {\n            a = b;\n\
    \            b = c;\n            c = a + b;\n            if (FermatPrimalityTest(c,\
    \ 50)) {\n                n -= 1;\n                if (n == 0) {\n           \
    \         return c;\n                }\n            }\n        }", "        if\
    \ (n == 1) {\n            return 2;\n        }\n        long x = 2;\n        long\
    \ y = 3;\n        int count = 2;\n        while (true) {\n            long tmp\
    \ = x + y;\n            x = y;\n            y = tmp;\n            count++;\n \
    \           if (IsPrime(y)) {\n                if (count == n) {\n           \
    \         return y;\n                }\n            }\n        }", "        long\
    \ a = 2;\n        long b = 3;\n        int count = 1;\n        for (int i = 1;\
    \ i < n; i++) {\n            long c = a + b;\n            a = b;\n           \
    \ b = c;\n            if (IsPrime(b)) {\n                count++;\n          \
    \  }\n        }\n        return b;", "        // your code here\n        return\
    \ 0;", "        long result = 2;\n        long prev1 = 2;\n        long prev2\
    \ = 1;\n        for (int i = 3; i <= n; i++) {\n            result = prev1 + prev2;\n\
    \            prev2 = prev1;\n            prev1 = result;\n            while (result\
    \ % 2 == 0) {\n                result = prev1 + prev2;\n                prev2\
    \ = prev1;\n                prev1 = result;\n            }\n            while\
    \ (!(result % 3 == 0 && result != 3) && !(result % 5 == 0 && result != 5) && !(result\
    \ % 7 == 0 && result != 7) && !(result % 11 == 0 && result != 11) && !(result\
    \ % 13 == 0 && result != 13) && !(result % 17 == 0 && result != 17) && !(result\
    \ % 19 == 0 && result != 19) && !(result % 23 == 0 && result != 23) && !(result\
    \ % 29 == 0 && result != 29) && !(result % 31 == 0 && result != 31) && !(result\
    \ % 37 == 0 && result != 37) && !(result % 41 == 0 && result != 41) && !(result\
    \ % 43 == 0 && result != 43) && !(result % 47 == 0 && result != 47) && !(result\
    \ % 53 == 0 && result != 53) && !(result % 59 == 0 && result != 59) && !(result\
    \ % 61 == 0 && result != 61) && !(result % 67 == 0 && result != 67) && !(result\
    \ % 71 == 0 && result != 71) && !(result % 73 == 0 && result != 73) && !(result\
    \ % 79 == 0 && result != 79) && !(result % 83 == 0 && result != 83) && !(result\
    \ % 89 == 0 && result != 89) && !(result % 97 == 0 && result != 97) && !(result\
    \ % 101 == 0 && result != 101) && !(result % 103 == 0 && result != 103) && !(result\
    \ % 107 == 0 && result != 107) && !(result % 109 == 0 && result != 109) && !(result\
    \ % 113 == 0 && result != 113) && !(result % 127 == 0 && result != 127) && !(result\
    \ % 131 == 0 && result != 131) && !(result", "        long a = 2, b = 3, c = 5;\n\
    \        long f = 2;\n        while (n > 2) {\n            long fa = a + b + c;\n\
    \            a = b;\n            b = c;\n            c = fa;\n            f +=\
    \ 1;\n            if (IsPrime(fa))\n                n -= 1;\n        }\n     \
    \   return c;", "        if (n <= 0) throw new Exception(\"PrimeFib: index must\
    \ be positive\");\n        long ret = 0;\n        long f1 = 1;\n        long f2\
    \ = 1;\n        long i = 1;\n        while (i < n) {\n            if (f1.IsPrime())\
    \ {\n                i += 1;\n                ret = f1;\n            }\n     \
    \       var f3 = f1 + f2;\n            f1 = f2;\n            f2 = f3;\n      \
    \  }\n        return ret;", "        long[] fib = new long[80];\n        fib[0]\
    \ = 2;\n        fib[1] = 3;\n        long i;\n        for (i = 2; i < 80; i++)\
    \ {\n            fib[i] = fib[i - 1] + fib[i - 2];\n            if (IsPrime(fib[i]))\
    \ {\n                n--;\n                if (n == 0) {\n                   \
    \ break;\n                }\n            }\n        }\n        return fib[i];",
  "        if (n <= 0) throw new ArgumentException(\"n must be a positive integer\"\
    );\n        var p = FibonacciPrime(n);\n        if (p != null) return p.Value;\n\
    \        throw new ApplicationException(\"A prime Fibonacci number not found.\"\
    );", "        long a = 2;\n        long b = 3;\n        long c = 5;\n        long\
    \ i = 3;\n        while (i < n) {\n            a = b;\n            b = c;\n  \
    \          c = a + b;\n            if (c % 2 == 0) {\n                continue;\n\
    \            }\n            if (Library.IsPrime(c)) {\n                i++;\n\
    \            }\n        }\n        return c;", "        if (n <= 0) {\n      \
    \      throw new ArgumentException(\"n must be positive\");\n        }\n     \
    \   if (n == 1) {\n            return 2;\n        }\n        if (n == 2) {\n \
    \           return 3;\n        }\n        long cur = 0;\n        long prev = 2;\n\
    \        long ans = 3;\n        for (int i = 3; i <= n; i++) {\n            cur\
    \ = ans;\n            ans = ans + prev;\n            prev = cur;\n           \
    \ while (ans % 2 == 0 || ans % 3 == 0 || ans % 5 == 0 ||\n                   ans\
    \ % 7 == 0 || ans % 11 == 0 || ans % 13 == 0) {\n                ans = ans + prev;\n\
    \                prev = cur;\n            }\n        }\n        return ans;",
  "        long a = 1;\n        long b = 1;\n        long p = 1;\n        long c =\
    \ 1;\n        while (n > 0) {\n            c = a + b;\n            a = b;\n  \
    \          b = c;\n            if (IsPrime(c)) {\n                p = c;\n   \
    \             n -= 1;\n            }\n        }\n        return p;", "       \
    \ long[] fib = { 2, 3, 5, 13, 89 };\n        return fib[n - 1];", "        long\
    \ a = 1, b = 1, c;\n        if (n == 1 || n == 2) return 1;\n        for (long\
    \ i = 2; i < n; i++) {\n            c = a + b;\n            a = b;\n         \
    \   b = c;\n            if (isPrime(c)) return c;\n        }\n        return -1;",
  "        int i = 0;\n        long fn = 0, fib = 0;\n        for (long j = 1; i <\
    \ n; j++) {\n            if (isPrime(j)) {\n                fib = Fibonacci(j);\n\
    \                if (isPrime(fib)) {\n                    i++;\n             \
    \       fn = fib;\n                }\n            }\n        }\n        return\
    \ fn;", "        long a = 1;\n        long b = 1;\n        while (n > 0) {\n \
    \           long c = a + b;\n            if (IsPrime(c)) {\n                n--;\n\
    \            }\n            a = b;\n            b = c;\n        }\n        return\
    \ a;", "        long i = 0;\n        long cnt = 0;\n        long temp1 = 1;\n\
    \        long temp2 = 2;\n        long result = 0;\n        do {\n           \
    \ if (Prime.Test(temp2)) {\n                cnt++;\n            }\n          \
    \  if (cnt == n) {\n                result = temp2;\n                break;\n\
    \            }\n            i = temp1 + temp2;\n            temp1 = temp2;\n \
    \           temp2 = i;\n        } while (true);\n        return result;", "  \
    \      var f = new List<long>() { 2, 3 };\n        for (long i = 0; i < n - 2;\
    \ i++) {\n            f.Add(f[i] + f[i + 1]);\n            while (!IsPrime(f[i\
    \ + 2])) {\n                f[i + 2] += f[i];\n            }\n        }\n    \
    \    return f[(int)n - 1];", "        long a = 1;\n        long b = 1;\n     \
    \   long c = 1;\n        int p = 2;\n        n -= 1;\n        while (n > 0) {\n\
    \            c = a + b;\n            a = b;\n            b = c;\n            if\
    \ (IsPrime(c)) {\n                p += 1;\n                if (p == n) {\n   \
    \                 return c;\n                }\n            }\n        }\n   \
    \     return c;", "        var f = 1L;\n        var s = 1L;\n        var t = 0L;\n\
    \        var count = 1L;\n        while (count < n) {\n            t = f + s;\n\
    \            f = s;\n            s = t;\n            if (is_prime(t)) {\n    \
    \            count += 1;\n            }\n        }\n        return t;", "    \
    \    long a = 2;\n        long b = 3;\n        long c = 5;\n        long i = 2;\n\
    \        while (i < n) {\n            i = i + 1;\n            a = b;\n       \
    \     b = c;\n            c = a + b;\n            if (IsPrime(c)) {\n        \
    \        i = i + 1;\n            }\n        }\n        return c;", "        long\
    \ i = 1;\n        long f1 = 1;\n        long f2 = 1;\n        while (i < n) {\n\
    \            long f = f1 + f2;\n            f1 = f2;\n            f2 = f;\n  \
    \          if (f1 == f2) {\n                Debug.WriteLine(f2 + \" is not prime\"\
    );\n            } else if (IsPrime(f2)) {\n                Debug.WriteLine(f2\
    \ + \" is prime\");\n                i++;\n            }\n        }\n        return\
    \ f2;", "        long f = 2;\n        long a = 1;\n        long b = 1;\n     \
    \   n -= 1;\n        while (n > 0) {\n            f += 1;\n            long c\
    \ = a + b;\n            a = b;\n            b = c;\n            if (IsPrime(f))\
    \ {\n                n -= 1;\n            }\n        }\n        return f;", " \
    \       // Declare the two variables (we'll use longs)\n        long l1 = 2L;\n\
    \        long l2 = 3L;\n        // Declare a counter.\n        long c = 2L;\n\
    \        // While counter is less than input:\n        while (c < n) {\n     \
    \       // If the number is prime\n            if (IsPrime(l2)) {\n          \
    \      // Increment the counter.\n                c++;\n            }\n      \
    \      // Swap l1 with l2, and set l2 to the sum of l1 and l2.\n            long\
    \ t = l1;\n            l1 = l2;\n            l2 = t + l2;\n        }\n       \
    \ // Return l2.\n        return l2;", "        long[] f = new long[n+1];\n   \
    \     f[0] = 1;\n        f[1] = 1;\n        long i = 2;\n        long c = 2;\n\
    \        while (c <= n) {\n            long x = f[i-1] + f[i-2];\n           \
    \ if (IsPrime(x)) {\n                f[i] = x;\n                c += 1;\n    \
    \        }\n            i += 1;\n        }\n        return f[i-1];", "       \
    \ var f = Fibonacci.Element(n - 1);\n        var p = Prime.Next(f);\n        return\
    \ p;", "        BigInteger a = 1, b = 1, c = 0;\n        for (long i = 0; i <\
    \ n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n\
    \            if (BigInteger.GreatestCommonDivisor(c, a) == 1 && IsPrime(c)) {\n\
    \                continue;\n            } else {\n                i--;\n     \
    \       }\n        }\n        return (long)c;", "        long i = 1;\n       \
    \ long a = 1;\n        long b = 1;\n        long j = 2;\n        while (j < n)\
    \ {\n            long c = a + b;\n            a = b;\n            b = c;\n   \
    \         i += 1;\n            if (IsPrime(c)) {\n                j += 1;\n  \
    \          }\n        }\n        return b;", "        long a = 1;\n        long\
    \ b = 1;\n        int count = 0;\n        while (count < n) {\n            if\
    \ (is_prime(b))\n                count++;\n            long c = a + b;\n     \
    \       a = b;\n            b = c;\n        }\n        return b;", "        //\
    \ Your code here\n        return 0;", "        long i;\n        long j;\n    \
    \    long p;\n        i = 2L;\n        j = 3L;\n        p = 0L;\n        while\
    \ (true) {\n            if (IsPrime(i)) {\n                p = p + 1L;\n     \
    \       }\n            if (p == n) {\n                return i;\n            }\n\
    \            if (IsPrime(j)) {\n                p = p + 1L;\n            }\n \
    \           if (p == n) {\n                return j;\n            }\n        \
    \    i = i + j;\n            j = i + j;\n        }", "        BigInteger a = BigInteger.Parse(\"\
    1\");\n        BigInteger b = BigInteger.Parse(\"1\");\n        long prime_fib_count\
    \ = 1;\n        long prime_fib = 2;\n        while (prime_fib_count < n) {\n \
    \           BigInteger next = a + b;\n            if (next.IsProbablePrime(128))\
    \ {\n                prime_fib_count++;\n                prime_fib = (long)next;\n\
    \            }\n            a = b;\n            b = next;\n        }\n       \
    \ return prime_fib;", "        if (n == 1) return 2;\n        if (n == 2) return\
    \ 3;\n        if (n == 3) return 5;\n        List<long> l = new List<long>();\n\
    \        l.Add(2);\n        l.Add(3);\n        l.Add(5);\n        long n0 = 2;\n\
    \        long n1 = 3;\n        long n2 = 5;\n        long n3 = 0;\n        long\
    \ i = 3;\n        while (i < n) {\n            n3 = n0 + n1 + n2;\n          \
    \  n0 = n1;\n            n1 = n2;\n            n2 = n3;\n            i++;\n  \
    \          if (IsPrime(n3)) {\n                l.Add(n3);\n            }\n   \
    \     }\n        return l[l.Count - 1];", "        if (n == 1) {\n           \
    \ return 2;\n        }\n        if (n == 2) {\n            return 3;\n       \
    \ }\n        long c = 5;\n        int i = 3;\n        long a = 2;\n        long\
    \ b = 3;\n        while (i < n) {\n            c = (a + b) % 1000000007;\n   \
    \         a = b;\n            b = c;\n            if (IsPrime(c)) {\n        \
    \        i += 1;\n            }\n        }\n        return c;", "        var sw\
    \ = new Stopwatch();\n        sw.Start();\n        var fib_number = PrimeFib_helper(n);\n\
    \        sw.Stop();\n        Console.WriteLine(\"Time consumed: {0} ms\", sw.ElapsedMilliseconds);\n\
    \        return fib_number;", "        long a = 2;\n        long b = 3;\n    \
    \    long p = 0;\n        long q = 0;\n        long c = 0;\n        int i = 0;\n\
    \        while (i < n) {\n            c = a + b;\n            a = b;\n       \
    \     b = c;\n            if (c % 2 == 0) {\n                continue;\n     \
    \       }\n            if (IsPrime(c)) {\n                q = c;\n           \
    \     i++;\n            }\n        }\n        return q;", "        var fib = FibonacciNumbers();\n\
    \        var prime = PrimeNumbers();\n        long p = prime.First();\n      \
    \  long f = fib.First();\n        for (int i = 0; i < n - 1; i++) {\n        \
    \    if (p < f)\n                p = prime.Next();\n            else if (p > f)\n\
    \                f = fib.Next();\n            else {\n                p = prime.Next();\n\
    \                f = fib.Next();\n            }\n        }\n        return p;",
  "        if (n == 1) return 2;\n        if (n == 2) return 3;\n        if (n ==\
    \ 3) return 5;\n        long i = 2;\n        long j = 3;\n        long z = 5;\n\
    \        for (long index = 4; index <= n; index++) {\n            var t = z;\n\
    \            z = i + j;\n            i = j;\n            j = t;\n            if\
    \ (IsPrime(z)) {\n                if (index == n) {\n                    return\
    \ z;\n                }\n            }\n        }\n        return -1;", "    \
    \    int limit = (int)Math.Ceiling(Math.Sqrt(n));\n        Debug.Assert(limit\
    \ >= 1);\n        List<int> primes = new List<int>();\n        for (int i = 1;\
    \ i <= limit; i++) {\n            if (LimitIsPrime(i)) {\n                primes.Add(i);\n\
    \            }\n        }\n        int[] prime_array = primes.ToArray();\n   \
    \     Array.Sort(prime_array);\n        long fib = 1;\n        int fib_index =\
    \ 1;\n        long prime_fib = 0;\n        int prime_fib_index = 0;\n        while\
    \ (prime_fib_index < n) {\n            fib_index++;\n            fib = NextFib(fib);\n\
    \            if (IsPrime(fib, prime_array)) {\n                prime_fib_index++;\n\
    \                prime_fib = fib;\n            }\n        }\n        return prime_fib;",
  "        var dict = new Dictionary<long, BigInteger>();\n        dict[0] = 0;\n\
    \        dict[1] = 1;\n        var idx = 2;\n        while (true) {\n        \
    \    dict[idx] = dict[idx - 1] + dict[idx - 2];\n            if (dict[idx].IsPrime())\
    \ {\n                if (n == 1) {\n                    return (long)dict[idx];\n\
    \                }\n                n--;\n            }\n            idx++;\n\
    \        }", "        long a = 2;\n        long b = 3;\n        if (n == 1) {\n\
    \            return a;\n        }\n        if (n == 2) {\n            return b;\n\
    \        }\n        long count = 2;\n        while (true) {\n            long\
    \ c = a + b;\n            if (IsPrime(c)) {\n                count++;\n      \
    \          if (count == n) {\n                    return c;\n                }\n\
    \            }\n            a = b;\n            b = c;\n        }", "        long\
    \ f1 = 2, f2 = 3, f3 = 5;\n        while (n > 3) {\n            long next = f1\
    \ + f2;\n            if (IsPrime(next))\n                n--;\n            f1\
    \ = f2;\n            f2 = f3;\n            f3 = next;\n        }\n        if (n\
    \ == 1)\n            return 2;\n        if (n == 2)\n            return 3;\n \
    \       return 5;", "        long i = 2;\n        long i1 = 2;\n        long i2\
    \ = 3;\n        while (n > 1) {\n            var i3 = i1 + i2;\n            if\
    \ (Utils.IsPrime(i3)) {\n                n -= 1;\n                i = i3;\n  \
    \          }\n            i1 = i2;\n            i2 = i3;\n        }\n        return\
    \ i;", "        List<long> a;\n        a = GetFibs(10000000);\n        return\
    \ a[n];", "        // Algorithm is based on https://en.wikipedia.org/wiki/Prime-generating_polynomial\n\
    \        long[] coeffs = new long[] {\n            16,\n            -220,\n  \
    \          -33,\n            -17,\n            -7,\n            -5,\n        \
    \    -2,\n            -1,\n            -1,\n            -1,\n            -1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,\n\
    \            1,\n            1,\n            1,\n            1,\n            1,",
  "        // ITERATIVE IMPLEMENTATION\n        // if n == 1 return 2\n        //\
    \ prev, current := 0, 1\n        // i := 1\n        // while True\n        //\
    \     next := current + prev\n        //     if next.isPrime():\n        //  \
    \       i += 1\n        //         if i == n:\n        //             return next\n\
    \        //     prev, current = current, next\n        return 0;", "        //\
    \ *** Your code here ***\n        throw new NotImplementedException();", "   \
    \     long a = 1;\n        long b = 1;\n        while (n > 0) {\n            var\
    \ c = a + b;\n            a = b;\n            b = c;\n            if (Primes.MillerRabin(b))\
    \ {\n                n--;\n            }\n        }\n        return b;", "   \
    \     long i = 2;\n        long a = 2;\n        long b = 3;\n        while (i\
    \ <= n) {\n            long c = a + b;\n            a = b;\n            b = c;\n\
    \            if (IsPrime(b)) {\n                i++;\n            }\n        }\n\
    \        return a;", "        BigInteger f1 = 0;\n        BigInteger f2 = 1;\n\
    \        long cnt = 0;\n        while (cnt < n) {\n            if (IsPrime(f2))\
    \ {\n                cnt += 1;\n            }\n            BigInteger s = f1 +\
    \ f2;\n            f1 = f2;\n            f2 = s;\n        }\n        return f2;",
  "        long fib0 = 0;\n        long fib1 = 1;\n        long i = 1;\n        long\
    \ fib = fib1;\n        while (true) {\n            fib = fib0 + fib1;\n      \
    \      fib0 = fib1;\n            fib1 = fib;\n            if (IsPrime(fib)) {\n\
    \                i += 1;\n                if (i == n)\n                    return\
    \ fib;\n            }\n        }", "        Debug.Assert(n >= 1L);\n        var\
    \ fibs = new HashSet<long>();\n        var primes = new HashSet<long>();\n   \
    \     var ps = new PrimeStream();\n        var i = 0L;\n        var f = 0L;\n\
    \        while (i < n) {\n            // Get next prime p.\n            var p\
    \ = ps.Next();\n            // Generate next Fibonacci number f.\n           \
    \ if (fibs.Count < 2) {\n                f = 1L;\n            } else {\n     \
    \           var l = fibs.Last();\n                fibs.Remove(l);\n          \
    \      f = l + fibs.Last();\n            }\n            fibs.Add(f);\n       \
    \     // If p is a prime Fibonacci number, then count it.\n            if (f %\
    \ p == 0L) {\n                i += 1L;\n                if (i == n) {\n      \
    \              return f;\n                }\n            }\n        }\n      \
    \  return -1L;", "        int i = 0;\n        long cur = 1;\n        long prev\
    \ = 1;\n        while (i < n) {\n            long old_cur = cur;\n           \
    \ cur = cur + prev;\n            prev = old_cur;\n            if (IsPrime(cur))\
    \ {\n                i++;\n            }\n        }\n        return cur;", " \
    \       long a = 2;\n        long b = 3;\n        long c = 5;\n        if (n <\
    \ 0) {\n            throw new ArgumentException(\"n must be non-negative\");\n\
    \        }\n        if (n == 0) {\n            return a;\n        }\n        if\
    \ (n == 1) {\n            return b;\n        }\n        if (n == 2) {\n      \
    \      return c;\n        }\n        for (int i = 3; i <= n; i++) {\n        \
    \    a = b;\n            b = c;\n            do {\n                c += 2 * b;\n\
    \            } while (!IsPrime(c));\n        }\n        return c;", "        long\
    \ a, b, x, y, z;\n        a = 1;\n        b = 1;\n        if (n == 1) {\n    \
    \        return 2;\n        }\n        if (n == 2) {\n            return 3;\n\
    \        }\n        for (long i = 2; i < n; i++) {\n            x = a + b;\n \
    \           y = 0;\n            if (x < 0) {\n                y = 0;\n       \
    \     } else {\n                y = x % 2;\n            }\n            while (y\
    \ == 0) {\n                x = x / 2;\n                y = x % 2;\n          \
    \  }\n            z = 0;\n            if (x < 0) {\n                z = 0;\n \
    \           } else {\n                z = x % 5;\n            }\n            while\
    \ (z == 0) {\n                x = x / 5;\n                z = x % 5;\n       \
    \     }\n            a = b;\n            b = x;\n        }\n        return x;",
  "        var f1 = 1L;\n        var f2 = 1L;\n        var f3 = 2L;\n        var i\
    \ = 2L;\n        while (i < n) {\n            f1 = f2;\n            f2 = f3;\n\
    \            f3 = f1 + f2;\n            i = i + 1;\n        }\n        return\
    \ f3;", "        var fn = new List<long>();\n        var i = 0L;\n        foreach\
    \ (var x in Primes()) {\n            if (x == Fib(i)) {\n                fn.Add(x);\n\
    \            }\n            if (fn.Count == n) {\n                return fn[(int)n\
    \ - 1];\n            }\n            i += 1;\n        }\n        return -1;", " \
    \       Tuple<BigInteger, BigInteger> fib = Fibonacci.Fibonacci1(1);\n       \
    \ long number = 2;\n        long i = 1;\n        for (; i < n; i++) {\n      \
    \      number++;\n            if (Prime.IsPrime(number)) {\n                fib\
    \ = Fibonacci.Fibonacci1(number);\n                if (fib.Item1 == number) {\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     return number;", "        // implement\n        long f0 = 2;\n        long\
    \ f1 = 3;\n        long fib = 5;\n        long count = 3;\n        while (count\
    \ < n) {\n            f0 = f1;\n            f1 = fib;\n            fib = f0 +\
    \ f1;\n            if (isPrime(fib)) {\n                count++;\n           \
    \ }\n        }\n        return fib;", "        if (n < 1) throw new ArgumentException(\"\
    n should be positive integer.\");\n        if (n == 1) return 2;\n        long\
    \ a = 2, b = 3, k = 2;\n        while (true) {\n            long c = a + b;\n\
    \            if (IsPrime(c)) {\n                if (++k == n) return c;\n    \
    \        }\n            a = b;\n            b = c;\n        }", "        var fb\
    \ = Fibonacci.Fib();\n        var pr = Prime.PrimePrime();\n        long r = 0;\n\
    \        while (n > 0) {\n            var f = fb.Next();\n            while (pr.Next()\
    \ < f) { }\n            if (pr.Current == f) {\n                n--;\n       \
    \         r = f;\n            }\n        }\n        return r;", "        var d\
    \ = new SortedDictionary<long, HashSet<long>>();\n        var q = new SortedSet<long>();\n\
    \        q.Add(2);\n        d[2] = new HashSet<long>();\n        q.Add(3);\n \
    \       d[3] = new HashSet<long>();\n        int c = 0;\n        while (true)\
    \ {\n            long x = q.Min;\n            q.Remove(x);\n            c += 1;\n\
    \            if (c == n) {\n                return x;\n            }\n       \
    \     foreach (var y in d[x]) {\n                d[x + y].Add(y);\n          \
    \      q.Add(x + y);\n            }\n            foreach (var y in d[x]) {\n \
    \               d[x + y + y].Add(y);\n                q.Add(x + y + y);\n    \
    \        }\n        }", "        // foundFibs is a list of Fibonacci numbers that\
    \ are primes.\n        List<long> foundFibs = new List<long>();\n        // currentFib\
    \ is a current Fibonacci number.\n        long currentFib = 2;\n        // currentFibIndex\
    \ is an index of the current Fibonacci number.\n        long currentFibIndex =\
    \ 3;\n        while (true) {\n            if (RabinMiller(currentFib)) {\n   \
    \             foundFibs.Add(currentFib);\n            }\n            if (foundFibs.Count\
    \ == n) {\n                return foundFibs[foundFibs.Count - 1];\n          \
    \  }\n            // Calculate next Fibonacci number.\n            currentFibIndex\
    \ = currentFibIndex + 1;\n            currentFib = Fibonacci(currentFibIndex);\n\
    \        }", "        var x = 1L;\n        var y = 2L;\n        var i = 2L;\n\
    \        while (i < n) {\n            var z = x + y;\n            x = y;\n   \
    \         y = z;\n            if (BigInteger.IsProbablePrime(y, 10)) {\n     \
    \           i++;\n            }\n        }\n        return y;", "        long\
    \ v = 1;\n        long w = 1;\n        long ret = 2;\n        long i = 2;\n  \
    \      while (true) {\n            if (IsPrime(v)) {\n                i += 1;\n\
    \                if (i == n) {\n                    ret = v;\n               \
    \     break;\n                }\n            }\n            w = v + w;\n     \
    \       v = w - v;\n        }\n        return ret;", "        long p = 2;\n  \
    \      long pp = 1;\n        for (long i = 2; ; i++) {\n            long np =\
    \ p + pp;\n            pp = p;\n            p = np;\n            if (IsPrime(p))\
    \ {\n                n -= 1;\n                if (n == 0) {\n                \
    \    return p;\n                }\n            }\n        }", "        if (n <\
    \ 1) {\n            throw new ArgumentException(\"n must be greater than 0.\"\
    , \"n\");\n        }\n        long a = 1;\n        long b = 1;\n        long i\
    \ = 1;\n        while (i != n) {\n            long tmp = a;\n            a = b;\n\
    \            b = b + tmp;\n            i++;\n            while (!isPrime(b)) {\n\
    \                tmp = a;\n                a = b;\n                b = b + tmp;\n\
    \                i++;\n            }\n        }\n        return b;", "       \
    \ BigInteger f = 1;\n        BigInteger g = 1;\n        BigInteger[] ps = new\
    \ BigInteger[n];\n        long pn = 0;\n        long m = 0;\n        while (pn\
    \ < n) {\n            m += 1;\n            BigInteger t = f;\n            f =\
    \ g;\n            g = t + g;\n            long g2 = (long)g;\n            if (g2\
    \ % 2 == 0 || g2 % 3 == 0 || g2 % 5 == 0 || g2 % 7 == 0) {\n                continue;\n\
    \            }\n            long p = 7;\n            bool ok = true;\n       \
    \     for (long i = 0; i < pn; i++) {\n                p = (long)ps[i];\n    \
    \            if (g2 % p == 0) {\n                    ok = false;\n           \
    \         break;\n                }\n            }\n            if (ok) {\n  \
    \              ps[pn] = g;\n                pn += 1;\n            }\n        }\n\
    \        return (long)ps[pn - 1];", "        n -= 1;\n        long a = 1;\n  \
    \      long b = 1;\n        long c = 0;\n        int count = 0;\n        while\
    \ (count < n) {\n            c = a + b;\n            a = b;\n            b = c;\n\
    \            if (c.IsPrime()) {\n                count += 1;\n            }\n\
    \        }\n        return c;"]
stop_tokens:
- "\n    }\n"
