language: cs
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger whole = BigInteger.Parse(value);\n
    \       BigInteger decimalPart = BigInteger.Parse(value.Substring(value.IndexOf('.')
    + 1));\n        if (decimalPart >= 5) {\n            whole += 1;\n        }\n
    \       return whole;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpc8ldy8xa.cs(28,16): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here.\n
    \       return 0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <dd625a4f4db343f4ba783677e94a7909>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <dd625a4f4db343f4ba783677e94a7909>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value.Split('.').Length
    == 1) {\n            return long.Parse(value);\n        }\n        if (value.Split('.')[1]
    == \"0\") {\n            return long.Parse(value.Split('.')[0]);\n        }\n
    \       decimal myVal = decimal.Parse(value);\n        //return Math.Round(myVal,
    0, MidpointRounding.AwayFromZero);\n        if (myVal > 0) {\n            return
    (long)Math.Ceiling(myVal);\n        } else {\n            return (long)Math.Floor(myVal);\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7569515a4dbb42148e1cfbf4a57353d3>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        int sign = 1;\n        long
    nearest;\n        if (value[0] == '-') {\n            sign = -1;\n            value
    = value.Substring(1);\n        }\n        if (value.IndexOf('.') == -1) {\n            nearest
    = long.Parse(value);\n        } else {\n            string before = value.Substring(0,
    value.IndexOf('.'));\n            string after = value.Substring(value.IndexOf('.')
    + 1);\n            if (after.Length > 1) {\n                if (after[1] > '4')
    {\n                    nearest = long.Parse(before) + 1;\n                } else
    {\n                    nearest = long.Parse(before);\n                }\n            }
    else {\n                nearest = long.Parse(before);\n            }\n        }\n
    \       return nearest * sign;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6afddeb7f31f4a1198fcfb1144b71281>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6afddeb7f31f4a1198fcfb1144b71281>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var x = BigInteger.Parse(value);\n
    \       var (q, r) = BigInteger.DivRem(x, 1);\n        if (r.IsZero) {\n            return
    (long) q;\n        }\n        var next = q + (x < 0 ? -1 : 1);\n        if (next
    == 0) {\n            return 0;\n        }\n        var (d, _) = BigInteger.DivRem(x
    - q, next - q);\n        if (d.IsZero) {\n            return 0;\n        }\n        return
    (long) (x < 0 ? q - 1 : q + 1);\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7h7nfkz7.cs(24,33): error CS7036: There is no argument given that corresponds
    to the required formal parameter ''remainder'' of ''BigInteger.DivRem(BigInteger,
    BigInteger, out BigInteger)''

    /tmp/tmp7h7nfkz7.cs(24,22): error CS1061: ''BigInteger'' does not contain a definition
    for ''Deconstruct'' and no accessible extension method ''Deconstruct'' accepting
    a first argument of type ''BigInteger'' could be found (are you missing a using
    directive or an assembly reference?)

    /tmp/tmp7h7nfkz7.cs(24,22): error CS8129: No suitable ''Deconstruct'' instance
    or extension method was found for type ''BigInteger'', with 2 out parameters and
    a void return type.

    /tmp/tmp7h7nfkz7.cs(24,14): error CS8130: Cannot infer the type of implicitly-typed
    deconstruction variable ''q''.

    /tmp/tmp7h7nfkz7.cs(24,17): error CS8130: Cannot infer the type of implicitly-typed
    deconstruction variable ''r''.

    /tmp/tmp7h7nfkz7.cs(32,22): error CS1061: ''BigInteger'' does not contain a definition
    for ''Deconstruct'' and no accessible extension method ''Deconstruct'' accepting
    a first argument of type ''BigInteger'' could be found (are you missing a using
    directive or an assembly reference?)

    /tmp/tmp7h7nfkz7.cs(32,22): error CS8129: No suitable ''Deconstruct'' instance
    or extension method was found for type ''BigInteger'', with 2 out parameters and
    a void return type.

    /tmp/tmp7h7nfkz7.cs(32,14): error CS8130: Cannot infer the type of implicitly-typed
    deconstruction variable ''d''.

    /tmp/tmp7h7nfkz7.cs(32,17): error CS8130: Cannot infer the type of implicitly-typed
    deconstruction variable ''_''.

    /tmp/tmp7h7nfkz7.cs(32,17): error CS8183: Cannot infer the type of implicitly-typed
    discard.

    '
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Convert the string value
    to a Double\n        double d = Convert.ToDouble(value);\n        // If d is positive,
    round away from zero, otherwise\n        // round towards zero.\n        return
    d >= 0 ? (long)Math.Ceiling(d) : (long)Math.Floor(d);\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0fd0688f899e4199bb4f2fe1daa5bd99>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double val = Double.Parse(value);\n
    \       if (val < 0) {\n            return (long)Math.Ceiling(val);\n        }
    else {\n            return (long)Math.Floor(val);\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1e297102b2b64afe8980f9ebe76c1b2f>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1e297102b2b64afe8980f9ebe76c1b2f>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double n = double.Parse(value);\n
    \       if (n < 0) {\n            return (long)Math.Ceiling(n);\n        } else
    {\n            return (long)Math.Floor(n);\n        }\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e2ba9c65d75b4238adea7e71f1e25a48>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e2ba9c65d75b4238adea7e71f1e25a48>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // >>> ClosestInteger((\"10\"))\n
    \       // (10L)\n        // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n
    \       // >>> ClosestInteger((\"15.2\"))\n        // (15L)\n        // >>> ClosestInteger((\"15.8\"))\n
    \       // (16L)\n        // >>> ClosestInteger((\"-15.8\"))\n        // (-16L)\n
    \       // >>> ClosestInteger((\"-15.2\"))\n        // (-15L)\n        // >>>
    ClosestInteger((\"-15.3\"))\n        // (-15L)\n        // >>> ClosestInteger((\"-15.5\"))\n
    \       // (-16L)\n        var v = double.Parse(value);\n        var r = Math.Round(v);\n
    \       if (r < v) {\n            return Math.Round(v + 0.5);\n        } else
    {\n            return Math.Round(v - 0.5);\n        }\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpd09u1nnw.cs(42,20): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpd09u1nnw.cs(44,20): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal num = decimal.Parse(value);\n
    \       long rounded = (long) Math.Floor(num);\n        if (num < 0) {\n            return
    (num - rounded <= 0.5m) ? rounded : rounded - 1;\n        } else {\n            return
    (rounded - num <= 0.5m) ? rounded : rounded + 1;\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <a39773651a994565b4481d4ff7e66c63>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f2132e505d9744f0a0de05379fb03ff9>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var s = value.Split('.');\n
    \       if (s.Length > 1) {\n            var d = double.Parse(value);\n            if
    (d < 0) {\n                return (long)Math.Ceiling(d);\n            } else {\n
    \               return (long)Math.Floor(d);\n            }\n        } else {\n
    \           return long.Parse(value);\n        }\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <5dbf10d66d5a407a84981c31ebb0ceaa>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <5dbf10d66d5a407a84981c31ebb0ceaa>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double closestInt = Math.Round(double.Parse(value));\n
    \       return Convert.ToInt64(closestInt);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <52790b2ec06d4cb0acc56118506ad510>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // FILL IN HERE\n        throw
    new NotImplementedException();\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <1fb20225c93542db846e7690b34396ab>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <1fb20225c93542db846e7690b34396ab>:0 \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var parts = value.Split('.');\n
    \       var intPart = int.Parse(parts[0]);\n        var decPart = parts.Length
    > 1 ? int.Parse(parts[1]) : 0;\n        return (decPart > 5) ? intPart + 1 : intPart;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1709ed1bda1c40f7ab70dfa8c6495f46>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1709ed1bda1c40f7ab70dfa8c6495f46>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double v = double.Parse(value);\n
    \       if (v > 0) {\n            return (long)Math.Ceiling(v);\n        } else
    {\n            return (long)Math.Floor(v);\n        }\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f563fd3a9ef84ab8b2534f17da43189b>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double v = double.Parse(value);\n
    \       if (Math.Ceiling(v) - v < v - Math.Floor(v)) {\n            return (long)Math.Ceiling(v);\n
    \       } else {\n            return (long)Math.Floor(v);\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e49ad834e0054150995fb28b0300d2c3>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Implement me!\n        return
    0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <40e77b900c6a43c884e8ce4bbf50223e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <40e77b900c6a43c884e8ce4bbf50223e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger num = BigInteger.Parse(value);\n
    \       BigInteger diff = num % 1;\n        if (diff > 0.5) num += 1;\n        else
    if (diff < -0.5) num -= 1;\n        return (long)num;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpqxi06uee.cs(25,13): error CS0019: Operator ''>'' cannot be applied to
    operands of type ''BigInteger'' and ''double''

    /tmp/tmpqxi06uee.cs(26,18): error CS0019: Operator ''<'' cannot be applied to
    operands of type ''BigInteger'' and ''double''

    '
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double n = Convert.ToDouble(value);\n
    \       return Convert.ToInt64(Math.Round(n, MidpointRounding.AwayFromZero));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger closest = BigInteger.Zero;\n
    \       BigInteger given = BigInteger.Parse(value);\n        var div = BigInteger.DivRem(given,
    BigInteger.One, out BigInteger rem);\n        if (rem > BigInteger.Zero) {\n            if
    (rem > BigInteger.One / 2) {\n                closest = div + BigInteger.One;\n
    \           } else {\n                closest = div;\n            }\n        }
    else {\n            closest = div;\n        }\n        return (long)closest;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00007] in <d68a3679220a46d8b5bb7dcabebf15a2>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <d68a3679220a46d8b5bb7dcabebf15a2>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d = Double.Parse(value);\n
    \       long l = (long) d;\n        if (d - l >= 0.5)\n            return l +
    1;\n        else\n            return l;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83d87f9f43454bf3a6896a432fe9a7d7>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var parts = value.Split('.');\n
    \       long whole = long.Parse(parts[0]);\n        if (parts.Length == 1) return
    whole;\n        long decimal_part = long.Parse(parts[1]);\n        if (decimal_part
    > 5) return whole + 1;\n        if (decimal_part < 5) return whole;\n        //
    else decimal_part == 5\n        return whole % 2 == 0 ? whole : whole + 1;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0a4a50623dfd4a8ab9bffe3f26edceaf>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0a4a50623dfd4a8ab9bffe3f26edceaf>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        string[] nums = value.Split('.');\n
    \       if (nums.Length == 1) return long.Parse(nums[0]);\n        long integer
    = long.Parse(nums[0]);\n        double decimal_value = 0;\n        for (int i
    = 0; i < nums[1].Length; i++) {\n            decimal_value += (nums[1][i] - '0')
    * Math.Pow(10, -i - 1);\n        }\n        if (decimal_value >= 0.5) return integer
    + 1;\n        return integer;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <20c0af318e924fe98aee90c9ce16fb71>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal number = decimal.Parse(value);\n
    \       if(number > 0) {\n            if((number - (long)number) < 0.5m) {\n                return
    (long)number;\n            } else {\n                return (long)number + 1;\n
    \           }\n        } else {\n            if((number - (long)number) < 0.5m)
    {\n                return (long)number;\n            } else {\n                return
    (long)number - 1;\n            }\n        }\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <98d7a5c277c44f71b670cbb50f674596>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long rounded = Math.Round(Convert.ToDouble(value));\n
    \       return rounded;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp9yfinf6o.cs(23,24): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Math.Round(Double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpvcv1f5qz.cs(23,16): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double x = double.Parse(value);\n
    \       if (x == Math.Round(x)) {\n            return (long)x;\n        }\n        if
    (x >= 0) {\n            return (long)Math.Ceiling(x);\n        }\n        return
    (long)Math.Floor(x);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0fad4134785a4a44b2db57da7b44f462>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double val;\n        if (double.TryParse(value,
    out val)) {\n            if (val >= 0) {\n                return (long)Math.Ceiling(val);\n
    \           } else {\n                return (long)Math.Floor(val);\n            }\n
    \       }\n        throw new ArgumentException(\"bad value\");\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b7d36183b38f4f20bf7b7d77af92e658>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return long.Parse(value);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <222fe75f2aa947e99509f961880f4614>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <222fe75f2aa947e99509f961880f4614>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <222fe75f2aa947e99509f961880f4614>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <222fe75f2aa947e99509f961880f4614>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double number = Double.Parse(value);\n
    \       double floor = Math.Floor(number);\n        double ceil = Math.Ceiling(number);\n
    \       double floorDiff = number - floor;\n        double ceilDiff = ceil - number;\n
    \       if (floorDiff < ceilDiff) {\n            return (long)floor;\n        }
    else {\n            return (long)ceil;\n        }\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <73e0045cd3e04ccaa912ef8c71a1fd3f>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // First, we want to check
    if we're dealing with a number that is\n        // int-able. If not, we should
    round it to the nearest integer\n        // using the round-away-from-zero rule.\n
    \       decimal decimalValue = Decimal.Parse(value);\n        return (long)decimalValue;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <63d874a2bb1642a38a03f568822b4c2e>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <63d874a2bb1642a38a03f568822b4c2e>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // In Python 2, int and long
    have different representations, but in\n        // Python 3 they have the same
    representation (long). The long\n        // representation uses a variable number
    of bytes to represent very\n        // large integers, so it supports arbitrarily
    large numbers.\n        //\n        // We will be using the long representation
    in Python 3 to represent\n        // both integer and long values. We do this
    in order to guarantee\n        // that any number can be represented in Python.\n
    \       //\n        // To convert the string to a number, we use the \"long\"
    built-in.\n        //\n        // >>> long(\"14.5\")\n        // 14L\n        //\n
    \       // As you can see, this simply strips off the decimal part of the\n        //
    number.\n        //\n        // We then convert it to a double by passing it to
    the double\n        // built-in.\n        //\n        // >>> double(14L)\n        //
    14.0\n        //\n        // >>> double(long(\"14.5\"))\n        // 14.0\n        //\n
    \       // We can then round it to the nearest integer (round).\n        //\n
    \       // >>> round(14.0)\n        // 14.0\n        //\n        // >>> round(14.5)\n
    \       // 14.0\n        //\n        // >>> round(15.5)\n        // 16.0\n        //\n
    \       // We then convert it back to a long.\n        //\n        // >>> long(round(14.0))\n
    \       // 14L\n        //\n        // >>> long(round(14.5))\n        // 14L\n
    \       //\n        // >>> long(round(15.5))\n        // 16L\n        //\n        //
    >>> long(round(double(long(\"14.5\"))))\n        // 14L\n        //\n        //
    >>> long(round(double(long(\"14.5\"))))\n        // 14L\n        //\n        //
    >>> long(round(double(long(\"15.5\"))))\n        // 16L\n        //\n        //
    >>> long(round(double(long(value))))\n        // 14L\n        //\n        // >>>
    long(round(double(long(value))))\n        // 14L\n        //\n        // >>> long\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpdbm195co.cs(22,24): error CS0161: ''Problem.ClosestInteger(string)'':
    not all code paths return a value

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Ceiling(Convert.ToDouble(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c30404a6fa744bb290fef2063e0ef036>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c30404a6fa744bb290fef2063e0ef036>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimalValue = decimal.Parse(value);\n
    \       decimal rounded = Math.Round(decimalValue);\n        if (rounded > decimalValue)
    {\n            return (long)Math.Floor(decimalValue);\n        } else {\n            return
    (long)Math.Ceiling(decimalValue);\n        }\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <fc68bb32726b404ea812ec38fe2c8d4d>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <fc68bb32726b404ea812ec38fe2c8d4d>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d;\n        bool isDouble
    = double.TryParse(value, out d);\n        if (!isDouble) return -1;\n        int
    i;\n        bool isInt = int.TryParse(value, out i);\n        if (isInt) return
    i;\n        int id = (int)d;\n        return d - id >= 0.5 ? id + 1 : id;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2b207aa660164c5990387343df19f1af>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        string[] v = value.Split('.');\n
    \       if (v.Length == 1) {\n            return long.Parse(v[0]);\n        }
    else {\n            if (v[1].Length == 1) {\n                long i = long.Parse(v[0]);\n
    \               long d = long.Parse(v[1]);\n                if (d >= 5) {\n                    return
    i + 1;\n                } else {\n                    return i;\n                }\n
    \           } else {\n                long i = long.Parse(v[0]);\n                long
    d = long.Parse(v[1].Substring(0, 2));\n                if (d >= 50) {\n                    return
    i + 1;\n                } else {\n                    return i;\n                }\n
    \           }\n        }\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <31b08142253449cd8a682b18bc346431>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return new Random().Next(0,
    2) > 0 ? Math.Round(double.Parse(value), 0, MidpointRounding.AwayFromZero) : Math.Round(double.Parse(value),
    0, MidpointRounding.AwayFromZero);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpe3ha6txg.cs(23,16): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f2132e505d9744f0a0de05379fb03ff9>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here\n        double
    d = Double.Parse(value);\n        if (d < 0) {\n            d = -d;\n        }\n
    \       long result = (long)Math.Round(d);\n        if (Double.Parse(value) <
    0) {\n            result = -result;\n        }\n        return result;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7b1730bdc7b44012a0ac0ad513d68a00>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger ret = BigInteger.Parse(value);\n
    \       return ret.ClosestInteger();\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpahf8s9ox.cs(24,20): error CS1061: ''BigInteger'' does not contain a definition
    for ''ClosestInteger'' and no accessible extension method ''ClosestInteger'' accepting
    a first argument of type ''BigInteger'' could be found (are you missing a using
    directive or an assembly reference?)

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal number = decimal.Parse(value);\n
    \       decimal fraction = number - Math.Truncate(number);\n        return fraction
    >= 0.5m ? Math.Ceiling(number) : Math.Floor(number);\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp6ecn5su3.cs(25,16): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Just truncate the string
    and convert it to long.\n        long d = long.Parse(value);\n        long floor
    = (long)Math.Floor(double.Parse(value));\n        long ceil = (long)Math.Ceiling(double.Parse(value));\n
    \       if (d == floor || ceil - d == d - floor)\n            return floor;\n
    \       else if (d > floor)\n            return ceil;\n        else\n            return
    floor;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <4298ac49dfd84a9aa33714892bffa5c9>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <4298ac49dfd84a9aa33714892bffa5c9>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <4298ac49dfd84a9aa33714892bffa5c9>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <4298ac49dfd84a9aa33714892bffa5c9>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // >>> value = \"15.3\"\n
    \       // >>> float(value)\n        // 15.3\n        // >>> int(float(value))\n
    \       // 15\n        // >>> int(float(value) + 0.5)\n        // 16\n        //
    >>> int(float(value) - 0.5)\n        // 15\n        float f = float.Parse(value);\n
    \       if ((f - (int)f) >= 0.5) {\n            return (int)f + 1;\n        }
    else {\n            return (int)f;\n        }\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <669b51acaa6f47209eccd77d13a8f2ad>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger val = BigInteger.Parse(value);\n
    \       BigInteger floor = BigInteger.Floor(val);\n        BigInteger ceil = BigInteger.Ceiling(val);\n
    \       BigInteger floor_delta = BigInteger.Abs(floor - val);\n        BigInteger
    ceil_delta = BigInteger.Abs(ceil - val);\n        if (floor_delta < ceil_delta)
    {\n            return (long)floor;\n        } else {\n            return (long)ceil;\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpjso43jll.cs(24,39): error CS0117: ''BigInteger'' does not contain a definition
    for ''Floor''

    /tmp/tmpjso43jll.cs(25,38): error CS0117: ''BigInteger'' does not contain a definition
    for ''Ceiling''

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var split = value.Split('.');\n
    \       var front = long.Parse(split[0]);\n        if (split.Length == 1) {\n
    \           return front;\n        }\n        var back = double.Parse(split[1]);\n
    \       if (back > 0) {\n            front += 1;\n        }\n        return front;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <265cf475a166483ba03508b84d3fbcc8>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <265cf475a166483ba03508b84d3fbcc8>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d = double.Parse(value);\n
    \       if (d < 0)\n            return (long)Math.Ceiling(d);\n        else\n
    \           return (long)Math.Floor(d);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <be403c0d0aa844aab90be16d0ba4edbd>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <be403c0d0aa844aab90be16d0ba4edbd>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimalValue = decimal.Parse(value);\n
    \       return (long)Math.Round(decimalValue, MidpointRounding.AwayFromZero);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var first = value.Split('.')[0];\n
    \       var second = value.Split('.')[1];\n        long ff = long.Parse(first);\n
    \       long sf = long.Parse(second);\n        // string tmp = second[0].ToString();\n
    \       // if(tmp.Equals(\"5\")){\n        //     // return ff;\n        // }\n
    \       if(sf <= 5){\n            return ff;\n        }\n        return ff + 1;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.IndexOutOfRangeException: Index was outside
    the bounds of the array.\n  at Problem.ClosestInteger (System.String value) [0x00016]
    in <3d33fb89aa2e4f2aa09f64e8d70a8e97>:0 \n  at Problem.Main (System.String[] args)
    [0x00001] in <3d33fb89aa2e4f2aa09f64e8d70a8e97>:0 \n[ERROR] FATAL UNHANDLED EXCEPTION:
    System.IndexOutOfRangeException: Index was outside the bounds of the array.\n
    \ at Problem.ClosestInteger (System.String value) [0x00016] in <3d33fb89aa2e4f2aa09f64e8d70a8e97>:0
    \n  at Problem.Main (System.String[] args) [0x00001] in <3d33fb89aa2e4f2aa09f64e8d70a8e97>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger number = BigInteger.Parse(value);\n
    \       BigInteger floor = BigInteger.Floor(number);\n        BigInteger ceil
    = BigInteger.Ceiling(number);\n        BigInteger down = floor - number;\n        BigInteger
    up = ceil - number;\n        if (down > up) {\n            return (long)floor;\n
    \       } else {\n            return (long)ceil;\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_pznx1d4.cs(24,39): error CS0117: ''BigInteger'' does not contain a definition
    for ''Floor''

    /tmp/tmp_pznx1d4.cs(25,38): error CS0117: ''BigInteger'' does not contain a definition
    for ''Ceiling''

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long) Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <3fd6f3c96b6f4a76874be2825a7d53d1>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // From the given value, extract
    the decimal number.\n        var decimal_value = BigInteger.Parse(value);\n        //
    Extract the integer part of the number.\n        var integer_part = BigInteger.DivRem(decimal_value,
    1, out var fractional_part);\n        // If the fractional part is .5, then we
    need to round away from zero.\n        if (fractional_part == 0.5) {\n            //
    From the integer part, if the number is negative, then get the\n            //
    negative equivalent.\n            if (integer_part < 0) {\n                //
    Check if the integer part is the same as the given value. If\n                //
    it is, then we are given a number of the form -n.5 and the\n                //
    closest integer is just -n.\n                if (integer_part == decimal_value)
    {\n                    return integer_part;\n                }\n                //
    The closest integer to the given value is one less than the\n                //
    given value, since we want to round away from zero.\n                return integer_part
    - 1;\n            }\n            // From the integer part, if the number is positive,
    then get the\n            // positive equivalent.\n            else {\n                //
    Check if the integer part is the same as the given value. If\n                //
    it is, then we are given a number of the form n.5 and the\n                //
    closest integer is just n.\n                if (integer_part == decimal_value)
    {\n                    return integer_part;\n                }\n                //
    The closest integer to the given value is one more than the\n                //
    given value, since we want to round away from zero.\n                return integer_part
    + 1;\n            }\n        }\n        // We are not given a number of the form
    n.5, so the closest integer is\n        // just the integer part of the given
    value.\n        return integer_part;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp15grhkga.cs(28,13): error CS0019: Operator ''=='' cannot be applied to
    operands of type ''BigInteger'' and ''double''

    /tmp/tmp15grhkga.cs(36,28): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp15grhkga.cs(40,24): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp15grhkga.cs(49,28): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp15grhkga.cs(53,24): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmp15grhkga.cs(58,16): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // match an integer or a decimal\n
    \       var match = Regex.Match(value, @\"^(\\d*)(\\.\\d*)?$\");\n        if (!match.Success)
    {\n            throw new ArgumentException(\"Invalid value.\", \"value\");\n        }\n
    \       var integer = BigInteger.Parse(match.Groups[1].Value);\n        var decimalPart
    = BigInteger.Parse(match.Groups[2].Value + \"5\");\n        if (decimalPart >
    0) {\n            integer += decimalPart.Sign;\n        }\n        return (long)integer;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpz2bfbkil.cs(24,21): error CS0103: The name ''Regex'' does not exist in
    the current context

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimal_value = Decimal.Parse(value);\n
    \       decimal decimal_value_abs = Math.Abs(decimal_value);\n        decimal
    decimal_floor = Math.Floor(decimal_value_abs);\n        decimal decimal_ceiling
    = Math.Ceiling(decimal_value_abs);\n        if (decimal_value_abs - decimal_floor
    >= 0.5M) {\n            return (long)(decimal_value > 0 ? decimal_ceiling : -decimal_ceiling);\n
    \       } else {\n            return (long)(decimal_value > 0 ? decimal_floor
    : -decimal_floor);\n        }\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double number = Convert.ToDouble(value);\n
    \       double decimalPart = number - Math.Truncate(number);\n        if (number
    >= 0) {\n            if (decimalPart >= 0.5)\n                return (long)Math.Ceiling(number);\n
    \           else\n                return (long)Math.Floor(number);\n        }\n
    \       else {\n            if (decimalPart >= 0.5)\n                return (long)Math.Ceiling(number);\n
    \           else\n                return (long)Math.Floor(number);\n        }\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double number = double.Parse(value);\n
    \       if (number < 0) {\n            return Convert.ToInt64(Math.Ceiling(number));\n
    \       } else {\n            return Convert.ToInt64(Math.Floor(number));\n        }\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8e4d2e6a6ce744fca8c7f86d13a0fdfa>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <8e4d2e6a6ce744fca8c7f86d13a0fdfa>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // We need to convert the
    string to a float, and it will be a decimal.\n        decimal number = Convert.ToDecimal(value);\n
    \       // We need to convert the float to an integer, but the problem asks\n
    \       // that the number be rounded away from zero. This can be achieved\n        //
    by simply adding 0.5 before the conversion.\n        return Convert.ToInt64(number
    + 0.5M);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <fa105d747fc54461abb9e448ba5dcf43>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <fa105d747fc54461abb9e448ba5dcf43>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: implement your code
    here\n        BigInteger res;\n        BigInteger.TryParse(value, out res);\n
    \       BigInteger temp1 = res, temp2 = res;\n        while (temp1 % 1 != 0)\n
    \           temp1++;\n        while (temp2 % 1 != 0)\n            temp2--;\n        if
    (res - temp2 <= temp1 - res)\n            return temp2;\n        else\n            return
    temp1;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpwlkkce_j.cs(32,20): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpwlkkce_j.cs(34,20): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // A1: Implicitly convert
    parameter to double\n        // P1: Double.Parse(value);\n        // P2: Convert.ToDouble(value);\n
    \       // P3: Double.TryParse(value, out double d) ? d : 0d;\n        var d =
    Convert.ToDouble(value);\n        return Math.Round(d);\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpxlt1sfsl.cs(28,16): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimalValue = decimal.Parse(value);\n
    \       if (decimalValue == 0) return 0;\n        return (long)Math.Round(decimalValue,
    0, MidpointRounding.AwayFromZero);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var num = double.Parse(value);\n
    \       var frac = num - Math.Floor(num);\n        if (frac > 0.5) {\n            return
    (long) Math.Ceiling(num);\n        } else {\n            return (long) Math.Floor(num);\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <254e0fdd13c246a397655cd1e2757e0f>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double dval = Convert.ToDouble(value);\n
    \       long rval = Convert.ToInt64(Math.Round(dval));\n        return rval;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4ddf6d3f846249c3ad2f5052ffb825a8>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double number = Double.Parse(value);\n
    \       return (long)Math.Round(number, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long) Math.Ceiling(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0110f14176e64dc8ac7b43e5177b4bb6>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0110f14176e64dc8ac7b43e5177b4bb6>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // We are interested in the
    closest integer to the one represented\n        // by value, but the method we
    employ to arrive at the answer is\n        // the same whether we are looking
    for the closest integer greater\n        // than the given number or the closest
    integer less than it.\n        // We will look for the closest integer greater
    than the given\n        // number and then we will adjust the result if necessary.\n
    \       // The magnitude of the given number is a long number (either\n        //
    positive or negative).\n        // If the given number is negative, we can make
    the problem easier\n        // by taking the absolute value of the given number
    and then\n        // multiplying our result by -1.\n        // We will now assume
    the number is positive.\n        // This is the positive number whose magnitude
    we are interested in.\n        decimal positive_value = decimal.Parse(value);\n
    \       // This is the value with the decimal place shifted one to the right\n
    \       // (i.e. we divide by 10).\n        decimal value_10 = positive_value
    / 10m;\n        // This is the value with the decimal place shifted ten to the
    right\n        // (i.e. we divide by 100).\n        decimal value_100 = value_10
    / 10m;\n        // We are interested in the closest integer to value, which means\n
    \       // we are interested in the difference between value and the closest\n
    \       // integer, and we are interested in the sign of this difference.\n        //
    If the difference is negative, the closest integer to value is\n        // the
    integer that is one less than value.\n        // If the difference is positive,
    the closest integer to value is\n        // the integer that is one more than
    value.\n        // If the difference is zero, the closest integer to value is\n
    \       // value.\n        // One of the easy ways to check the sign of a decimal
    number is to\n        // multiply it by a million. So we will do that.\n        decimal
    difference_1000000 = (positive_value - (long) positive_value) * 1000000m;\n        //
    Now we will check the sign of difference_1000000.\n        // If it is negative,
    the closest integer to value is the integer\n        // that is one less than
    value.\n        // If it is positive, the closest integer to value is the integer\n\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp0qvnf916.cs(22,24): error CS0161: ''Problem.ClosestInteger(string)'':
    not all code paths return a value

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var val = BigInteger.Parse(value);\n
    \       return val.CompareTo(BigInteger.Zero) >= 0 ?\n            BigInteger.Ceiling(val)
    :\n            BigInteger.Floor(val);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmppzlaclip.cs(25,24): error CS0117: ''BigInteger'' does not contain a definition
    for ''Ceiling''

    /tmp/tmppzlaclip.cs(26,24): error CS0117: ''BigInteger'' does not contain a definition
    for ''Floor''

    '
  timestamp: 1659977285
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code here!\n        long
    closest = long.Parse(value);\n        long closest_d = 0;\n        if (closest
    < 0) {\n            closest_d = closest - 1;\n        } else {\n            closest_d
    = closest + 1;\n        }\n        double test_d = closest - Math.Floor(double.Parse(value));\n
    \       double test = closest_d - Math.Floor(double.Parse(value));\n        if
    (test_d == 0.5 && test == 0.5) {\n            return closest;\n        } else
    if (test_d == 0.5 && test != 0.5) {\n            return closest_d;\n        }
    else if (test_d != 0.5 && test == 0.5) {\n            return closest;\n        }
    else if (test_d < 0.5 && test < 0.5) {\n            return closest;\n        }
    else if (test_d < 0.5 && test > 0.5) {\n            return closest;\n        }
    else if (test_d > 0.5 && test < 0.5) {\n            return closest_d;\n        }
    else if (test_d > 0.5 && test > 0.5) {\n            return closest_d;\n        }\n
    \       return -1;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <9fb4e5d2ba9c40dd84ecfe4c6ef61565>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <9fb4e5d2ba9c40dd84ecfe4c6ef61565>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <9fb4e5d2ba9c40dd84ecfe4c6ef61565>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <9fb4e5d2ba9c40dd84ecfe4c6ef61565>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return value.Contains(\".\")
    ? Convert.ToInt64(Math.Round(Convert.ToDouble(value))) : Convert.ToInt64(value);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0db0be9dd4c74ba7951f67657bfedc8c>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long iValue = long.Parse(value);\n
    \       double dValue = double.Parse(value);\n        double diff = dValue - iValue;\n
    \       if (Math.Abs(diff) < 0.5) {\n            return iValue;\n        } else
    {\n            return iValue + (long)Math.Sign(diff);\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <4c6c37a865944a9488da0c44219275a0>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <4c6c37a865944a9488da0c44219275a0>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <4c6c37a865944a9488da0c44219275a0>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <4c6c37a865944a9488da0c44219275a0>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // \U0001F4AC Parse the value
    string\n        double doubleValue = double.Parse(value);\n\n        // \U0001F4AC
    Check if the doubleValue is positive\n        if (doubleValue >= 0) {\n            //
    \U0001F4AC Get the rounded value\n            long roundedValue = Convert.ToInt64(Math.Round(doubleValue));\n\n
    \           // \U0001F4AC Get the decimals\n            double decimals = doubleValue
    - roundedValue;\n\n            // \U0001F4AC Check if the decimals are more than
    0.5\n            if (decimals >= 0.5) {\n                return roundedValue +
    1;\n            } else {\n                return roundedValue;\n            }\n
    \       } else {\n            // \U0001F4AC Get the rounded value\n            long
    roundedValue = Convert.ToInt64(Math.Round(doubleValue));\n\n            // \U0001F4AC
    Get the decimals\n            double decimals = doubleValue - roundedValue;\n\n
    \           // \U0001F4AC Check if the decimals are less than -0.5\n            if
    (decimals <= -0.5) {\n                return roundedValue - 1;\n            }
    else {\n                return roundedValue;\n            }\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value.IndexOf(\".\") ==
    -1) {\n            return Int64.Parse(value);\n        }\n        double d = Double.Parse(value);\n
    \       if (d >= 0) {\n            return (long)Math.Floor(d + 0.5);\n        }
    else {\n            return (long)Math.Ceiling(d - 0.5);\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value.IndexOf('.') ==
    -1)\n            return long.Parse(value);\n        string[] split = value.Split('.');\n
    \       long whole = long.Parse(split[0]);\n        int decimalDigits = split[1].Length;\n
    \       int pow = 1;\n        for (int i = 0; i < decimalDigits; i++)\n            pow
    *= 10;\n        long decimalPart = long.Parse(split[1]);\n        if (decimalPart
    < pow / 2)\n            return whole;\n        return whole + 1;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <17676322be20426db56dae27ffaf54bd>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here.\n
    \       double a = Double.Parse(value);\n        if (a - (int)a < 0.5)\n            return
    (int)a;\n        else\n            return (int)a + 1;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <801bfe435c54448fbda722aaf23cc01b>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f2132e505d9744f0a0de05379fb03ff9>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // split on comma\n        var
    parts = value.Split('.');\n        if (parts.Length == 1) {\n            return
    long.Parse(parts[0]);\n        }\n        long intPart = long.Parse(parts[0]);\n
    \       long fractionalPart = long.Parse(parts[1]);\n        if (fractionalPart
    > 5) {\n            intPart += 1;\n        }\n        return intPart;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <14f1f423e0254fba9ed2f9772395459c>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <14f1f423e0254fba9ed2f9772395459c>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger val;\n        BigInteger.TryParse(value,
    out val);\n        BigInteger c1 = BigInteger.Floor(val);\n        BigInteger
    c2 = BigInteger.Ceiling(val);\n        if (val-c1 < c2-val) {\n            return
    (long)c1;\n        } else {\n            return (long)c2;\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp7xvlyqaq.cs(25,36): error CS0117: ''BigInteger'' does not contain a definition
    for ''Floor''

    /tmp/tmp7xvlyqaq.cs(26,36): error CS0117: ''BigInteger'' does not contain a definition
    for ''Ceiling''

    '
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var result = long.Parse(value);\n
    \       if (value.Contains(\".\")) {\n            var fNumber = float.Parse(value);\n
    \           result = (long)fNumber;\n            if (fNumber - result > 0.5f)\n
    \               result += 1;\n        }\n        return result;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <72a94b80d4624a738cf8c794432777ab>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <72a94b80d4624a738cf8c794432777ab>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <72a94b80d4624a738cf8c794432777ab>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <72a94b80d4624a738cf8c794432777ab>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var comparisonValue = 0;\n
    \       if (value.Contains(\".\")) {\n            var split = value.Split('.');\n
    \           comparisonValue = int.Parse(split[1]);\n        }\n        var comparison
    = new BigInteger(comparisonValue);\n        var closest = new BigInteger(value);\n
    \       if (comparison > 0) {\n            closest++;\n        }\n        return
    (long)closest;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp_n_p_aap.cs(29,38): error CS1503: Argument 1: cannot convert from ''string''
    to ''int''

    '
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // takes the string and converts
    it to a double\n        double d = Convert.ToDouble(value);\n        // checks
    if the number is positive or negative, then rounds accordingly\n        if (d
    >= 0) {\n            d = Math.Round(d);\n        } else {\n            d = Math.Ceiling(d);\n
    \       }\n        // converts the double back to a long\n        long l = Convert.ToInt64(d);\n
    \       return l;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6b1e3ddc9a9f4423aa53385ebe3ab579>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6b1e3ddc9a9f4423aa53385ebe3ab579>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d = double.Parse(value);\n
    \       return (long)Math.Round(d);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6c903bd8c0a949ca8a0a0c1f5de6972e>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger dividend = BigInteger.Parse(value);\n
    \       BigInteger divisor = BigInteger.Parse(\"1\");\n        BigInteger remainder
    = BigInteger.Parse(\"0\");\n        BigInteger quotient = BigInteger.DivRem(dividend,
    divisor, out remainder);\n        long quotient_as_long = (long) quotient;\n        long
    remainder_as_long = (long) remainder;\n        if (remainder_as_long <= 0) {\n
    \           return quotient_as_long;\n        } else {\n            if (value[0]
    == '-') {\n                return quotient_as_long - 1;\n            } else {\n
    \               return quotient_as_long + 1;\n            }\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <820bbae88e9b452bb2ec23ba4da6de54>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <820bbae88e9b452bb2ec23ba4da6de54>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Parse the value\n        double
    val = double.Parse(value);\n        // Find the integer part\n        var int_part
    = (long)val;\n        // Find the fractional part\n        var frac_part = val
    - int_part;\n        // Compare to see if it's closer to the next integer\n        if
    (frac_part >= 0.5) {\n            return int_part + 1;\n        } else {\n            return
    int_part;\n        }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b1591566179c43ce87c582b5aeafaf1e>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO - implement ClosestInteger\n
    \       throw new NotImplementedException();\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <4ebbd2f9afdb46659126ed767ffa1eca>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <4ebbd2f9afdb46659126ed767ffa1eca>:0 \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (string.IsNullOrEmpty(value))
    {\n            throw new Exception(\"Empty string\");\n        }\n        value
    = value.Trim();\n        // not using decimal because decimal has 28 decimal places,
    but sometimes\n        // a number like \"1e3000000000000000\" is passed to the
    function\n        double val;\n        if (!double.TryParse(value, out val)) {\n
    \           throw new Exception(\"Bad input\");\n        }\n        // val is
    in this range\n        var max_int = (double)Int64.MaxValue;\n        var min_int
    = (double)Int64.MinValue;\n        if (val > max_int) {\n            throw new
    Exception(\"Value too big\");\n        }\n        if (val < min_int) {\n            throw
    new Exception(\"Value too small\");\n        }\n        var val_m = (int)Math.Ceiling(val);\n
    \       var val_n = (int)Math.Floor(val);\n        var diff_m = Math.Abs(val_m
    - val);\n        var diff_n = Math.Abs(val_n - val);\n        if (diff_m == diff_n)
    {\n            if (val > 0) {\n                return val_m;\n            } else
    {\n                return val_n;\n            }\n        }\n        if (diff_m
    < diff_n) {\n            return val_m;\n        } else {\n            return val_n;\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long floor = (long)Math.Floor(double.Parse(value));\n
    \       long ceil = (long)Math.Ceiling(double.Parse(value));\n        if (value.Equals(floor.ToString()))
    {\n            return floor;\n        }\n        if (value.Equals(ceil.ToString()))
    {\n            return ceil;\n        }\n        if (Math.Abs(floor) < Math.Abs(ceil))
    {\n            return floor;\n        }\n        return ceil;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <3654581304084f2d987e1791f3170ce5>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <3654581304084f2d987e1791f3170ce5>:0
    \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger result = BigInteger.Parse(value);\n
    \       return (long)result;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <ad978c6dcbea49f9872a560b113a12d6>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <ad978c6dcbea49f9872a560b113a12d6>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var number = BigInteger.Parse(value);\n
    \       var closest = BigInteger.Zero;\n        if (number < BigInteger.Zero)
    {\n            var negative_closest = BigInteger.Zero;\n            for (var i
    = BigInteger.One; i > number; i *= BigInteger.MinusOne) {\n                negative_closest
    = number + i;\n            }\n            closest = number - negative_closest;\n
    \       } else {\n            for (var i = BigInteger.One; i < number; i++) {\n
    \               closest = number - i;\n            }\n        }\n        return
    (long)number;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <fa4b62805449472ab2926aa0745cdd35>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <fa4b62805449472ab2926aa0745cdd35>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here\n        return
    0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here!\n
    \       throw new NotImplementedException();\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <b72b99f9a9c54e699725bdf8ad31a85b>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <b72b99f9a9c54e699725bdf8ad31a85b>:0 \n"
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal num = decimal.Parse(value);\n
    \       return (long)Math.Round(num, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977286
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger result = BigInteger.Zero;\n
    \       decimal decimalValue = decimal.Parse(value);\n        result = BigInteger.Parse(Math.Round(decimalValue).ToString());\n
    \       return result;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpp77mccz2.cs(26,16): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(float.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7fc3bad870244291859d129cdae1b4d4>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var x = BigInteger.Parse(value);\n
    \       var r = x % 1;\n        return (long)(x - r);\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <ab21891019d045bbb5f86c655236b03f>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <ab21891019d045bbb5f86c655236b03f>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977287
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        int sign = 1;\n        if
    (value[0] == '-') {\n            sign = -1;\n            value = value.Substring(1);\n
    \       }\n        int decimalPoint = value.IndexOf('.');\n        int integer
    = int.Parse(value.Substring(0, decimalPoint));\n        if (decimalPoint == -1)
    {\n            return integer * sign;\n        }\n        double mantissa = double.Parse(value.Substring(decimalPoint));\n
    \       int nextInteger = (integer + 1) * sign;\n        if (Math.Abs(integer
    - mantissa) < Math.Abs(nextInteger - mantissa)) {\n            return integer
    * sign;\n        }\n        return nextInteger;\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.ArgumentOutOfRangeException: Length cannot
    be less than zero.\nParameter name: length\n  at System.String.Substring (System.Int32
    startIndex, System.Int32 length) [0x00031] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x0002a] in <784fd15883784a109929c8c7dfb76e3f>:0
    \n  at Problem.Main (System.String[] args) [0x00001] in <784fd15883784a109929c8c7dfb76e3f>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.ArgumentOutOfRangeException: Length
    cannot be less than zero.\nParameter name: length\n  at System.String.Substring
    (System.Int32 startIndex, System.Int32 length) [0x00031] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x0002a] in <784fd15883784a109929c8c7dfb76e3f>:0
    \n  at Problem.Main (System.String[] args) [0x00001] in <784fd15883784a109929c8c7dfb76e3f>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Create a function that
    takes a value (string) representing a number\n        // and returns the closest
    integer to it. If the number is equidistant\n        // from two integers, round
    it away from zero.\n        // Examples\n        // >>> ClosestInteger((\"10\"))\n
    \       // (10L)\n        // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n
    \       // Note:\n        // Rounding away from zero means that if the given number
    is equidistant\n        // from two integers, the one you should return is the
    one that is the\n        // farthest from zero. For example closest_integer(\"14.5\")
    should\n        // return 15 and closest_integer(\"-14.5\") should return -15.\n
    \       //\n        // Convert the number from a string to a double\n        double
    Number = Convert.ToDouble(value);\n        // Round the number up\n        double
    NumberUp = Math.Ceiling(Number);\n        // Round the number down\n        double
    NumberDown = Math.Floor(Number);\n        // If the number up is greater than
    the number down, take away 0.5\n        // from the number up and add 0.5 to the
    number down\n        if (NumberUp > NumberDown) {\n            NumberUp -= 0.5;\n
    \           NumberDown += 0.5;\n        }\n        // If the number up is equal
    to the number down, check if the number\n        // is positive\n        else
    if (NumberUp == NumberDown) {\n            // If the number is positive, return
    the number up\n            if (Number > 0) {\n                return Convert.ToInt64(NumberUp);\n
    \           }\n            // If the number is negative, return the number down\n
    \           else {\n                return Convert.ToInt64(NumberDown);\n            }\n
    \       }\n        // Find the difference between the number and the number up\n
    \       double DifferenceUp = Math.Abs(Number - NumberUp);\n        // Find the
    difference between the number and the number down\n        double DifferenceDown
    = Math.Abs(Number - NumberDown);\n        // If the difference between the number
    and the number up is greater\n        // than the difference between the number
    and the number down, return\n        // the number down\n        if (DifferenceUp\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpackrcd3u.cs(68,25): error CS1026: ) expected

    /tmp/tmpackrcd3u.cs(68,25): error CS1525: Invalid expression term ''}''

    /tmp/tmpackrcd3u.cs(68,25): error CS1002: ; expected

    '
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // This is a problem where
    I make the implementation\n        // needlessly more complicated than the problem.\n
    \       // I could use the static TryParse method from Convert\n        // to
    check whether or not the string contains a decimal.\n        // I could also use
    the built-in Math.Round method to\n        // convert a double to an integer.\n
    \       // But I didn't.\n        long closest;\n        if (value.Contains(\".\"))
    {\n            closest = Convert.ToInt64(value.Split('.')[0]);\n            if
    (closest < 0) {\n                closest -= 1;\n            } else {\n                closest
    += 1;\n            }\n        } else {\n            closest = Convert.ToInt64(value);\n
    \       }\n        return closest;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4d91e8f17dc24619b78e5738c0982008>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(Convert.ToDouble(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <5a7a643004a0473aaefaf9528a1f3405>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double val = double.Parse(value);\n
    \       return val > 0 ? (long) Math.Ceiling(val) : (long) Math.Floor(val);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b08fc7c2cb0f462694ebf7c5a7f527f3>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your solution goes here.\n
    \       return 0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d07872b1b28346a79479bd3114bc5ba0>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d07872b1b28346a79479bd3114bc5ba0>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long answer = 0;\n        //
    Your code goes here\n        // -9223372036854775808 to 9223372036854775807\n
    \       return answer;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <23105ea42812452a94326b45323e5142>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <23105ea42812452a94326b45323e5142>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal d = decimal.Parse(value);\n
    \       long intPart = (long) d;\n        decimal fracPart = d - intPart;\n        return
    fracPart < 0.5m ? intPart : intPart + 1;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <3fef0702986d46e0b45b1173d684cca3>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double input = Convert.ToDouble(value);\n
    \       return Convert.ToInt64(Math.Round(input, MidpointRounding.AwayFromZero));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value == null)\n            throw
    new ArgumentNullException();\n        if (value.Length == 0)\n            throw
    new ArgumentException();\n        float v = float.Parse(value);\n        float
    fractpart = v - (long)v;\n        if (fractpart > 0.5)\n            return (long)v
    + 1;\n        if (fractpart < -0.5)\n            return (long)v - 1;\n        return
    (long)v;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7d333a9f03734fba8aa3d4473a88ee16>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7d333a9f03734fba8aa3d4473a88ee16>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Write your code here.\n
    \       //throw new NotImplementedException();\n        int sign = 0;\n        if
    (value[0] == '-') {\n            sign = -1;\n            value = value.Substring(1);\n
    \       } else {\n            sign = 1;\n        }\n        long result = 0;\n
    \       int i = 0;\n        while (i < value.Length && value[i] != '.') {\n            result
    = result * 10 + (long)(value[i] - '0');\n            i++;\n        }\n        if
    (i != value.Length) {\n            i++;\n            if (i < value.Length) {\n
    \               if (value[i] - '0' >= 5) {\n                    result++;\n                }\n
    \           }\n        }\n        return result * sign;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // >>> ClosestInteger((\"10\"))\n
    \       // (10L)\n        // >>> ClosestInteger((\"15.3\"))\n        // (15L)\n
    \       // >>> ClosestInteger((\"14.5\"))\n        // (15L)\n        // >>> ClosestInteger((\"-14.5\"))\n
    \       // (-15L)\n        // >>> ClosestInteger((\"-14.4\"))\n        // (-14L)\n
    \       float flt = float.Parse(value);\n        // float flt = 0;\n        //
    float.TryParse(value, out flt);\n        // using System.Globalization.NumberStyles.Any;\n
    \       // float flt = float.Parse(value, NumberStyles.Any);\n        // Console.WriteLine(flt);\n
    \       // float.TryParse(value, System.Globalization.NumberStyles.Any, null,
    out flt);\n        // float.TryParse(value, out flt);\n        // Console.WriteLine(flt);\n
    \       if (flt > 0) {\n            return (long)Math.Floor(flt);\n        } else
    {\n            return (long)Math.Ceiling(flt);\n        }\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1afd1d189e594026b4c8dc25041cbc87>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <1afd1d189e594026b4c8dc25041cbc87>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var digits = value.Split('.');\n
    \       if (digits.Length == 1) {\n            return int.Parse(digits[0]);\n
    \       } else {\n            var leading = int.Parse(digits[0]);\n            var
    part = int.Parse(digits[1]);\n            var closer = leading;\n            if
    (part > 5) {\n                closer += 1;\n            }\n            return
    closer;\n        }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <745ab509c6f448c885941f1ca1b6d1a4>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <745ab509c6f448c885941f1ca1b6d1a4>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Convert the input string
    to a float\n        float f = float.Parse(value);\n        if(Math.Abs(f) > 0.5)
    {\n            // Round the float to the closest integer\n            return (long)Math.Round(f);\n
    \       } else {\n            // Round the float up to the next integer\n            return
    (long)Math.Ceiling(f);\n        }\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e6ecc517998647e88c52022f98e63028>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // replace this with your
    code\n        return 0;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <96cb94c26349418aa849462aec459b60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <96cb94c26349418aa849462aec459b60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal valueDec = decimal.Parse(value);\n
    \       int valueInt = (int)valueDec;\n        if (valueDec > valueInt) {\n            return
    valueInt + 1;\n        }\n        else {\n            return valueInt;\n        }\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d3197db9df0840bd9c27396a8a4a775a>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d3197db9df0840bd9c27396a8a4a775a>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var valueAsDecimal = decimal.Parse(value);\n
    \       var floor = Math.Floor(valueAsDecimal);\n        var ceil = Math.Ceiling(valueAsDecimal);\n
    \       if (valueAsDecimal == floor) {\n            return (long)floor;\n        }\n
    \       if (valueAsDecimal == ceil) {\n            return (long)ceil;\n        }\n
    \       if (valueAsDecimal - floor < ceil - valueAsDecimal) {\n            return
    (long)floor;\n        }\n        return (long)ceil;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7bb979b36fdc49d4aaffa3c31ca1127c>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var parts = value.Split('.');\n
    \       long result = long.Parse(parts[0]);\n        if (parts.Length == 1) {\n
    \           return result;\n        }\n        double fraction = double.Parse(\"0.\"
    + parts[1]);\n        if (fraction > 0.5) {\n            result += 1;\n        }\n
    \       return result;\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4dd5aafa62fe4d3d82995ce16bcc672b>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <4dd5aafa62fe4d3d82995ce16bcc672b>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: Implement this function\n
    \       double number = double.Parse(value);\n        var number1 = Math.Round(number);\n
    \       return (long)number1;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <3c1b190cc2e74adb8d478b419bc849cc>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return -1;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <44099c82f46b40909642687c1aff4acf>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <44099c82f46b40909642687c1aff4acf>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Write your code here\n
    \       return 0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <52fbd3fbc4a0452f8b427957e8f6ec41>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <52fbd3fbc4a0452f8b427957e8f6ec41>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var number = double.Parse(value);\n
    \       return (long) (Math.Abs(number - Math.Floor(number)) < Math.Abs(number
    - Math.Ceiling(number)) ? Math.Floor(number) : Math.Ceiling(number));\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2af4e5394adc4679a0195843734ffb4b>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Math.Round(Convert.ToDouble(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp4ev8qnir.cs(23,16): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimal_value = Decimal.Parse(value);\n
    \       decimal decimal_ceiling = Decimal.Ceiling(decimal_value);\n        decimal
    decimal_floor = Decimal.Floor(decimal_value);\n        decimal ceiling_difference
    = decimal_ceiling - decimal_value;\n        decimal floor_difference = decimal_value
    - decimal_floor;\n        if (ceiling_difference > floor_difference) {\n            return
    (long)decimal_floor;\n        } else {\n            return (long)decimal_ceiling;\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <40146d6af99f4fc6ab24246e47a7d2c6>:0
    \n"
  stdout: ''
  timestamp: 1659977287
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long a = 0;\n        // Write
    your code here.\n        double b = Convert.ToDouble(value);\n        a = Convert.ToInt64(Math.Round(b));\n
    \       return a;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d8c0a30134a54aaa966b17dc0cd0321e>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double n = double.Parse(value);\n
    \       long i = (long)Math.Floor(n);\n        if (n - i < 0.5) {\n            return
    i;\n        } else {\n            return i + 1;\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <45412949a8f04818b58903f4d1a58cbe>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Write code here.\n        double
    d = double.Parse(value);\n        if(d > 0) {\n            if(d - Math.Floor(d)
    < 0.5) {\n                return (long)Math.Floor(d);\n            } else {\n
    \               return (long)Math.Ceiling(d);\n            }\n        } else {\n
    \           if(d - Math.Floor(d) > -0.5) {\n                return (long)Math.Floor(d);\n
    \           } else {\n                return (long)Math.Ceiling(d);\n            }\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (Int64.TryParse(value,
    out long result)) {\n            return result;\n        }\n        else {\n            double
    p = double.Parse(value);\n            return Convert.ToInt64(Math.Ceiling(p));\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d98af125a10e48b6ab581ae498cf5f1b>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d98af125a10e48b6ab581ae498cf5f1b>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Assume input is a valid
    string with no negative signs\n        int i = 0;\n        for (; i < value.Length;
    i++) {\n            if (value[i] == '.') {\n                break;\n            }\n
    \       }\n        if (i == value.Length) {\n            return long.Parse(value);\n
    \       }\n        i++;\n        char next_digit = (i == value.Length) ? '0' :
    value[i];\n        // Round away from zero\n        if (next_digit >= '5') {\n
    \           return long.Parse(value.Substring(0, i)) + 1;\n        }\n        return
    long.Parse(value.Substring(0, i));\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00074] in <6c5cce6baaf04767a0fde92864c04299>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <6c5cce6baaf04767a0fde92864c04299>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00074] in <6c5cce6baaf04767a0fde92864c04299>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <6c5cce6baaf04767a0fde92864c04299>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return long.Parse(value);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: Input string was not in
    a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <222fe75f2aa947e99509f961880f4614>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <222fe75f2aa947e99509f961880f4614>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: Input string was
    not in a correct format.\n  at System.Number.ThrowOverflowOrFormatException (System.Boolean
    overflow, System.String overflowResourceKey) [0x0001a] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Number.ParseInt64 (System.ReadOnlySpan`1[T] value, System.Globalization.NumberStyles
    styles, System.Globalization.NumberFormatInfo info) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at System.Int64.Parse (System.String s) [0x00016] in <aa5dff9b31c64fce86559bbbf6cd364f>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <222fe75f2aa947e99509f961880f4614>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <222fe75f2aa947e99509f961880f4614>:0
    \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal decimal_value = decimal.Parse(value);\n
    \       decimal truncated_value = decimal.Truncate(decimal_value);\n        decimal
    decimal_remainder = decimal_value - truncated_value;\n        decimal decimal_remainder_abs
    = Math.Abs(decimal_remainder);\n        if (decimal_remainder_abs < 0.5m) {\n
    \           return (long)truncated_value;\n        } else {\n            if (decimal_value
    > 0) {\n                return (long)decimal.Ceiling(decimal_value);\n            }
    else {\n                return (long)decimal.Floor(decimal_value);\n            }\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: Finish this function\n
    \       return Math.Round(Convert.ToDouble(value));\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpryzfmhqh.cs(24,16): error CS0266: Cannot implicitly convert type ''double''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code here...\n        return
    0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <23241900ab0b4ccd9de5e7a1751a76ed>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <23241900ab0b4ccd9de5e7a1751a76ed>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Convert string to double.\n
    \       double d = Convert.ToDouble(value);\n        // Round double.\n        long
    i = (long) Math.Round(d);\n        // Return rounded integer.\n        return
    i;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <bf3fbf6d67ba49efb12e6dc148bc5289>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger decValue = BigInteger.Parse(value);\n
    \       BigInteger integer = BigInteger.Parse(String.Format(\"{0:0}\", decValue));\n
    \       BigInteger fraction = decValue - integer;\n        if (fraction == 0)\n
    \           return (long)integer;\n        else if (fraction < 0)\n            return
    (long)integer - 1;\n        else\n            return (long)integer + 1;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.FormatException: The value could not be
    parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) [0x00000] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at Problem.ClosestInteger (System.String value) [0x00001] in <3f777b1791024fcb8ccfdaa5c543ce96>:0
    \n  at Problem.Main (System.String[] args) [0x00016] in <3f777b1791024fcb8ccfdaa5c543ce96>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.FormatException: The value could not
    be parsed.\n  at System.Numerics.BigNumber.ParseBigInteger (System.ReadOnlySpan`1[T]
    value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x0001e] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigNumber.ParseBigInteger
    (System.String value, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo
    info) [0x00014] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style, System.IFormatProvider
    provider) [0x00008] in <60e4143c0cb74cd7b46ca0d0274780b4>:0 \n  at System.Numerics.BigInteger.Parse
    (System.String value, System.Globalization.NumberStyles style) [0x00007] in <60e4143c0cb74cd7b46ca0d0274780b4>:0
    \n  at System.Numerics.BigInteger.Parse (System.String value) ["
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger i = BigInteger.Parse(value);\n
    \       BigInteger i_ceil = BigInteger.Ceiling(i);\n        BigInteger i_floor
    = BigInteger.Floor(i);\n        BigInteger dist_ceil = i_ceil - i;\n        BigInteger
    dist_floor = i - i_floor;\n        if (dist_ceil == dist_floor) {\n            return
    (long)BigInteger.Sign(i) * i_ceil;\n        }\n        if (dist_ceil < dist_floor)
    {\n            return (long)i_ceil;\n        }\n        return (long)i_floor;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5uwkxlw7.cs(24,40): error CS0117: ''BigInteger'' does not contain a definition
    for ''Ceiling''

    /tmp/tmp5uwkxlw7.cs(25,41): error CS0117: ''BigInteger'' does not contain a definition
    for ''Floor''

    /tmp/tmp5uwkxlw7.cs(29,37): error CS1955: Non-invocable member ''BigInteger.Sign''
    cannot be used like a method.

    '
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal x = decimal.Parse(value);\n
    \       // decimal y = x - Math.Truncate(x);\n        decimal y = x - decimal.Truncate(x);\n
    \       if (y < 0.5m) {\n            return decimal.ToInt64(decimal.Truncate(x));\n
    \       } else {\n            return decimal.ToInt64(decimal.Truncate(x)) + 1;\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <91e75301fb894fd2ba7d2fe29e87d2b6>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        string[] s = value.Split('.');\n
    \       int i = int.Parse(s[0]);\n        if (s.Length > 1) {\n            double
    d = double.Parse(\"0.\" + s[1]);\n            if (d >= 0.5)\n                i++;\n
    \       }\n        return i;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b3840d85085645e1803c9e80689fa2fd>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: Implement this function!\n
    \       // Hint: Using BigInteger might be useful here!\n        BigInteger r
    = 0;\n        BigInteger.TryParse(value, out r);\n        // return (long) Math.Round(Convert.ToDouble(value));\n
    \       if(r < 0) {\n            return BigInteger.Subtract(r, new BigInteger(1));\n
    \       }\n        else {\n            return BigInteger.Add(r, new BigInteger(1));\n
    \       }\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmph1a1equj.cs(29,20): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmph1a1equj.cs(32,20): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code here\n        long
    ret = 0;\n        try {\n            ret = long.Parse(value);\n        } catch
    (FormatException e) {\n            ret = (long)Math.Ceiling(double.Parse(value));\n
    \       }\n        return ret;\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2c2ba865fb2f45188df0ff1e90fae323>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <2c2ba865fb2f45188df0ff1e90fae323>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        string[] parts = value.Split('.');\n
    \       BigInteger v = BigInteger.Parse(parts[0]);\n        if (parts.Length ==
    1) {\n            return (long)v;\n        }\n        BigInteger ten = BigInteger.Parse(\"10\");\n
    \       BigInteger d = BigInteger.Parse(parts[1]);\n        if (d < ten / 2) {\n
    \           return (long)v;\n        }\n        if (value[0] == '-') {\n            return
    (long)(v - 1);\n        }\n        return (long)(v + 1);\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: Please write your
    code here.\n        throw new NotImplementedException();\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <0dbb8ca2536f49ae98be8a3dadefe256>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <0dbb8ca2536f49ae98be8a3dadefe256>:0 \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        decimal number = decimal.Parse(value);\n
    \       return (long)Math.Round(number, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var res = decimal.Parse(value);\n
    \       return (long)Math.Round(res, 0, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // float is a 32 bit IEEE
    754 floating point number\n        // decimal is a 128 bit decimal number\n        //
    Convert.ToDouble(value) is not precise enough\n        // Math.Round(double) with
    MidpointRounding.AwayFromZero is not precise enough\n        // Math.Round(decimal)
    with MidpointRounding.AwayFromZero is not precise enough\n        // Math.Floor(double)
    is not precise enough\n        // Math.Ceiling(double) is not precise enough\n
    \       // Math.Truncate(double) is not precise enough\n        //\n        //
    Decimal.Round(decimal, MidpointRounding.AwayFromZero) is the only thing that is
    precise enough.\n        var d = Decimal.Parse(value);\n        var c = Decimal.Round(d,
    MidpointRounding.AwayFromZero);\n        return (long)c;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long x = 0;\n        bool
    y = long.TryParse(value, out x);\n        if (y) {\n            return x;\n        }
    else {\n            double z = double.Parse(value);\n            if (z > 0) {\n
    \               z = z + 0.5;\n            } else {\n                z = z - 0.5;\n
    \           }\n            x = (long)z;\n            return x;\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double num = Convert.ToDouble(value);\n
    \       if (num >= 0) {\n            return Convert.ToInt64(Math.Floor(num));\n
    \       } else {\n            return Convert.ToInt64(Math.Ceiling(num));\n        }\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <de8dfebb159e4136b549356a3b87c3ed>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <de8dfebb159e4136b549356a3b87c3ed>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // return 0;\n        decimal
    d = decimal.Parse(value);\n        decimal i = Math.Truncate(d);\n        decimal
    f = d - i;\n        if (f == 0.5m) {\n            i = Math.Sign(d) * (Math.Abs(i)
    + 1);\n        } else if (f > 0.5m) {\n            i = i + 1;\n        }\n        return
    (long)i;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <e01c6af35d504ae3a493c9e1ba12e411>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // if there is no decimal
    point then we can simply parse the string\n        if (value.IndexOf('.') == -1)
    {\n            return long.Parse(value);\n        }\n        // otherwise, split
    the string into two parts, one before the decimal point\n        // and one after\n
    \       var parts = value.Split('.');\n        var before = parts[0];\n        var
    after = parts[1];\n        // check to see if the value after the decimal point
    is greater than .5\n        // and then round accordingly\n        if (decimal.Parse(\"0.\"
    + after) >= .5m) {\n            return long.Parse(before) + 1;\n        }\n        return
    long.Parse(before);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c99093b9f31546d5a3bd464b386fac54>:0
    \n"
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return Convert.ToInt64(Math.Round(Convert.ToDouble(value)));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <f2132e505d9744f0a0de05379fb03ff9>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long ret;\n        var dec
    = decimal.Parse(value);\n        if (dec > 0) {\n            ret = (long)dec +
    (dec % 1 >= 0.5m ? 1 : 0);\n        } else {\n            ret = (long)dec - (dec
    % 1 <= -0.5m ? 1 : 0);\n        }\n        return ret;\n    }\n    public static
    void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        BigInteger bval = BigInteger.Parse(value);\n
    \       if (bval % 1 == 0) return (long)bval;\n        return (long)Math.Round(bval);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp5nj8bmun.cs(25,33): error CS1503: Argument 1: cannot convert from ''System.Numerics.BigInteger''
    to ''decimal''

    '
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        string[] nums = value.Split('.');\n
    \       if (nums.Length == 1) {\n            return long.Parse(nums[0]);\n        }
    else {\n            return long.Parse(nums[0]) + (long.Parse(nums[1][0].ToString())
    >= 5 ? 1 : 0);\n        }\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <a0a0acb0008f4b87b3752dc6ff4e7b83>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        long i = 0;\n        decimal
    r;\n        decimal n = decimal.Parse(value);\n        if (Math.Abs(Math.Truncate(n)
    - n) < 0.5m) {\n            i = (long)Math.Truncate(n);\n        } else {\n            r
    = Math.Round(n, 1);\n            if (r < 0) {\n                i = (long)Math.Truncate(r
    - 0.5m);\n            } else {\n                i = (long)Math.Truncate(r + 0.5m);\n
    \           }\n        }\n        return i;\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977288
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return long.Parse(Math.Round(double.Parse(value)).ToString());\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <51b4409c28414af6998a9e932a74892f>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var d = decimal.Parse(value);\n
    \       var intPart = (long)d;\n        var decPart = d - intPart;\n        if
    (decPart < 0.5m) return intPart;\n        if (decPart > 0.5m) return intPart +
    1;\n        if (intPart > 0) return intPart + 1;\n        return intPart - 1;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <d1ee9cf186544e92969535f03411c2c6>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here\n        return
    0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double number = double.Parse(value);\n
    \       double roundedNumber = Math.Round(number);\n        if (number < 0) {\n
    \           double cmp = Math.Abs(number - Math.Ceiling(number));\n            double
    cmp2 = Math.Abs(number - Math.Floor(number));\n            if (cmp < cmp2) {\n
    \               return (long)Math.Ceiling(number);\n            } else {\n                return
    (long)Math.Floor(number);\n            }\n        } else {\n            double
    cmp = Math.Abs(number - Math.Ceiling(number));\n            double cmp2 = Math.Abs(number
    - Math.Floor(number));\n            if (cmp < cmp2) {\n                return
    (long)Math.Ceiling(number);\n            } else {\n                return (long)Math.Floor(number);\n
    \           }\n        }\n    }\n    public static void Main(string[] args) {\n
    \   Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <5891c2eb857d47518718bf41444529c5>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value.Contains(\".\"))
    {\n            return long.Parse(value.Split('.')[0]);\n        }\n        return
    long.Parse(value);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <333ad22c46634e02b8f5145c4e28c540>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <333ad22c46634e02b8f5145c4e28c540>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var close = Math.Truncate(Decimal.Parse(value));\n
    \       var isNegative = Decimal.Parse(value) < 0;\n        var diff = Math.Abs(Decimal.Parse(value)
    - close);\n        return isNegative ? -(long)(close - diff) : (long)(close +
    diff);\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c9e26393e1204dffaeb8a213c425e9c2>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <c9e26393e1204dffaeb8a213c425e9c2>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value == null)\n            throw
    new ArgumentNullException(\"value\");\n        var dec = decimal.Parse(value);\n
    \       var res = Math.Round(dec);\n        return (long)res;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <031b8ac1ed524467a2b60262ce748715>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // If the value is given as
    an integer already we can simply return it.\n        if (value.Contains(\".\"))
    {\n            // Otherwise, we need to find the closest integer.\n            var
    split = value.Split('.');\n            var whole = int.Parse(split[0]);\n            var
    frac = split[1];\n            // The logic for determining which integer is closest
    is fairly\n            // simple.\n            var mid = new string('5', frac.Length);\n
    \           var result = 0;\n            if (frac.CompareTo(mid) < 0) {\n                result
    = whole;\n            } else if (frac.CompareTo(mid) > 0) {\n                result
    = whole + 1;\n            } else {\n                // If the fractional part
    is exactly equal to the midpoint,\n                // we need to round away from
    zero.\n                if (whole >= 0) {\n                    result = whole +
    1;\n                } else {\n                    result = whole - 1;\n                }\n
    \           }\n            return result;\n        } else {\n            return
    long.Parse(value);\n        }\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977289
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here\n        return
    0;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <da00933556424b508dcbf6baec6e6a60>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977286
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d = double.Parse(value);\n
    \       // Equidistant\n        if (d % 1 == 0.5) {\n            return (long)d
    + (d > 0 ? 1 : -1);\n        }\n        return (long)Math.Round(d);\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        float number = float.Parse(value);\n
    \       float ceil = Math.Ceiling(number);\n        float floor = Math.Floor(number);\n
    \       if (number == ceil) {\n            return (long)number;\n        }\n        else
    if (number - floor >= ceil - number) {\n            return (long)ceil;\n        }\n
    \       else {\n            return (long)floor;\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpep0xrt6p.cs(24,22): error CS0266: Cannot implicitly convert type ''double''
    to ''float''. An explicit conversion exists (are you missing a cast?)

    /tmp/tmpep0xrt6p.cs(25,23): error CS0266: Cannot implicitly convert type ''double''
    to ''float''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return 0;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b0c87d594cb44c45b622f3802eca3071>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // Your code goes here\n        float
    x = float.Parse(value);\n        float ceil = (float)Math.Ceiling(x);\n        float
    floor = (float)Math.Floor(x);\n        if (x - floor < ceil - x) {\n            return
    (long)floor;\n        } else {\n            return (long)ceil;\n        }\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <7a217ef5e4914d8caa833264857eb401>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return (long)Math.Round(double.Parse(value));\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <83ab1e6a02544cf6b29291b2f5381605>:0
    \n"
  stdout: ''
  timestamp: 1659977284
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double x = Convert.ToDouble(value);\n
    \       double a = Math.Floor(x);\n        double b = Math.Ceiling(x);\n        if
    (x - a < b - x)\n            return (long)a;\n        else\n            return
    (long)b;\n    }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <34e2c9e81106494db2d07d91da97a486>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double d = double.Parse(value);\n
    \       if (d < 0)\n            return (long) Math.Ceiling(d);\n        else\n
    \           return (long) Math.Floor(d);\n    }\n    public static void Main(string[]
    args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0441216e333b4a33a0750a8803d3f86c>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <0441216e333b4a33a0750a8803d3f86c>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // split string into mantissa
    and fraction\n        // if fraction is greater than 0.5, then round up\n        //
    if fraction is less than 0.5, then round down\n        decimal d = decimal.Parse(value);\n
    \       return Math.Round(d);\n    }\n    public static void Main(string[] args)
    {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\")) == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\"))
    == (15L));\n    Debug.Assert(ClosestInteger((\"0\")) == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpkwq3yqqj.cs(27,16): error CS0266: Cannot implicitly convert type ''decimal''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977289
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var n = BigInteger.Parse(value);\n
    \       return n.ToString().Contains(\".\") ?\n            RoundAway(n) :\n            n;\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmpa6wjz4bj.cs(25,13): error CS0103: The name ''RoundAway'' does not exist
    in the current context

    '
  timestamp: 1659977289
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        throw new NotImplementedException();\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "\nUnhandled Exception:\nSystem.NotImplementedException: The method or operation
    is not implemented.\n  at Problem.Main (System.String[] args) [0x00001] in <2ec815a2db224f418a5316877e9ffba1>:0
    \n[ERROR] FATAL UNHANDLED EXCEPTION: System.NotImplementedException: The method
    or operation is not implemented.\n  at Problem.Main (System.String[] args) [0x00001]
    in <2ec815a2db224f418a5316877e9ffba1>:0 \n"
  stdout: ''
  timestamp: 1659977285
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return -1;\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <44099c82f46b40909642687c1aff4acf>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <44099c82f46b40909642687c1aff4acf>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String "
  stdout: ''
  timestamp: 1659977287
- exit_code: 1
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        // TODO: implement.\n        BigInteger
    integerValue = BigInteger.Parse(value);\n        return integerValue;\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: SyntaxError
  stderr: ''
  stdout: 'Microsoft (R) Visual C# Compiler version 3.6.0-4.20224.5 (ec77c100)

    Copyright (C) Microsoft Corporation. All rights reserved.


    /tmp/tmp38zgpgw4.cs(25,16): error CS0266: Cannot implicitly convert type ''System.Numerics.BigInteger''
    to ''long''. An explicit conversion exists (are you missing a cast?)

    '
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        if (value.Contains(\".\"))
    {\n            var nums = value.Split('.');\n            if (nums[1].CompareTo(\"5\")
    >= 0) {\n                return long.Parse(nums[0]) + 1;\n            } else {\n
    \               return long.Parse(nums[0]);\n            }\n        } else {\n
    \           return long.Parse(value);\n        }\n    }\n    public static void
    Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) == (10L));\n
    \   Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <6c187985141c46fdae8e91e2e80ca517>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        var parsed = Double.Parse(value);\n
    \       if (parsed >= 0) {\n            return (long)Math.Ceiling(parsed);\n        }
    else {\n            return (long)Math.Floor(parsed);\n        }\n    }\n    public
    static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\")) ==
    (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <b6a468441a7448058b59a1ad3bc42c16>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double num = double.Parse(value);\n
    \       return (long)Math.Round(num, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        return long.Parse(value.Split('.')[0]);\n
    \   }\n    public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: Exception
  stderr: "Fail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String
    message, System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <ce43acf2ca3f4613bbe784e4f3a5fb1a>:0
    \nFail: \n  at System.Diagnostics.DefaultTraceListener.Fail (System.String message,
    System.String detailMessage) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceListener.Fail (System.String message) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.DefaultTraceListener.Fail
    (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at
    System.Diagnostics.TraceInternal.Fail (System.String message) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0
    \n  at System.Diagnostics.TraceInternal.Assert (System.Boolean condition) [0x00000]
    in <4932fe0df07342e1823cac360f8a44f7>:0 \n  at System.Diagnostics.Debug.Assert
    (System.Boolean condition) [0x00000] in <4932fe0df07342e1823cac360f8a44f7>:0 \n
    \ at Problem.Main (System.String[] args) [0x00000] in <ce43acf2ca3f4613bbe784e4f3a5fb1a>:0
    \n"
  stdout: ''
  timestamp: 1659977289
- exit_code: 0
  program: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing
    System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass
    Problem {\n    // Create a function that takes a value (string) representing a
    number\n    // and returns the closest integer to it. If the number is equidistant\n
    \   // from two integers, round it away from zero.\n    // Examples\n    // >>>
    ClosestInteger((\"10\"))\n    // (10L)\n    // >>> ClosestInteger((\"15.3\"))\n
    \   // (15L)\n    // Note:\n    // Rounding away from zero means that if the given
    number is equidistant\n    // from two integers, the one you should return is
    the one that is the\n    // farthest from zero. For example closest_integer(\"14.5\")
    should\n    // return 15 and closest_integer(\"-14.5\") should return -15.\n    public
    static long ClosestInteger(string value) {\n        double dVal = Convert.ToDouble(value);\n
    \       return (long)Math.Round(dVal, MidpointRounding.AwayFromZero);\n    }\n
    \   public static void Main(string[] args) {\n    Debug.Assert(ClosestInteger((\"10\"))
    == (10L));\n    Debug.Assert(ClosestInteger((\"14.5\")) == (15L));\n    Debug.Assert(ClosestInteger((\"-15.5\"))
    == (-16L));\n    Debug.Assert(ClosestInteger((\"15.3\")) == (15L));\n    Debug.Assert(ClosestInteger((\"0\"))
    == (0L));\n    }\n\n}\n"
  status: OK
  stderr: None
  stdout: ''
  timestamp: 1659977289
