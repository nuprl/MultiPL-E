name: HumanEval_59_largest_prime_factor
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Return the largest prime factor of n. Assume n > 1 and is not\
  \ a prime.\n    // >>> LargestPrimeFactor((13195L))\n    // (29L)\n    // >>> LargestPrimeFactor((2048L))\n\
  \    // (2L)\n    public static long LargestPrimeFactor(long n) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(LargestPrimeFactor((15L))\
  \ == (5L));\n    Debug.Assert(LargestPrimeFactor((27L)) == (3L));\n    Debug.Assert(LargestPrimeFactor((63L))\
  \ == (7L));\n    Debug.Assert(LargestPrimeFactor((330L)) == (11L));\n    Debug.Assert(LargestPrimeFactor((13195L))\
  \ == (29L));\n    }\n\n}\n"
completions: ["        // Brute force attempt.\n        // We could store primes less\
    \ than n/2.\n        for (long i = n - 1; i > 1; i--) {\n            if (n % i\
    \ == 0 && IsPrime(i))\n                return i;\n        }\n        return 1;",
  "        var f = new SieveFactorizer(n);\n        return f.AllFactors().Max();",
  "        for (long p = 2; p <= n; p++) {\n            if (n % p == 0) {\n      \
    \          n /= p;\n                p--;\n            }\n        }\n        return\
    \ n;", "        for (long p = (long)Math.Sqrt(n); p > 1; p--) {\n            if\
    \ (n % p == 0 && IsPrime(p)) {\n                return p;\n            }\n   \
    \     }\n        return n;", "        // Note: n is not a prime, so there must\
    \ be a prime factor p\n        // such that p <= sqrt(n).\n        var p = new\
    \ PrimeGenerator();\n        while (true) {\n            var q = p.Next();\n \
    \           if (q > Math.Sqrt(n)) {\n                // There are no more primes\
    \ <= sqrt(n).\n                return n;\n            }\n            if (n % q\
    \ == 0) {\n                // Found a prime factor, so continue to search for\
    \ a larger one.\n                n /= q;\n            }\n        }", "       \
    \ long maxPrime = 0;\n        while (n % 2 == 0) {\n            maxPrime = 2;\n\
    \            n >>= 1;\n        }\n        for (long i = 3; i <= Math.Sqrt(n);\
    \ i += 2) {\n            while (n % i == 0) {\n                maxPrime = i;\n\
    \                n = n / i;\n            }\n        }\n        if (n > 2)\n  \
    \          maxPrime = n;\n        return maxPrime;", "        var p = 2L;\n  \
    \      while (p < n) {\n            while (n % p == 0) {\n                n /=\
    \ p;\n            }\n            p += 1;\n        }\n        return n;", "   \
    \     long a = 2;\n        while (a * a <= n) {\n            if (n % a == 0)\n\
    \                n /= a;\n            else\n                a++;\n        }\n\
    \        return n;", "        while (n % 2 == 0) {\n            n /= 2;\n    \
    \    }\n        long next_factor = 3;\n        long largest_factor = 1;\n    \
    \    while (n > 1) {\n            if (n % next_factor == 0) {\n              \
    \  n /= next_factor;\n                largest_factor = next_factor;\n        \
    \    } else {\n                next_factor += 2;\n            }\n        }\n \
    \       return largest_factor;", "        // Start with the largest prime factor\
    \ of n, which is at most n / 2.\n        long p = 1;\n        for (long i = (n\
    \ / 2); i > 1; i--) {\n            if (IsPrime(i) && (n % i == 0)) {\n       \
    \         p = i;\n                break;\n            }\n        }\n        return\
    \ p;", "        if (n % 2 == 0) {\n            return LargestPrimeFactor(n / 2);\n\
    \        }\n        var i = 3L;\n        while (n % i != 0) {\n            i +=\
    \ 2;\n        }\n        if (i == n) {\n            return i;\n        }\n   \
    \     return LargestPrimeFactor(n / i);", "        long p = 2;\n        while\
    \ (n > 1) {\n            while (n % p == 0) {\n                n /= p;\n     \
    \       }\n            p++;\n        }\n        return p - 1;", '        return
    Enumerable.Range(2, (int)Math.Sqrt(n) - 1).Where(i => n % i == 0).Select(i =>
    LargestPrimeFactor(i)).Concat(new long[] { n }).Max();', "        long largest\
    \ = 2;\n        for (long factor = 3; factor < n; factor += 2) {\n           \
    \ while (n % factor == 0) {\n                n /= factor;\n                largest\
    \ = factor;\n            }\n        }\n        return largest;", "        // n\
    \ is guaranteed to be composite so it has to have a prime factor p.\n        //\
    \ If p > sqrt(n), then n/p < sqrt(n) and we will also find p.\n        long limit\
    \ = (long)Math.Sqrt(n);\n        long p = 2;\n        for (; p <= limit; p++)\
    \ {\n            if (n % p == 0) {\n                return LargestPrimeFactor(n\
    \ / p);\n            }\n        }\n        // If p > sqrt(n), the next iteration\
    \ will return n.\n        return n;", "        long prime = 2;\n        long res\
    \ = prime;\n        for (; prime <= n; prime = NextPrime(prime)) {\n         \
    \   if (n % prime == 0) {\n                res = prime;\n                n /=\
    \ prime;\n            }\n        }\n        return res;", "        // Solve problem\
    \ by exploiting the following facts:\n        // - Every number has a prime factor\
    \ less than its square root.\n        // - Every number greater than 3 is the\
    \ sum of 1 and the product of 2\n        //   primes.\n        //\n        //\
    \ Find the smallest prime factor of n and factor out that number until\n     \
    \   // n is the product of 2 primes. Then take the smaller of the 2 primes.\n\
    \        while (n % 2 == 0) n /= 2;\n        if (n == 1) return 2;\n        if\
    \ (n == 3) return 3;\n        long fac = 3;\n        while (fac * fac <= n) {\n\
    \            if (n % fac == 0) {\n                n /= fac;\n                if\
    \ (n == 1) break;\n                if (n % 2 == 0) {\n                    n /=\
    \ 2;\n                    if (n == 1) break;\n                }\n            }\n\
    \            fac += 2;\n        }\n        return fac;", "        long biggest\
    \ = 1;\n        for (long divisor = 2; divisor * divisor <= n; divisor++) {\n\
    \            if (n % divisor == 0) {\n                biggest = divisor;\n   \
    \             while (n % divisor == 0) {\n                    n /= divisor;\n\
    \                }\n            }\n        }\n        if (n > 1) {\n         \
    \   biggest = n;\n        }\n        return biggest;", "        long i;\n    \
    \    long q;\n        i = 2;\n        while (true) {\n            q = n / i;\n\
    \            if (q * i == n) {\n                n = q;\n                if (n\
    \ == 1) {\n                    return i;\n                }\n            } else\
    \ {\n                i = i + 1;\n            }\n        }", "        long largest\
    \ = 1;\n        long f = 2;\n        while (n > 1) {\n            // Consume all\
    \ of f if it divides n.\n            while (n % f == 0) {\n                largest\
    \ = f;\n                n /= f;\n            }\n            // f is prime if it\
    \ is not divisible by 2, 3, or 5. \n            if (f == 2) {\n              \
    \  f = 3;\n            } else if (f == 3) {\n                f = 5;\n        \
    \    } else {\n                f += 2;\n                while (f % 3 == 0 || f\
    \ % 5 == 0) {\n                    f += 2;\n                }\n            }\n\
    \        }\n        return largest;", "        long r = n;\n        for (long\
    \ i = 2; i <= r; i++) {\n            if (r % i == 0) {\n                do {\n\
    \                    r /= i;\n                } while (r % i == 0);\n        \
    \    }\n        }\n        return r;", "        long factor = 2;\n        while\
    \ (n > 1) {\n            if (n % factor == 0) {\n                n /= factor;\n\
    \            } else {\n                factor += 1;\n            }\n        }\n\
    \        return factor;", "        for (long i = 3; ; i += 2) {\n            if\
    \ (n % i == 0) {\n                if (i * i > n) {\n                    return\
    \ n;\n                }\n                else {\n                    return LargestPrimeFactor(n\
    \ / i);\n                }\n            }\n        }", "        // Assume n >\
    \ 1 and not prime.\n        if (n == 2)\n            return 2;\n        if (n\
    \ % 2 == 0)\n            return 2;\n        var largestPrimeFactor = 0L;\n   \
    \     // Only need to check odd numbers up to sqrt(n).\n        for (long i =\
    \ 3; i * i <= n; i += 2) {\n            // Check if i is a prime factor of n.\n\
    \            if (n % i == 0) {\n                largestPrimeFactor = i;\n    \
    \            // Continue dividing by i as long as n % i == 0.\n              \
    \  do {\n                    n /= i;\n                } while (n % i == 0);\n\
    \            }\n        }\n        if (n > largestPrimeFactor)\n            return\
    \ n;\n        return largestPrimeFactor;", "        if (IsPrime(n)) {\n      \
    \      return n;\n        }\n        for (long divisor = 2; divisor <= Math.Sqrt(n);\
    \ divisor++) {\n            if (n % divisor == 0) {\n                return LargestPrimeFactor(n\
    \ / divisor);\n            }\n        }\n        // Should never get here.\n \
    \       throw new Exception(\"Can't get here\");", "        long x = n;\n    \
    \    long prime = 0;\n        int factor = 2;\n        while (x > 1) {\n     \
    \       while (x % factor == 0) {\n                x /= factor;\n            \
    \    prime = factor;\n            }\n            factor++;\n        }\n      \
    \  return prime;", "        long a = n;\n        for (long i = 2; i <= Math.Sqrt(n);\
    \ i++) {\n            if (a % i == 0) {\n                a /= i;\n           \
    \     while (a % i == 0) {\n                    a /= i;\n                }\n \
    \           }\n        }\n        return a;", "        long p = 2;\n        long\
    \ q = n;\n        while (p * p <= q) {\n            if (q % p == 0) {\n      \
    \          q /= p;\n            } else {\n                p++;\n            }\n\
    \        }\n        return q;", "        long largestFactor = 1;\n        long\
    \ prime = 2;\n        while (prime <= n / largestFactor) {\n            if (n\
    \ % prime == 0) {\n                largestFactor = prime;\n                while\
    \ (n % prime == 0) {\n                    n /= prime;\n                }\n   \
    \         }\n            prime += 1;\n        }\n        return largestFactor;",
  "        long d = 2;\n        while (n > 1) {\n            if (n % d == 0) {\n \
    \               n /= d;\n            } else {\n                d += 1;\n     \
    \       }\n        }\n        return d;", "        for (long d = 2; d <= n; d++)\
    \ {\n            if (n % d == 0) {\n                n /= d;\n                d--;\n\
    \            }\n        }\n        return n;", "        long largest_prime_factor\
    \ = 0;\n        long divisor = 2;\n        while (n > 1) {\n            while\
    \ (n % divisor == 0) {\n                n /= divisor;\n                largest_prime_factor\
    \ = divisor;\n            }\n            divisor += 1;\n        }\n        return\
    \ largest_prime_factor;", "        // TODO: Fill this in.\n        long largest\
    \ = 0;\n        for (long factor = 2; factor < n; factor++) {\n            if\
    \ (n % factor == 0) {\n                n /= factor;\n                largest =\
    \ factor;\n            }\n        }\n        return largest;", "        long maxf\
    \ = 1;\n        while (n % 2 == 0) { maxf = 2; n /= 2; }\n        for (long i\
    \ = 3; i <= n; i += 2) {\n            if (n % i == 0) {\n                maxf\
    \ = i;\n                while (n % i == 0) { n /= i; }\n            }\n      \
    \  }\n        return maxf;", "        for (long i = (long)Math.Ceiling(Math.Sqrt(n));\
    \ i > 1; i--) {\n            if (n % i == 0 && IsPrime(i)) {\n               \
    \ return i;\n            }\n        }\n        return -1;", "        // YOUR CODE\
    \ HERE\n        // http://www.programminglogic.com/the-sieve-of-eratosthenes-implemented-in-c/\n\
    \        long limit = (long)Math.Ceiling(Math.Sqrt(n));\n        List<long> primes\
    \ = new List<long>();\n        List<long> nonprimes = new List<long>();\n    \
    \    // initialize a Sieve of Eratosthenes\n        for (long i = 2; i <= limit;\
    \ i++) {\n            primes.Add(i);\n        }\n        foreach (long prime in\
    \ primes) {\n            for (long i = prime * prime; i <= limit; i += prime)\
    \ {\n                nonprimes.Add(i);\n            }\n        }\n        primes\
    \ = primes.Except(nonprimes).ToList();\n        foreach (long prime in primes)\
    \ {\n            if (n % prime == 0) {\n                return prime;\n      \
    \      }\n        }\n        return n;", "        long i;\n        for (i = 2;\
    \ i * i <= n; i++) {\n            while (n % i == 0) {\n                n /= i;\n\
    \            }\n        }\n        return n;", "        long d = 2;\n        while\
    \ (n > 1) {\n            while (n % d == 0) {\n                n /= d;\n     \
    \       }\n            d++;\n        }\n        return d - 1;", "        long\
    \ maxPrime = 1;\n        long f = 3;\n        while (f * f <= n) {\n         \
    \   if (n % f == 0) {\n                maxPrime = f;\n                n /= f;\n\
    \            } else {\n                f += 2;\n            }\n        }\n   \
    \     if (n > 1) {\n            maxPrime = n;\n        }\n        return maxPrime;",
  "        long largestPrimeFactor = 1;\n        long divisor = 2;\n        while\
    \ (n > 1) {\n            while (n % divisor == 0) {\n                largestPrimeFactor\
    \ = divisor;\n                n /= divisor;\n            }\n            divisor\
    \ += 1;\n        }\n        return largestPrimeFactor;", "        long result\
    \ = 1;\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i ==\
    \ 0) {\n                result = i;\n                while (n % i == 0)\n    \
    \                n /= i;\n            }\n        }\n        if (n > 1)\n     \
    \       result = n;\n        return result;", "        long p = 2;\n        while\
    \ (p <= n) {\n            if (n % p == 0) {\n                n /= p;\n       \
    \     } else {\n                p += 1;\n            }\n        }\n        return\
    \ p;", "        for (long x = (long)Math.Ceiling(Math.Sqrt(n)); x > 1; x--) {\n\
    \            if (n % x == 0 && Prime.IsPrime(x)) {\n                return x;\n\
    \            }\n        }\n        return -1;", "        long max = 1;\n     \
    \   for (long x = 2; x * x <= n; x++) {\n            if (n % x == 0) {\n     \
    \           for (long y = 2; y * y <= x; y++) {\n                    if (x % y\
    \ == 0)\n                        goto NonPrime;\n                }\n         \
    \       max = x;\n                NonPrime: ;\n            }\n        }\n    \
    \    return max;", "        // Note: it is enough to check just primes. \n   \
    \     var primes = PrimeGenerator.GetPrimesBelow(10000);\n        foreach (var\
    \ p in primes.Reverse()) {\n            if (n % p == 0) {\n                return\
    \ p;\n            }\n        }\n        throw new InvalidOperationException(\"\
    Reached unreachable code.\");", "        long factor = 2;\n        long lastFactor\
    \ = 1;\n        long maxFactor = (long)Math.Ceiling(Math.Sqrt(n));\n        while\
    \ (n > 1 && factor <= maxFactor) {\n            if (n % factor == 0) {\n     \
    \           lastFactor = factor;\n                n /= factor;\n             \
    \   while (n % factor == 0) {\n                    n /= factor;\n            \
    \    }\n                maxFactor = (long)Math.Ceiling(Math.Sqrt(n));\n      \
    \      }\n            factor += 1;\n        }\n        if (n == 1) {\n       \
    \     return lastFactor;\n        } else {\n            return n;\n        }",
  "        long f = 2;\n        while (n > 1) {\n            if (n % f == 0) {\n \
    \               n /= f;\n            } else {\n                f++;\n        \
    \    }\n        }\n        return f;", "        var factor = 2L;\n        while\
    \ (n > 1) {\n            if (n % factor == 0) {\n                n /= factor;\n\
    \            } else {\n                factor += 1;\n            }\n        }\n\
    \        return factor;", "        long a = 3;\n        while (n % 2 == 0) {\n\
    \            n /= 2;\n        }\n        if (n == 1) {\n            return 2;\n\
    \        }\n        long temp = n;\n        while (temp >= a * a) {\n        \
    \    if (temp % a == 0) {\n                temp /= a;\n            } else {\n\
    \                a += 2;\n            }\n        }\n        return temp;", " \
    \       long i = 2;\n        while (n > 1) {\n            if (n % i == 0) {\n\
    \                n /= i;\n            } else {\n                i++;\n       \
    \     }\n        }\n        return i;", "        // Returns the smallest prime\
    \ factor of n.\n        long SmallestPrimeFactor(long n) {\n            if (n\
    \ % 2 == 0) return 2;\n            for (long p = 3; p * p <= n; p += 2) {\n  \
    \              if (n % p == 0) return p;\n            }\n            return n;\n\
    \        }\n        long p = SmallestPrimeFactor(n);\n        return p == n ?\
    \ p : LargestPrimeFactor(n / p);", "        long max = 1;\n        long p = 2;\n\
    \        while (n > 1) {\n            long q = n / p;\n            long r = n\
    \ % p;\n            if (r == 0) {\n                while (r == 0) {\n        \
    \            n = q;\n                    q = n / p;\n                    r = n\
    \ % p;\n                }\n                max = p;\n            }\n         \
    \   p += 1;\n        }\n        return max;", "        var i = 2L;\n        while\
    \ (i * i <= n) {\n            if (n % i == 0)\n                n /= i;\n     \
    \       else\n                i += 1;\n        }\n        return n;", "      \
    \  var factors = Factorize(n);\n        return factors.Max();", "        long\
    \ f = 2;\n        while (n > 1) {\n            while (n % f == 0) {\n        \
    \        n /= f;\n            }\n            f++;\n        }\n        return f\
    \ - 1;", "        long largest = 2;\n        // Now try to find a prime factor\
    \ of n\n        for (long i = 3; i < n; i++) {\n            // if i divides n,\
    \ then i is prime and a factor\n            if (n % i == 0) {\n              \
    \  // Is i prime?\n                bool isPrime = true;\n                for (long\
    \ j = 2; j < i; j++) {\n                    if (i % j == 0) {\n              \
    \          isPrime = false;\n                        break;\n                \
    \    }\n                }\n                if (isPrime) {\n                  \
    \  // found a prime factor\n                    largest = i;\n               \
    \ }\n            }\n        }\n        return largest;", "        // (1) Try all\
    \ the possible prime factors starting from 2 until sqrt(n).\n        // The largest\
    \ prime factor must be less than or equal to sqrt(n).\n        // (2) For each\
    \ possible prime factor p, check if n is divisible by p.\n        // (3) If n\
    \ is divisible by p, reduce n by dividing it by p.\n        // (4) Continue to\
    \ do (2) and (3) until n is 1.\n        // (5) Keep track of the largest prime\
    \ factor so far.\n        // (6) Return the largest prime factor.\n        long\
    \ largestPrimeFactor = 0;\n        long primeFactor = 2;\n        long sqrtN =\
    \ (long)Math.Sqrt(n);\n        while (primeFactor <= sqrtN) {\n            if\
    \ (n % primeFactor == 0) {\n                largestPrimeFactor = primeFactor;\n\
    \                while (n % primeFactor == 0) {\n                    n /= primeFactor;\n\
    \                }\n                sqrtN = (long)Math.Sqrt(n);\n            }\n\
    \            primeFactor++;\n        }\n        if (n > 1) {\n            largestPrimeFactor\
    \ = n;\n        }\n        return largestPrimeFactor;", "        long currentFactor\
    \ = 2;\n        long lastFactor = 1;\n        while (n > 1) {\n            if\
    \ (n % currentFactor == 0) {\n                lastFactor = currentFactor;\n  \
    \              n /= currentFactor;\n                while (n % currentFactor ==\
    \ 0) {\n                    n /= currentFactor;\n                }\n         \
    \   }\n            currentFactor++;\n        }\n        return lastFactor;", " \
    \       // Find smallest prime factor and use it to divide out factors of n.\n\
    \        for (long i = 2; i <= Math.Sqrt(n); i++) {\n            if (n % i ==\
    \ 0) {\n                return LargestPrimeFactor(n / i);\n            }\n   \
    \     }\n        return n;", "        // We keep checking even numbers. This means\
    \ we don't have to worry about odd numbers.\n        // We only have to check\
    \ primes up to the square root of n, but we keep a list of primes\n        //\
    \ up to the square root of n so we can check the primality of other numbers.\n\
    \        long sqrt = (long)Math.Sqrt(n);\n        List<long> primes = new List<long>();\n\
    \        for (long i = 2; i <= sqrt; i++) {\n            // Check if i is prime.\n\
    \            bool prime = true;\n            foreach (long p in primes) {\n  \
    \              if (i % p == 0) {\n                    prime = false;\n       \
    \             break;\n                }\n            }\n            if (prime)\
    \ {\n                // i is prime.\n                primes.Add(i);\n        \
    \        // Divide out i if n is divisible by i.\n                while (n % i\
    \ == 0) {\n                    n /= i;\n                }\n            }\n   \
    \     }\n        return n;", "        if (n == 2) return 2;\n        for (long\
    \ i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                return\
    \ LargestPrimeFactor(n / i);\n            }\n        }\n        return n;", " \
    \       long largest = 0;\n        if (n < 2) return 0;\n        for (long d =\
    \ 2; d <= n; d++) {\n            if (n % d == 0) {\n                n /= d;\n\
    \                largest = d;\n                d = 1;\n            }\n       \
    \ }\n        return largest;", "        var max = 0L;\n        while (n % 2 ==\
    \ 0) {\n            max = 2;\n            n /= 2;\n        }\n        for (var\
    \ f = 3L; f * f <= n; f += 2) {\n            while (n % f == 0) {\n          \
    \      max = f;\n                n /= f;\n            }\n        }\n        if\
    \ (n > 2) {\n            max = n;\n        }\n        return max;", "        long\
    \ factor = 2;\n        while (factor * factor <= n) {\n            if (n % factor\
    \ == 0) {\n                n /= factor;\n            } else {\n              \
    \  factor++;\n            }\n        }\n        return n;", "        Debug.Assert(n\
    \ > 1);\n        Debug.Assert(n % 2 == 0 || n % 3 == 0);\n        for (long i\
    \ = 5L; i * i <= n; i += 6) {\n            if (n % i == 0) {\n               \
    \ return LargestPrimeFactor(n / i);\n            }\n            if (n % (i + 2)\
    \ == 0) {\n                return LargestPrimeFactor(n / (i + 2));\n         \
    \   }\n        }\n        return n;", "        long result = 1;\n        for (long\
    \ p = 2; p <= n; p++) {\n            while (n % p == 0) {\n                result\
    \ = p;\n                n /= p;\n            }\n        }\n        return result;",
  '        return PrimeFactors(n).Max();', "        long c = 1;\n        if (n%2 ==\
    \ 0) {\n            c = 2;\n            while (n%2 == 0) {\n                n\
    \ /= 2;\n            }\n        }\n        if (n == 1) {\n            return c;\n\
    \        }\n        int i = 3;\n        while (i <= n) {\n            if (n%i\
    \ == 0) {\n                n /= i;\n                c = i;\n            } else\
    \ {\n                i += 2;\n            }\n        }\n        return c;", " \
    \       long prime = 1;\n        for (long i = 2; i <= Math.Sqrt(n); i++) {\n\
    \            if (IsPrime(i) && n % i == 0) {\n                prime = i;\n   \
    \         }\n        }\n        return prime;", "        Debug.Assert(n > 1L);\n\
    \        for (long i = 2L; i * i <= n; i++) {\n            while (n % i == 0L)\
    \ {\n                n /= i;\n            }\n        }\n        return n;", " \
    \       long factor = 2;\n        long lastFactor = 1;\n        while (n > 1)\
    \ {\n            if (n % factor == 0) {\n                lastFactor = factor;\n\
    \                n /= factor;\n                while (n % factor == 0) {\n   \
    \                 n /= factor;\n                }\n            }\n           \
    \ factor += 1;\n        }\n        return lastFactor;", "        if (n <= 3) {\n\
    \            return n;\n        }\n        if (n % 2 == 0) {\n            return\
    \ LargestPrimeFactor(n / 2);\n        }\n        if (n % 3 == 0) {\n         \
    \   return LargestPrimeFactor(n / 3);\n        }\n        long m = (long)Math.Sqrt(n);\n\
    \        long a = 5;\n        while (a <= m) {\n            if (n % a == 0) {\n\
    \                return LargestPrimeFactor(n / a);\n            }\n          \
    \  a += 2;\n            if (n % a == 0) {\n                return LargestPrimeFactor(n\
    \ / a);\n            }\n            a += 4;\n        }\n        return n;", " \
    \       int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0)\
    \ {\n                n /= i;\n            } else {\n                i++;\n   \
    \         }\n        }\n        return n;", "        long largestFactor = 1;\n\
    \        long[] primes = new long[] { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109,\
    \ 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\
    \ 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,\
    \ 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389,\
    \ 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487,\
    \ 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\
    \ 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,\
    \ 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,\
    \ 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919,\
    \ 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021,\
    \ 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103,\
    \ 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181,", "        // Find the\
    \ largest prime factor of n.\n        long p = 2;\n        while (n > 1) {\n \
    \           // Find the smallest prime factor of n.\n            while (n % p\
    \ == 0) {\n                n /= p;\n            }\n            // p must be less\
    \ than sqrt(n).\n            p = NextPrime(p);\n        }\n        return p;",
  '        return LargestPrimeFactorHelper(n, 2);', "        var factors = new List<long>();\n\
    \        // Factor out all powers of 2.\n        for (; n % 2 == 0; n /= 2) {\n\
    \            factors.Add(2);\n        }\n        // Factor out all odd factors.\n\
    \        long p = 3;\n        while (n > 1) {\n            while (n % p == 0)\
    \ {\n                factors.Add(p);\n                n /= p;\n            }\n\
    \            p += 2;\n        }\n        return factors.Max();", '        return
    Factorize(n).Last();', "        for (long i = 2; i < Math.Sqrt(n); i++) {\n  \
    \          if (n % i == 0) {\n                long p = LargestPrimeFactor(n /\
    \ i);\n                if (p == 1) {\n                    return n / i;\n    \
    \            } else {\n                    return p;\n                }\n    \
    \        }\n        }\n        return 1;", "        long result = 0;\n       \
    \ int i = 2;\n        while (i * i <= n) {\n            if (n % i == 0) {\n  \
    \              n /= i;\n                result = i;\n            } else {\n  \
    \              i += 1;\n            }\n        }\n        if (n > result) {\n\
    \            result = n;\n        }\n        return result;", "        // Enter\
    \ your code here.\n        return -1;", "        for (long i = 2; i * i <= n;\
    \ i++) {\n            if (n % i == 0) {\n                n /= i;\n           \
    \     i = 1;\n            }\n        }\n        return n;", "        long largestPrimeFactor\
    \ = 2;\n        long a = 2;\n        while (n > 1) {\n            while (n % a\
    \ == 0) {\n                n /= a;\n                largestPrimeFactor = a;\n\
    \            }\n            if (a == 2) {\n                a = 3;\n          \
    \  } else {\n                a += 2;\n            }\n        }\n        return\
    \ largestPrimeFactor;", "        long i;\n        for (i = 3; i <= n; i += 2)\
    \ {\n            if (n % i == 0) {\n                return LargestPrimeFactor(n\
    \ / i);\n            }\n        }\n        return n;", "        long factors =\
    \ 0;\n        long factor = 2;\n        while (n > 1) {\n            while (n\
    \ % factor == 0) {\n                factors = factor;\n                n /= factor;\n\
    \            }\n            factor += 1;\n        }\n        return factors;",
  "        long largest = 1;\n        while (n % 2 == 0) {\n            largest =\
    \ 2;\n            n /= 2;\n        }\n        long p = 3;\n        long limit\
    \ = (long)Math.Sqrt(n);\n        while (n > 1 && p <= limit) {\n            if\
    \ (n % p == 0) {\n                largest = p;\n                n /= p;\n    \
    \            limit = (long)Math.Sqrt(n);\n            } else {\n             \
    \   p += 2;\n            }\n        }\n        if (n == 1) {\n            return\
    \ largest;\n        } else {\n            return n;\n        }", "        while\
    \ (n % 2 == 0) {\n            n /= 2;\n        }\n        if (n == 1) {\n    \
    \        return 2;\n        }\n        long root = (long)Math.Sqrt(n);\n     \
    \   long p = 3;\n        while (p <= root) {\n            if (n % p == 0) {\n\
    \                n /= p;\n                root = (long)Math.Sqrt(n);\n       \
    \     } else {\n                p += 2;\n            }\n        }\n        return\
    \ n;", "        long largest_prime_factor = 1;\n        for (long factor = 2;\
    \ factor <= n; factor++) {\n            while (n % factor == 0) {\n          \
    \      largest_prime_factor = factor;\n                n /= factor;\n        \
    \    }\n        }\n        return largest_prime_factor;", "        long[] f =\
    \ Factoring.Factor(n);\n        return f[f.Length - 1];", "        long largestPrimeFactor\
    \ = 1;\n        // TODO: find the largest prime factor of n.\n        return largestPrimeFactor;",
  "        long ans = 2;\n        while (n > 1) {\n            if (n % ans == 0) {\n\
    \                n /= ans;\n            } else {\n                ans++;\n   \
    \         }\n        }\n        return ans;", "        for (long i = 2; i <= n\
    \ / i; i++) {\n            while (n % i == 0) {\n                n /= i;\n   \
    \         }\n        }\n        return n;", "        // This works by dividing\
    \ out as many small factors as possible and\n        // then trying larger factors.\
    \ If a composite is found, it divides out\n        // the smallest factor and\
    \ tries again, until the largest factor is\n        // found.\n        // Since\
    \ the smallest factor is at most sqrt(n), this only takes O(sqrt(n))\n       \
    \ // time.\n        long f = 2;\n        for (; f * f <= n; ++f) {\n         \
    \   while (n % f == 0) {\n                n /= f;\n            }\n        }\n\
    \        return n;", "        if (IsPrime(n)) {\n            return n;\n     \
    \   }\n        long[] factors = Factorization(n);\n        long m = factors[factors.Length\
    \ - 1];\n        return m;", "        long p = 2;\n        while (n % p == 0)\
    \ {\n            n /= p;\n        }\n        p = 3;\n        // Stop at square\
    \ root of n because any factor larger than the square\n        // root must have\
    \ a corresponding factor smaller than the square root.\n        while (p <= Math.Sqrt(n))\
    \ {\n            while (n % p == 0) {\n                n /= p;\n            }\n\
    \            p += 2;\n        }\n        return n;", "        long p = LargestPrimeFactor(n,\
    \ n / 2);\n        Debug.Assert(p != n);\n        return p;", "        if (n <=\
    \ 1) throw new ArgumentException();\n        if (IsPrime(n)) return n;\n     \
    \   long i = 2;\n        long largest = -1;\n        while (n > 1) {\n       \
    \     if (n % i == 0) {\n                largest = i;\n                n /= i;\n\
    \            } else {\n                i += 1;\n            }\n        }\n   \
    \     return largest;", "        if (n < 0) n = -n;\n        if (n <= 1) return\
    \ n;\n        if (IsPrime(n)) return n;\n        int i = 0;\n        for (long\
    \ p = Prime(i); p * p <= n; p = Prime(++i)) {\n            if (n % p == 0) return\
    \ p;\n        }\n        return n;", "        long p;\n        for (p = 2; p *\
    \ p <= n; p++) {\n            if (n % p == 0) {\n                n /= p;\n   \
    \             while (n % p == 0) {\n                    n /= p;\n            \
    \    }\n            }\n        }\n        return n;", "        while (n % 2 ==\
    \ 0) {\n            n /= 2;\n        }\n        long divisor = 3;\n        while\
    \ (n > 1) {\n            if (n % divisor == 0) {\n                n /= divisor;\n\
    \            } else {\n                divisor += 2;\n            }\n        }\n\
    \        return divisor;", "        long i = 2;\n        while (i <= n) {\n  \
    \          if (n % i == 0) {\n                n /= i;\n            } else {\n\
    \                i++;\n            }\n        }\n        return i;", '        return
    0;', "        long d = 2;\n        while (n % d != 0) {\n            d += 1;\n\
    \        }\n        n /= d;\n        if (n > 1) {\n            return LargestPrimeFactor(n);\n\
    \        }\n        return d;", "        // Write your code here\n        long\
    \ largest = 2;\n        while (n % 2 == 0) {\n            n /= 2;\n        }\n\
    \        if (n == 1) {\n            return largest;\n        }\n        largest\
    \ = 3;\n        while (n % 3 == 0) {\n            n /= 3;\n        }\n       \
    \ if (n == 1) {\n            return largest;\n        }\n        for (long i =\
    \ 5; i <= n; i += 6) {\n            if (n % i == 0) {\n                n /= i;\n\
    \                largest = i;\n            }\n            if (n % (i + 2) == 0)\
    \ {\n                n /= (i + 2);\n                largest = i + 2;\n       \
    \     }\n        }\n        return largest;", "        var result = 2L;\n    \
    \    while (n % result == 0) {\n            n /= result;\n        }\n        result\
    \ = 3L;\n        while (n > 1) {\n            if (n % result == 0) {\n       \
    \         n /= result;\n            } else {\n                result += 2;\n \
    \           }\n        }\n        return result;", "        long largest = 0;\n\
    \        long mod = n;\n        // Iterate through primes up to sqrt(n) and check\
    \ if the number is divisible by that prime\n        foreach (var prime in Problem.PrimeSequence().TakeWhile(x\
    \ => x <= Math.Sqrt(n))) {\n            if (mod % prime == 0) {\n            \
    \    largest = prime;\n                mod /= prime;\n            }\n        }\n\
    \        // If after dividing out all the primes from sqrt(n) to 2, the modulus\
    \ is still > 1, the largest prime is the modulus.\n        if (mod > 1) {\n  \
    \          largest = mod;\n        }\n        return largest;", "        long\
    \ res = 2;\n        while (n > 1) {\n            long d = PollardRho(n);\n   \
    \         if (d == -1) {\n                res = n;\n                break;\n \
    \           }\n            else {\n                n /= d;\n            }\n  \
    \      }\n        return res;", "        var factor = n;\n        var divisor\
    \ = 2L;\n        while (factor >= divisor * divisor) {\n            if (factor\
    \ % divisor == 0) {\n                factor /= divisor;\n            } else {\n\
    \                divisor += 1;\n            }\n        }\n        return factor;",
  '        return 1;', "        for (long i = 2; i < n; i++) {\n            if (n\
    \ % i == 0) {\n                return LargestPrimeFactor(n / i);\n           \
    \ }\n        }\n        return n;", "        if (n < 2) {\n            throw new\
    \ ArgumentException(\"n must be > 1\");\n        }\n        if (IsPrime(n)) {\n\
    \            throw new ArgumentException(\"n must not be prime\");\n        }\n\
    \        long prime = 1;\n        for (long i = 2; i * i <= n; i++) {\n      \
    \      if (n % i == 0 && IsPrime(i)) {\n                prime = i;\n         \
    \   }\n        }\n        return prime;", "        var max = (long)Math.Sqrt(n);\n\
    \        for (var i = 2L; i <= max; i++) {\n            if (n % i == 0) {\n  \
    \              return LargestPrimeFactor(n / i);\n            }\n        }\n \
    \       return n;", "        long factor = 2;\n        while (n > 1) {\n     \
    \       if (n % factor == 0) {\n                n /= factor;\n            } else\
    \ {\n                factor++;\n            }\n        }\n        return factor;",
  "        long largest = 0;\n        while (n % 2 == 0) {\n            largest =\
    \ 2;\n            n /= 2;\n        }\n        long p = 3;\n        while (n >\
    \ 1) {\n            while (n % p == 0) {\n                largest = p;\n     \
    \           n /= p;\n            }\n            p += 2;\n        }\n        return\
    \ largest;", "        // Base case: n is prime.\n        if (IsPrime(n)) {\n \
    \           return n;\n        }\n        // Recurse: n is not prime.\n      \
    \  long p = SmallestPrimeFactor(n);\n        return LargestPrimeFactor(n / p);",
  "        if(n < 2)\n            throw new ArgumentException(\"\");\n        if(n\
    \ <= 3)\n            return n;\n        var factors = PrimeFactorsOf(n);\n   \
    \     return factors.Max();", "        for (long i = 2L; i < n; i++) {\n     \
    \       if (n % i == 0) {\n                return LargestPrimeFactor(n / i);\n\
    \            }\n        }\n        return n;", "        // Find a factor less\
    \ than sqrt(n).\n        long k = (long)Math.Ceiling(Math.Sqrt(n));\n        long\
    \ fac = 2;\n        for (; fac < k; fac++) {\n            if (n % fac == 0) {\n\
    \                break;\n            }\n        }\n        if (fac == k) {\n \
    \           return n;\n        }\n        // Recursively find the largest prime\
    \ factor of n/fac.\n        return LargestPrimeFactor(n / fac);", "        long\
    \ prime = 1;\n        for (long i = 2; i * i <= n; i++) {\n            if (n %\
    \ i == 0) {\n                prime = i;\n                while (n % i == 0) {\n\
    \                    n /= i;\n                }\n            }\n        }\n  \
    \      if (n > 1) {\n            prime = n;\n        }\n        return prime;",
  "        long a = 2;\n        while (n > 1) {\n            if (n % a == 0) {\n \
    \               n /= a;\n            } else {\n                a += 1;\n     \
    \       }\n        }\n        return a;", "        long p;\n        for (p = 2;\
    \ p < n; p++) {\n            if (n % p == 0) {\n                break;\n     \
    \       }\n        }\n        long n1 = n / p;\n        if (n1 > 1) {\n      \
    \      return LargestPrimeFactor(n1);\n        } else {\n            return p;\n\
    \        }", "        long factor = n;\n        long fact = 2;\n        while\
    \ (fact * fact <= factor) {\n            if (factor % fact == 0) {\n         \
    \       factor /= fact;\n            } else {\n                fact += 1;\n  \
    \          }\n        }\n        return factor;", "        for (long i = (long)\
    \ Math.Sqrt(n); i > 1; i--) {\n            if (n % i == 0 && BigInteger.Parse(i.ToString()).IsProbablePrime(20))\
    \ {\n                return i;\n            }\n        }\n        return 1;",
  '        return PrimeFactors(n).Max();', "        long largest = 0;\n        for\
    \ (long i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n           \
    \     while (n % i == 0) {\n                    n /= i;\n                }\n \
    \               largest = i;\n            }\n        }\n        if (n > 1) {\n\
    \            largest = n;\n        }\n        return largest;", "        // Divide\
    \ by as many 2s as possible.\n        while (n % 2 == 0) {\n            n /= 2;\n\
    \        }\n        // Odd numbers only.\n        long factor = 3;\n        while\
    \ (factor * factor <= n) {\n            if (n % factor == 0) {\n             \
    \   n /= factor;\n            } else {\n                factor += 2;\n       \
    \     }\n        }\n        return n;", "        long[] primes = GetPrimes(n);\n\
    \        long result = primes.Last(prime => n % prime == 0);\n        return result;",
  "        Debug.Assert(n > 1);\n        long m = n;\n        long p = 1;\n      \
    \  for (long d = 2; d * d <= m; d++) {\n            if (m % d == 0) {\n      \
    \          p = d;\n                while (m % d == 0) {\n                    m\
    \ /= d;\n                }\n            }\n        }\n        if (m > 1) {\n \
    \           p = m;\n        }\n        return p;", "        Debug.Assert(n > 1L);\n\
    \        long result = n;\n        for (long i = 2L; i * i <= n; i++) {\n    \
    \        if (n % i == 0L) {\n                result = i;\n                while\
    \ (n % i == 0L) {\n                    n /= i;\n                }\n          \
    \  }\n        }\n        if (n > 1L) {\n            result = n;\n        }\n \
    \       return result;", "        long i = 2;\n        while (i < n) {\n     \
    \       if (n % i == 0) {\n                n /= i;\n            } else {\n   \
    \             i++;\n            }\n        }\n        return n;", "        for\
    \ (long p = 2; p * p <= n; p++) {\n            if (n % p == 0) {\n           \
    \     return LargestPrimeFactor(n / p);\n            }\n        }\n        return\
    \ n;", "        long p = 1;\n        while (n % 2 == 0) {\n            p = 2;\n\
    \            n /= 2;\n        }\n        for (long i = 3; i <= Math.Sqrt(n); i\
    \ += 2) {\n            while (n % i == 0) {\n                p = i;\n        \
    \        n /= i;\n            }\n        }\n        if (n > 2) {\n           \
    \ p = n;\n        }\n        return p;", '        return PrimeFactor(n).Select(x
    => x.Key).Max();', "        long p = 1;\n        while (n % 2 == 0) {\n      \
    \      p = 2;\n            n = n / 2;\n        }\n        if (n == 1) {\n    \
    \        return p;\n        }\n        for (long f = 3; f * f <= n; f += 2) {\n\
    \            while (n % f == 0) {\n                p = f;\n                n =\
    \ n / f;\n            }\n        }\n        if (n > 1) {\n            p = n;\n\
    \        }\n        return p;", "        long factor = 2;\n        while (factor\
    \ * factor <= n) {\n            if (n % factor == 0) {\n                n /= factor;\n\
    \            } else {\n                factor++;\n            }\n        }\n \
    \       return n;", "        for (long i = 2; i * i <= n; i++) {\n           \
    \ if (n % i == 0) {\n                return LargestPrimeFactor(n / i);\n     \
    \       }\n        }\n        return n;", '        return EulerUtil.Factorize(n).Keys.Max();',
  "        if (n <= 1)\n            throw new ArgumentException();\n        if (n.IsPrime())\n\
    \            throw new ArgumentException();\n        var factor = n.FirstFactor();\n\
    \        if (factor == n)\n            return factor;\n        var other = n /\
    \ factor;\n        return Math.Max(factor, LargestPrimeFactor(other));", "   \
    \     long maxPrime = 1;\n        long x = n;\n        while (x % 2 == 0) {\n\
    \            maxPrime = 2;\n            x /= 2;\n        }\n        while (x %\
    \ 3 == 0) {\n            maxPrime = 3;\n            x /= 3;\n        }\n     \
    \   for (long i = 6; i * i <= x; i += 6) {\n            if (x % (i - 1) == 0)\
    \ {\n                maxPrime = i - 1;\n                x /= i - 1;\n        \
    \    }\n            if (x % (i + 1) == 0) {\n                maxPrime = i + 1;\n\
    \                x /= i + 1;\n            }\n        }\n        if (x > 1) {\n\
    \            maxPrime = x;\n        }\n        return maxPrime;", "        //\
    \ Factorize n by dividing by small primes.\n        long p = 2;\n        while\
    \ (n % p == 0) {\n            n /= p;\n        }\n        p = 3;\n        while\
    \ (n % p == 0) {\n            n /= p;\n        }\n        p = 5;\n        while\
    \ (n % p == 0) {\n            n /= p;\n        }\n        // Now we only have\
    \ to worry about primes p >= 7.\n        // Divide out 7s until we get a number\
    \ < 7.\n        while (n % 7 == 0) {\n            n /= 7;\n        }\n       \
    \ // If the remaining number is 1, we're done.\n        if (n == 1) {\n      \
    \      return 7;\n        }\n        // The remaining number must be an odd number\
    \ > 7.\n        // We can factorize p^2, where p is the largest prime factor.\n\
    \        // So we can factorize the remaining number by trial division up to sqrt(n).\n\
    \        long limit = (long)Math.Sqrt(n);\n        for (p = 7; p <= limit; p +=\
    \ 2) {\n            while (n % p == 0) {\n                n /= p;\n          \
    \  }\n        }\n        // If the remaining number is 1, we're done.\n      \
    \  if (n == 1) {\n            return p;\n        }\n        // Otherwise the remaining\
    \ number must be the largest prime factor.\n        return n;", "        // Use\
    \ trial division, dividing by every prime in 2..sqrt(n) until\n        // a divisor\
    \ is found. The largest prime will be the last one to \n        // divide n.\n\
    \        int i = 2;\n        while (n > 1) {\n            while (n % i == 0) {\n\
    \                n /= i;\n            }\n            i++;\n        }\n       \
    \ return i - 1;", "        var nFactor = new PrimeFactor(n);\n        return nFactor.Factors.Max(i\
    \ => i.Key);", "        Debug.Assert(n > 1);\n        Debug.Assert(IsPrime(n)\
    \ == false);\n        long p = 2;\n        while (n % p != 0) {\n            p\
    \ = NextPrime(p);\n        }\n        return p;", "        if (n <= 1) throw new\
    \ ArgumentException();\n        if (IsPrime(n)) return n;\n        for (long i\
    \ = 2; i < Sqrt(n); i++) {\n            if (n % i == 0) {\n                if\
    \ (IsPrime(i)) {\n                    return LargestPrimeFactor(n / i);\n    \
    \            }\n            }\n        }\n        throw new Exception(\"I don't\
    \ think this ever gets executed.\");", "        long max_factor = n;\n       \
    \ long factor = 2;\n        while (factor < max_factor) {\n            if (n %\
    \ factor == 0) {\n                max_factor = n / factor;\n                n\
    \ = factor;\n            }\n            factor += 1;\n        }\n        return\
    \ n;", "        long largest_prime_factor = -1;\n        long factor = 2;\n  \
    \      while (factor <= n) {\n            if (n % factor == 0) {\n           \
    \     if (factor > largest_prime_factor) {\n                    largest_prime_factor\
    \ = factor;\n                }\n                n /= factor;\n            } else\
    \ {\n                ++factor;\n            }\n        }\n        return largest_prime_factor;",
  "        var i = 2L;\n        while (n % i != 0) {\n            i += 1;\n      \
    \  }\n        var n_prime = n / i;\n        if (n_prime > 1) {\n            return\
    \ LargestPrimeFactor(n_prime);\n        } else {\n            return i;\n    \
    \    }", "        if (n <= 1)\n            throw new ArgumentException();\n  \
    \      long ret = 1;\n        // solve by trial division\n        while (n % 2\
    \ == 0) {\n            ret = 2;\n            n /= 2;\n        }\n        for (long\
    \ i = 3; i * i <= n; i += 2) {\n            while (n % i == 0) {\n           \
    \     ret = i;\n                n /= i;\n            }\n        }\n        if\
    \ (n > 2)\n            ret = n;\n        return ret;", "        long i = 2;\n\
    \        while (i < n) {\n            if (n % i == 0) {\n                n /=\
    \ i;\n            } else {\n                i++;\n            }\n        }\n \
    \       return n;", "        // Use the fact that all primes > 3 are of the form\
    \ 6n +- 1\n        long d = 0;\n        while (n % 2 == 0) {\n            d =\
    \ 2;\n            n /= 2;\n        }\n        while (n % 3 == 0) {\n         \
    \   d = 3;\n            n /= 3;\n        }\n        long p = 5;\n        while\
    \ (n > 1) {\n            long q = p * p;\n            if (q > n) {\n         \
    \       // p is prime\n                d = n;\n                break;\n      \
    \      }\n            while (n % p == 0) {\n                d = p;\n         \
    \       n /= p;\n            }\n            p += 2;\n            while (n % p\
    \ == 0) {\n                d = p;\n                n /= p;\n            }\n  \
    \          p += 4;\n        }\n        return d;", "        // Get all prime numbers\
    \ smaller than n.\n        List<long> primes = new List<long> { 2L };\n      \
    \  for (long i = 3L; i < n; i += 2L) {\n            bool isPrime = true;\n   \
    \         foreach (long prime in primes) {\n                if (i % prime == 0L)\
    \ {\n                    isPrime = false;\n                    break;\n      \
    \          }\n            }\n            if (isPrime)\n                primes.Add(i);\n\
    \        }\n        // Get all prime factors of n.\n        List<long> primeFactors\
    \ = new List<long>();\n        foreach (long prime in primes) {\n            if\
    \ (n % prime == 0L)\n                primeFactors.Add(prime);\n        }\n   \
    \     // Return the largest one.\n        return primeFactors.Max();", "     \
    \   long f = 2;\n        while (n % f == 0) {\n            n /= f;\n        }\n\
    \        long largest = f;\n        for (long i = 3; i * i <= n; i += 2) {\n \
    \           while (n % i == 0) {\n                n /= i;\n                largest\
    \ = i;\n            }\n        }\n        if (n > 1) {\n            largest =\
    \ n;\n        }\n        return largest;", "        foreach (var p in PrimeSieve((long)Math.Sqrt(n)))\
    \ {\n            if (n % p == 0) {\n                return p;\n            }\n\
    \        }\n        throw new ArgumentException();", '        return Factorization.LargestPrimeFactor(n);',
  "        // Fill in the missing code.\n        return PrimeFactorization(n).First().Key;",
  "        long p = 2;\n        while (n > 1) {\n            if (n % p == 0) {\n \
    \               while (n % p == 0) {\n                    n /= p;\n          \
    \      }\n            }\n            p += 1;\n        }\n        return p - 1;",
  "        // TODO: Insert code here!\n        long n_copy = n;\n        long largest_prime_factor\
    \ = 1;\n        long i = 2;\n        while (i * i <= n_copy) {\n            if\
    \ (n_copy % i == 0) {\n                largest_prime_factor = i;\n           \
    \     n_copy /= i;\n            } else {\n                i += 1;\n          \
    \  }\n        }\n        if (n_copy > largest_prime_factor) {\n            largest_prime_factor\
    \ = n_copy;\n        }\n        return largest_prime_factor;", "        // Since\
    \ n is not a prime, there exists some prime p, s.t. p <= sqrt(n).\n        //\
    \ The largest such p is the largest prime factor of n.\n        long rt = (long)Math.Ceiling(Math.Sqrt(n));\n\
    \        // Start with p = 2 and increment until p is greater than the square\
    \ root of n.\n        for (long p = 2; p <= rt; p = p + 1) {\n            // If\
    \ p is a factor of n, then return p.\n            if (n % p == 0) {\n        \
    \        return p;\n            }\n        }\n        // If n is prime, then it\
    \ is its own largest prime factor.\n        return n;", "        // Starting with\
    \ 2, try dividing out all numbers up to the sqrt of n.\n        long i = 2;\n\
    \        while (i <= (long)Math.Sqrt(n)) {\n            if (n % i == 0) {\n  \
    \              // If i is a factor, divide it out and get a new n.\n         \
    \       n /= i;\n            } else {\n                // Otherwise, increment\
    \ i and check that.\n                i++;\n            }\n        }\n        //\
    \ The remaining factor will be the largest prime factor.\n        return n;",
  "        BigInteger N = BigInteger.Pow(2, n);\n        BigInteger r = N;\n     \
    \   while (r % 2 == 0)\n            r /= 2;\n        BigInteger f = 3;\n     \
    \   BigInteger m = (long)Math.Sqrt(r);\n        while (r > 1 && f <= m) {\n  \
    \          if (r % f == 0)\n                r /= f;\n            else\n      \
    \          f += 2;\n        }\n        if (r == 1)\n            return (long)f;\n\
    \        else\n            return (long)r;", "        long largest = 1;\n    \
    \    long factor = 2;\n        while (n > 1) {\n            while (n % factor\
    \ == 0) {\n                largest = factor;\n                n /= factor;\n \
    \           }\n            factor++;\n        }\n        return largest;", " \
    \       for (long i = 2; i < n; i++) {\n            if (n % i == 0) {\n      \
    \          return LargestPrimeFactor(n / i);\n            }\n        }\n     \
    \   return n;", "        long factor = 1;\n        while (n % 2 == 0) {\n    \
    \        factor = 2;\n            n /= 2;\n        }\n        for (long i = 3;\
    \ i * i <= n; i += 2) {\n            while (n % i == 0) {\n                factor\
    \ = i;\n                n /= i;\n            }\n        }\n        if (n > 1)\
    \ {\n            factor = n;\n        }\n        return factor;", "        //\
    \ Our general strategy is to do trial division:\n        //   Divide n by 2, 3,\
    \ 4, 5, etc. and keep track of the largest prime\n        //   factor. It is sufficient\
    \ to check up to the square root of n since\n        //   this is where any remaining\
    \ factors must be.\n        //   - In theory, it is sufficient to check up to\
    \ (n / 2) + 1 since\n        //     otherwise a factor would be found earlier.\
    \ (This is why the for\n        //     loop goes up to n / 2 + 1.) However, this\
    \ makes the logic more\n        //     complicated, so we stick with the square\
    \ root.\n        // The special case of 2 will be considered separately.\n   \
    \     long i = 3;\n        long max_prime_factor = 1;\n        while (i * i <=\
    \ n) {\n            if (n % i == 0) {\n                max_prime_factor = i;\n\
    \                n /= i;\n            } else {\n                i += 2;\n    \
    \        }\n        }\n        // In theory, n at this point should be a prime\
    \ factor, but it might not\n        // be if n started as a prime.\n        return\
    \ Math.Max(max_prime_factor, n);", "        BigInteger BigN = new BigInteger(n);\n\
    \        int factors = 0;\n        for (long i = 2; i < n; i++) {\n          \
    \  if (BigN % i == 0) {\n                BigN /= i;\n                factors++;\n\
    \            }\n        }\n        return factors;", "        Debug.Assert(n >\
    \ 1);\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0)\
    \ {\n                return LargestPrimeFactor(n / i);\n            }\n      \
    \  }\n        return n;", "        var primeFactors = new List<long>();\n    \
    \    for (var i = 2L; i <= n; i++) {\n            if (n % i == 0) {\n        \
    \        primeFactors.Add(i);\n                n /= i;\n                i--;\n\
    \            }\n        }\n        return primeFactors.Max();", "        long\
    \ largest = -1;\n        long f = 2;\n        while (n > 1) {\n            while\
    \ (n % f == 0) {\n                n /= f;\n                largest = f;\n    \
    \        }\n            f += 1;\n        }\n        return largest;", '        return
    0;', "        int p = 2;\n        while (p * p <= n) {\n            if (n % p\
    \ == 0) {\n                n /= p;\n            } else {\n                ++p;\n\
    \            }\n        }\n        return n;", "        long sqrt = (long)Math.Ceiling(Math.Sqrt(n));\n\
    \        long i = sqrt;\n        while (i > 1) {\n            if (n % i == 0 &&\
    \ IsPrime(i)) {\n                return i;\n            }\n            i -= 1;\n\
    \        }\n        throw new Exception(\"Something went horribly wrong\");",
  "        var primeFactors = MathHelper.GetPrimeFactors(n);\n        if (primeFactors.Count\
    \ == 0)\n            throw new InvalidOperationException(\"n must not be prime\"\
    );\n        return primeFactors.Last();", "        var ret = 0L;\n        for\
    \ (long i = 2L; i * i <= n; i++) {\n            if (n % i == 0) {\n          \
    \      n /= i;\n                ret = i;\n            }\n        }\n        return\
    \ n > 1 ? n : ret;", "        long p = 2;\n        while (n % p == 0) {\n    \
    \        n /= p;\n        }\n        for (long i = 3; i < n; i += 2) {\n     \
    \       if (n % i == 0) {\n                n /= i;\n                i -= 2;\n\
    \            }\n        }\n        return n;", "        long largest = 0;\n  \
    \      for (long i = 2; i <= n; i++) {\n            if (n % i == 0) {\n      \
    \          largest = i;\n                while (n % i == 0) {\n              \
    \      n /= i;\n                }\n            }\n        }\n        return largest;",
  "        Debug.Assert(n > 1);\n        long factor = 2;\n        while (n % factor\
    \ != 0) {\n            factor++;\n        }\n        if (factor == n) {\n    \
    \        return factor;\n        }\n        return LargestPrimeFactor(n / factor);",
  "        // 2 is a special case because it's the only even prime number.\n     \
    \   if (n % 2 == 0) {\n            return 2;\n        }\n        // Next candidate\
    \ is 3, or the next odd number after that.\n        long factor = 3;\n       \
    \ // Only need to go up to the square root of n.\n        long max = (long)Math.Sqrt(n);\n\
    \        while (n > 1 && factor <= max) {\n            if (n % factor == 0) {\n\
    \                n /= factor;\n                // n is now the largest factor;\
    \ try to divide it again.\n                max = (long)Math.Sqrt(n);\n       \
    \     } else {\n                // Try the next odd number.\n                factor\
    \ += 2;\n            }\n        }\n        // Whatever is left is prime.\n   \
    \     return n;", "        long factor = 2;\n        while (factor * factor <=\
    \ n) {\n            if (n % factor == 0) {\n                n /= factor;\n   \
    \         } else {\n                factor++;\n            }\n        }\n    \
    \    return n;", "        long max = 0;\n        for (long i = 2; i <= n / i;\
    \ i++) {\n            if (n % i == 0) {\n                max = i;\n          \
    \      while (n % i == 0) {\n                    n /= i;\n                }\n\
    \            }\n        }\n        if (n > 1) {\n            max = n;\n      \
    \  }\n        return max;", "        long result = 0;\n        while (n % 2 ==\
    \ 0) {\n            result = 2;\n            n /= 2;\n        }\n        long\
    \ factor = 3;\n        while (factor * factor <= n) {\n            if (n % factor\
    \ == 0) {\n                result = factor;\n                n /= factor;\n  \
    \          } else {\n                factor += 2;\n            }\n        }\n\
    \        if (n > 1) {\n            result = n;\n        }\n        return result;",
  "        var lastFactor = 1L;\n        var factor = 2L;\n        while (n > 1) {\n\
    \            while (n % factor == 0) {\n                lastFactor = factor;\n\
    \                n /= factor;\n            }\n            factor++;\n        }\n\
    \        return lastFactor;", "        if(!IsPrime(n)) {\n            throw new\
    \ InvalidOperationException(\"n is not prime\");\n        }\n        long p =\
    \ 1;\n        // Try prime factors in increasing order.\n        for(long i =\
    \ 2; i <= n; i++) {\n            if(IsPrime(i) && n % i == 0) {\n            \
    \    p = i;\n            }\n        }\n        return p;", "        long result\
    \ = 0;\n        for (long p = 2; p <= Math.Sqrt(n); p++) {\n            if (n\
    \ % p == 0) {\n                if (IsPrime(p)) {\n                    result =\
    \ p;\n                }\n            }\n        }\n        return result;", " \
    \       if (n <= 3) return n;\n        // The greatest prime factor of n is at\
    \ most floor(sqrt(n)).\n        long max = (long)Math.Floor(Math.Sqrt(n));\n \
    \       // Check all factors of n up to max, starting with the largest.\n    \
    \    for (long i = max; i > 1; i--) {\n            if (n % i == 0) {\n       \
    \         // n is divisible by i, so i is a factor of n.\n                // We\
    \ should check that i is prime.\n                // The greatest prime factor\
    \ of i is at most floor(sqrt(i)).\n                max = (long)Math.Floor(Math.Sqrt(i));\n\
    \                // Check all factors of i up to max, starting with the largest.\n\
    \                for (long j = max; j > 1; j--) {\n                    if (i %\
    \ j == 0) {\n                        // i is divisible by j, so i is not prime.\n\
    \                        // The greatest prime factor of n is the largest factor\n\
    \                        // of i that we checked.\n                        return\
    \ j;\n                    }\n                }\n                // We only reach\
    \ this point if j == 1, so i is prime.\n                return i;\n          \
    \  }\n        }\n        // We only reach this point if i == 1, so n is prime.\n\
    \        return n;", "        var i = 2L;\n        while (n % i != 0) {\n    \
    \        i++;\n        }\n        return i;", "        long largest = 2;\n   \
    \     while (n % 2 == 0) {\n            n /= 2;\n        }\n        if (n == 1)\
    \ {\n            return largest;\n        }\n        largest = 3;\n        long\
    \ d = 5;\n        while (d*d <= n) {\n            if (n % d == 0) {\n        \
    \        n /= d;\n                largest = d;\n            } else {\n       \
    \         d += 2;\n            }\n        }\n        return Math.Max(largest,\
    \ n);", "        foreach (long k in RangeFrom(2L, n - 1)) {\n            if (n\
    \ % k == 0) {\n                return LargestPrimeFactor(n / k);\n           \
    \ }\n        }\n        return n;", "        Debug.Assert(n > 1);\n        for\
    \ (long i = 2; i < n / 2; i++) {\n            if (n % i == 0) {\n            \
    \    return LargestPrimeFactor(n / i);\n            }\n        }\n        return\
    \ n;", "        long i = 2;\n        long maxPrime = 2;\n        while (i < n)\
    \ {\n            if (n % i == 0) {\n                maxPrime = i;\n          \
    \      n /= i;\n            } else {\n                i++;\n            }\n  \
    \      }\n        return maxPrime;", "        long factor = 2;\n        while\
    \ (n > 1) {\n            if (n % factor == 0) {\n                n /= factor;\n\
    \            } else {\n                factor += 1;\n            }\n        }\n\
    \        return factor;", "        long prime = n;\n        while (true) {\n \
    \           // If 'prime' is a factor of 'n', then it is our largest prime\n \
    \           // factor. The largest prime factor must be prime itself.\n      \
    \      if (IsPrime(prime) && (n % prime == 0))\n                return prime;\n\
    \            prime -= 1;\n        }", "        long x = 2;\n        while (x <=\
    \ Math.Sqrt(n)) {\n            if (n % x == 0) {\n                n /= x;\n  \
    \          } else {\n                x++;\n            }\n        }\n        return\
    \ n;", "        var factors = new List<long>();\n        while (n % 2 == 0) {\n\
    \            factors.Add(2);\n            n /= 2;\n        }\n        long k =\
    \ 3;\n        while (k * k <= n) {\n            if (n % k == 0) {\n          \
    \      factors.Add(k);\n                n /= k;\n            } else {\n      \
    \          k += 2;\n            }\n        }\n        if (n > 1) {\n         \
    \   factors.Add(n);\n        }\n        return factors.Max();", "        var factor\
    \ = 1L;\n        for (var i = 2L; i * i <= n; i++) {\n            if (n % i ==\
    \ 0) {\n                if (IsPrime(i)) {\n                    factor = i;\n \
    \               }\n                if (IsPrime(n / i)) {\n                   \
    \ factor = n / i;\n                }\n            }\n        }\n        return\
    \ factor;", "        long i;\n        for (i = (long)Math.Sqrt(n); i > 1; i--)\
    \ {\n            if (n % i == 0 && IsPrime(i)) {\n                return i;\n\
    \            }\n        }\n        return 1;", "        long factor = 2;\n   \
    \     while (n > 1) {\n            while (n % factor == 0)\n                n\
    \ /= factor;\n            factor++;\n        }\n        return factor - 1;", " \
    \       long result = 2;\n        while (n % result == 0)\n            n /= result;\n\
    \        if (n == 1)\n            return result;\n        result = 3;\n      \
    \  while (n > 1) {\n            while (n % result == 0)\n                n /=\
    \ result;\n            result += 2;\n        }\n        return result - 2;", " \
    \       long d = 2;\n        while (d * d <= n) {\n            if (n % d == 0)\
    \ {\n                n /= d;\n            } else {\n                d += 1;\n\
    \            }\n        }\n        return n;", "        // Find primes less than\
    \ sqrt(n) using Sieve of Eratosthenes\n        // Then use these primes to find\
    \ the largest prime factor of n\n        var bound = (long)Math.Sqrt(n);\n   \
    \     List<long> primes = new List<long>();\n        // Initiate primes list\n\
    \        for (long i = 0; i <= bound; i++) {\n            primes.Add(i);\n   \
    \     }\n        // Compute primes\n        for (long i = 2; i <= bound; i++)\
    \ {\n            if (primes[(int)i] == 0) {\n                continue;\n     \
    \       }\n            long p = primes[(int)i];\n            long k = 2 * p;\n\
    \            while (k <= bound) {\n                primes[(int)k] = 0;\n     \
    \           k += p;\n            }\n        }\n        // Eliminate non-primes\n\
    \        for (int i = primes.Count - 1; i >= 0; i--) {\n            if (primes[i]\
    \ == 0) {\n                primes.RemoveAt(i);\n            }\n        }\n   \
    \     // Find the largest prime factor\n        long largest = 0;\n        foreach\
    \ (long p in primes) {\n            if (n % p == 0) {\n                largest\
    \ = p;\n            }\n        }\n        return largest;", "        long p =\
    \ 2;\n        while (p * p <= n) {\n            if (n % p == 0) {\n          \
    \      n /= p;\n            } else {\n                p++;\n            }\n  \
    \      }\n        return n;"]
stop_tokens:
- "\n    }\n"
