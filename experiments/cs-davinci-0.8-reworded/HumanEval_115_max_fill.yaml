name: HumanEval_115_max_fill
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given a rectangular grid of wells. Each row represents\
  \ a single well,\n    // and each 1 in a row represents a single unit of water.\n\
  \    // Each well has a corresponding bucket that can be used to extract water from\
  \ it, \n    // and all buckets have the same capacity.\n    // Your task is to use\
  \ the buckets to empty the wells.\n    // Output the number of times you need to\
  \ lower the buckets.\n    // Example 1:\n    // >>> MaxFill((new List<List<long>>(new\
  \ List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)1L,\
  \ (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)1L, (long)0L,\
  \ (long)0L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L})})), (1L))\n    // (6L)\n    // Example 2:\n    // >>> MaxFill((new\
  \ List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L,\
  \ (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)1L, (long)1L, (long)1L})})), (2L))\n    // (5L)\n    // Example 3:\n   \
  \ // >>> MaxFill((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new\
  \ long[]{(long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)0L})})), (5L))\n    // (0L)\n    // Constraints:\n    // * all\
  \ wells have the same length\n    // * 1 <= grid.length <= 10^2\n    // * 1 <= grid[:,1].length\
  \ <= 10^2\n    // * grid[i][j] -> 0 | 1\n    // * 1 <= capacity <= 10\n    public\
  \ static long MaxFill(List<List<long>> grid, long capacity) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(MaxFill((new\
  \ List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L,\
  \ (long)1L, (long)1L, (long)1L})})), (1L)) == (6L));\n    Debug.Assert(MaxFill((new\
  \ List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L,\
  \ (long)1L, (long)1L, (long)1L}), (List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)1L, (long)1L, (long)1L})})), (2L)) == (5L));\n    Debug.Assert(MaxFill((new\
  \ List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L,\
  \ (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L, (long)0L,\
  \ (long)0L})})), (5L)) == (0L));\n    Debug.Assert(MaxFill((new List<List<long>>(new\
  \ List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L})})), (2L)) == (4L));\n    Debug.Assert(MaxFill((new List<List<long>>(new\
  \ List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L}), (List<long>)new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
  \ (long)1L})})), (9L)) == (2L));\n    }\n\n}\n"
completions: ["        // Fill in code here...\n        return -1;", '        return
    (long)GridSolver.Solve(grid, capacity);', "        long sum = 0;\n        // use\
    \ a stack to find how many rows have at least one water\n        Stack<long> row_stack\
    \ = new Stack<long>();\n        for (long row = (long)0L; row < grid.Count; row++)\
    \ {\n            for (long col = (long)0L; col < grid[(int)row].Count; col++)\
    \ {\n                if (grid[(int)row][(int)col] == (long)1L) {\n           \
    \         row_stack.Push(row);\n                    break;\n                }\n\
    \            }\n        }\n        long row_count = row_stack.Count;\n       \
    \ sum += row_count;\n        // now for each row (non-water rows) calculate how\
    \ many buckets\n        // you need to put water in the next row\n        List<long>\
    \ rows_to_fill = new List<long>();\n        long prev_row = (long)0L;\n      \
    \  while (row_stack.Count > (long)0L) {\n            long row = row_stack.Pop();\n\
    \            long sum_next_row = (long)0L;\n            for (long col = (long)0L;\
    \ col < grid[(int)row].Count; col++) {\n                if (grid[(int)row][(int)col]\
    \ == (long)1L) {\n                    sum_next_row += (long)1L;\n            \
    \    }\n            }\n            if (sum_next_row > capacity) {\n          \
    \      if (prev_row == (long)0L) {\n                    sum += sum_next_row;\n\
    \                }\n                else {\n                    sum += sum_next_row\
    \ - capacity;\n                }\n                prev_row = row;\n          \
    \  }\n        }\n        return sum;", "        // Insert your code here\n   \
    \     return 0;", "        long ans = 0;\n        long[] num = grid.Select(x =>\
    \ x.Count(y => y == 1)).ToArray();\n        long[] tmp = new long[num.Length];\n\
    \        bool iff = true;\n        while (iff) {\n            for (int i = 0;\
    \ i < num.Length; i++) {\n                if (num[i] > 0) {\n                \
    \    tmp[i] = num[i] - capacity;\n                    if (tmp[i] < 0) {\n    \
    \                    tmp[i] = 0;\n                    }\n                }\n \
    \           }\n            iff = false;\n            for (int i = 0; i < num.Length;\
    \ i++) {\n                if (num[i] != tmp[i]) {\n                    iff = true;\n\
    \                }\n                num[i] = tmp[i];\n            }\n        \
    \    ans++;\n        }\n        return ans - 1;", "        long fill = 0;\n  \
    \      for (int i = 0; i < grid.Count; i++) {\n            for (int j = 0; j <\
    \ grid[i].Count; j++) {\n                if (grid[i][j] == 1) {\n            \
    \        long amount = grid[i].Count - j;\n                    if (amount > capacity)\
    \ {\n                        amount = capacity;\n                    }\n     \
    \               grid[i][j] -= amount;\n                    fill += amount;\n \
    \               }\n            }\n        }\n        return fill;", "        if\
    \ (capacity < 1) {\n            throw new ArgumentException(\"Capacity must be\
    \ 1 or greater\");\n        }\n        long result = 0;\n        for (long j =\
    \ 0; j < grid[0].Count; j++) {\n            long currentCol = 0;\n           \
    \ for (long i = 0; i < grid.Count; i++) {\n                if (grid[(int)i][(int)j]\
    \ == 0) {\n                    result += currentCol;\n                    currentCol\
    \ = 0;\n                } else {\n                    currentCol++;\n        \
    \            if (currentCol > capacity) {\n                        currentCol\
    \ = capacity;\n                    }\n                }\n            }\n     \
    \       result += currentCol;\n        }\n        return result;", "        long\
    \ h = grid.Count;\n        long w = grid[0].Count;\n        long cap = capacity;\n\
    \        long cnt = 0;\n        long cnt2 = 0;\n        // do the horizontal operation\n\
    \        for (long i = 0; i < h; i++) {\n            for (long j = 0; j < w; j++)\
    \ {\n                if (grid[(int)i][(int)j] == 1) {\n                    if\
    \ (cap > 0) {\n                        grid[(int)i][(int)j] = 0;\n           \
    \             cap--;\n                        cnt++;\n                    }\n\
    \                    else {\n                        cap = capacity;\n       \
    \                 cnt2++;\n                        grid[(int)i][(int)j] = 0;\n\
    \                        cap--;\n                        cnt++;\n            \
    \        }\n                }\n            }\n        }\n        // do the vertical\
    \ operation\n        for (long i = 0; i < w; i++) {\n            for (long j =\
    \ 0; j < h; j++) {\n                if (grid[(int)j][(int)i] == 1) {\n       \
    \             if (cap > 0) {\n                        grid[(int)j][(int)i] = 0;\n\
    \                        cap--;\n                        cnt++;\n            \
    \        }\n                    else {\n                        cap = capacity;\n\
    \                        cnt2++;\n                        grid[(int)j][(int)i]\
    \ = 0;\n                        cap--;\n                        cnt++;\n     \
    \               }\n                }\n            }\n        }\n        return\
    \ cnt + cnt2;", "        long max = grid.SelectMany(x => x).Max();\n        long\
    \ sum = grid.SelectMany(x => x).Sum();\n        return max * sum - capacity *\
    \ sum;", "        // The answer is essentially the sum of the distances between\n\
    \        // the midpoint of each row and the leftmost 1. We can solve this\n \
    \       // by finding that midpoint and leftmost 1 for each row, and then summing\n\
    \        // up the distances.\n        // The algorithm below does this in an\
    \ efficient way.\n        long ans = 0;\n        for (int i = 0; i < grid.Count;\
    \ i++) {\n            // Initialize leftmost 1 position.\n            int left\
    \ = -1;\n            // We can ignore a row if it's entirely empty.\n        \
    \    if (grid[i].All(a => a == 0)) continue;\n            // Iterate through the\
    \ row.\n            for (int j = 0; j < grid[i].Count; j++) {\n              \
    \  // Update the leftmost 1 position.\n                if (grid[i][j] == 1) left\
    \ = j;\n                // If we've gone past the midpoint and found a 1, we're\
    \ done.\n                if (j >= grid[i].Count / 2 && left != -1) break;\n  \
    \              // Calculate the distance between the midpoint and leftmost 1.\n\
    \                long dist = Math.Abs(j - left);\n                // Account for\
    \ positions where there is no 1.\n                if (left == -1) dist = j;\n\
    \                // Check for edge cases.\n                if (j == grid[i].Count\
    \ - 1 && left == -1) {\n                    // If the row is entirely 0's, the\
    \ distance is from the midpoint\n                    // to the end of the row.\n\
    \                    dist = grid[i].Count - (grid[i].Count / 2) - 1;\n       \
    \         } else if (j == grid[i].Count - 1 && left != -1) {\n               \
    \     // If the row is entirely 1's, the distance is from the midpoint\n     \
    \               // to the leftmost 1.\n                    dist = left;\n    \
    \            }\n                // Add the distance to the answer.\n         \
    \       ans += dist;\n            }\n        }\n        // Finally, multiply the\
    \ answer by the bucket capacity.\n        return ans * capacity;", "        //\
    \ Your code here.\n\n        return 0;", "        // Make a copy of grid for each\
    \ row\n        // of buckets, one for each capacity\n        var maps = new List<List<List<long>>>();\n\
    \        for (var i = 0; i < capacity; i++) {\n            maps.Add(new List<List<long>>());\n\
    \            foreach (var row in grid) {\n                maps[i].Add(new List<long>(row));\n\
    \            }\n        }\n        // For each row...\n        for (var i = 0;\
    \ i < grid.Count; i++) {\n            // For each column...\n            for (var\
    \ j = 0; j < grid[i].Count; j++) {\n                // If this column is filled...\n\
    \                if (grid[i][j] == 1) {\n                    // For each bucket...\n\
    \                    for (var bucket = 0; bucket < capacity; bucket++) {\n   \
    \                     // Fill it\n                        maps[bucket][i][j] =\
    \ 1;\n                    }\n                }\n            }\n        }\n   \
    \     // Number of times we need to lower the buckets\n        var count = 0;\n\
    \        // While any of the buckets still have water...\n        while (maps.Any(map\
    \ => map.Any(row => row.Any(c => c == 1)))) {\n            // Increment the count\n\
    \            count++;\n            // For each bucket...\n            for (var\
    \ bucket = 0; bucket < capacity; bucket++) {\n                // For each row...\n\
    \                for (var i = 0; i < maps[bucket].Count; i++) {\n            \
    \        // For each column...\n                    for (var j = 0; j < maps[bucket][i].Count;\
    \ j++) {\n                        // If this column is filled...\n           \
    \             if (maps[bucket][i][j] == 1) {\n                            // Try\
    \ to empty it\n                            maps[bucket][i][j] = 0;\n         \
    \                   // If it was last bucket...\n                            if\
    \ (bucket == capacity - 1) {\n                                // Go to next row\n\
    \                                continue;\n                            }\n  \
    \                          // Try to fill the bucket below\n                 \
    \           maps[bucket + 1][i][j] = 1;\n                        }\n         \
    \           }\n                }\n            }\n        }\n        // Return",
  '        return sum(map((long i) => max(map((long j) => grid[i][j], (long i) =>
    i, (long)0L, (long)grid[i].Count)), (long i) => i, (long)0L, (long)grid.Count));',
  "        if(grid.IsEmpty()) {\n            return 0;\n        }\n\n        long\
    \ rowCount = grid.Count;\n        long columnCount = grid[0].Count;\n        if(columnCount\
    \ == 0) {\n            return 0;\n        }\n\n        var wellSums = new long[rowCount][];\n\
    \        for(long i = 0; i < rowCount; i++) {\n            var well = grid[(int)i];\n\
    \            wellSums[(int)i] = new long[columnCount];\n            for(long j\
    \ = 0; j < columnCount; j++) {\n                wellSums[(int)i][(int)j] = well[(int)j];\n\
    \                if(i > 0) {\n                    wellSums[(int)i][(int)j] +=\
    \ wellSums[(int)(i - 1)][(int)j];\n                }\n            }\n        }\n\
    \n        var columnSums = new long[columnCount];\n        for(long j = 0; j <\
    \ columnCount; j++) {\n            columnSums[(int)j] = wellSums[(int)(rowCount\
    \ - 1)][(int)j];\n        }\n\n        var maxFills = new long[columnCount];\n\
    \        long c = columnCount - 1;\n        while(c >= 0) {\n            if(columnSums[(int)c]\
    \ == 0) {\n                maxFills[(int)c] = columnCount - c - 1;\n         \
    \       c--;\n                continue;\n            }\n\n            if(columnSums[(int)c]\
    \ < capacity) {\n                maxFills[(int)c] = columnCount - c;\n       \
    \         c--;\n                continue;\n            }\n\n            long row\
    \ = rowCount - 1;\n            while(row >= 0) {\n                long water =\
    \ wellSums[(int)row][(int)c];\n                if(water == 0) {\n            \
    \        break;\n                }\n\n                if(water <= capacity) {\n\
    \                    maxFills[(int)c] = columnCount - c;\n                   \
    \ c--;\n                    break;\n                }\n\n                row--;\n\
    \            }\n        }\n\n        long maxFillsSum =", "        long m = grid.Count;\n\
    \        long n = grid[0].Count;\n        long steps = 0;\n        for (int i\
    \ = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n            \
    \    steps += grid[i][j] / capacity;\n                if (grid[i][j] % capacity\
    \ != 0) {\n                    steps++;\n                }\n            }\n  \
    \      }\n        return steps;", "        long total = 0;\n        for (int y\
    \ = 0; y < grid.Count; y++) {\n            for (int x = 0; x < grid[y].Count;\
    \ x++) {\n                if (grid[y][x] == 1) {\n                    total +=\
    \ capacity;\n                }\n            }\n        }\n        return total;",
  "        long fillCount = 0;\n        var r = grid.Count;\n        var c = grid[0].Count;\n\
    \        var rowMax = new long[r];\n        var columnMax = new long[c];\n   \
    \     for (int i = 0; i < r; i++) {\n            rowMax[i] = grid[i].Max();\n\
    \        }\n        for (int j = 0; j < c; j++) {\n            columnMax[j] =\
    \ Enumerable.Range(0, r).Select(i => grid[i][j]).Max();\n        }\n        for\
    \ (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n     \
    \           if (grid[i][j] == 0) {\n                    fillCount += Math.Min(rowMax[i],\
    \ columnMax[j]);\n                }\n            }\n        }\n        return\
    \ fillCount;", "        long x = 0;\n        for (int i = 0; i < grid.Count; i++)\
    \ {\n            for (int j = 0; j < grid[i].Count; j++) {\n                if\
    \ (grid[i][j] != 0) {\n                    x += capacity;\n                }\n\
    \            }\n        }\n        return x;", "        long max = 0;\n      \
    \  long index = 0;\n        List<long> heights = new List<long>();\n        foreach\
    \ (List<long> row in grid) {\n            for (long i = 0; i < row.Count; i++)\
    \ {\n                if (row[(int)i] == 1) {\n                    if (index >\
    \ heights.Count - 1) {\n                        heights.Add(1);\n            \
    \        } else {\n                        heights[(int)index] += 1;\n       \
    \             }\n                } else {\n                    index += 1;\n \
    \               }\n            }\n            index = 0;\n        }\n        foreach\
    \ (long h in heights) {\n            if (h > max) {\n                max = h;\n\
    \            }\n        }\n        return max % capacity == 0 ? max / capacity\
    \ : max / capacity + 1;", '        throw new NotImplementedException();', "  \
    \      int row = grid.Count;\n        int col = grid[0].Count;\n        long result\
    \ = 0;\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j\
    \ < col; j++) {\n                if (grid[i][j] == 1) {\n                    result\
    \ += 1;\n                    // Everytime, fill all the wells that can be filled\
    \ by the capacity of this bucket.\n                    for (int k = 0; k < row;\
    \ k++) {\n                        int filled = 0;\n                        for\
    \ (int m = 0; m < col; m++) {\n                            if (grid[k][m] == 1)\
    \ {\n                                filled += 1;\n                          \
    \  }\n                            if (filled == capacity) {\n                \
    \                break;\n                            }\n                     \
    \   }\n                        if (filled >= capacity) {\n                   \
    \         for (int n = 0; n < col; n++) {\n                                grid[k][n]\
    \ = 0;\n                            }\n                        }\n           \
    \         }\n                }\n            }\n        }\n        return result;",
  "        long result = 0;\n        var height = grid.Count;\n        var length\
    \ = grid[0].Count;\n        for (int y = 0; y < height; y++) {\n            for\
    \ (int x = 0; x < length; x++) {\n                if (grid[y][x] == 1) {\n   \
    \                 grid[y][x] = 0;\n                    result++;\n           \
    \         if (x > 0 && grid[y][x - 1] == 1) {\n                        x--;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ result;", "        // fill empty well to capacity\n        // empty wells above\n\
    \        // repeat until grid is empty\n        var score = 0L;\n        var gridCopy\
    \ = new List<List<long>>(grid);\n        while (gridCopy.Any(r => r.Any(x => x\
    \ > 0))) {\n            score += capacity;\n            var min = gridCopy.Min(r\
    \ => r.Sum());\n            gridCopy = gridCopy.Select(r => r.Select(i => i -\
    \ min).ToList()).ToList();\n        }\n        return score;", "        var result\
    \ = default(long);\n        // Your code goes here.\n        return result;",
  "        long in_cap = 0;\n        foreach (var line in grid) {\n            in_cap\
    \ += line.Where(u => u == 1).LongCount();\n        }\n        long result = (long)0;\n\
    \        long max_cap = capacity * grid[0].LongCount();\n        while (in_cap\
    \ > 0) {\n            result += 1;\n            in_cap -= max_cap;\n        }\n\
    \        return result;", "        // your code goes here\n        return 0;",
  "        // compute the amount of water in the grid before we start\n        var\
    \ initialWater = grid.Sum(row => row.Count(n => n == 1));\n        var totalBuckets\
    \ = grid.First().Count;\n        var buckets = new List<long>(capacity);\n   \
    \     var maxFill = 0L;\n        var maxFillSteps = 0L;\n        var currentFill\
    \ = 0L;\n        foreach (var row in grid) {\n            var rowSum = row.Sum();\n\
    \            if (currentFill + rowSum > capacity) {\n                // reset\
    \ the buckets to zero and refill\n                currentFill = 0;\n         \
    \       maxFillSteps++;\n            }\n            // use up the buckets\n  \
    \          currentFill += rowSum;\n            maxFill = Math.Max(maxFill, currentFill);\n\
    \        }\n        // take the maximum water we filled in the grid, and fill\
    \ it to the top\n        maxFillSteps += maxFill / capacity;\n        // now fill\
    \ the grid to capacity\n        maxFillSteps += (totalBuckets * capacity - initialWater)\
    \ / capacity;\n        // if the full buckets divided out, there's still a bucket\
    \ to fill\n        if ((totalBuckets * capacity - initialWater) % capacity !=\
    \ 0) {\n            maxFillSteps++;\n        }\n        return maxFillSteps;",
  '        return _MaxFill(grid, capacity);', "        Func<long, List<long>, long>\
    \ dropBucket = null;\n        Func<long, List<long>, long> raiseBucket = null;\n\
    \        long rows = (long)grid.Count;\n        long columns = (long)grid[0].Count;\n\
    \        // initialize all wells to empty\n        //long[][] wells = Enumerable.Range(0,\
    \ (int)rows).Select(v => Enumerable.Range(0, (int)columns).Select(v2 => 0L).ToArray()).ToArray();\n\
    \        long[][] wells = new long[rows][];\n        for (long i = 0; i < rows;\
    \ i++) {\n            wells[i] = new long[columns];\n        }\n        // initialize\
    \ all wells to contain water\n        for (long i = 0; i < rows; i++) {\n    \
    \        for (long j = 0; j < columns; j++) {\n                wells[i][j] = grid[(int)i][(int)j];\n\
    \            }\n        }\n        // simulate dropping and raising the bucket\n\
    \        dropBucket = (ticks, pos) => {\n            // raise bucket\n       \
    \     for (long i = pos[0]; i < rows; i++) {\n                for (long j = 0;\
    \ j < columns; j++) {\n                    wells[i][j] += capacity;\n        \
    \        }\n            }\n            return ticks + 1;\n        };\n       \
    \ raiseBucket = (ticks, pos) => {\n            // raise bucket\n            for\
    \ (long i = pos[0]; i < rows; i++) {\n                for (long j = 0; j < columns;\
    \ j++) {\n                    wells[i][j] -= capacity;\n                }\n  \
    \          }\n            return ticks + 1;\n        };\n        // raise/drop\
    \ bucket until all wells are empty\n        long ticks = 0;\n        for (long\
    \ i = 0; i < rows; i++) {\n            for (long j = 0; j < columns; j++) {\n\
    \                if (wells[i][j] != 0) {\n                    long[] pos = new\
    \ long[] { i, j };\n                    // if bucket at i and water at i, drop\n\
    \                    if (i <= pos[0]) {", '        return 0;', "        int lx\
    \ = grid.Count;\n        int ly = grid[0].Count;\n        int[,] wells = new int[lx,\
    \ ly];\n        int dx = 1;\n        int dy = 0;\n        int x = 0;\n       \
    \ int y = 0;\n        int[,] dirs = new int[,] { { 1, 0 }, { 0, 1 }, { -1, 0 },\
    \ { 0, -1 } };\n        int di = 0;\n        int drops = 0;\n        long bucket\
    \ = capacity;\n        while (true) {\n            wells[x, y] = Math.Max(wells[x,\
    \ y] - bucket, 0);\n            drops += bucket;\n            bucket = capacity;\n\
    \            if (wells[x, y] > 0) {\n                bucket -= wells[x, y];\n\
    \            }\n            if (bucket > 0) {\n                int nx = x + dirs[di,\
    \ 0];\n                int ny = y + dirs[di, 1];\n                if (nx < 0 ||\
    \ nx >= lx || ny < 0 || ny >= ly) {\n                    di = (di + 1) % 4;\n\
    \                    continue;\n                }\n                x = nx;\n \
    \               y = ny;\n            } else {\n                break;\n      \
    \      }\n        }\n        return drops;", "        List<long> sub = new List<long>();\n\
    \        foreach (var x in grid) {\n            List<long> wells = x;\n      \
    \      foreach (var y in wells) {\n                if (y == 1) {\n           \
    \         sub.Add(capacity);\n                }\n            }\n        }\n  \
    \      List<long> bucket = new List<long>();\n        for (int i = 0; i < grid.Count;\
    \ i++) {\n            bucket.Add(0);\n        }\n        for (int i = 0; i < sub.Count;\
    \ i++) {\n            for (int j = 0; j < bucket.Count; j++) {\n             \
    \   if (bucket[j] == 0) {\n                    bucket[j] = sub[i];\n         \
    \           break;\n                }\n            }\n        }\n        long\
    \ max = -1;\n        foreach (var x in bucket) {\n            if (x > max) {\n\
    \                max = x;\n            }\n        }\n        return max;", " \
    \       // Implementation 1:\n        // * extract water from wells until all\
    \ have 0 in them\n        // * for each row, determine how many 1s are in the\
    \ row\n        // * multiply by the number of rows and return the total\n    \
    \    // Remarks:\n        // * runs in theta(n^2) time\n        // * runs in theta(1)\
    \ space\n        return 0;", "        long fillCount = 0;\n        long totalUnits\
    \ = grid.SelectMany(r => r).Sum();\n        for (int j = 0; j < grid[0].Count;\
    \ j++) {\n            for (int i = 0; i < grid.Count; i++) {\n               \
    \ if (grid[i][j] == 1) {\n                    totalUnits--;\n                \
    \    fillCount++;\n                    capacity--;\n                    if (capacity\
    \ == 0) {\n                        capacity = 1;\n                        fillCount++;\n\
    \                    }\n                }\n            }\n            capacity\
    \ = 1;\n            fillCount++;\n        }\n        return fillCount;", "   \
    \     long result = 0;\n        int h = grid.Count;\n        int w = grid[0].Count;\n\
    \        var d = new long[h, w];\n        for (int y = 0; y < h; y++) {\n    \
    \        for (int x = 0; x < w; x++) {\n                d[y, x] = grid[y][x];\n\
    \            }\n        }\n        for (int t = 0; t < 100; t++) {\n         \
    \   var lowest = new List<int>();\n            int min = h + w;\n            for\
    \ (int y = 0; y < h; y++) {\n                for (int x = 0; x < w; x++) {\n \
    \                   int sum = 0;\n                    for (int y2 = 0; y2 < h;\
    \ y2++) {\n                        for (int x2 = 0; x2 < w; x2++) {\n        \
    \                    sum += d[y2, x2] - d[y, x];\n                        }\n\
    \                    }\n                    sum = Math.Abs(sum);\n           \
    \         if (sum == min) {\n                        lowest.Add(x + y * w);\n\
    \                    }\n                    if (sum < min) {\n               \
    \         min = sum;\n                        lowest.Clear();\n              \
    \          lowest.Add(x + y * w);\n                    }\n                }\n\
    \            }\n            if (lowest.Count == 0) break;\n            int n =\
    \ (int)Math.Min(capacity, min);\n            result += n;\n            foreach\
    \ (int i in lowest) {\n                int x = i % w;\n                int y =\
    \ i / w;\n                d[y, x] += n;\n            }\n        }\n        return\
    \ result;", "        int maxCount = 0;\n        for (int i = 0; i < grid.Count;\
    \ i++) {\n            maxCount += grid[i].Count(e => e == 1);\n        }\n   \
    \     long turnCount = 0;\n        int count = 0;\n        for (int i = 0; i <\
    \ grid.Count; i++) {\n            for (int j = 0; j < grid[i].Count; j++) {\n\
    \                if (grid[i][j] == 1) {\n                    turnCount++;\n  \
    \                  count++;\n                    if (capacity == 0) {\n      \
    \                  if (count == maxCount) {\n                            return\
    \ turnCount;\n                        }\n                        turnCount +=\
    \ grid.Count - i - 1;\n                        break;\n                    }\n\
    \                    if (capacity > 1) {\n                        capacity--;\n\
    \                    }\n                }\n            }\n            if (count\
    \ == maxCount) {\n                return turnCount;\n            }\n         \
    \   capacity = capacity == 0 ? 0 : capacity - 1;\n        }\n        return turnCount;",
  '        return Enumerable.Range(0, grid.Count).SelectMany(i => Enumerable.Range(0,
    grid[i].Count)).Sum(j => grid[j / grid[0].Count][j % grid[0].Count] * capacity
    / grid.Count);', "        var n = grid.Count;\n        var m = grid[0].Count;\n\
    \        var total = n * m;\n        var sb = new StringBuilder();\n        foreach\
    \ (var row in grid) {\n            foreach (var item in row) {\n             \
    \   sb.Append(item);\n            }\n        }\n        var state = long.Parse(sb.ToString(),\
    \ System.Globalization.NumberStyles.HexNumber);\n        var memo = new Dictionary<long,\
    \ long>();\n        var ans = GetLongestDrop(state, capacity, memo);\n       \
    \ return ans;", '        return 0;', "        // your code goes here\n       \
    \ long well_count = 0;\n        foreach (List<long> well in grid) {\n        \
    \    if (well.Sum() > 0) {\n                well_count++;\n            }\n   \
    \     }\n        if (well_count == 0) {\n            return 0;\n        }\n  \
    \      long num_rows = grid.Count;\n        long num_cols = grid[0].Count;\n \
    \       long well_col_sum = 0;\n        long well_row_sum = 0;\n        foreach\
    \ (List<long> well in grid) {\n            well_col_sum += well.Sum();\n     \
    \   }\n        well_row_sum = well_col_sum / num_cols;\n        well_col_sum =\
    \ well_col_sum % num_cols;\n        long x = well_col_sum / well_row_sum;\n  \
    \      long y = well_col_sum % well_row_sum;\n        long c = capacity;\n   \
    \     well_col_sum = 0;\n        long num_iterations = 0;\n        foreach (List<long>\
    \ well in grid) {\n            well_col_sum += well.Sum();\n        }\n      \
    \  while (well_col_sum > 0) {\n            long z = well_col_sum / c;\n      \
    \      well_col_sum -= z * c;\n            if (well_col_sum < x) {\n         \
    \       num_iterations += z * c + well_col_sum;\n                well_col_sum\
    \ = 0;\n            } else {\n                num_iterations += z * c + x;\n \
    \               well_col_sum -= x;\n            }\n        }\n        return num_iterations;",
  "        long ans = 0;\n        foreach (var row in grid) {\n            var filled\
    \ = new List<long>();\n            var val = 0L;\n            var i = 0;\n   \
    \         while (i < row.Count) {\n                if (row[i] == 1) {\n      \
    \              if (filled.Count < capacity) {\n                        filled.Add(val);\n\
    \                        val = 0;\n                    } else {\n            \
    \            filled.Sort();\n                        ans += filled[0];\n     \
    \                   filled[0] = val;\n                        val = 0;\n     \
    \               }\n                } else {\n                    val++;\n    \
    \            }\n                i++;\n            }\n            if (filled.Count\
    \ > 0) {\n                filled.Sort();\n                ans += filled[0];\n\
    \            }\n        }\n        return ans;", '        throw new NotImplementedException();',
  "        long maxHeight = 0;\n        long length = grid[0].Count;\n        long\
    \ width = grid.Count;\n        long maxRowCount = 0;\n        foreach (List<long>\
    \ row in grid) {\n            long rowCount = 0;\n            foreach (long cell\
    \ in row) {\n                if (cell == 1) {\n                    rowCount++;\n\
    \                }\n            }\n            if (rowCount > maxRowCount) {\n\
    \                maxRowCount = rowCount;\n            }\n        }\n        long\
    \ wellCount = 0;\n        for (long i = 1; i <= capacity; i++) {\n           \
    \ wellCount += (i * maxRowCount);\n        }\n        return wellCount;", "  \
    \      long sum = 0;\n        foreach (var row in grid) {\n            foreach\
    \ (var value in row) {\n                sum += value;\n            }\n       \
    \ }\n        return sum / capacity;", "        long result = 0;\n        for (int\
    \ i = 0; i < grid.Count; i++) {\n            for (int j = 0; j < grid[i].Count;\
    \ j++) {\n                if (grid[i][j] > 0) {\n                    result +=\
    \ 1;\n                    if (grid[i][j] > capacity) {\n                     \
    \   for (int k = i + 1; k < grid.Count; k++) {\n                            grid[k][j]\
    \ -= (grid[i][j] - capacity);\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        return result;", " \
    \       // Part 1: Write a function that adds up the number of full buckets required\
    \ to fill a column.\n        // Example:\n        // >>> numFullBucketsInColumn((new\
    \ List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)0L,\
    \ (long)0L, (long)1L, (long)0L}), (List<long>)new List<long>(new long[]{(long)0L,\
    \ (long)1L, (long)0L, (long)0L}), (List<long>)new List<long>(new long[]{(long)1L,\
    \ (long)1L, (long)1L, (long)1L})})), (2L), (1L))\n        // (1L)\n        //\
    \ >>> numFullBucketsInColumn((new List<List<long>>(new List<long>[]{(List<long>)new\
    \ List<long>(new long[]{(long)0L, (long)0L, (long)1L, (long)1L}), (List<long>)new\
    \ List<long>(new long[]{(long)0L, (long)0L, (long)0L, (long)0L}), (List<long>)new\
    \ List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}), (List<long>)new\
    \ List<long>(new long[]{(long)0L, (long)1L, (long)1L, (long)1L})})), (1L), (2L))\n\
    \        // (3L)\n        // >>> numFullBucketsInColumn((new List<List<long>>(new\
    \ List<long>[]{(List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L}),\
    \ (List<long>)new List<long>(new long[]{(long)0L, (long)0L, (long)0L})})), (0L),\
    \ (1L))\n        // (0L)\n        // Constraints:\n        // * 1 <= row <= grid",
  "        long ans = 0;\n        for (int i = 0; i < grid.Count; i++) {\n       \
    \     long[] row = grid[i].ToArray();\n            for (int j = 0; j < row.Length;\
    \ j++) {\n                if (row[j] == 1) {\n                    for (int k =\
    \ 0; k < capacity; k++) {\n                        if (i + k >= grid.Count) {\n\
    \                            break;\n                        }\n             \
    \           if (grid[i + k][j] == 0) {\n                            grid[i + k][j]\
    \ = 1;\n                            ans++;\n                        }\n      \
    \              }\n                }\n            }\n        }\n        return\
    \ ans;", "        // your code goes here\n        int n = grid.Count;\n      \
    \  int m = grid[0].Count;\n        var e = 0L;\n        var list = new List<long>();\n\
    \        for (int i = 0; i < n; i++) {\n            var f = grid[i].Count(x =>\
    \ x == 1);\n            e += f;\n            if (f == m) {\n                list.Add(i);\n\
    \            }\n        }\n        var r = 0L;\n        var h = new bool[n];\n\
    \        for (int i = 0; i < n; i++) {\n            h[i] = list.Contains(i);\n\
    \        }\n        for (int i = 0; i < n; i++) {\n            if (h[i]) {\n \
    \               continue;\n            }\n            var d = 0L;\n          \
    \  for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n   \
    \                 d++;\n                }\n            }\n            if (d >\
    \ capacity) {\n                return -1;\n            }\n            if (d ==\
    \ capacity) {\n                r++;\n                h[i] = true;\n          \
    \      continue;\n            }\n            for (int j = i - 1; j >= 0; j--)\
    \ {\n                if (h[j]) {\n                    continue;\n            \
    \    }\n                for (int k = 0; k < m; k++) {\n                    if\
    \ (grid[j][k] == 1) {\n                        d++;\n                    }\n \
    \               }\n                if (d > capacity) {\n                    return\
    \ -1;\n                }\n                if (d == capacity) {\n             \
    \       r++;\n                    h[j] = true;\n                    break;\n \
    \               }\n            }\n        }\n        return r;", "        // You\
    \ can use Console.WriteLine to debug your solution.\n        // Console.WriteLine(\"\
    this is a debug message\");\n        // var answer = 1;\n        // return answer;\n\
    \        var nrow = grid.Count;\n        var ncol = grid[0].Count;\n        long\
    \ nflip = 0;\n        for (int i = 0; i < nrow; i++) {\n            for (int j\
    \ = 0; j < ncol; j++) {\n                if (grid[i][j] == 1) {\n            \
    \        nflip++;\n                    var targetRow = Math.Min(i + capacity,\
    \ nrow - 1);\n                    for (int k = i; k <= targetRow; k++) {\n   \
    \                     grid[k][j] = grid[k][j] == 0 ? 1 : 0;\n                \
    \    }\n                }\n            }\n        }\n        return nflip;", " \
    \       long c=0;\n        // BEGIN (write your solution here)\n        for (long\
    \ i=0; i<grid.Count; i++) {\n            for (long j=0; j<grid[(int)i].Count;\
    \ j++) {\n                if (grid[(int)i][(int)j]==1) {\n                   \
    \ grid[(int)i][(int)j]=0;\n                    c++;\n                    capacity--;\n\
    \                    if (capacity>0) {\n                        if (i>0) {\n \
    \                           grid[(int)i-1][(int)j]=0;\n                      \
    \      capacity--;\n                        }\n                        if (capacity>0)\
    \ {\n                            if (j>0) {\n                                grid[(int)i][(int)j-1]=0;\n\
    \                                capacity--;\n                            }\n\
    \                            if (capacity>0) {\n                             \
    \   if (i<grid.Count-1) {\n                                    grid[(int)i+1][(int)j]=0;\n\
    \                                    capacity--;\n                           \
    \     }\n                                if (capacity>0) {\n                 \
    \                   if (j<grid[(int)i].Count-1) {\n                          \
    \              grid[(int)i][(int)j+1]=0;\n                                   \
    \     capacity--;\n                                    }\n                   \
    \             }\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n        }\n        //\
    \ END\n        return c;", "        long row_index = 0;\n        long col_index\
    \ = 0;\n        long row_len = grid.Count;\n        long col_len = grid[0].Count;\n\
    \        long total_taps = 0;\n        long filled_to = 0;\n        long num_taps\
    \ = 0;\n        bool flag = false;\n        while (row_index < row_len) {\n  \
    \          col_index = 0;\n            while (col_index < col_len) {\n       \
    \         if (grid[(int)row_index][(int)col_index] > 0) {\n                  \
    \  total_taps += grid[(int)row_index][(int)col_index];\n                    filled_to\
    \ = Math.Min(total_taps, capacity);\n                    num_taps += (filled_to\
    \ - grid[(int)row_index][(int)col_index]);\n                    grid[(int)row_index][(int)col_index]\
    \ = filled_to;\n                    flag = true;\n                }\n        \
    \        col_index += 1;\n            }\n            if (flag) {\n           \
    \     total_taps = 0;\n                flag = false;\n            }\n        \
    \    row_index += 1;\n        }\n        return num_taps;", "        if (grid.Count\
    \ == 0) {\n            return 0;\n        }\n        long len = grid[0].Count;\n\
    \        long total = 0;\n        long[] count = new long[len];\n        foreach\
    \ (var row in grid) {\n            for (long i = 0; i < len; i++) {\n        \
    \        if (row[(int)i] == 1) {\n                    count[(int)i]++;\n     \
    \               total++;\n                }\n            }\n        }\n      \
    \  return Fill(count, capacity, total);", '        return 0;', '        return
    -1;', '        return 0;', "        Debug.Assert(grid.Count > 0);\n        Debug.Assert(grid[0].Count\
    \ > 0);\n        Debug.Assert(grid.Count <= 100);\n        Debug.Assert(grid[0].Count\
    \ <= 100);\n        Debug.Assert(capacity >= 1);\n        Debug.Assert(capacity\
    \ <= 10);\n        long n = grid.Count;\n        long m = grid[0].Count;\n   \
    \     long answer = 0;\n        long[,] sums = new long[n, m];\n        for (long\
    \ i = 0; i < n; i++) {\n            for (long j = 0; j < m; j++) {\n         \
    \       sums[i, j] = grid[(int)i][(int)j];\n                if (i > 0) {\n   \
    \                 sums[i, j] += sums[i - 1, j];\n                }\n         \
    \       if (j > 0) {\n                    sums[i, j] += sums[i, j - 1];\n    \
    \            }\n                if (i > 0 && j > 0) {\n                    sums[i,\
    \ j] -= sums[i - 1, j - 1];\n                }\n            }\n        }\n   \
    \     for (long i = 0; i < n; i++) {\n            for (long j = 0; j < m; j++)\
    \ {\n                long current_row_sum = sums[i, m - 1];\n                if\
    \ (j > 0) {\n                    current_row_sum -= sums[i, j - 1];\n        \
    \        }\n                long num_buckets = 1 + current_row_sum / capacity;\n\
    \                answer += num_buckets;\n            }\n        }\n        return\
    \ answer;", "        // your code here\n        long step = 0;\n        int rows\
    \ = grid.Count();\n        int cols = grid[0].Count();\n        int[,] state =\
    \ new int[rows, cols];\n        int[,] dist = new int[rows, cols];\n        int[]\
    \ delta = new int[] {-1, 0, 1, 0, -1};\n        int[] delta_col = new int[] {-1,\
    \ 0, 1, 0, -1};\n        for (int i = 0; i < rows; i++) {\n            for (int\
    \ j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n          \
    \          state[i, j] = 1;\n                    dist[i, j] = 0;\n           \
    \     } else {\n                    state[i, j] = 0;\n                    dist[i,\
    \ j] = 10000;\n                }\n            }\n        }\n        Console.WriteLine(\"\
    Sorted grid\");\n        for (int i = 0; i < rows; i++) {\n            for (int\
    \ j = 0; j < cols; j++) {\n                Console.Write(\"{0} \", state[i, j]);\n\
    \            }\n            Console.WriteLine();\n        }\n        while (true)\
    \ {\n            step++;\n            Console.WriteLine(\"state after step {0}\"\
    , step);\n            for (int i = 0; i < rows; i++) {\n                for (int\
    \ j = 0; j < cols; j++) {\n                    Console.Write(\"{0} \", state[i,\
    \ j]);\n                }\n                Console.WriteLine();\n            }\n\
    \            bool done = true;\n            for (int i = 0; i < rows; i++) {\n\
    \                for (int j = 0; j < cols; j++) {\n                    if (state[i,\
    \ j] == step) {\n                        for (int k = 0; k < 4; k++) {\n     \
    \                       int new_row = i + delta[k];\n                        \
    \    int new_col = j + delta_col[k];\n                            if (0 <= new_row\
    \ && new_row < rows && 0 <= new_col && new_col < cols) {\n                ", " \
    \       long count = 0;\n        List<long> maxCol = new List<long>();\n     \
    \   List<long> maxRow = new List<long>();\n        List<long> rowCap = new List<long>();\n\
    \        List<long> colCap = new List<long>();\n        foreach (List<long> row\
    \ in grid) {\n            long val = row.Sum();\n            if (val > 0) {\n\
    \                count += val;\n                maxRow.Add(val);\n           \
    \     if (val > capacity) {\n                    rowCap.Add(capacity);\n     \
    \           } else {\n                    rowCap.Add(val);\n                }\n\
    \            }\n        }\n        for (int i = 0; i < grid[0].Count; i++) {\n\
    \            long val = 0;\n            foreach (List<long> row in grid) {\n \
    \               val += row[i];\n            }\n            if (val > 0) {\n  \
    \              maxCol.Add(val);\n                if (val > capacity) {\n     \
    \               colCap.Add(capacity);\n                } else {\n            \
    \        colCap.Add(val);\n                }\n            }\n        }\n     \
    \   while (true) {\n            if (maxRow.Count > 0) {\n                long\
    \ t = maxRow.Max();\n                int ind = maxRow.IndexOf(t);\n          \
    \      count -= t;\n                t -= rowCap[ind];\n                if (t >\
    \ 0) {\n                    maxRow[ind] = t;\n                } else {\n     \
    \               maxRow.RemoveAt(ind);\n                    rowCap.RemoveAt(ind);\n\
    \                }\n            } else if (maxCol.Count > 0) {\n             \
    \   long t = maxCol.Max();\n                int ind = maxCol.IndexOf(t);\n   \
    \             count -= t;\n                t -= colCap[ind];\n               \
    \ if (t > 0) {\n                    maxCol[ind] = t;\n                } else {\n\
    \                    maxCol.RemoveAt(ind);\n                    colCap.RemoveAt(ind);\n\
    \                }\n            } else {\n                break;\n           \
    \ }\n        }\n        return count;", "        long width = grid[0].Count;\n\
    \        long height = grid.Count;\n        long total = 0;\n        for (long\
    \ y = 0; y < height; y++) {\n            for (long x = 0; x < width; x++) {\n\
    \                total += grid[(int)y][(int)x];\n            }\n        }\n  \
    \      long count = 0;\n        long bucketCapacity = 0;\n        for (long y\
    \ = 0; y < height; y++) {\n            for (long x = 0; x < width; x++) {\n  \
    \              bucketCapacity += grid[(int)y][(int)x];\n                count++;\n\
    \                if (count > 1 && bucketCapacity == capacity) {\n            \
    \        bucketCapacity = 0;\n                    count = 0;\n               \
    \ }\n            }\n            if (bucketCapacity > 0) {\n                bucketCapacity\
    \ = 0;\n                count = 0;\n            }\n        }\n        return total;",
  "        // your code here...\n        return 1;", "        // TODO\n        return\
    \ 0;", "        long maxFill = 0;\n        for (int row = 0; row < grid.Count;\
    \ row++) {\n            for (int col = 0; col < grid[row].Count; col++) {\n  \
    \              if (grid[row][col] == 1) {\n                    long fill = 0;\n\
    \                    if (row + 1 < grid.Count) {\n                        fill\
    \ += capacity - grid[row + 1][col];\n                    }\n                 \
    \   if (col + 1 < grid[row].Count) {\n                        fill += capacity\
    \ - grid[row][col + 1];\n                    }\n                    maxFill +=\
    \ fill;\n                }\n            }\n        }\n        return maxFill;",
  "        long res = 0;\n        long row = grid.Count;\n        long col = grid[0].Count;\n\
    \        long[,]matrix = new long[row,col];\n        for(int i = 0; i < row; i++)\
    \ {\n            for(int j = 0; j < col; j++) {\n                matrix[i,j] =\
    \ grid[i][j];\n            }\n        }\n        for(int i = 0; i < row; i++)\
    \ {\n            for(int j = 0; j < col; j++) {\n                if(matrix[i,j]\
    \ == 1) {\n                    res += capacity;\n                    int[,]move\
    \ = new int[2,2]{{1,0},{0,1}};\n                    for(int k = 0; k < 2; k++)\
    \ {\n                        int ni = i + move[k,0];\n                       \
    \ int nj = j + move[k,1];\n                        if(ni >= 0 && ni < row && nj\
    \ >= 0 && nj < col) {\n                            if(matrix[ni,nj] == 1) {\n\
    \                                matrix[ni,nj] = 0;\n                        \
    \        res--;\n                            }\n                        }\n  \
    \                  }\n                }\n            }\n        }\n        return\
    \ res;", "        long fills = 0;\n        long maxFill = grid.Count * capacity;\n\
    \        foreach (var row in grid) {\n            fills += row.Count(x => x ==\
    \ 1);\n        }\n        return maxFill - fills;", "        if(!grid.Any())\n\
    \            return 0;\n        int w = grid[0].Count;\n        int h = grid.Count;\n\
    \        long[,] b = new long[w,h];\n        for(int j = 0; j < h; j++) {\n  \
    \          for(int i = 0; i < w; i++) {\n                b[i,j] = grid[j][i];\n\
    \            }\n        }\n        long f = 0;\n        while(true) {\n      \
    \      long[,] nb = new long[w,h];\n            for(int j = 0; j < h; j++) {\n\
    \                for(int i = 0; i < w; i++) {\n                    if(b[i,j] <\
    \ 0) {\n                        b[i,j] = 0;\n                        continue;\n\
    \                    }\n                    if(b[i,j] == 0)\n                \
    \        continue;\n                    long v = capacity;\n                 \
    \   if(i > 0) {\n                        v = Math.Min(v, b[i-1,j]);\n        \
    \            }\n                    if(i < w-1) {\n                        v =\
    \ Math.Min(v, b[i+1,j]);\n                    }\n                    if(j > 0)\
    \ {\n                        v = Math.Min(v, b[i,j-1]);\n                    }\n\
    \                    if(j < h-1) {\n                        v = Math.Min(v, b[i,j+1]);\n\
    \                    }\n                    if(v == 0)\n                     \
    \   continue;\n                    nb[i,j] = b[i,j] - v;\n                   \
    \ if(i > 0) {\n                        nb[i-1,j] += v;\n                    }\n\
    \                    if(i < w-1) {\n                        nb[i+1,j] += v;\n\
    \                    }\n                    if(j > 0) {\n                    \
    \    nb[i,j-1] += v;\n                    }\n                    if(j < h-1) {\n\
    \                        nb[i,j+1] += v;\n                    }\n            \
    \        f += v;\n                }\n            }\n            if(ArrayEquals(b,\
    \ nb))\n                break;", "        return grid.Aggregate(new List<long>(),\
    \ (agg,row) => {\n            return agg.Add((row.Aggregate(0L, (ag,i) => ag +\
    \ i)));\n        }).Aggregate(0L, (agg,r) => {\n            return agg + r / capacity\
    \ + (r % capacity == 0 ? 0 : 1);\n        });", "        long width = (long)grid[0].Count;\n\
    \        long height = (long)grid.Count;\n        long num = (long)grid.Sum(i\
    \ => i.Sum());\n        long buckets = num / capacity;\n        if (num % capacity\
    \ != 0) {\n            buckets += 1;\n        }\n        long[,] g = new long[height,\
    \ width];\n        for (long y = 0; y < height; y++) {\n            for (long\
    \ x = 0; x < width; x++) {\n                g[y, x] = grid[(int)y][(int)x];\n\
    \            }\n        }\n        long fill = 0;\n        for (long i = 0; i\
    \ < buckets; i++) {\n            long[,] c = new long[height, width];\n      \
    \      long[,] t = new long[height, width];\n            for (long y = 0; y <\
    \ height; y++) {\n                for (long x = 0; x < width; x++) {\n       \
    \             if (g[y, x] > 0) {\n                        c[y, x] = 0;\n     \
    \                   g[y, x] -= 1;\n                        t[y, x] = 1;\n    \
    \                    if (y > 0) {\n                            c[y - 1, x] = c[y,\
    \ x] + 1;\n                        }\n                        if (y < height -\
    \ 1) {\n                            c[y + 1, x] = c[y, x] + 1;\n             \
    \           }\n                        if (x > 0) {\n                        \
    \    c[y, x - 1] = c[y, x] + 1;\n                        }\n                 \
    \       if (x < width - 1) {\n                            c[y, x + 1] = c[y, x]\
    \ + 1;\n                        }\n                    }\n                }\n\
    \            }\n            while (true) {\n                long[,] s = new long[height,\
    \ width];\n                for (long y = 0; y < height; y++) {\n             \
    \       for (long x = 0; x < width; x++) {\n                        if (t[y, x]\
    \ == 1) {\n                            s[y, x] = 1;\n                        \
    \    if (y > 0", '        return 0;', "        // your code here\n        long\
    \ ret = -1;\n        return ret;", "        // your code here\n        // [0,\
    \ 0, 1, 0]\n        // [0, 1, 0, 0]\n        // [1, 1, 1, 1]\n        //  0  1\
    \  2  3\n        // \n        // [0, 0, 1, 1]\n        // [0, 0, 0, 0]\n     \
    \   // [1, 1, 1, 1]\n        // [0, 1, 1, 1]\n        //  0  1  2  3\n       \
    \ // \n        // [0, 0, 0]\n        // [0, 0, 0]\n        //  0  1  2\n     \
    \   // \n        // (6L)\n        // \n        // (5L)\n        // \n        //\
    \ (0L)\n        // \n        //\n        // 0, 0, 1, 0\n        // 0, 1, 0, 0\n\
    \        // 1, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1, 1, 1\n       \
    \ // 1, 0, 0, 0\n        // 1, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1,\
    \ 1, 1\n        // 0, 1, 1, 1\n        // 1, 0, 0, 0\n        // 1, 1, 1, 1\n\
    \        // 0, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1, 1, 1\n       \
    \ // 1, 0, 0, 0\n        // 1, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1,\
    \ 1, 1\n        // 0, 1, 1, 1\n        // 1, 0, 0, 0\n        // 1, 1, 1, 1\n\
    \        // 0, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1, 1, 1\n       \
    \ // 1, 0, 0, 0\n        // 1, 1, 1, 1\n        // 0, 1, 1, 1\n        // 0, 1,\
    \ 1, 1\n        // 0, 1, 1, 1\n        // 1, 0, 0, 0\n        // 1, 1, 1, 1\n\
    \        //", "        long ans = 0;\n        for (int i = 0; i < grid.Count;\
    \ i++) {\n            for (int j = 0; j < grid[i].Count; j++) {\n            \
    \    if (grid[i][j] == 1) {\n                    ans += capacity;\n          \
    \          if (i > 0) {\n                        ans -= Math.Min(capacity, grid[i\
    \ - 1][j]);\n                    }\n                    if (j > 0) {\n       \
    \                 ans -= Math.Min(capacity, grid[i][j - 1]);\n               \
    \     }\n                }\n            }\n        }\n        return ans;", " \
    \       long bucketCount = grid.Count;\n        long wellCount = grid[0].Count;\n\
    \        long result = 0;\n        long totalWater = 0;\n        long i = 0;\n\
    \        long j = 0;\n        for (i = 0; i < bucketCount; i++) {\n          \
    \  for (j = 0; j < wellCount; j++) {\n                totalWater += grid[i][j];\n\
    \            }\n        }\n        long bucket = 0;\n        long diff = 0;\n\
    \        for (i = 0; i < bucketCount; i++) {\n            bucket = 0;\n      \
    \      for (j = 0; j < wellCount; j++) {\n                bucket += grid[i][j];\n\
    \                if (bucket > capacity) {\n                    diff = bucket -\
    \ capacity;\n                    bucket = capacity;\n                    grid[i][j]\
    \ -= diff;\n                    grid[i][j - 1] += diff;\n                }\n \
    \           }\n            result += capacity - bucket;\n        }\n        return\
    \ result;", "        long res = 0;\n        long lastRound = long.MaxValue;\n\
    \        while (true) {\n            for (int i = 0; i < grid.Count; i++) {\n\
    \                for (int j = 0; j < grid[i].Count; j++) {\n                 \
    \   if (grid[i][j] < lastRound) {\n                        res += grid[i][j];\n\
    \                        grid[i][j] = 0;\n                    } else {\n     \
    \                   res += lastRound;\n                        grid[i][j] -= lastRound;\n\
    \                    }\n                }\n            }\n            if (lastRound\
    \ == capacity) {\n                break;\n            }\n            lastRound\
    \ = Math.Min(lastRound * 2, capacity);\n        }\n        return res;", "   \
    \     var x = new List<List<long>>();\n        var k = grid.Count;\n        var\
    \ n = grid[0].Count;\n        var s = 0L;\n        var t = 1L;\n        var c\
    \ = new List<List<long>>();\n        foreach (var i in Enumerable.Range(0, (int)k))\
    \ {\n            c.Add(new List<long>());\n            foreach (var j in Enumerable.Range(0,\
    \ (int)n)) {\n                c[i].Add(grid[i][j]);\n                s += grid[i][j];\n\
    \            }\n        }\n        var r = 0L;\n        while (true) {\n     \
    \       var a = new List<List<long>>();\n            foreach (var i in Enumerable.Range(0,\
    \ (int)n)) {\n                a.Add(new List<long>());\n                foreach\
    \ (var j in Enumerable.Range(0, (int)k)) {\n                    a[i].Add(t);\n\
    \                }\n            }\n            var f = new List<List<long>>();\n\
    \            foreach (var i in Enumerable.Range(0, (int)n)) {\n              \
    \  f.Add(new List<long>());\n                foreach (var j in Enumerable.Range(0,\
    \ (int)k)) {\n                    f[i].Add(new List<long>());\n              \
    \      foreach (var m in Enumerable.Range(0, (int)k)) {\n                    \
    \    f[i][j].Add(0L);\n                    }\n                }\n            }\n\
    \            var v = new List<List<long>>();\n            foreach (var i in Enumerable.Range(0,\
    \ (int)n)) {\n                v.Add(new List<long>());\n                foreach\
    \ (var j in Enumerable.Range(0, (int)k)) {\n                    v[i].Add(new List<long>());\n\
    \                    foreach (var m in Enumerable.Range(0, (int)k)) {\n      \
    \                  v[i][j].Add(0L);\n                    }\n                }\n\
    \            }\n            var d = new List<List<long>>();\n            foreach\
    \ (var i", "        // your code goes here\n        var wellsCount = grid.Count;\n\
    \        var wellsLength = grid[0].Count;\n        var levelsCount = 0;\n    \
    \    while (grid.Count > 0) {\n            var wellsLevel = Fill(grid, capacity);\n\
    \            levelsCount += wellsLevel;\n            grid = RemoveLevel(grid,\
    \ wellsLevel);\n        }\n        return levelsCount;", "        List<long> totalWater\
    \ = new List<long>();\n        long sum = 0;\n        long cnt = 0;\n        foreach\
    \ (var row in grid) {\n            totalWater.Add(row.Sum());\n            sum\
    \ += row.Sum();\n        }\n        var r = sum / capacity;\n        foreach (var\
    \ row in grid) {\n            cnt += row.Count(i => i == 1);\n        }\n    \
    \    var r1 = cnt / capacity;\n        return r * 2 + r1;", "        // Our strategy\
    \ will be to allocate a bucket to each well, \n        // then distribute their\
    \ capacity evenly by height, \n        // and then use the remaining capacity\
    \ of the tallest wells to fill the shortest wells.\n        long height = grid.Count;\n\
    \        long width = grid[0].Count;\n        long row_capacity = capacity / height;\n\
    \        long total_fill = 0;\n        long[] row_fill = new long[height];\n \
    \       for (long i = 0; i < height; i++) {\n            row_fill[i] = row_capacity;\n\
    \            for (long j = 0; j < width; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 1) {\n                    total_fill += row_fill[i];\n                  \
    \  grid[(int)i][(int)j] = 0;\n                }\n            }\n        }\n  \
    \      // If a well does not fill to capacity,\n        // it gains a \"remaining\
    \ capacity\" equal to its maximum fill potential.\n        long remaining_capacity\
    \ = capacity - total_fill;\n        for (long i = 0; i < height; i++) {\n    \
    \        row_fill[i] = Math.Max(row_fill[i], (capacity - total_fill) / (height\
    \ - i));\n        }\n        long[] col_fill = new long[width];\n        for (long\
    \ j = 0; j < width; j++) {\n            col_fill[j] = 0;\n            for (long\
    \ i = 0; i < height; i++) {\n                if (grid[(int)i][(int)j] == 1) {\n\
    \                    col_fill[j] = i;\n                }\n            }\n    \
    \    }\n        // If a well does not fill to capacity,\n        // it gains a\
    \ \"remaining capacity\" equal to its maximum fill potential.\n        for (long\
    \ j = 0; j < width; j++) {\n            for (long i = 0; i < height; i++) {\n\
    \                if (i == col_fill[j]) {\n                    total_fill += Math.Min(remaining_capacity,\
    \ row_fill[i]);\n                    remaining_capacity -= row_fill[i];\n    \
    \            }\n            }\n        }\n       ", "        int max = grid.Max(x\
    \ => x.Count());\n        long count = 0;\n        for (int i = 0; i < max; i++)\
    \ {\n            for (int j = 0; j < grid.Count(); j++) {\n                if\
    \ (grid[j].Count > i && grid[j][i] > 0) {\n                    count += capacity;\n\
    \                }\n            }\n        }\n        return count;", "      \
    \  // TODO\n        return 0;", "        var rows = grid.Count;\n        var cols\
    \ = grid[0].Count;\n        var res = 0L;\n        var deep = new bool[rows, cols];\n\
    \        for (var r = 0; r < rows; r++) {\n            for (var c = 0; c < cols;\
    \ c++) {\n                if (grid[r][c] == 1 && !deep[r, c]) {\n            \
    \        for (var i = 0; i < rows; i++) {\n                        for (var j\
    \ = 0; j < cols; j++) {\n                            deep[i, j] = false;\n   \
    \                     }\n                    }\n                    res += Fill(grid,\
    \ deep, rows, cols, r, c, capacity);\n                }\n            }\n     \
    \   }\n        return res;", '        throw new NotImplementedException();', '        throw
    new NotImplementedException();', "        // Fill in your answer here\n      \
    \  var grid2 = grid.Select(x => x.ToArray()).ToArray();\n        long f = 0;\n\
    \        int heigh = grid2.Length;\n        int width = grid2[0].Length;\n   \
    \     for (int i = 0; i < width; i++) {\n            f += capacity;\n        \
    \    long current = capacity;\n            for (int j = 0; j < heigh; j++) {\n\
    \                if (grid2[j][i] == 1) {\n                    current--;\n   \
    \                 if (current < 0) {\n                        current = capacity;\n\
    \                        f += capacity;\n                    }\n             \
    \   }\n            }\n        }\n        return f;", "        long result = 0;\n\
    \        for (long row = 0; row < grid.Count; row++) {\n            for (long\
    \ col = 0; col < grid[(int)row].Count; col++) {\n                if (grid[(int)row][(int)col]\
    \ == 0) {\n                    if (row + 1 < grid.Count) {\n                 \
    \       if (grid[(int)row + 1][(int)col] == 1) {\n                           \
    \ result++;\n                            grid[(int)row + 1][(int)col] = 0;\n \
    \                       }\n                    }\n                    if (col\
    \ + 1 < grid[(int)row].Count) {\n                        if (grid[(int)row][(int)col\
    \ + 1] == 1) {\n                            result++;\n                      \
    \      grid[(int)row][(int)col + 1] = 0;\n                        }\n        \
    \            }\n                }\n            }\n        }\n        return result;",
  "        // check that grid is valid\n        Debug.Assert(grid.Count >= 1 && grid.Count\
    \ <= 100);\n        Debug.Assert(grid[0].Count >= 1 && grid[0].Count <= 100);\n\
    \        foreach (List<long> row in grid) {\n            Debug.Assert(row.Count\
    \ == grid[0].Count);\n            foreach (long val in row) {\n              \
    \  Debug.Assert(val == 0 || val == 1);\n            }\n        }\n        Debug.Assert(capacity\
    \ >= 1 && capacity <= 10);\n        // fill in the code here\n        // how long\
    \ are the rows\n        int numColumns = grid[0].Count;\n        // for each row,\
    \ what is the min amount of water needed to fill that row\n        List<long>\
    \ minRowWater = new List<long>();\n        // what is the total water we need\
    \ in all the rows\n        long totalWater = 0;\n        // for each row, how\
    \ many buckets do we need to fill it\n        List<long> rowBuckets = new List<long>();\n\
    \        // total number of buckets used in all rows\n        long totalBuckets\
    \ = 0;\n        // how long are the rows\n        int numRows = grid.Count;\n\
    \        // keep track of the number of times we lowered the buckets\n       \
    \ long numLowered = 0;\n        // go through the rows\n        for (int row =\
    \ 0; row < numRows; row++) {\n            // go through each column\n        \
    \    long totalInRow = 0;\n            for (int col = 0; col < numColumns; col++)\
    \ {\n                // count the number of 1s in the row\n                if\
    \ (grid[row][col] == 1) {\n                    totalInRow++;\n               \
    \ }\n            }\n            // calculate the minimum amount of water needed\
    \ to fill the row\n            long need = numColumns - totalInRow;\n        \
    \    // calculate the minimum number of buckets needed to fill the row\n     \
    \       long buckets = need / capacity;\n            if (need % capacity != 0)\
    \ {\n                buckets++;\n            }\n            totalWater += need;\n\
    \            totalBuckets += buckets;\n            minRowWater.Add(need);\n  \
    \          rowBuckets.Add(buckets", "        var height = grid.Count;\n      \
    \  var width = grid[0].Count;\n        // True indicates the cell has been filled.\n\
    \        var filled = Enumerable.Repeat(false, height).Select(e => Enumerable.Repeat(false,\
    \ width).ToList()).ToList();\n        var total_moves = 0;\n        for (var i\
    \ = 0; i < height; i++) {\n            for (var j = 0; j < width; j++) {\n   \
    \             if (grid[i][j] == 1 && !filled[i][j]) {\n                    total_moves\
    \ += 1;\n                    total_moves += Fill(grid, filled, i, j, capacity);\n\
    \                }\n            }\n        }\n        return total_moves;", '        return
    0;', '        return -1;', "        long max_buckets = 0;\n        long grid_height\
    \ = (long)grid.Count;\n        long grid_width = (long)grid[0].Count;\n      \
    \  long min_buckets = 0;\n        for (long i = 0; i < grid_height; i++) {\n \
    \           for (long j = 0; j < grid_width; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 1) {\n                    min_buckets += 1;\n                }\n        \
    \    }\n        }\n        long[][] buckets = new long[grid_height][];\n     \
    \   for (long i = 0; i < grid_height; i++) {\n            buckets[i] = new long[grid_width];\n\
    \        }\n        for (long i = 0; i < grid_height; i++) {\n            for\
    \ (long j = 0; j < grid_width; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 1) {\n                    if (buckets[(int)i][(int)j] < capacity) {\n   \
    \                     buckets[(int)i][(int)j] += 1;\n                        if\
    \ (i > 0) {\n                            buckets[(int)(i - 1)][(int)j] += 1;\n\
    \                        }\n                        if (i < grid_height - 1) {\n\
    \                            buckets[(int)(i + 1)][(int)j] += 1;\n           \
    \             }\n                        if (j > 0) {\n                      \
    \      buckets[(int)i][(int)(j - 1)] += 1;\n                        }\n      \
    \                  if (j < grid_width - 1) {\n                            buckets[(int)i][(int)(j\
    \ + 1)] += 1;\n                        }\n                    }\n            \
    \    }\n            }\n        }\n        for (long i = 0; i < grid_height; i++)\
    \ {\n            for (long j = 0; j < grid_width; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 1) {\n                    max_buckets += buckets[(int)i][(int)j];\n     \
    \           }\n            }\n        }\n        return (max_buckets /", "   \
    \     long result = 0;\n        int height = grid.Count;\n        int width =\
    \ grid[0].Count;\n        for (int y = 0; y < height; y++) {\n            for\
    \ (int x = 0; x < width; x++) {\n                if (grid[y][x] == 1) {\n    \
    \                result += capacity;\n                    for (int dy = y + 1;\
    \ dy < height; dy++) {\n                        if (grid[dy][x] == 1) {\n    \
    \                        result += 1;\n                        } else {\n    \
    \                        break;\n                        }\n                 \
    \   }\n                }\n            }\n        }\n        return result;", " \
    \       var m = grid.Count;\n        var n = grid[0].Count;\n        var maxRows\
    \ = Enumerable.Range(0, m).Select(i => grid[i].Sum()).ToList();\n        var maxCols\
    \ = Enumerable.Range(0, n).Select(j => grid.Select(row => row[j]).Sum()).ToList();\n\
    \        var maxRowsSorted = maxRows.Select((item, index) => new { Item = item,\
    \ Index = index }).OrderByDescending(x => x.Item).Select(x => x.Index).ToList();\n\
    \        var maxColsSorted = maxCols.Select((item, index) => new { Item = item,\
    \ Index = index }).OrderByDescending(x => x.Item).Select(x => x.Index).ToList();\n\
    \        var maxRowsBackup = maxRows.ToList();\n        var maxColsBackup = maxCols.ToList();\n\
    \        var emptyRows = new bool[m];\n        var emptyCols = new bool[n];\n\
    \        var res = 0L;\n        while (maxRowsSorted.Count + maxColsSorted.Count\
    \ > 0) {\n            var maxRow = maxRowsSorted.FirstOrDefault();\n         \
    \   var maxCol = maxColsSorted.FirstOrDefault();\n            if (maxRow != -1\
    \ && (maxCol == -1 || maxRows[maxRow] >= maxCols[maxCol])) {\n               \
    \ res += maxRows[maxRow] / capacity;\n                if (maxRows[maxRow] % capacity\
    \ != 0) {\n                    res++;\n                }\n                maxRows[maxRow]\
    \ = 0;\n                maxRowsSorted.RemoveAt(0);\n                emptyRows[maxRow]\
    \ = true;\n                for (var j = 0; j < n; j++) {\n                   \
    \ if (emptyCols[j]) {\n                        continue;\n                   \
    \ }\n                    maxCols[j] -= grid[maxRow][j];\n                    if\
    \ (maxCols[j] <= 0) {\n                        maxColsSorted.Remove(j);\n    \
    \                    emptyCols[j] = true;\n                    }\n           \
    \    ", "        var indices = Enumerable.Range(0, grid.Count).ToList();\n   \
    \     var w = grid[0].Count;\n        var h = grid.Count;\n        return indices.SelectMany(y\
    \ => {\n            var row = grid[y];\n            return indices.Where(x =>\
    \ row[x] == 1).Select(x => new {x, y});\n        }).Aggregate(0L, (count, point)\
    \ => {\n            var wells = new List<List<int>> {new List<int> {point.x, point.y}};\n\
    \            var nextWells = new List<List<int>>();\n            var bucketSize\
    \ = capacity;\n            while (bucketSize > 0) {\n                nextWells.Clear();\n\
    \                foreach (var well in wells) {\n                    var x = well[0];\n\
    \                    var y = well[1];\n                    if (x > 0 && grid[y][x\
    \ - 1] == 1) {\n                        grid[y][x - 1] = 0;\n                \
    \        nextWells.Add(new List<int> {x - 1, y});\n                    }\n   \
    \                 if (x < w - 1 && grid[y][x + 1] == 1) {\n                  \
    \      grid[y][x + 1] = 0;\n                        nextWells.Add(new List<int>\
    \ {x + 1, y});\n                    }\n                    if (y > 0 && grid[y\
    \ - 1][x] == 1) {\n                        grid[y - 1][x] = 0;\n             \
    \           nextWells.Add(new List<int> {x, y - 1});\n                    }\n\
    \                    if (y < h - 1 && grid[y + 1][x] == 1) {\n               \
    \         grid[y + 1][x] = 0;\n                        nextWells.Add(new List<int>\
    \ {x, y + 1});\n                    }\n                }\n                bucketSize--;\n\
    \                var tmp = wells;\n                wells = nextWells;\n      \
    \          nextWells = tmp;\n            }\n            var newCount = 1 + (capacity\
    \ - bucketSize);\n            Debug.Assert(newCount > 0);\n            return\
    \ count + newCount;\n        });", '        return 0;', "        // Your code\
    \ goes here\n        return default(long);", "        var arr = grid.Select(x\
    \ => x.ToArray()).ToArray();\n        var width = arr[0].Length;\n        var\
    \ height = arr.Length;\n        var bits = Enumerable.Range(0, height).Select(x\
    \ => BitVector.Create(width)).ToArray();\n        for (var i = 0; i < height;\
    \ i++) {\n            for (var j = 0; j < width; j++) {\n                bits[i][j]\
    \ = arr[i][j] == 1;\n            }\n        }\n        long result = 0;\n    \
    \    while (true) {\n            var hasChange = false;\n            var hasAllZero\
    \ = true;\n            for (var i = 0; i < height; i++) {\n                var\
    \ allOne = true;\n                for (var j = 0; j < width; j++) {\n        \
    \            if (bits[i][j]) {\n                        hasAllZero = false;\n\
    \                        allOne = false;\n                        if (j < width\
    \ - 1 && !bits[i][j + 1]) {\n                            var above = i < height\
    \ - 1 ? bits[i + 1][j] : false;\n                            var below = i > 0\
    \ ? bits[i - 1][j] : false;\n                            if (!above && !below)\
    \ {\n                                bits[i][j] = false;\n                   \
    \             bits[i][j + 1] = true;\n                                hasChange\
    \ = true;\n                            }\n                        }\n        \
    \            } else {\n                        allOne = false;\n             \
    \       }\n                }\n                if (allOne) {\n                \
    \    bits[i] = BitVector.Create(width);\n                    hasChange = true;\n\
    \                }\n            }\n            if (hasAllZero) {\n           \
    \     break;\n            }\n            if (!hasChange) {\n                result\
    \ += capacity;\n                for (var i = 0; i < height; i++) {\n         \
    \           bits[i] = BitVector.Create(width);\n                }\n          \
    \  }\n        }\n        return result;", '        return 0;', "        long total\
    \ = 0;\n        for (long i = 0; i < grid.Count; i++) {\n            for (long\
    \ j = 0; j < grid[(int)i].Count; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 1) {\n                    long fill = capacity;\n                    while\
    \ (fill > 0) {\n                        total += fill;\n                     \
    \   fill--;\n                    }\n                }\n            }\n       \
    \ }\n        return total;", "        long result = 0;\n        long rowCount\
    \ = grid.Count;\n        long columnCount = grid[0].Count;\n        for (long\
    \ i = 0; i < columnCount; i++) {\n            for (long j = 0; j < rowCount; j++)\
    \ {\n                long drops = 0;\n                if (grid[(int)j][(int)i]\
    \ == 0) {\n                    for (long k = j + 1; k < rowCount; k++) {\n   \
    \                     if (grid[(int)k][(int)i] == 1) {\n                     \
    \       drops += 1;\n                        }\n                    }\n      \
    \              if (drops > 0) {\n                        result += Math.Ceiling((double)(drops\
    \ * 1L) / (double)(capacity * 1L));\n                    }\n                }\n\
    \            }\n        }\n        return result;", "        long res = 0;\n \
    \       return res;", "        var m = (long)grid.Count;\n        var n = (long)grid[0].Count;\n\
    \        var filled = Enumerable.Repeat(0L, (int)n).ToList();\n        var total\
    \ = 0L;\n        for (var i = 0L; i < m; i++) {\n            var row = grid[(int)i];\n\
    \            var prev = 0L;\n            for (var j = 0L; j < n; j++) {\n    \
    \            filled[(int)j] += row[(int)j];\n                if (filled[(int)j]\
    \ > capacity) {\n                    total += (filled[(int)j] - capacity);\n \
    \                   filled[(int)j] = capacity;\n                }\n          \
    \      prev = filled[(int)j];\n            }\n        }\n        return total;",
  "        // Store the data from grid as a 2D array\n        long[,] data = new long[grid.Count,\
    \ grid[0].Count];\n        for (int i = 0; i < grid.Count; i++) {\n          \
    \  for (int j = 0; j < grid[i].Count; j++) {\n                data[i, j] = grid[i][j];\n\
    \            }\n        }\n        // Store the number of iterations\n       \
    \ long numOfIterations = 0;\n        // Get the number of rows and columns\n \
    \       int rows = data.GetLength(0);\n        int cols = data.GetLength(1);\n\
    \        // Start running the loop until we are done\n        while (true) {\n\
    \            // Initialize the lowest index, highest index, and found flag\n \
    \           int lowIndex = -1;\n            int highIndex = -1;\n            bool\
    \ found = false;\n            // Start looking for a row where we need to fill\
    \ water\n            for (int i = 0; i < rows; i++) {\n                // Initialize\
    \ the sum\n                long sum = 0;\n                // Start looping through\
    \ the columns\n                for (int j = 0; j < cols; j++) {\n            \
    \        // Break if there is a block of water\n                    if (data[i,\
    \ j] == 1) {\n                        break;\n                    }\n        \
    \            // If the row hasn't been filled yet\n                    if (data[i,\
    \ j] == 0) {\n                        // Increment the sum\n                 \
    \       sum++;\n                    }\n                }\n                // Check\
    \ if the sum is equal to the capacity\n                if (sum == capacity) {\n\
    \                    // Mark that we have found a row\n                    found\
    \ = true;\n                    // Check if the lowest index has been initialized\n\
    \                    if (lowIndex == -1) {\n                        // Initialize\
    \ the lowest index\n                        lowIndex = i;\n                  \
    \  }\n                    // Set the highest index\n                    highIndex\
    \ = i;\n                }\n            }\n            // Check if we have found\
    \ any rows to fill\n            if (found) {\n                // Increment the\
    \ number of iterations\n                numOfIterations++;\n                //\
    \ Fill the rows with water\n                for (int i = lowIndex; i <= highIndex;\
    \ i++) {\n                    for (int j", "        long totalWells = (long)grid.Count()\
    \ * (long)grid[0].Count();\n        long totalWater = 0;\n        long fillCount\
    \ = 0;\n        for (long row = 0; row < grid.Count(); row++) {\n            for\
    \ (long column = 0; column < grid[0].Count(); column++) {\n                totalWater\
    \ += grid[(int)row][(int)column];\n            }\n        }\n        long waterPerTrip\
    \ = (long)capacity * totalWells;\n        if (totalWater <= waterPerTrip) {\n\
    \            return 1;\n        }\n        fillCount = totalWater / waterPerTrip;\n\
    \        if (totalWater % waterPerTrip != 0) {\n            fillCount++;\n   \
    \     }\n        return fillCount;", "        long result = 0;\n        long rowIndex\
    \ = 0;\n        long rowLength = grid[0].Count;\n        long columnIndex = 0;\n\
    \        while (rowIndex < grid.Count) {\n            long needToFill = capacity;\n\
    \            if (grid[rowIndex][columnIndex] == 1) {\n                needToFill--;\n\
    \            }\n            if (needToFill == 0) {\n                columnIndex++;\n\
    \                if (columnIndex == rowLength) {\n                    columnIndex\
    \ = 0;\n                    rowIndex++;\n                }\n                continue;\n\
    \            }\n            long rowLengthToIterate = rowLength - columnIndex;\n\
    \            if (needToFill < rowLengthToIterate) {\n                rowLengthToIterate\
    \ = needToFill;\n            }\n            long columnToUse = columnIndex + rowLengthToIterate\
    \ - 1;\n            while (needToFill > 0) {\n                while (grid[rowIndex][columnToUse]\
    \ == 0) {\n                    columnToUse--;\n                }\n           \
    \     grid[rowIndex][columnToUse] = 0;\n                needToFill--;\n      \
    \      }\n            result++;\n            columnIndex = 0;\n            rowIndex++;\n\
    \        }\n        return result;", "        // your code here\n        return\
    \ 0;", '        return 0;', "        var max_depth = grid.Select(r => r.Sum()).Max();\n\
    \        var num_cols = grid[0].Count;\n        var res = 0L;\n        for (var\
    \ depth = 1; depth <= max_depth; depth++) {\n            var num_rows = grid.Count(r\
    \ => r.Sum() >= depth);\n            var num_buckets = num_rows * num_cols;\n\
    \            var num_buckets_used = num_buckets;\n            for (var r = 0;\
    \ r < grid.Count; r++) {\n                var row = grid[r];\n               \
    \ for (var c = 0; c < row.Count; c++) {\n                    if (row[c] >= depth)\
    \ {\n                        num_buckets_used--;\n                    }\n    \
    \            }\n            }\n            num_buckets_used = Math.Max(0, num_buckets_used);\n\
    \            res += num_buckets_used / capacity;\n            if (num_buckets_used\
    \ % capacity != 0) {\n                res++;\n            }\n        }\n     \
    \   return res;", "        var n = grid.Count;\n        var m = grid[0].Count;\n\
    \        var S = new long[n, m];\n        for (var i = 0; i < n; i++) {\n    \
    \        for (var j = 0; j < m; j++) {\n                S[i, j] = grid[i][j];\n\
    \            }\n        }\n        var moves = 0L;\n        while (true) {\n \
    \           var C = (long[,])S.Clone();\n            for (var i = 0; i < n; i++)\
    \ {\n                for (var j = 0; j < m; j++) {\n                    if (S[i,\
    \ j] == 0) {\n                        C[i, j] = 0;\n                    } else\
    \ {\n                        if (i == 0) {\n                            C[i, j]\
    \ = 0;\n                        } else {\n                            C[i, j]\
    \ = S[i - 1, j];\n                        }\n                    }\n         \
    \       }\n            }\n            var E = (long[,])S.Clone();\n          \
    \  for (var i = 0; i < n; i++) {\n                for (var j = 0; j < m; j++)\
    \ {\n                    E[i, j] = Math.Min(C[i, j], S[i, j]);\n             \
    \   }\n            }\n            if (E.Cast<long>().Sum() == 0) {\n         \
    \       break;\n            }\n            for (var i = 0; i < n; i++) {\n   \
    \             for (var j = 0; j < m; j++) {\n                    S[i, j] -= E[i,\
    \ j];\n                }\n            }\n            moves += 1;\n        }\n\
    \        return moves;", '        throw new NotImplementedException();', "   \
    \     // Your code here.\n        return 0;", "        long res = 0;\n       \
    \ List<List<long>> gridCopy = new List<List<long>>();\n        foreach (List<long>\
    \ r in grid) {\n            gridCopy.Add(new List<long>(r));\n        }\n    \
    \    List<long> bucket = new List<long>();\n        for (long i = 0; i < grid[0].Count;\
    \ i++) {\n            bucket.Add(capacity);\n        }\n        for (long i =\
    \ 0; i < grid.Count; i++) {\n            for (long j = 0; j < grid[i].Count; j++)\
    \ {\n                if (grid[i][j] == 1) {\n                    grid[i][j] =\
    \ 0;\n                    bucket[j] -= 1;\n                    res += 1;\n   \
    \             }\n            }\n            List<long> newBucket = new List<long>();\n\
    \            for (long j = 0; j < grid[i].Count; j++) {\n                newBucket.Add(bucket[j]);\n\
    \            }\n            for (long j = 0; j < grid[i].Count; j++) {\n     \
    \           if (gridCopy[i][j] == 1) {\n                    newBucket[j] -= 1;\n\
    \                    res += 1;\n                }\n            }\n           \
    \ bucket = newBucket;\n        }\n        return res;", "        var max = 0L;\n\
    \        for (var i = 0; i < grid.Count; i++) {\n            max = Math.Max(max,\
    \ grid[i].Count);\n        }\n        var buckets = new List<List<long>>();\n\
    \        for (var i = 0; i < grid.Count; i++) {\n            buckets.Add(new List<long>());\n\
    \            for (var j = 0; j < max; j++) {\n                buckets[i].Add(0);\n\
    \            }\n        }\n        var count = 0L;\n        while (true) {\n \
    \           var found = false;\n            for (var i = 0; i < grid.Count; i++)\
    \ {\n                for (var j = 0; j < grid[i].Count; j++) {\n             \
    \       if (grid[i][j] == 1) {\n                        found = true;\n      \
    \                  count++;\n                        Fill(buckets, grid, i, j,\
    \ capacity);\n                    }\n                }\n            }\n      \
    \      if (!found) {\n                break;\n            }\n        }\n     \
    \   return count;", "        long sum = 0;\n        long last_sum = 0;\n     \
    \   long[] row_min = new long[grid.Count];\n        long[] row_max = new long[grid.Count];\n\
    \        while (true) {\n            sum = 0;\n            long count = 0;\n \
    \           for (int row = 0; row < grid.Count; row++) {\n                row_min[row]\
    \ = long.MaxValue;\n                row_max[row] = long.MinValue;\n          \
    \      for (int col = 0; col < grid[row].Count; col++) {\n                   \
    \ if (grid[row][col] == 1) {\n                        row_min[row] = Math.Min(row_min[row],\
    \ col);\n                        row_max[row] = Math.Max(row_max[row], col);\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n            if (count == 0) {\n                break;\n      \
    \      }\n            for (int row = 0; row < grid.Count; row++) {\n         \
    \       int col = (int)row_min[row];\n                while (col <= row_max[row])\
    \ {\n                    if (col - row_min[row] >= capacity) {\n             \
    \           break;\n                    }\n                    if (grid[row][col]\
    \ == 1) {\n                        sum++;\n                        grid[row][col]\
    \ = 0;\n                    }\n                    col++;\n                }\n\
    \            }\n            if (sum == last_sum) {\n                // deadlocked\n\
    \                return -1;\n            }\n            last_sum = sum;\n    \
    \    }\n        return sum;", "        int n = grid.Count;\n        int m = grid[0].Count;\n\
    \        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n        \
    \            long need = capacity - (i + 1);\n                    long taken =\
    \ Math.Min(capacity, need);\n                    ans += taken;\n             \
    \       for (int k = 0; k < n; k++) {\n                        grid[k][j] = Math.Max(0,\
    \ grid[k][j] - taken);\n                    }\n                }\n           \
    \ }\n        }\n        return ans;", "        //\n        return 0;", "     \
    \   // your code here\n        throw new NotImplementedException();", "      \
    \  long maxFill = 0;\n        foreach (List<long> row in grid) {\n           \
    \ maxFill += MaxFillRow(row, capacity);\n        }\n        return maxFill;",
  "        long numRows = grid.Count;\n        long numCols = grid[0].Count;\n   \
    \     long[,] sGrid = new long[numRows, numCols];\n        for (long r=0; r<numRows;\
    \ r++) {\n            for (long c=0; c<numCols; c++) {\n                sGrid[r,c]\
    \ = grid[(int)r][(int)c];\n            }\n        }\n        long needed = 0;\n\
    \        for (long r=0; r<numRows; r++) {\n            long sum = 0;\n       \
    \     for (long c=0; c<numCols; c++) {\n                sum += sGrid[r,c];\n \
    \           }\n            if (sum < numCols) {\n                needed++;\n \
    \           }\n        }\n        long result = needed * capacity;\n        return\
    \ result;", "        long result = 0;\n        if (grid == null || grid.Count\
    \ == 0) {\n            return result;\n        }\n        // Only need to record\
    \ the water levels.\n        List<long> levels = new List<long>();\n        long\
    \ water = 0;\n        // For each well, fill up the buckets\n        foreach (List<long>\
    \ well in grid) {\n            long i = 0;\n            while (i < well.Count)\
    \ {\n                // If the bucket is filled, stop\n                if (water\
    \ == capacity) {\n                    break;\n                }\n            \
    \    // If the current well has water, fill up the bucket\n                if\
    \ (well[(int)i] == 1) {\n                    water++;\n                }\n   \
    \             i++;\n            }\n            // If the bucket is not empty,\
    \ then add to the result\n            if (water > 0) {\n                levels.Add(water);\n\
    \                result += water;\n                water = 0;\n            }\n\
    \        }\n        // Now, we need to drain the buckets down\n        int i1\
    \ = 0;\n        while (i1 < levels.Count) {\n            water = 0;\n        \
    \    // Drain the bucket, until it is empty\n            while (water < levels[i1])\
    \ {\n                long j = 0;\n                // Fill up the bucket first\n\
    \                while (j < grid[i1].Count) {\n                    if (water ==\
    \ capacity) {\n                        break;\n                    }\n       \
    \             if (grid[i1][(int)j] == 1) {\n                        water++;\n\
    \                    }\n                    j++;\n                }\n        \
    \        // Now drain the bucket\n                j = 0;\n                while\
    \ (j < grid[i1].Count) {\n                    if (water == 0) {\n            \
    \            break;\n                    }\n                    if (grid[i1][(int)j]\
    \ == 1) {\n                        water--;\n                    }\n         \
    \           j++;\n                }\n                result++;\n            }\n\
    \            i1++;\n        }\n        return result;", "        // BEGIN SOLUTION\n\
    \        long wells = 0;\n        long rows = grid.Count;\n        long cols =\
    \ grid[0].Count;\n        long[] max_per_col = new long[cols];\n        for (long\
    \ c = 0; c < cols; c++) {\n            max_per_col[c] = 0;\n            for (long\
    \ r = 0; r < rows; r++) {\n                if (grid[r][c] > max_per_col[c]) {\n\
    \                    max_per_col[c] = grid[r][c];\n                }\n       \
    \     }\n        }\n        long units = 0;\n        while (true) {\n        \
    \    long[] lowest_per_col = new long[cols];\n            long lowest = long.MaxValue;\n\
    \            for (long c = 0; c < cols; c++) {\n                lowest_per_col[c]\
    \ = long.MaxValue;\n                for (long r = 0; r < rows; r++) {\n      \
    \              if (grid[r][c] > 0 && grid[r][c] < lowest_per_col[c]) {\n     \
    \                   lowest_per_col[c] = grid[r][c];\n                    }\n \
    \               }\n                if (lowest_per_col[c] < lowest) {\n       \
    \             lowest = lowest_per_col[c];\n                }\n            }\n\
    \            if (lowest > 0) {\n                for (long c = 0; c < cols; c++)\
    \ {\n                    if (lowest_per_col[c] == lowest) {\n                \
    \        wells++;\n                        units += lowest;\n                \
    \        for (long r = 0; r < rows; r++) {\n                            grid[r][c]\
    \ -= lowest;\n                        }\n                    }\n             \
    \   }\n            } else {\n                break;\n            }\n        }\n\
    \        for (long c = 0; c < cols; c++) {\n            for (long r = 0; r < rows;\
    \ r++) {\n                if (grid[r][c] > 0) {\n                    wells++;\n\
    \                    units += grid[r][c];\n                }\n            }\n\
    \        }\n        return wells * capacity - units;\n        // END SOLUTION\n\
    \   ", '        return Enumerable.Range(0, grid.Count()).Select(i => Enumerable.Range(0,
    grid[i].Count()).Select(j => new { i, j }).Where(p => grid[p.i][p.j] == 1).Select(p
    => new { p.i, p.j, H = grid.Select(r => r[p.j]).Take(p.i).Sum() }).Aggregate(0L,
    (count, p) => count + (long)Math.Ceiling((double)(capacity - p.H) / capacity))).Sum();',
  "        // fill every well that has a 1\n        int numTotalOnes = 0;\n      \
    \  foreach (List<long> row in grid) {\n            numTotalOnes += row.Count(x\
    \ => x == 1);\n        }\n        // grid is uniformly full:\n        if (numTotalOnes\
    \ == grid.Count * grid[0].Count) {\n            return 0;\n        }\n       \
    \ // number of well fillings:\n        long numFillings = 0;\n        long numWellsFilled\
    \ = 0;\n        int numWells = grid.Count;\n        int width = grid[0].Count;\n\
    \        // re-fill wells until all wells are full\n        while (numWellsFilled\
    \ < numWells) {\n            // scan the rows top to bottom and fill first well\
    \ that hasn't been filled\n            foreach (List<long> row in grid) {\n  \
    \              int i = grid.IndexOf(row);\n                if (row.Any(x => x\
    \ == 1)) {\n                    // fill the well:\n                    numFillings++;\n\
    \                    // fill the well\n                    grid[i] = new List<long>(new\
    \ long[width]);\n                    numWellsFilled++;\n                }\n  \
    \          }\n        }\n        // number of times the buckets need to be lowered\
    \ is the number of fillings\n        return numFillings;", '        return 0;',
  "        // Your code goes here.\n        return 0;", "        long r = 0;\n   \
    \     var wells_length = grid[0].Count;\n        var max_col_sum = new long[wells_length];\n\
    \        for (var i = 0; i < wells_length; i++) {\n            var col_sum = 0;\n\
    \            for (var j = 0; j < grid.Count; j++) {\n                if (grid[j][i]\
    \ == 1) {\n                    col_sum++;\n                }\n            }\n\
    \            max_col_sum[i] = col_sum;\n        }\n        var max_col_sum_sorted\
    \ = max_col_sum.ToList();\n        max_col_sum_sorted.Sort();\n        var max_col_sum_sorted_length\
    \ = max_col_sum_sorted.Count;\n        for (var i = 0; i < max_col_sum_sorted_length;\
    \ i++) {\n            var idx = Array.IndexOf(max_col_sum, max_col_sum_sorted[i]);\n\
    \            for (var j = 0; j < max_col_sum_sorted[i]; j++) {\n             \
    \   for (var k = 0; k < capacity; k++) {\n                    for (var m = 0;\
    \ m < grid.Count; m++) {\n                        if (grid[m][idx] == 1) {\n \
    \                           grid[m][idx] = 0;\n                            r++;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n        return r;", "        var wells = grid.Select(x =>\
    \ x.Select(y => (int)y).ToArray()).ToArray();\n        var checkFilled = wells.Select(x\
    \ => x.Sum()).ToArray();\n        var filled = new bool[wells.Length];\n     \
    \   int rounds = 0;\n        while (checkFilled.Any(x => x > 0)) {\n         \
    \   for (int i = 0; i < wells.Length; i++) {\n                if (filled[i]) continue;\n\
    \                for (int j = 0; j < wells[i].Length; j++) {\n               \
    \     if (checkFilled[i] <= 0) {\n                        filled[i] = true;\n\
    \                        break;\n                    }\n                    if\
    \ (wells[i][j] > 0) {\n                        wells[i][j] = 0;\n            \
    \            checkFilled[i]--;\n                    }\n                }\n   \
    \         }\n            rounds++;\n        }\n        return rounds;", "    \
    \    long i = 0;\n        for (i = 0; i < grid.Count; i += 1) {\n            for\
    \ (long j = 0; j < grid[(int)i].Count; j += 1) {\n                grid[(int)i][(int)j]\
    \ = grid[(int)i][(int)j] * capacity;\n            }\n        }\n        long ans\
    \ = 0;\n        for (i = 0; i < grid.Count; i += 1) {\n            for (long j\
    \ = 0; j < grid[(int)i].Count; j += 1) {\n                if (grid[(int)i][(int)j]\
    \ == 0) {\n                    continue;\n                }\n                if\
    \ (i > 0) {\n                    if (grid[(int)i - 1][(int)j] > 0) {\n       \
    \                 long diff = Math.Min(grid[(int)i][(int)j], grid[(int)i - 1][(int)j]);\n\
    \                        grid[(int)i][(int)j] -= diff;\n                     \
    \   grid[(int)i - 1][(int)j] -= diff;\n                        ans += diff;\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (grid[(int)i][(int)j - 1] > 0) {\n                       \
    \ long diff = Math.Min(grid[(int)i][(int)j], grid[(int)i][(int)j - 1]);\n    \
    \                    grid[(int)i][(int)j] -= diff;\n                        grid[(int)i][(int)j\
    \ - 1] -= diff;\n                        ans += diff;\n                    }\n\
    \                }\n            }\n        }\n        return ans;", "        return\
    \ Enumerable.Range(0, (int)grid.Count).Select(i => Enumerable.Range(0, (int)grid[i].Count).Select(j\
    \ => new {\n            i = i,\n            j = j,\n            c = grid[i][j]\n\
    \        }).Aggregate((long)0L, (acc, x) => acc + x.c)).Aggregate((long)0L, (acc,\
    \ x) => acc + x / capacity) + grid.Aggregate((long)0L, (acc, x) => acc + x.Min());",
  "        // Implement your solution here\n        return 0;", "        long ret\
    \ = 0;\n        long k = 0;\n        return ret;", "        long output = 0;\n\
    \        if (grid.Count == 0) return output;\n        long row_count = grid.Count;\n\
    \        long col_count = grid[0].Count;\n        long well_count = row_count*col_count;\n\
    \        for (int i = 0; i < grid.Count; i++) {\n            for (int j = 0; j\
    \ < grid[i].Count; j++) {\n                grid[i][j] = (grid[i][j] == 1) ? capacity\
    \ : 0;\n            }\n        }\n        //Console.WriteLine(\"Initial well:\
    \ \");\n        //print_grid(grid);\n        while (grid[row_count-1][col_count-1]\
    \ < capacity) {\n            //Console.WriteLine(\"----------------------------------------\"\
    );\n            for (int i = 0; i < row_count; i++) {\n                for (int\
    \ j = 0; j < col_count; j++) {\n                    if (grid[i][j] > 0) {\n  \
    \                      //Console.WriteLine(\"Found well at \" + i + \",\" + j);\n\
    \                        grid[i][j]--;\n                        if (i < row_count-1)\
    \ {\n                            grid[i+1][j]++;\n                        }\n\
    \                        if (j < col_count-1) {\n                            grid[i][j+1]++;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            //Console.WriteLine(\"Filled grid: \");\n            //print_grid(grid);\n\
    \            output++;\n        }\n        return output;", '        throw new
    NotImplementedException();', "        // your code goes here\n        return -1;",
  "        if (capacity > grid.Count) capacity = grid.Count;\n        if (capacity\
    \ < 1) return 0;\n        long num_fills = 0;\n        for (long j = 0; j < grid[0].Count;\
    \ j++) {\n            for (long i = 0; i < grid.Count; i++) {\n              \
    \  if (grid[(int)i][(int)j] == 1) {\n                    num_fills += 1;\n   \
    \                 // move i down\n                    long bucket_move_distance\
    \ = Math.Min(capacity, grid.Count - i);\n                    i += bucket_move_distance;\n\
    \                    i -= 1;\n                }\n            }\n        }\n  \
    \      return num_fills;", '        return -1;', "        long totalWater = 0;\n\
    \        long bucketFill = 0;\n        for (int i = 0; i < grid.Count; i++) {\n\
    \            for (int j = 0; j < grid[i].Count; j++) {\n                totalWater\
    \ += grid[i][j];\n            }\n        }\n        foreach (var well in grid)\
    \ {\n            bucketFill += well.Count(x => x == 1);\n        }\n        bucketFill\
    \ = totalWater / capacity;\n        return bucketFill;", "        var freeWater\
    \ = 0L;\n        var waterLevel = 0L;\n        var didFill = true;\n        while\
    \ (didFill) {\n            didFill = false;\n            for (var i = 0; i < grid.Count;\
    \ i++) {\n                var row = grid[i];\n                for (var j = 0;\
    \ j < row.Count; j++) {\n                    var cell = row[j];\n            \
    \        if (cell > waterLevel) {\n                        var needed = cell -\
    \ waterLevel;\n                        if (freeWater >= needed) {\n          \
    \                  freeWater -= needed;\n                            didFill =\
    \ true;\n                        } else {\n                            return\
    \ -1;\n                        }\n                    }\n                }\n \
    \           }\n            if (didFill) {\n                waterLevel++;\n   \
    \             freeWater += capacity;\n            }\n        }\n        return\
    \ waterLevel;", "        // <summary>\n        // Returns the maximum number of\
    \ buckets of water that can be filled from the wells.\n        // </summary>\n\
    \        // <param name=\"grid\"> The grid representing the wells, with each 1\
    \ representing a unit of water. </param>\n        // <param name=\"capacity\"\
    > The capacity of the buckets. </param>\n        // <returns> The maximum number\
    \ of buckets of water that can be filled from the wells. </returns>\n        Func<List<List<long>>,\
    \ List<long>> columnSums = null;\n        columnSums = (List<List<long>> listOfLists)\
    \ => {\n            // <summary>\n            // Returns the list of sums over\
    \ the columns of the input, where each element of the output is the sum over all\
    \ elements in a single column.\n            // </summary>\n            // <param\
    \ name=\"listOfLists\"> The input list. </param>\n            // <returns> The\
    \ list of sums over the columns of the input. </returns>\n            long column_count\
    \ = ((long)listOfLists.Count);\n            if (column_count <= 0L) {\n      \
    \          return ((List<long>)new List<long>());\n            }\n           \
    \ else {\n                List<long> column_sums = ((List<long>)new List<long>());\n\
    \                foreach (List<long> column in ((IEnumerable<List<long>>)listOfLists.First()).Zip(((IEnumerable<List<long>>)listOfLists.Skip(1)),\
    \ (Func<List<long>, List<long>, List<long>>)((first, second) => {\n          \
    \          return ((List<long>)first.Zip(second, (Func<long, long, long>)((first_item,\
    \ second_item) => {\n                        return ((long)(first_item + second_item));\n\
    \                    })).ToList());\n                }))) {\n                \
    \    column_sums.Add(((long)column.Sum()));\n                }\n             \
    \   return (column_sums);\n            }\n        };\n        Func<List<long>,\
    \ Tuple<long, long>> firstAndLastNonzero = null;\n        firstAndLastNonzero\
    \ = (List<long> list) =>", "        long v = 0;\n        long z = 0;\n       \
    \ // Fill in implementation here\n        for (int i = 0; i < grid.Count; i++)\
    \ {\n            for (int j = 0; j < grid[i].Count; j++) {\n                if\
    \ (grid[i][j] == 1) {\n                    v += 1;\n                }\n      \
    \      }\n            if (grid[i].Count % capacity == 0) {\n                z\
    \ += grid[i].Count / capacity;\n            } else {\n                z += (grid[i].Count\
    \ / capacity) + 1;\n            }\n        }\n        return z + v;", "      \
    \  int r = grid.Count;\n        int c = grid[0].Count;\n        int count = 0;\n\
    \        //int[,] dp = new int[r, c];\n        List<int> lowest = new List<int>();\n\
    \        //for (int i = 0; i < r; i++) {\n        //    for (int j = 0; j < c;\
    \ j++) {\n        //        // if we want to include this element\n        //\
    \        if (grid[i][j] == 1) {\n        //            // set the lowest element\
    \ that we can use for this cell\n        //            // equal to max of all\
    \ the elements before it\n        //            int max = 0;\n        //     \
    \       for (int k = 0; k < i; k++) {\n        //                for (int m =\
    \ 0; m < c; m++) {\n        //                    max = Math.Max(max, dp[k, m]);\n\
    \        //                }\n        //            }\n        //            dp[i,\
    \ j] = max + 1;\n        //        }\n        //    }\n        //}\n        //for\
    \ (int i = 0; i < r; i++) {\n        //    for (int j = 0; j < c; j++) {\n   \
    \     //        // if we want to include this element\n        //        if (grid[i][j]\
    \ == 1) {\n        //            // set the lowest element that we can use for\
    \ this cell\n        //            // equal to max of all the elements before\
    \ it\n        //            int max = 0;\n        //            for (int k = 0;\
    \ k < i; k++) {\n        //                for (int m = 0; m < c; m++) {\n   \
    \     //                    max = Math.Max(max, dp[k, m]);\n        //       \
    \         }\n        //            }\n        //            dp[i, j] = max + 1;\n\
    \        //        }\n        //    }\n        //}\n        for (int i = 0; i\
    \ < r; i++) {\n            for (int j = 0; j < c; j++) {\n                // if\
    \ we want to include this element\n                if (grid[i][j] == 1) {\n  \
    \                  lowest.", "        // O(N) time, O(1) space (excluding the\
    \ output)\n        long numFills = 0;\n        // if the first row is full, we\
    \ can just fill that row and not need to change anything else\n        if (grid[0].Sum()\
    \ == grid[0].Count) {\n            numFills += capacity;\n        } else {\n \
    \           // next we look at the first row, and the full rows below it\n   \
    \         for (int col = 0; col < grid[0].Count; col++) {\n                //\
    \ the number of rows we have to fill\n                int numRowsToFill = 0;\n\
    \                for (int row = 0; row < grid.Count; row++) {\n              \
    \      if (grid[row][col] == 1) {\n                        numRowsToFill++;\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n                // if we have any rows to fill, we\
    \ fill that column\n                if (numRowsToFill > 0) {\n               \
    \     numFills += capacity;\n                    // now, we need to check what\
    \ we should do with this column and the columns to the right of it\n         \
    \           // if we want to fill the first row, we can, and just fill it\n  \
    \                  if (grid[0][col] == 0) {\n                        for (int\
    \ row = 0; row < grid.Count; row++) {\n                            if (grid[row][col]\
    \ == 1) {\n                                numFills++;\n                     \
    \       } else {\n                                break;\n                   \
    \         }\n                        }\n                    }\n              \
    \      // we can no longer fill the first row, so we just move on\n          \
    \          // repeat for the remaining columns\n                    for (int colToFill\
    \ = col + 1; colToFill < grid[0].Count; colToFill++) {\n                     \
    \   if (grid[0][colToFill] == 0) {\n                            for (int row =\
    \ 0; row < grid.Count; row++) {\n                                if (grid[row][colToFill]\
    \ == 1) {\n                                    numFills++;\n                 \
    \               } else {\n                                    break;\n       \
    \                         }\n                            }\n                 \
    \       }\n                    }\n                }\n            }\n        }\n\
    \        return numFills;", "        // your code goes here\n        return 0;",
  "        // this solution is essentially the same as mine,\n        // the only\
    \ difference is the use of sum and gcd\n        // which does make it slightly\
    \ shorter but would\n        // not have occurred to me\n        long sum = 0;\n\
    \        foreach (var row in grid) {\n            sum += row.Count(x => x == 1);\n\
    \        }\n        return sum - grid.Count * BigInteger.GreatestCommonDivisor(sum,\
    \ grid.Count);", "        long answer = 0;\n        // Your answer here!\n   \
    \     return answer;", "        long sum = 0;\n        for (long i = 0; i < grid.Count;\
    \ i++) {\n            for (long j = 0; j < grid[(int)i].Count; j++) {\n      \
    \          if (grid[(int)i][(int)j] == 1) {\n                    sum++;\n    \
    \            }\n            }\n        }\n        return sum / capacity + (sum\
    \ % capacity == 0 ? 0 : 1);", "        long well_height = (long)grid.Count;\n\
    \        long well_width = (long)grid[0].Count;\n        long max_fill = 0;\n\
    \        var bucket = new List<long>((int)well_width);\n        for (long i =\
    \ 0; i < well_width; i++) {\n            bucket.Add(0);\n        }\n        for\
    \ (long i = 0; i < well_height; i++) {\n            var fill = 0;\n          \
    \  for (long j = 0; j < well_width; j++) {\n                if (grid[(int)i][(int)j]\
    \ == 0) {\n                    bucket[(int)j] = Math.Min(bucket[(int)j] + 1, capacity);\n\
    \                } else {\n                    fill = Math.Max(fill, bucket[(int)j]);\n\
    \                    bucket[(int)j] = 0;\n                }\n            }\n \
    \           max_fill += fill;\n        }\n        return max_fill;", '        throw
    new NotImplementedException();', "        // your code here\n        return 0;",
  '        return 0;', "        var h = grid.Count;\n        var w = grid[0].Count;\n\
    \        var q = new Queue<long>();\n        var ret = 0L;\n        for (var i\
    \ = 0; i < h; i++) {\n            for (var j = 0; j < w; j++) {\n            \
    \    var v = grid[i][j];\n                if (v == 0) {\n                    q.Enqueue(capacity);\n\
    \                } else {\n                    ret += capacity - v;\n        \
    \            q.Enqueue(v);\n                }\n            }\n        }\n    \
    \    while (q.Count > 0) {\n            var v = q.Dequeue();\n            if (v\
    \ == capacity) {\n                ret += capacity;\n            } else {\n   \
    \             q.Enqueue(v + 1);\n            }\n        }\n        return ret;",
  '        return 0;', '        throw new NotImplementedException();', "        //\
    \ fill the buckets\n        long res = 0;\n        for (int i = 0; i < grid.Count;\
    \ i++) {\n            long val = capacity;\n            for (int j = 0; j < grid[i].Count;\
    \ j++) {\n                long cnt = grid[i][j];\n                if (cnt == 0)\
    \ continue;\n                if (val == 0) {\n                    res++;\n   \
    \                 val = capacity;\n                }\n                if (val\
    \ >= cnt) {\n                    val -= cnt;\n                } else {\n     \
    \               grid[i][j] -= val;\n                    val = 0;\n           \
    \     }\n            }\n            if (val < capacity) res++;\n        }\n  \
    \      // dump the buckets to wells\n        for (int j = 0; j < grid[0].Count;\
    \ j++) {\n            long val = capacity;\n            for (int i = 0; i < grid.Count;\
    \ i++) {\n                long cnt = grid[i][j];\n                if (cnt == 0)\
    \ continue;\n                if (val == 0) {\n                    res++;\n   \
    \                 val = capacity;\n                }\n                if (val\
    \ >= cnt) {\n                    val -= cnt;\n                } else {\n     \
    \               grid[i][j] -= val;\n                    val = 0;\n           \
    \     }\n            }\n            if (val < capacity) res++;\n        }\n  \
    \      return res;", "        long n = grid.Count;\n        long m = grid[0].Count;\n\
    \        long lower = 1;\n        long upper = (n + 1) * (m + 1);\n        while\
    \ (lower != upper) {\n            long mid = (lower + upper) / 2;\n          \
    \  if (IsPossible(grid, mid, capacity)) {\n                upper = mid;\n    \
    \        } else {\n                lower = mid + 1;\n            }\n        }\n\
    \        return lower;", "        long __ret = 0;\n        // these lists contain\
    \ the y-values of each cell per x-value\n        List<List<long>> filled = new\
    \ List<List<long>>();\n        List<List<long>> empty = new List<List<long>>();\n\
    \        long x = 0;\n        // fill the lists\n        foreach (List<long> row\
    \ in grid) {\n            empty.Add(new List<long>());\n            filled.Add(new\
    \ List<long>());\n            foreach (long cell in row) {\n                if\
    \ (cell == 1) {\n                    filled[x].Add(row.IndexOf(cell));\n     \
    \           } else {\n                    empty[x].Add(row.IndexOf(cell));\n \
    \               }\n            }\n            x++;\n        }\n        // initialize\
    \ \n        long columns = empty.Count;\n        long rows = empty[0].Count;\n\
    \        long[,] water = new long[columns, rows];\n        // determine how much\
    \ water there is in each empty cell\n        for (long j = 0; j < rows; j++) {\n\
    \            long count = 0;\n            foreach (List<long> well in filled)\
    \ {\n                if (well.Contains(j)) {\n                    count++;\n \
    \               }\n            }\n            for (long i = 0; i < columns; i++)\
    \ {\n                water[i, j] = count;\n            }\n        }\n        //\
    \ fill the buckets\n        while (water[0, 0] > 0) {\n            // fill each\
    \ column\n            for (long i = 0; i < columns; i++) {\n                //\
    \ fill each row in the column\n                for (long j = 0; j < rows; j++)\
    \ {\n                    // fill the cell with a bucket if it's not full\n   \
    \                 if (water[i, j] > 0) {\n                        water[i, j]\
    \ -= capacity;\n                        __ret++;\n                    }\n    \
    \            }\n            }\n        }\n        return __ret;", "        //\
    \ your code here\n        return 0;", '        return 0;', "        long counter\
    \ = 0;\n        long[] sizes = new long[grid.Count];\n        long max = 0;\n\
    \        for (int i = 0; i < grid.Count; i++) {\n            sizes[i] = grid[i].Count(x\
    \ => x == 1);\n            max = Math.Max(max, sizes[i]);\n        }\n       \
    \ while (max > 0) {\n            counter += grid.Count;\n            max -= capacity;\n\
    \        }\n        return counter;", "        var width = grid[0].Count;\n  \
    \      var height = grid.Count;\n        var water = 0L;\n        for (var y =\
    \ 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n     \
    \           water += grid[y][x];\n            }\n        }\n        var size =\
    \ water / capacity;\n        if (water % capacity != 0) {\n            size++;\n\
    \        }\n        return size;", "        // TODO!\n        return 0;", "  \
    \      long sum = 0;\n        for (int i = 0; i < grid.Count; i++) {\n       \
    \     for (int j = 0; j < grid[i].Count; j++) {\n                if (grid[i][j]\
    \ == 1) {\n                    if (capacity == 1) {\n                        //\
    \ only one unit of water in the well and bucket capacity is 1\n              \
    \          sum++;\n                    } else {\n                        // bucket\
    \ capacity is larger than one and the bucket can be reused\n                 \
    \       sum++;\n                        j += capacity - 1;\n                 \
    \   }\n                }\n            }\n        }\n        return sum;", "  \
    \      // your code goes here\n        return 0;", "        long[][] gridarr =\
    \ grid.Select(x => x.ToArray()).ToArray();\n        var solver = new MaxFillSolver(gridarr,\
    \ capacity);\n        solver.Solve();\n        return solver.Solution;", "   \
    \     long count = 0;\n        bool flag = true;\n        while (flag) {\n   \
    \         flag = false;\n            for (long i = 0; i < grid.Count; i++) {\n\
    \                var row = grid[(int)i];\n                for (long j = 0; j <\
    \ row.Count; j++) {\n                    if (row[(int)j] != 0) {\n           \
    \             flag = true;\n                        row[(int)j] = 0;\n       \
    \                 for (long k = j + 1; k < row.Count; k++) {\n               \
    \             if (row[(int)k] != 0) {\n                                row[(int)k]--;\n\
    \                            }\n                        }\n                  \
    \      count++;\n                    }\n                }\n            }\n   \
    \     }\n        return count;", "        var rows = grid.Count;\n        var\
    \ cols = grid[0].Count;\n        var max = 0L;\n        for (int i = 0; i < rows;\
    \ i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j]\
    \ == 1) {\n                    max += capacity;\n                }\n         \
    \   }\n        }\n        return max;", "        // your code here\n        long\
    \ maxCol = 0;\n        long numRows = grid.Count;\n        if (numRows > 0) {\n\
    \            long numCols = grid[0].Count;\n            for (long col = 0; col\
    \ < numCols; col++) {\n                long fill = 0;\n                for (long\
    \ row = 0; row < numRows; row++) {\n                    if (grid[(int)row][(int)col]\
    \ == 1) {\n                        fill++;\n                    }\n          \
    \      }\n                maxCol = Math.Max(maxCol, Math.Min(fill, capacity));\n\
    \            }\n        }\n        return maxCol;", "        // Your code goes\
    \ here.\n        return -1;", '        return new NumberTheory(grid, capacity).MaxFill();',
  "        // Implement your solution here\n        throw new NotImplementedException();",
  "        // your code goes here\n        return 0;", "        // input:\n      \
    \  //   grid:      long[][]\n        //   capacity:  long\n        // output:\n\
    \        //   long\n        //         0\n        // ----------\n        // :\
    \   :   :\n        // 0   1   0\n        // ----------\n        // :   :   :\n\
    \        // 0   1   0\n        // ----------\n        // :   :   :\n        //\
    \ 1   1   1\n        // ----------\n        // The grid was created by:\n    \
    \    //      List<List<long>> grid = (new List<List<long>>(new List<long>[]{\n\
    \        //          (List<long>)new List<long>(new long[]{(long)0L, (long)0L,\
    \ (long)1L, (long)0L}),\n        //          (List<long>)new List<long>(new long[]{(long)0L,\
    \ (long)1L, (long)0L, (long)0L}),\n        //          (List<long>)new List<long>(new\
    \ long[]{(long)1L, (long)1L, (long)1L, (long)1L})\n        //      }));\n    \
    \    //\n        // Answer is 6.\n        // To get there, you need to lower bucket\
    \ twice to the first well, and then once for each of the other wells.\n      \
    \  //\n        // Every bucket has a capacity of 1.\n        //\n        // The\
    \ grid was created by:\n        //      List<List<long>> grid = (new List<List<long>>(new\
    \ List<long>[]{\n        //          (List<long>)new List<long>(new long[]{(long)0L,\
    \ (long)0L, (long)1L, (long)1L}),\n        //          (List<long>)new List<long>(new\
    \ long[]{(long)0L, (long)0L, (long)0L, (long)0L}),\n        //          (List<long>)new\
    \ List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}),\n        //\
    \          (List<long>)new List<long", "        if (grid.Count == 0) {\n     \
    \       return 0;\n        }\n        var matrix = new long[grid.Count, grid[0].Count];\n\
    \        for (int i = 0; i < grid.Count; i++) {\n            for (int j = 0; j\
    \ < grid[i].Count; j++) {\n                matrix[i, j] = grid[i][j];\n      \
    \      }\n        }\n        var maxFill = 0;\n        while (true) {\n      \
    \      var fill = MaxFill(matrix, capacity);\n            if (fill == 0) {\n \
    \               break;\n            }\n            maxFill += fill;\n        }\n\
    \        return maxFill;", "        long res = 0;\n        long rowLen = grid[0].Count;\n\
    \        long colLen = grid.Count;\n        for (long i = 0; i < rowLen; i++)\
    \ {\n            for (long j = 0; j < colLen; j++) {\n                long well\
    \ = grid[(int)j][(int)i];\n                long diff = capacity - well;\n    \
    \            if (diff > 0) {\n                    res += diff;\n             \
    \       for (long k = j + 1; k < colLen; k++) {\n                        grid[(int)k][(int)i]\
    \ = Math.Min(capacity, grid[(int)k][(int)i] + diff);\n                    }\n\
    \                }\n            }\n        }\n        return res;", "        var\
    \ fillCount = 0L;\n        var rowCount = grid.Count;\n        var colCount =\
    \ grid[0].Count;\n        var dumpCol = 0;\n        var dumpRow = 0;\n       \
    \ foreach (var row in grid) {\n            var filled = row.Sum();\n         \
    \   if (filled >= capacity) {\n                if (filled > capacity) {\n    \
    \                throw new Exception(\"Filled > capacity\");\n               \
    \ }\n                dumpRow = fillCount;\n                break;\n          \
    \  }\n            fillCount += 1;\n        }\n        if (fillCount == rowCount)\
    \ {\n            foreach (var col in Enumerable.Range(0, colCount)) {\n      \
    \          var filled = grid.Sum(r => r[col]);\n                if (filled >=\
    \ capacity) {\n                    if (filled > capacity) {\n                \
    \        throw new Exception(\"Filled > capacity\");\n                    }\n\
    \                    dumpCol = fillCount;\n                    break;\n      \
    \          }\n                fillCount += 1;\n            }\n        }\n    \
    \    return fillCount;", "        var lengths = new List<int>();\n        var\
    \ height = grid.Count;\n        var width = grid[0].Count;\n        // sum the\
    \ heights of columns and collect lengths of rows\n        var total = 0;\n   \
    \     for (var i = 0; i < width; i++) {\n            var length = 0;\n       \
    \     for (var j = 0; j < height; j++) {\n                if (grid[j][i] > 0)\
    \ {\n                    length++;\n                    total++;\n           \
    \     }\n            }\n            lengths.Add(length);\n        }\n        //\
    \ if sum of lengths is less than capacity, return 0\n        if (total <= capacity)\
    \ {\n            return 0;\n        }\n        // init state\n        var times\
    \ = 0;\n        var lengthIndex = 0;\n        // each iteration corresponds to\
    \ one trip to fill and empty\n        while (true) {\n            // collect the\
    \ rows that have heights > 0\n            var rows = new List<int>();\n      \
    \      for (var i = 0; i < width; i++) {\n                if (lengths[i] > 0)\
    \ {\n                    rows.Add(i);\n                }\n            }\n    \
    \        // if there is no more rows, break\n            if (rows.Count == 0)\
    \ {\n                break;\n            }\n            // this is the row that\
    \ gets emptied next\n            lengthIndex = rows[0];\n            // fill the\
    \ bucket with the specified amount of water\n            var filled = 0;\n   \
    \         for (var i = 0; i < width; i++) {\n                if (grid[0][i] >\
    \ 0) {\n                    var amount = Math.Min(grid[0][i], capacity - filled);\n\
    \                    filled += amount;\n                    grid[0][i] -= amount;\n\
    \                    lengths[i]--;\n                }\n                if (filled\
    \ == capacity) {\n                    break;\n                }\n            }\n\
    \            times++;\n            // move the rows down\n            for (var\
    \ i = 1; i < height; i++) {\n                grid[i - 1] = grid[i];\n        \
    \    }\n            grid[height - 1] = new List<long>();\n            // create\
    \ new row of empty wells\n            for (var i = 0; i < width; i++) {", "  \
    \      long rows = grid.Count;\n        long cols = grid[0].Count;\n        long\
    \ result = 0;\n        for (long row = 0; row < rows; row++) {\n            for\
    \ (long col = 0; col < cols; col++) {\n                if (grid[(int)row][(int)col]\
    \ == 1) {\n                    for (long c = col; c < cols; c++) {\n         \
    \               result += grid[(int)row][(int)c];\n                        grid[(int)row][(int)c]\
    \ = 0;\n                    }\n                    result += capacity - 1;\n \
    \                   grid[(int)row][(int)col] = capacity;\n                }\n\
    \            }\n        }\n        return result;", "        if (grid.Count ==\
    \ 0) return 0;\n        long m = grid.Count;\n        long n = grid[0].Count;\n\
    \        long i;\n        long j;\n        long moves = 0;\n        long[,] gridD\
    \ = new long[m, n];\n        long[,] tmpD = new long[m, n];\n        for (i =\
    \ 0; i < m; i++) {\n            for (j = 0; j < n; j++) {\n                gridD[i,\
    \ j] = grid[(int)i][(int)j];\n            }\n        }\n        for (i = 0; i\
    \ < m; i++) {\n            for (j = 0; j < n; j++) {\n                tmpD[i,\
    \ j] = gridD[i, j];\n            }\n        }\n        long flow;\n        long\
    \ maxflow;\n        do {\n            moves += 1;\n            flow = 0;\n   \
    \         for (i = 0; i < m; i++) {\n                for (j = 0; j < n; j++) {\n\
    \                    gridD[i, j] = tmpD[i, j];\n                }\n          \
    \  }\n            for (i = 0; i < m; i++) {\n                for (j = 0; j < n;\
    \ j++) {\n                    if (gridD[i, j] == 1) {\n                      \
    \  maxflow = capacity;\n                        if (i > 0) {\n               \
    \             maxflow = Math.Min(maxflow, gridD[i - 1, j]);\n                \
    \        }\n                        if (i < m - 1) {\n                       \
    \     maxflow = Math.Min(maxflow, gridD[i + 1, j]);\n                        }\n\
    \                        if (j > 0) {\n                            maxflow = Math.Min(maxflow,\
    \ gridD[i, j - 1]);\n                        }\n                        if (j\
    \ < n - 1) {\n                            maxflow = Math.Min(maxflow, gridD[i,\
    \ j + 1]);\n                        }\n                        flow += maxflow;\n\
    \                        if (i > 0) {\n                            tmpD[i - 1,\
    \ j] -= maxflow;\n                        }\n                        if (i < m\
    \ - 1) {\n", '        throw new NotImplementedException();', "        long result\
    \ = 0;\n        if (grid.Count == 0) return result;\n        int rows = grid.Count;\n\
    \        int cols = grid[0].Count;\n        long[] wells = new long[cols];\n \
    \       for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols;\
    \ j++) {\n                wells[j] += grid[i][j];\n            }\n        }\n\
    \        long maxWell = wells.Max();\n        while (maxWell > 0) {\n        \
    \    long fill = 0;\n            foreach (long well in wells) {\n            \
    \    if (well > 0) {\n                    long amount = Math.Min(well, capacity);\n\
    \                    wells[fill] -= amount;\n                    fill++;\n   \
    \             }\n            }\n            result++;\n            maxWell = wells.Max();\n\
    \        }\n        return result;", "        // 0. Initialisation\n        int\
    \ rows = grid.Count;\n        int cols = grid[0].Count;\n        int[,] wells\
    \ = new int[rows, cols];\n        int[,] dp = new int[rows, cols];\n        for\
    \ (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n\
    \                wells[i, j] = (int)grid[i][j];\n            }\n        }\n  \
    \      // 1. DP\n        int maxDepth = 0;\n        for (int i = 0; i < rows;\
    \ i++) {\n            for (int j = 0; j < cols; j++) {\n                if (wells[i,\
    \ j] > 0) {\n                    dp[i, j] = 1;\n                    int maxRight\
    \ = j > 0 ? dp[i, j - 1] : 0;\n                    int maxBelow = i > 0 ? dp[i\
    \ - 1, j] : 0;\n                    int maxDiag = i > 0 && j > 0 ? dp[i - 1, j\
    \ - 1] : 0;\n                    int max = Math.Max(maxRight, Math.Max(maxBelow,\
    \ maxDiag));\n                    dp[i, j] += max;\n                    maxDepth\
    \ = Math.Max(maxDepth, dp[i, j]);\n                }\n            }\n        }\n\
    \        // 2. Get number of steps from maximum depth\n        int maxFill = maxDepth\
    \ / (int)capacity;\n        int maxFillRemainder = maxDepth % (int)capacity;\n\
    \        return maxFill + (maxFillRemainder > 0 ? 1 : 0);", "        long moves\
    \ = 0;\n        for (long x = 0; x < grid.Count; x++) {\n            long rowSum\
    \ = grid[(int)x].Sum();\n            if (rowSum > capacity) {\n              \
    \  List<long> empties = new List<long>();\n                for (long i = 0; i\
    \ < grid[(int)x].Count; i++) {\n                    if (grid[(int)x][(int)i] ==\
    \ 0) {\n                        empties.Add(i);\n                    }\n     \
    \           }\n                for (long j = 0; j < empties.Count; j++) {\n  \
    \                  grid[(int)x][(int)empties[(int)j]] = 1;\n                 \
    \   rowSum--;\n                    if (rowSum <= capacity) {\n               \
    \         break;\n                    }\n                }\n            }\n  \
    \          moves += rowSum;\n        }\n        return moves;", '        throw
    new NotImplementedException();', "        var rows = grid.Count;\n        var\
    \ cols = grid[0].Count;\n        var result = 0L;\n        for (var row = 0; row\
    \ < rows; row++) {\n            for (var col = 0; col < cols; col++) {\n     \
    \           if (grid[row][col] == 1) {\n                    var units = capacity;\n\
    \                    for (var cur_row = row; cur_row < rows && units > 0; cur_row++)\
    \ {\n                        if (grid[cur_row][col] == 1) {\n                \
    \            units -= 1;\n                            grid[cur_row][col] = 0;\n\
    \                        }\n                    }\n                    result\
    \ += capacity - units;\n                }\n            }\n        }\n        return\
    \ result;", "        // fill buckets\n        // take them to leftmost position\
    \ \n        // take the common factor between capacity and number of buckets\n\
    \        // take that amount from each column\n\n        // fill buckets\n   \
    \     var filledBuckets = new List<long>();\n        for (var i = 0; i < grid.Count;\
    \ i++) {\n            for (var j = 0; j < grid[i].Count; j++) {\n            \
    \    if (grid[i][j] == 1) {\n                    filledBuckets.Add(capacity);\n\
    \                }\n            }\n        }\n\n        var sumBuckets = filledBuckets.Sum();\n\
    \        var gcd = filledBuckets.Aggregate(FuncGcd);\n        var lcm = (filledBuckets.Aggregate(FuncLcm))\
    \ / capacity;\n        var result = sumBuckets / gcd;\n        return result +\
    \ filledBuckets.Count;", "        return Enumerable.Range(0, grid.Count).Sum(\n\
    \            row => Enumerable.Range(0, grid[row].Count).Sum(\n              \
    \  col => (long)Math.Ceiling((double)grid[row][col] / capacity)\n            )\n\
    \        );", "        // Your code goes here.\n        return 0;", "        //\
    \ Fill in the code to solve the problem\n        long[,] grid2 = new long[grid.Count,\
    \ grid[0].Count];\n        for (long i = 0; i < grid.Count; i++) {\n         \
    \   for (long j = 0; j < grid[0].Count; j++) {\n                grid2[i, j] =\
    \ grid[(int)i][(int)j];\n            }\n        }\n        long result = 0;\n\
    \        for (long i = 0; i < grid.Count; i++) {\n            for (long j = 0;\
    \ j < grid[0].Count; j++) {\n                if (grid2[i, j] == 1) {\n       \
    \             result += capacity;\n                    grid2[i, j] = 0;\n    \
    \                if (i < grid.Count - 1) {\n                        grid2[i +\
    \ 1, j] = 1;\n                    }\n                }\n            }\n      \
    \  }\n        return result;", "        // Write your code here.\n        return\
    \ 0;", '        return default(long);', "        if(capacity == 0) {\n       \
    \     return 0;\n        }\n        long sum = 0;\n        foreach(List<long>\
    \ row in grid) {\n            sum += row.Sum();\n        }\n        if(sum ==\
    \ 0) {\n            return 0;\n        }\n        long minBuckets = sum / capacity;\n\
    \        if(sum % capacity != 0) {\n            minBuckets++;\n        }\n   \
    \     long max = grid.Select(row => row.Where(unit => unit == 1).Count()).Max();\n\
    \        long min = grid.Select(row => row.Where(unit => unit == 1).Count()).Min();\n\
    \        if(min == max) {\n            return minBuckets;\n        }\n       \
    \ return Math.Max(minBuckets, max);", "        // your code goes here\n      \
    \  return 0;", "        int rows = grid.Count();\n        int cols = grid[0].Count();\n\
    \        int[,] volume = new int[rows, cols];\n        int _result = 0;\n    \
    \    for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++)\
    \ {\n                volume[r, c] = grid[r][c] == 1 ? 1 : 0;\n            }\n\
    \        }\n        int i = 0;\n        int j = 0;\n        int[,] directions\
    \ = new int[4, 2] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n        long\
    \ minHeight = 0;\n        long height = -1;\n        long up = 0;\n        long\
    \ down = 0;\n        // start from upper left corner\n        while (true) {\n\
    \            if (i == rows - 1 && j == cols - 1) {\n                break;\n \
    \           }\n            // iterate over all directions\n            for (int\
    \ d = 0; d < 4; d++) {\n                int r = i + directions[d, 0];\n      \
    \          int c = j + directions[d, 1];\n                // check that we are\
    \ inside the grid\n                if (r >= 0 && r < rows && c >= 0 && c < cols)\
    \ {\n                    // check that there is water on this cell\n         \
    \           if (volume[r, c] > 0) {\n                        // find the minimum\
    \ cell in the all directions\n                        if (minHeight == 0 || volume[r,\
    \ c] < minHeight) {\n                            minHeight = volume[r, c];\n \
    \                           height = minHeight;\n                            up\
    \ = 0;\n                            down = 0;\n                            i =\
    \ r;\n                            j = c;\n                        }\n        \
    \            }\n                }\n            }\n            if (height == -1)\
    \ {\n                break;\n            }\n            // update the minHeight\n\
    \            minHeight = 0;\n            for (int d = 0; d < 4; d++) {\n     \
    \           int r = i + directions[d, 0];\n                int c = j + directions[d,\
    \ 1];\n                if (r >= 0 && r < rows &&", "        long rows = (long)grid.Count;\n\
    \        long cols = (long)grid[0].Count;\n        var result = (long)0L;\n  \
    \      var filled = new List<List<long>>();\n        var N = new List<long>();\n\
    \        var S = new List<long>();\n        var E = new List<long>();\n      \
    \  var W = new List<long>();\n        var drops = new List<long>();\n        var\
    \ filledRows = new List<long>();\n        var filledCols = new List<long>();\n\
    \        for (var i = (long)0L; (i) < (rows); i++) {\n            for (var j =\
    \ (long)0L; (j) < (cols); j++) {\n                if ((grid[(int)i][(int)j]) ==\
    \ (1L)) {\n                    result += (long)1L;\n                    filled.Add(new\
    \ List<long>(new long[]{(long)i, (long)j}));\n                    N.Add((long)0L);\n\
    \                    S.Add((long)0L);\n                    E.Add((long)0L);\n\
    \                    W.Add((long)0L);\n                    drops.Add((long)0L);\n\
    \                    filledRows.Add((long)0L);\n                    filledCols.Add((long)0L);\n\
    \                }\n            }\n        }\n        while ((filled.Count) >\
    \ (0L)) {\n            var bucket = (long)0L;\n            var min = (long)0L;\n\
    \            for (var i = (long)0L; (i) < (filled.Count); i++) {\n           \
    \     if (((drops[(int)i]) == (min)) && ((filledRows[(int)i]) == (filledRows[(int)bucket])))\
    \ {\n                    if ((filledCols[(int)i]) < (filledCols[(int)bucket]))\
    \ {\n                        bucket = i;\n                    }\n            \
    \    }\n                if ((drops[(int)i]) < (min)) {\n                    min\
    \ = drops[(int)i];\n                    bucket = i;\n                }\n     \
    \       }\n            var row =", '        throw new NotImplementedException();',
  "        var n = grid.Count;\n        var m = grid[0].Count;\n        var l = new\
    \ List<long>();\n        for (var i = 0; i < n; i++) {\n            var r = 0L;\n\
    \            for (var j = 0; j < m; j++) {\n                r = r + grid[i][j];\n\
    \            }\n            l.Add(r);\n        }\n        var s = 0L;\n      \
    \  var e = capacity * m;\n        while (s != e) {\n            var c = (s + e)\
    \ / 2;\n            var b = true;\n            for (var i = 0; i < n; i++) {\n\
    \                var r = l[i];\n                if (r > c) {\n               \
    \     b = false;\n                    break;\n                }\n            }\n\
    \            if (b) {\n                e = c;\n            } else {\n        \
    \        s = c + 1;\n            }\n        }\n        var w = 0L;\n        for\
    \ (var i = 0; i < n; i++) {\n            var r = l[i];\n            if (r != s)\
    \ {\n                var d = s - r;\n                w = w + d;\n            }\n\
    \        }\n        return w;", "        // Your code here\n        var b = new\
    \ BigInteger[2, grid.Count, grid[0].Count];\n        var c = new BigInteger[grid.Count,\
    \ grid[0].Count];\n        for (int i = 0; i < grid.Count; i++) {\n          \
    \  for (int j = 0; j < grid[i].Count; j++) {\n                c[i, j] = grid[i][j];\n\
    \            }\n        }\n        long current = 0;\n        long next = 1;\n\
    \        int width = grid[0].Count;\n        int height = grid.Count;\n      \
    \  b[current, 0, 0] = capacity;\n        long res = 0;\n        while (true) {\n\
    \            var cell = GetCellToFill(b, current, width, height);\n          \
    \  if (cell == null) {\n                return res;\n            }\n         \
    \   b[next, cell.row, cell.col] = b[current, cell.row, cell.col];\n          \
    \  b[current, cell.row, cell.col] = 0;\n            c[cell.row, cell.col]--;\n\
    \            for (int i = 0; i < width; i++) {\n                if (b[current,\
    \ cell.row, i] > 0) {\n                    b[next, cell.row, i] = b[current, cell.row,\
    \ i] - 1;\n                    b[current, cell.row, i] = 0;\n                }\n\
    \            }\n            for (int i = 0; i < height; i++) {\n             \
    \   if (b[current, i, cell.col] > 0) {\n                    b[next, i, cell.col]\
    \ = b[current, i, cell.col] - 1;\n                    b[current, i, cell.col]\
    \ = 0;\n                }\n            }\n            res++;\n            current\
    \ = (current + 1) % 2;\n            next = (next + 1) % 2;\n        }", "    \
    \    // Your code goes here\n        var wells = grid.Select(row => row.Where(it\
    \ => it == 1).Count()).ToList();\n        long fillCount = 0;\n        foreach\
    \ (var well in wells) {\n            var fill = well / capacity;\n           \
    \ if (well % capacity != 0) {\n                fill += 1;\n            }\n   \
    \         fillCount += fill;\n        }\n        return fillCount;", '        return
    MaxFillRec(grid, 0, capacity);', "        // First we check if the well(s) are\
    \ empty\n        var isEmpty = true;\n        foreach (var innerList in grid)\
    \ {\n            foreach (var item in innerList) {\n                if (item !=\
    \ 0) {\n                    isEmpty = false;\n                    break;\n   \
    \             }\n            }\n        }\n        if (isEmpty) {\n          \
    \  return 0;\n        }\n        // Then we iterate through each cell, and check\
    \ if it's filled; if not, we fill it.\n        // This is for the first water\
    \ pass, to fill the first row\n        for (int row = 0; row < grid.Count; row++)\
    \ {\n            for (int col = 0; col < grid[row].Count; col++) {\n         \
    \       if (grid[row][col] != 1) {\n                    grid[row][col] = 1;\n\
    \                }\n            }\n        }\n        // Then we iterate through\
    \ each cell, and check if it's filled; if not, we fill it.\n        // This is\
    \ for the second water pass, to fill the columns\n        for (int row = 0; row\
    \ < grid.Count; row++) {\n            for (int col = 0; col < grid[row].Count;\
    \ col++) {\n                if (grid[row][col] != 1) {\n                    grid[row][col]\
    \ = 1;\n                }\n            }\n        }\n        var count = 0;\n\
    \        // Then we iterate through each cell, and check if it's filled; if not,\
    \ we fill it.\n        // This is for the third water pass, to fill the rest of\
    \ the wells\n        for (int row = 0; row < grid.Count; row++) {\n          \
    \  for (int col = 0; col < grid[row].Count; col++) {\n                if (grid[row][col]\
    \ != 1) {\n                    grid[row][col] = 1;\n                    count++;\n\
    \                }\n            }\n        }\n        // Finally, we return the\
    \ number of times the bucket was lowered\n        return count;", "        long\
    \ res = 0;\n        for (long i = 0; i < grid.Count; i++) {\n            List<long>\
    \ well = grid[(int)i];\n            for (long j = 0; j < well.Count; j++) {\n\
    \                long cur = well[(int)j];\n                if (cur != 0) {\n \
    \                   res += (long)1L;\n                    for (long k = i; k <\
    \ grid.Count; k++) {\n                        List<long> next = grid[(int)k];\n\
    \                        for (long m = j; m < next.Count; m++) {\n           \
    \                 if (capacity == 0) {\n                                return\
    \ res;\n                            }\n                            long newCur\
    \ = next[(int)m];\n                            if (newCur != 0) {\n          \
    \                      next[(int)m] = (long)0L;\n                            \
    \    capacity -= (long)1L;\n                            }\n                  \
    \      }\n                    }\n                }\n            }\n        }\n\
    \        return res;", "        // create a row-major count of wells to be filled\n\
    \        long totalWells = 0;\n        for (int i = 0; i < grid.Count; i++) {\n\
    \            for (int j = 0; j < grid[i].Count; j++) {\n                if (grid[i][j]\
    \ == 1) {\n                    totalWells++;\n                }\n            }\n\
    \        }\n        long totalFills = 0;\n        // fill wells by row until complete\n\
    \        while (totalWells > 0) {\n            for (int i = 0; i < grid.Count;\
    \ i++) {\n                for (int j = 0; j < grid[i].Count; j++) {\n        \
    \            if (grid[i][j] == 1) {\n                        grid[i][j] = 0;\n\
    \                        totalWells--;\n                        totalFills++;\n\
    \                        if (totalWells == 0) {\n                            break;\n\
    \                        }\n                    }\n                }\n       \
    \         if (totalWells == 0) {\n                    break;\n               \
    \ }\n            }\n        }\n        // return total fill count divided by bucket\
    \ capacity\n        return totalFills / capacity;"]
stop_tokens:
- "\n    }\n"
