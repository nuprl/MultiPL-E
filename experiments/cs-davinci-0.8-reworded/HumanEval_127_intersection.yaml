name: HumanEval_127_intersection
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // You are given two intervals,\n    // where each interval is\
  \ a pair of integers. For example, interval = (start, end) = (1, 2).\n    // The\
  \ given intervals are closed which means that the interval (start, end)\n    //\
  \ includes both start and end.\n    // For each given interval, it is assumed that\
  \ its start is less or equal its end.\n    // Your task is to determine whether\
  \ the length of intersection of these two \n    // intervals is a prime number.\n\
  \    // Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n  \
  \  // which its length is 1, which not a prime number.\n    // If the length of\
  \ the intersection is a prime number, return \"YES\",\n    // otherwise, return\
  \ \"NO\".\n    // If the two intervals don't intersect, return \"NO\".\n    // [input/output]\
  \ samples:\n    // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(2L, 3L)))\n\
  \    // (\"NO\")\n    // >>> Intersection((Tuple.Create(-1L, 1L)), (Tuple.Create(0L,\
  \ 4L)))\n    // (\"NO\")\n    // >>> Intersection((Tuple.Create(-3L, -1L)), (Tuple.Create(-5L,\
  \ 5L)))\n    // (\"YES\")\n    public static string Intersection(Tuple<long, long>\
  \ interval1, Tuple<long, long> interval2) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Intersection((Tuple.Create(1L,\
  \ 2L)), (Tuple.Create(2L, 3L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-1L,\
  \ 1L)), (Tuple.Create(0L, 4L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-3L,\
  \ -1L)), (Tuple.Create(-5L, 5L))).Equals((\"YES\")));\n    Debug.Assert(Intersection((Tuple.Create(-2L,\
  \ 2L)), (Tuple.Create(-4L, 0L))).Equals((\"YES\")));\n    Debug.Assert(Intersection((Tuple.Create(-11L,\
  \ 2L)), (Tuple.Create(-1L, -1L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(1L,\
  \ 2L)), (Tuple.Create(3L, 5L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(1L,\
  \ 2L)), (Tuple.Create(1L, 2L))).Equals((\"NO\")));\n    Debug.Assert(Intersection((Tuple.Create(-2L,\
  \ -2L)), (Tuple.Create(-3L, -2L))).Equals((\"NO\")));\n    }\n\n}\n"
completions: ["        var a = interval1.Item1;\n        var b = interval1.Item2;\n\
    \        var c = interval2.Item1;\n        var d = interval2.Item2;\n        if\
    \ (a > b) {\n            var x = a;\n            a = b;\n            b = x;\n\
    \        }\n        if (c > d) {\n            var x = c;\n            c = d;\n\
    \            d = x;\n        }\n        if (b < c || d < a) {\n            return\
    \ \"NO\";\n        }\n        var x1 = c > a ? c : a;\n        var x2 = d < b\
    \ ? d : b;\n        var len = x2 - x1 + 1;\n        if (len <= 1) {\n        \
    \    return \"NO\";\n        }\n        return (len & 1) == 0 ? \"NO\" : \"YES\"\
    ;", "        // your code goes here\n        // was stumped on this one, got help\
    \ from /u/CrazyMerlyn\n        var isect = (interval1.Item1 > interval2.Item1)\
    \ ? interval1.Item1 : interval2.Item1;\n        var isectEnd = (interval1.Item2\
    \ < interval2.Item2) ? interval1.Item2 : interval2.Item2;\n        if (isect >\
    \ isectEnd) {\n            return \"NO\";\n        }\n        return IsPrime(isectEnd\
    \ - isect + 1) ? \"YES\" : \"NO\";", "        // Your code here:\n        long\
    \ istart = Math.Max(interval1.Item1, interval2.Item1);\n        long iend = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long length = iend - istart + 1;\n        return\
    \ IsPrime(length) ? \"YES\" : \"NO\";", "        if (interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2) {\n            return \"NO\";\n      \
    \  }\n        var interStart = Math.Max(interval1.Item1, interval2.Item1);\n \
    \       var interEnd = Math.Min(interval1.Item2, interval2.Item2);\n        var\
    \ interLength = interEnd - interStart + 1;\n        return IsPrime(interLength)\
    \ ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        long\
    \ length = end - start + 1;\n        if (length < 1) {\n            return \"\
    NO\";\n        }\n        if (BigInteger.IsPrime(length)) {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";", "        var a = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var b = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (a > b) {\n            return \"NO\";\n        }\n        if (b -\
    \ a + 1 == 1) {\n            return \"NO\";\n        }\n        if (IsPrime(b\
    \ - a + 1)) {\n            return \"YES\";\n        }\n        return \"NO\";",
  "        // the following has a time complexity of O(1)\n        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        return\
    \ IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2) {\n            return\
    \ \"NO\";\n        }\n        // here we have at least 1 integer value in common,\n\
    \        // and the length of intersection is a prime number, return \"YES\",\n\
    \        // otherwise, return \"NO\".\n        // so we need to compute the length\
    \ of intersection.\n        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        var length\
    \ = end - start + 1;\n        if (length <= 1) {\n            return \"NO\";\n\
    \        }\n        // check if length is a prime number.\n        return IsPrime(length)\
    \ ? \"YES\" : \"NO\";", "        long length = 0;\n        long start1 = interval1.Item1;\n\
    \        long end1 = interval1.Item2;\n        long start2 = interval2.Item1;\n\
    \        long end2 = interval2.Item2;\n        if(start1 > end1) {\n         \
    \   start1 = interval1.Item2;\n            end1 = interval1.Item1;\n        }\n\
    \        if(start2 > end2) {\n            start2 = interval2.Item2;\n        \
    \    end2 = interval2.Item1;\n        }\n        if(start1 >= end2 || start2 >=\
    \ end1) {\n            return \"NO\";\n        }\n        if(start1 <= start2\
    \ && end1 <= end2) {\n            length = end1 - start2;\n        }\n       \
    \ if(start1 <= start2 && end1 >= end2) {\n            length = end2 - start2;\n\
    \        }\n        if(start1 >= start2 && end1 <= end2) {\n            length\
    \ = end1 - start1;\n        }\n        if(start1 >= start2 && end1 >= end2) {\n\
    \            length = end2 - start1;\n        }\n        if(length < 0) {\n  \
    \          length = -length;\n        }\n        if(length == 1) {\n         \
    \   return \"NO\";\n        }\n        bool prime = true;\n        for(long i\
    \ = 2; i < length; i++) {\n            if(length % i == 0) {\n               \
    \ prime = false;\n                break;\n            }\n        }\n        if(prime)\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";", "      \
    \  var x = Math.Max(interval1.Item1, interval2.Item1);\n        var y = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (x > y) {\n            return \"NO\";\n      \
    \  }\n        return IsPrime(y - x + 1) ? \"YES\" : \"NO\";", "        // check\
    \ order of intervals\n        if (interval1.Item1 > interval1.Item2) {\n     \
    \       var temp = interval1.Item1;\n            interval1 = Tuple.Create(interval1.Item2,\
    \ temp);\n        }\n        if (interval2.Item1 > interval2.Item2) {\n      \
    \      var temp = interval2.Item1;\n            interval2 = Tuple.Create(interval2.Item2,\
    \ temp);\n        }\n        // \n        var x1 = interval1.Item1;\n        var\
    \ x2 = interval1.Item2;\n        var y1 = interval2.Item1;\n        var y2 = interval2.Item2;\n\
    \        // check if it intersects\n        if (x1 <= y1 && y1 <= x2 && x2 <=\
    \ y2) {\n            // the left edge of second interval is inside the first interval\n\
    \            return IsPrime(x2 - y1 + 1) ? \"YES\" : \"NO\";\n        } else if\
    \ (y1 <= x1 && x1 <= y2 && y2 <= x2) {\n            // the right edge of second\
    \ interval is inside the first interval\n            return IsPrime(y2 - x1 +\
    \ 1) ? \"YES\" : \"NO\";\n        } else if (x1 <= y1 && y2 <= x2) {\n       \
    \     // second interval is inside the first interval\n            return IsPrime(y2\
    \ - y1 + 1) ? \"YES\" : \"NO\";\n        } else if (y1 <= x1 && x2 <= y2) {\n\
    \            // first interval is inside the second interval\n            return\
    \ IsPrime(x2 - x1 + 1) ? \"YES\" : \"NO\";\n        } else {\n            return\
    \ \"NO\";\n        }", "        // Your code is here...\n        return \"\";",
  "        // Your code here\n        long min = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long max = Math.Min(interval1.Item2, interval2.Item2);\n        long\
    \ len = max - min + 1;\n        if (len < 0) {\n            return \"NO\";\n \
    \       }\n        if (isPrime(len)) {\n            return \"YES\";\n        }\n\
    \        return \"NO\";", "        // interval1 = (1, 2)  interval2 = (2, 3)\n\
    \        // interval1 = (1, 3)  interval2 = (2, 3)\n        // interval1 = (2,\
    \ 3)  interval2 = (1, 3)\n        // interval1 = (2, 3)  interval2 = (1, 2)\n\
    \        //\n        //\n        // \n        //\n        //\n        //\n   \
    \     var start = Math.Max(interval1.Item1, interval2.Item1);\n        var end\
    \ = Math.Min(interval1.Item2, interval2.Item2);\n        if (start > end) return\
    \ \"NO\";\n        var result = BigInteger.Subtract(end, start) + 1;\n       \
    \ return (IsPrime(result)) ? \"YES\" : \"NO\";", "        // determine if they\
    \ intersect\n        // compute length of intersection\n        // determine if\
    \ length is prime\n        // return \"YES\" if length is prime, \"NO\" otherwise\n\
    \        // if they do not intersect, return \"NO\"\n        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2)\n            return\
    \ \"NO\";\n        long maxStart = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long minEnd = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ IsPrime(minEnd - maxStart + 1) ? \"YES\" : \"NO\";", "        var int1A = interval1.Item1;\n\
    \        var int1B = interval1.Item2;\n        var int2A = interval2.Item1;\n\
    \        var int2B = interval2.Item2;\n        var int1  = Tuple.Create(Math.Min(int1A,\
    \ int1B), Math.Max(int1A, int1B));\n        var int2  = Tuple.Create(Math.Min(int2A,\
    \ int2B), Math.Max(int2A, int2B));\n        var s = Math.Max(int1.Item1, int2.Item1);\n\
    \        var e = Math.Min(int1.Item2, int2.Item2);\n        var v = Math.Max(0,\
    \ e - s + 1);\n        //\n        if (v == 0) {\n            return \"NO\";\n\
    \        }\n        // Optimization to check small primes\n        if (v < 255)\
    \ {\n            if (v == 1 || v == 2 || v == 3 || v == 5 || v == 7 || v == 11\
    \ || v == 13 || v == 17 || v == 19 || v == 23 || v == 29 || v == 31 || v == 37\
    \ || v == 41 || v == 43 || v == 47 || v == 53 || v == 59 || v == 61 || v == 67\
    \ || v == 71 || v == 73 || v == 79 || v == 83 || v == 89 || v == 97 || v == 101\
    \ || v == 103 || v == 107 || v == 109 || v == 113 || v == 127 || v == 131 || v\
    \ == 137 || v == 139 || v == 149 || v == 151 || v == 157 || v == 163 || v == 167\
    \ || v == 173 || v == 179 || v == 181 || v == 191 || v == 193 || v == 197 || v\
    \ == 199 || v == 211 || v == 223 || v == 227 || v == 229 || v == 233 || v == 239\
    \ || v == 241 || v == 251 || v == 253) {\n                return \"YES\";\n  \
    \          }\n        }\n        if (v < 1001) {\n            if (v == 257 ||\
    \ v == 263 || v == 269 || v == 271 || v == 277 || v == 281 || v == 283 || v ==\
    \ 293 || v ==", "        var list1 = Enumerable.Range((int)interval1.Item1, (int)(interval1.Item2\
    \ - interval1.Item1 + 1)).ToList();\n        var list2 = Enumerable.Range((int)interval2.Item1,\
    \ (int)(interval2.Item2 - interval2.Item1 + 1)).ToList();\n        var total =\
    \ list1.Count + list2.Count;\n        var intersect = list1.Intersect(list2).Count();\n\
    \        if (intersect == 0) {\n            return \"NO\";\n        }\n      \
    \  if (IsPrime(intersect)) {\n            return \"YES\";\n        }\n       \
    \ return \"NO\";", "        // Find the intersection of the two intervals.\n \
    \       var result = FindIntersection(interval1, interval2);\n        return \"\
    NO\";", "        var lowerEnd = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var upperEnd = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ IsPrime(upperEnd - lowerEnd + 1) ? \"YES\" : \"NO\";", "        long start =\
    \ Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start <= end) {\n            int len = (int)(end\
    \ - start + 1);\n            if (len > 1) {\n                if (len % 2 == 0)\
    \ {\n                    return \"NO\";\n                }\n                int\
    \ mid = len / 2;\n                bool flag = true;\n                for (int\
    \ i = 3; i <= mid; i += 2) {\n                    if (len % i == 0) {\n      \
    \                  flag = false;\n                        break;\n           \
    \         }\n                }\n                if (flag) {\n                \
    \    return \"YES\";\n                }\n            }\n        }\n        return\
    \ \"NO\";", "        var a = interval1.Item1;\n        var b = interval1.Item2;\n\
    \        var c = interval2.Item1;\n        var d = interval2.Item2;\n        if\
    \ (d < a || b < c) {\n            return \"NO\";\n        }\n        var e = Math.Max(a,\
    \ c);\n        var f = Math.Min(b, d);\n        var length = f - e + 1;\n    \
    \    if (length <= 0) {\n            return \"NO\";\n        }\n        return\
    \ IsPrime(length) ? \"YES\" : \"NO\";", '        return (3L == IntersectionSize(interval1,
    interval2)) ? "YES" : "NO";', "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long length = end - start + 1;\n        if (length < 0) return \"NO\"\
    ;\n        for (long i = 2; i * i <= length; i++) {\n            if (length %\
    \ i == 0) return \"NO\";\n        }\n        return \"YES\";", "        if(interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2) {\n            return\
    \ \"NO\";\n        }\n        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ isPrime(end - start + 1) ? \"YES\" : \"NO\";", "        var start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        var\
    \ length = end - start + 1;\n        if (IsPrime(length)) {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";", "        var newInterval1 = interval1.Item1\
    \ > interval2.Item1 ? interval1 : interval2;\n        var newInterval2 = interval1.Item1\
    \ <= interval2.Item1 ? interval1 : interval2;\n        var result = GetIntersection(newInterval1,\
    \ newInterval2);\n        return IsPrime(result.Item2 - result.Item1 + 1) ? \"\
    YES\" : \"NO\";", "        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start\
    \ > end) return \"NO\";\n        var len = end - start + 1;\n        return isPrime(len)\
    \ ? \"YES\" : \"NO\";", "        var min = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var max = Math.Min(interval1.Item2, interval2.Item2);\n        var diff\
    \ = max - min;\n        if (diff < 0) {\n            return \"NO\";\n        }\n\
    \        if (diff == 0) {\n            return \"YES\";\n        }\n        if\
    \ (diff == 1) {\n            return \"NO\";\n        }\n        return IsPrime(diff)\
    \ ? \"YES\" : \"NO\";", "        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        var length\
    \ = Math.Max(end - start + 1, 0);\n        return IsPrime(length) ? \"YES\" :\
    \ \"NO\";", "        // The intersection of the intervals (1, 3), (2, 4) is (2,\
    \ 3)\n        // >>> Intersection((Tuple.Create(1L, 3L)), (Tuple.Create(2L, 4L)))\n\
    \        // (\"NO\")\n        // >>> Intersection((Tuple.Create(1L, 2L)), (Tuple.Create(1L,\
    \ 2L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L, 2L)),\
    \ (Tuple.Create(2L, 3L)))\n        // (\"NO\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(1L, 3L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(0L, 3L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(0L, 2L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(0L, 1L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(0L, 0L)))\n        // (\"NO\")\n        // >>> Intersection((Tuple.Create(0L,\
    \ 0L)), (Tuple.Create(0L, 0L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 2L)), (Tuple.Create(3L, 4L)))\n        // (\"NO\")\n        // >>> Intersection((Tuple.Create(0L,\
    \ 3L)), (Tuple.Create(3L, 4L)))\n        // (\"NO\")\n        // >>> Intersection((Tuple.Create(0L,\
    \ 0L)), (Tuple.Create(1L, 1L)))\n        // (\"NO\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 3L)), (Tuple.Create(2L, 3L)))\n        // (\"YES\")\n        // >>> Intersection((Tuple.Create(1L,\
    \ 3L)), (T", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start\
    \ > end) {\n            return \"NO\";\n        }\n        return IsPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";", "        // Write your code here\n      \
    \  BigInteger a, b, c, d;\n        a = interval1.Item1;\n        b = interval1.Item2;\n\
    \        c = interval2.Item1;\n        d = interval2.Item2;\n        if (a > b)\
    \ {\n            BigInteger tmp = a;\n            a = b;\n            b = tmp;\n\
    \        }\n        if (c > d) {\n            BigInteger tmp = c;\n          \
    \  c = d;\n            d = tmp;\n        }\n        if (a > d || b < c) {\n  \
    \          return \"NO\";\n        }\n        BigInteger left = a < c ? c : a;\n\
    \        BigInteger right = b < d ? b : d;\n        return isPrime(right - left\
    \ + 1) ? \"YES\" : \"NO\";", "        // check if there is an intersection\n \
    \       if (interval1.Item2 < interval2.Item1 || interval2.Item2 < interval1.Item1)\
    \ {\n            return \"NO\";\n        }\n        // check if there is an intersection\n\
    \        if (interval1.Item1 >= interval2.Item1 && interval1.Item2 <= interval2.Item2)\
    \ {\n            return IsPrime(interval1.Item2 - interval1.Item1 + 1) ? \"YES\"\
    \ : \"NO\";\n        }\n        if (interval2.Item1 >= interval1.Item1 && interval2.Item2\
    \ <= interval1.Item2) {\n            return IsPrime(interval2.Item2 - interval2.Item1\
    \ + 1) ? \"YES\" : \"NO\";\n        }\n        // interval1 is before interval2\n\
    \        if (interval1.Item2 < interval2.Item1) {\n            return IsPrime(interval1.Item2\
    \ - interval2.Item1 + 1) ? \"YES\" : \"NO\";\n        }\n        // interval2\
    \ is before interval1\n        if (interval2.Item2 < interval1.Item1) {\n    \
    \        return IsPrime(interval2.Item2 - interval1.Item1 + 1) ? \"YES\" : \"\
    NO\";\n        }\n        // should not be here\n        return \"NO\";", '        return
    "0";', "        long d1 = interval1.Item2 - interval1.Item1;\n        long d2\
    \ = interval2.Item2 - interval2.Item1;\n        long d = 0;\n        if (interval1.Item1\
    \ <= interval2.Item1) {\n            if (interval1.Item2 >= interval2.Item1) {\n\
    \                d = Math.Min(interval1.Item2, interval2.Item2) - interval2.Item1;\n\
    \            }\n        } else {\n            if (interval2.Item2 >= interval1.Item1)\
    \ {\n                d = Math.Min(interval1.Item2, interval2.Item2) - interval1.Item1;\n\
    \            }\n        }\n        return IsPrime(d) ? \"YES\" : \"NO\";", " \
    \       var i1 = interval1;\n        var i2 = interval2;\n        if (i1.Item1\
    \ > i2.Item1) {\n            var temp = i1;\n            i1 = i2;\n          \
    \  i2 = temp;\n        }\n        // i1 starts before i2\n        var start =\
    \ Math.Max(i1.Item1, i2.Item1);\n        var end = Math.Min(i1.Item2, i2.Item2);\n\
    \        var diff = end - start;\n        if (diff < 1) return \"NO\";\n     \
    \   for (int i = 2; i <= diff; i++) {\n            if (diff % i == 0) return \"\
    NO\";\n        }\n        return \"YES\";", "        var sorted = new Tuple<long,\
    \ long>[] { interval1, interval2 }.OrderBy(x => x.Item1).ToArray();\n        if\
    \ (sorted[0].Item2 < sorted[1].Item1) {\n            return \"NO\";\n        }\n\
    \        var diff = sorted[1].Item1 - sorted[0].Item2;\n        if (diff == 1)\
    \ {\n            return \"YES\";\n        }\n        return !IsPrime(diff) ? \"\
    NO\" : \"YES\";", "        // Given intervals, where each interval is a pair of\
    \ integers. \n        // For example, interval = (start, end) = (1, 2).\n    \
    \    // The given intervals are closed which means that the interval (start, end)\n\
    \        // includes both start and end.\n        // For each given interval,\
    \ it is assumed that its start is less or equal its end.\n        // Your task\
    \ is to determine whether the length of intersection of these two \n        //\
    \ intervals is a prime number.\n        // If the length of the intersection is\
    \ a prime number, return \"YES\",\n        // otherwise, return \"NO\".\n    \
    \    // If the two intervals don't intersect, return \"NO\".\n        // Length\
    \ of intersection is the difference between the greater of the\n        // endpoints\
    \ of the two intervals and the lesser of the endpoints of the\n        // two\
    \ intervals.\n        // If the length of the intersection is less than one, return\
    \ \"NO\".\n        // Set interval1 to the interval with the smaller start point.\n\
    \        if (interval1.Item1 > interval2.Item1) {\n            var temp = interval1;\n\
    \            interval1 = interval2;\n            interval2 = temp;\n        }\n\
    \        // Determine whether the length of intersection of these two intervals\
    \ is a prime number.\n        // If the length of the intersection is a prime\
    \ number, return \"YES\",\n        // otherwise, return \"NO\".\n        // If\
    \ the two intervals don't intersect, return \"NO\".\n        // Determine whether\
    \ the two intervals intersect.\n        if (interval1.Item2 >= interval2.Item1)\
    \ {\n            // Determine the start and end points of the intersection of\
    \ the two intervals.\n            var start = interval2.Item1;\n            var\
    \ end = Math.Min(interval1.Item2, interval2.Item2);\n            // Length of\
    \ intersection is the difference between the greater of the\n            // endpoints\
    \ of the two intervals and the lesser of the endpoints of the\n            //\
    \ two intervals.\n            var length = end - start;\n            // If the\
    \ length of the intersection is less than one, return \"NO\".\n            if\
    \ (length < 1) {\n                return \"NO\";\n            }\n            //\
    \ Determine whether the length of the intersection is a prime number.\n      \
    \      if (IsPrime", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        long\
    \ length = end - start + 1;\n        return length < 2 ? \"NO\" : IsPrime(length)\
    \ ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start\
    \ > end) return \"NO\";\n        long length = end - start + 1;\n        if (IsPrime(length))\
    \ return \"YES\";\n        return \"NO\";", "        var intersection = interval1.Intersect(interval2);\n\
    \        if (intersection.Count() == 0) {\n            return \"NO\";\n      \
    \  }\n        var start = intersection.First();\n        var end = intersection.Last();\n\
    \        var length = end - start + 1;\n        var p = new Prime();\n       \
    \ return p.isPrime(length) ? \"YES\" : \"NO\";", "        var intersetion = GetIntersection(interval1,\
    \ interval2);\n        if (intersetion.Item1 == -1 || intersetion.Item2 == -1)\
    \ {\n            return \"NO\";\n        }\n        var length = intersetion.Item2\
    \ - intersetion.Item1 + 1;\n        return IsPrime(length) ? \"YES\" : \"NO\";",
  "        // WRITE CODE HERE\n        long min = interval1.Item1;\n        long max\
    \ = interval1.Item2;\n        // if interval2 is beyond the interval 1, or \n\
    \        // if interval2 is beyond the interval 1, or \n        // if interval2\
    \ is beyond the interval 1, or \n        if (interval2.Item1 > max || interval2.Item2\
    \ < min || \n            interval2.Item1 < min && interval2.Item2 < min ||\n \
    \           interval2.Item1 > max && interval2.Item2 > max) {\n            return\
    \ \"NO\";\n        }\n        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        long left1 = interval1.Item1;\n\
    \        long right1 = interval1.Item2;\n        long left2 = interval2.Item1;\n\
    \        long right2 = interval2.Item2;\n        long left = Math.Max(left1, left2);\n\
    \        long right = Math.Min(right1, right2);\n        long intervalLength =\
    \ right - left + 1;\n        if (intervalLength < 1) {\n            return \"\
    NO\";\n        }\n        return IsPrime(intervalLength) ? \"YES\" : \"NO\";",
  "        // your code\n        if (interval1.Item1 > interval2.Item2 || interval2.Item1\
    \ > interval1.Item2)\n            return \"NO\";\n        var start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        var a\
    \ = interval1.Item1;\n        var b = interval1.Item2;\n        var c = interval2.Item1;\n\
    \        var d = interval2.Item2;\n        if (c > b || a > d) {\n           \
    \ return \"NO\";\n        }\n        var start = Math.Max(a, c);\n        var\
    \ end = Math.Min(b, d);\n        if (IsPrime(end - start + 1)) {\n           \
    \ return \"YES\";\n        }\n        return \"NO\";", "        var s = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var e = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (s <= e) {\n            var len = e - s + 1;\n            if (IsPrime(len))\
    \ {\n                return \"YES\";\n            }\n        }\n        return\
    \ \"NO\";", "        if (interval1.Item1 > interval2.Item2 || interval2.Item1\
    \ > interval1.Item2) {\n            return \"NO\";\n        }\n        long firstStart\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long firstEnd = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long length = firstEnd - firstStart + 1;\n      \
    \  // check if length is a prime number\n        if (length == 1) {\n        \
    \    return \"NO\";\n        }\n        for (long i = 2; i <= Math.Sqrt(length);\
    \ i++) {\n            if (length % i == 0) {\n                return \"NO\";\n\
    \            }\n        }\n        return \"YES\";", "        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2)\n            return\
    \ \"NO\";\n        else {\n            long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n            long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \            return IsPrime(end - start + 1) ? \"YES\" : \"NO\";\n        }",
  "        int maxStart = Math.Max((int)interval1.Item1, (int)interval2.Item1);\n\
    \        int minEnd = Math.Min((int)interval1.Item2, (int)interval2.Item2);\n\
    \        if (maxStart > minEnd) return \"NO\";\n        int intersectionLength\
    \ = minEnd - maxStart + 1;\n        return isPrime(intersectionLength) ? \"YES\"\
    \ : \"NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        // intersection:\
    \ (start, end)\n        if (start > end) {\n            return \"NO\";\n     \
    \   }\n        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "       \
    \ if (interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n        if (interval1.Item1 <= interval2.Item1)\
    \ {\n            if (interval1.Item2 < interval2.Item2) {\n                return\
    \ \"YES\";\n            }\n            else {\n                return \"NO\";\n\
    \            }\n        }\n        else {\n            if (interval2.Item2 < interval1.Item2)\
    \ {\n                return \"YES\";\n            }\n            else {\n    \
    \            return \"NO\";\n            }\n        }", "        long intersectionLength\
    \ = CalculateIntersectionLength(interval1, interval2);\n        if (intersectionLength\
    \ == 0) {\n            return \"NO\";\n        }\n        bool isPrime = IsPrime(intersectionLength);\n\
    \        return isPrime ? \"YES\" : \"NO\";", "        if (interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2)\n            return \"NO\";\n        var\
    \ start = Math.Max(interval1.Item1, interval2.Item1);\n        var end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start == end)\n            return (start + \"\
    \").Contains(\"2\") ? \"YES\" : \"NO\";\n        if (end - start == 1)\n     \
    \       return \"YES\";\n        if (end - start > 5)\n            return \"NO\"\
    ;\n        return Program.IsPrime(end - start) ? \"YES\" : \"NO\";", "       \
    \ var x = interval1.Item1;\n        var y = interval1.Item2;\n        var z =\
    \ interval2.Item1;\n        var w = interval2.Item2;\n        return ((z <= x\
    \ && x <= w) || (z <= y && y <= w) || (x <= z && z <= y) || (x <= w && w <= y))\
    \ ?\n            (IsPrime(Math.Max(0, Math.Min(y, w) - Math.Max(x, z)) + 1) ?\
    \ \"YES\" : \"NO\") : \"NO\";", "        int c1 = interval1.Item1.CompareTo(interval2.Item1);\n\
    \        int c2 = interval1.Item2.CompareTo(interval2.Item2);\n        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        // |1|-----|\n        //       |2|-----|\n      \
    \  if (c1 <= 0 && c2 <= 0) {\n            return isPrime(end - start + 1) ? \"\
    YES\" : \"NO\";\n        }\n        //       |1|-----|\n        // |2|-----|\n\
    \        if (c1 >= 0 && c2 >= 0) {\n            return isPrime(end - start + 1)\
    \ ? \"YES\" : \"NO\";\n        }\n        // |1|-----|\n        // |2|-----|\n\
    \        if (c1 <= 0 && c2 >= 0) {\n            return isPrime(interval1.Item2\
    \ - interval2.Item1 + 1) ? \"YES\" : \"NO\";\n        }\n        // |2|-----|\n\
    \        // |1|-----|\n        if (c1 >= 0 && c2 <= 0) {\n            return isPrime(interval2.Item2\
    \ - interval1.Item1 + 1) ? \"YES\" : \"NO\";\n        }\n        return \"NO\"\
    ;", "        long a = interval1.Item1;\n        long b = interval1.Item2;\n  \
    \      long c = interval2.Item1;\n        long d = interval2.Item2;\n        bool\
    \ isIntersect = (a <= c && c <= b) || (a <= d && d <= b) || (c <= a && a <= d)\
    \ || (c <= b && b <= d);\n        long intersectLeft = Math.Max(a, c);\n     \
    \   long intersectRight = Math.Min(b, d);\n        long intersectLength = Math.Max(0,\
    \ intersectRight - intersectLeft + 1);\n        return isIntersect && IsPrime(intersectLength)\
    \ ? \"YES\" : \"NO\";", "        long x1 = interval1.Item1;\n        long y1 =\
    \ interval1.Item2;\n        long x2 = interval2.Item1;\n        long y2 = interval2.Item2;\n\
    \        long intersectionStart = Math.Max(x1, x2);\n        long intersectionEnd\
    \ = Math.Min(y1, y2);\n        if (intersectionStart > intersectionEnd) {\n  \
    \          return \"NO\";\n        }\n        long intersectionLength = intersectionEnd\
    \ - intersectionStart + 1;\n        if (IsPrime(intersectionLength)) {\n     \
    \       return \"YES\";\n        }\n        return \"NO\";", "        var a =\
    \ new long[] {interval1.Item1, interval1.Item2};\n        var b = new long[] {interval2.Item1,\
    \ interval2.Item2};\n        var l1 = interval1.Item2 - interval1.Item1;\n   \
    \     var l2 = interval2.Item2 - interval2.Item1;\n        var l3 = Math.Max(a[0],\
    \ b[0]) - Math.Min(a[1], b[1]);\n        if (l3 > 0) return \"NO\";\n        var\
    \ l = l1+l2+l3+1;\n        return IsPrime(l) ? \"YES\" : \"NO\";", "        var\
    \ result = interval1.IntersectWith(interval2);\n        if (result == null) return\
    \ \"NO\";\n        var len = result.Length();\n        return IsPrime(len) ? \"\
    YES\" : \"NO\";", "        var hash = new HashSet<long>();\n        for (long\
    \ i = interval1.Item1; i <= interval1.Item2; i++) {\n            hash.Add(i);\n\
    \        }\n        for (long i = interval2.Item1; i <= interval2.Item2; i++)\
    \ {\n            hash.Add(i);\n        }\n        var list = hash.ToList();\n\
    \        list.Sort();\n        var diff = list[list.Count - 1] - list[0];\n  \
    \      if (diff == 0) {\n            return \"NO\";\n        }\n        if (diff\
    \ == 1) {\n            return IsPrime(diff) ? \"YES\" : \"NO\";\n        }\n \
    \       var m = 2;\n        var n = diff - 1;\n        for (; m <= n; m++, n--)\
    \ {\n            if (IsPrime(m) && IsPrime(n)) {\n                return \"YES\"\
    ;\n            }\n        }\n        return \"NO\";", "        long start1 = interval1.Item1;\n\
    \        long end1 = interval1.Item2;\n        long start2 = interval2.Item1;\n\
    \        long end2 = interval2.Item2;\n        long start3 = Math.Max(start1,\
    \ start2);\n        long end3 = Math.Min(end1, end2);\n        long length = end3\
    \ - start3 + 1;\n        if (length < 0)\n            return \"NO\";\n       \
    \ if (length == 0)\n            return \"YES\";\n        if (length == 1)\n  \
    \          return \"NO\";\n        return length.IsPrime() ? \"YES\" : \"NO\";",
  "        // calculate the intersection of two intervals\n        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long count = end - start + 1;\n        if (count <= 0) {\n          \
    \  return \"NO\";\n        }\n        if (count == 1) {\n            return \"\
    YES\";\n        }\n        // test if the length of the intersection is a prime\
    \ number\n        if (count % 2 == 0) {\n            return \"NO\";\n        }\n\
    \        long sqrt = (long)Math.Sqrt(count);\n        for (long i = 3; i <= sqrt;\
    \ i += 2) {\n            if (count % i == 0) {\n                return \"NO\"\
    ;\n            }\n        }\n        return \"YES\";", "        var starts = new\
    \ List<long>();\n        var ends = new List<long>();\n        if (interval1.Item1\
    \ < interval2.Item1) {\n            starts.Add(interval1.Item1);\n           \
    \ starts.Add(interval2.Item1);\n        } else {\n            starts.Add(interval2.Item1);\n\
    \            starts.Add(interval1.Item1);\n        }\n        if (interval1.Item2\
    \ < interval2.Item2) {\n            ends.Add(interval1.Item2);\n            ends.Add(interval2.Item2);\n\
    \        } else {\n            ends.Add(interval2.Item2);\n            ends.Add(interval1.Item2);\n\
    \        }\n        if (starts[0] <= ends[0] && starts[1] <= ends[1]) {\n    \
    \        var start = starts[1];\n            var end = ends[0];\n            var\
    \ intervalLength = (end - start) + 1;\n            if (start < end) {\n      \
    \          return isPrime(intervalLength) ? \"YES\" : \"NO\";\n            }\n\
    \        }\n        return \"NO\";", "        var start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (start > end) return \"NO\";\n        var len = end - start + 1;\n\
    \        if (BigInteger.IsProbablePrime(len)) {\n            return \"YES\";\n\
    \        }\n        return \"NO\";", "        var (start1, end1) = interval1;\n\
    \        var (start2, end2) = interval2;\n        // 1. calculate the intersection.\n\
    \        var left = Math.Max(start1, start2);\n        var right = Math.Min(end1,\
    \ end2);\n        if (left > right) return \"NO\"; // the two intervals don't\
    \ intersect.\n        var len = right - left + 1;\n        // 2. test whether\
    \ or not the len is a prime number.\n        var isPrime = IsPrime2(len);\n  \
    \      return isPrime ? \"YES\" : \"NO\";", "        var maxStart = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var minEnd = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        var length = Math.Max(0, minEnd - maxStart + 1);\n        if (length\
    \ <= 1) return \"NO\";\n        return length.IsPrime() ? \"YES\" : \"NO\";",
  "        long start1 = interval1.Item1;\n        long end1 = interval1.Item2;\n\
    \        long start2 = interval2.Item1;\n        long end2 = interval2.Item2;\n\
    \        long minStart = Math.Max(start1, start2);\n        long maxEnd = Math.Min(end1,\
    \ end2);\n        long intersectionLength = maxEnd - minStart + 1;\n        return\
    \ IsPrime(intersectionLength) ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long diff = end - start;\n        if (diff < 0) {\n            return\
    \ \"NO\";\n        }\n        bool isPrime = true;\n        for (long factor =\
    \ 2; factor <= diff / 2; factor++) {\n            if (diff % factor == 0) {\n\
    \                isPrime = false;\n                break;\n            }\n   \
    \     }\n        return isPrime ? \"YES\" : \"NO\";", "        // make sure interval1\
    \ start is always less than interval2 start\n        // to simplify our next coding\n\
    \        if (interval1.Item1 > interval2.Item1) {\n            var temp = interval1;\n\
    \            interval1 = interval2;\n            interval2 = temp;\n        }\n\
    \        // be careful the case where two interval have no intersection at all\n\
    \        if (interval1.Item2 < interval2.Item1) {\n            return \"NO\";\n\
    \        }\n        var start = interval2.Item1;\n        var end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        // test if the length of intersection is a prime\
    \ number\n        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "    \
    \    long min, max;\n        if (interval1.Item1 < interval2.Item1) {\n      \
    \      min = interval2.Item1;\n        } else {\n            min = interval1.Item1;\n\
    \        }\n        if (interval1.Item2 < interval2.Item2) {\n            max\
    \ = interval1.Item2;\n        } else {\n            max = interval2.Item2;\n \
    \       }\n        if (min > max) {\n            return \"NO\";\n        }\n \
    \       long len = max - min + 1;\n        for (long i = 2; i * i <= len; i++)\
    \ {\n            if (len % i == 0) {\n                return \"NO\";\n       \
    \     }\n        }\n        return \"YES\";", "        // Note:\n        // The\
    \ prime numbers of length of the intersection are {2, 3, 5}.\n        // If the\
    \ intersection of these two intervals contains at least one of \n        // those\
    \ numbers, return \"YES\", otherwise, return \"NO\".\n        // Note:\n     \
    \   // 1. The given intervals have no intersection, return \"NO\".\n        //\
    \ 2. The given intervals have an intersection and the length of \n        // \
    \   the intersection is not a prime number, return \"NO\".\n        // 3. The\
    \ given intervals have an intersection and the length of \n        //    the intersection\
    \ is a prime number, return \"YES\".\n        // Note:\n        // The given intervals\
    \ are closed which means that the interval (start, end)\n        // includes both\
    \ start and end.\n        // The given intervals are ordered which means that\
    \ their start is less or \n        // equal their end.\n        var (start1, end1)\
    \ = interval1;\n        var (start2, end2) = interval2;\n        // Note:\n  \
    \      // We should be able to determine if the intersection of those \n     \
    \   // two intervals is non-empty or empty just by comparing the end and \n  \
    \      // start points of those two intervals.\n        // (1, 3) : start = 1,\
    \ end = 3\n        // (2, 4) : start = 2, end = 4\n        // (1, 4) : start =\
    \ 1, end = 4\n        // If we compare the end of the first interval with the\
    \ start of the \n        // second interval and we are able to determine that\
    \ end <= start,\n        // then we know that the two intervals don't intersect.\n\
    \        // If we compare the end of the first interval with the start of the\
    \ \n        // second interval and we are able to determine that end > start,\n\
    \        // then we know that the two intervals intersect.\n        // If the\
    \ two intervals don't intersect, return \"NO\".\n        if (end1 <= start2) {\n\
    \            return \"NO\";\n        }\n        // Note:\n        // To get the\
    \ intersection of those two intervals, we need to compare the \n        // start\
    \ and end of the two intervals and get the maximum of the start \n        // and\
    \ the minimum of the end.\n        // (1, 3) : start = 1", "        long a = interval1.Item1;\n\
    \        long b = interval1.Item2;\n        long c = interval2.Item1;\n      \
    \  long d = interval2.Item2;\n        if (a > b) {\n            long t = a;\n\
    \            a = b;\n            b = t;\n        }\n        if (c > d) {\n   \
    \         long t = c;\n            c = d;\n            d = t;\n        }\n   \
    \     long L = Math.Max(a, c);\n        long R = Math.Min(b, d);\n        long\
    \ k = R - L + 1;\n        return k <= 0 ? \"NO\" : (IsPrime(k) ? \"YES\" : \"\
    NO\");", "        var orderedIntervals = new List<Tuple<long, long>>();\n    \
    \    orderedIntervals.Add(Tuple.Create(interval1.Item1, interval1.Item2));\n \
    \       orderedIntervals.Add(Tuple.Create(interval2.Item1, interval2.Item2));\n\
    \        orderedIntervals.Sort();\n        //(start1, end1) and (start2, end2)\
    \ are two different intervals\n        // . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .", "        // interval1: (a, b) = (start, end)\n     \
    \   // interval2: (c, d) = (start, end)\n        // intersection: [max(a, c),\
    \ min(b, d)]\n        // intersection.Length = [min(b, d) - max(a, c) + 1]\n \
    \       long start = Math.Max(interval1.Item1, interval2.Item1);\n        long\
    \ end = Math.Min(interval1.Item2, interval2.Item2);\n        long intersectionLength\
    \ = end - start + 1;\n        if (intersectionLength < 0) {\n            return\
    \ \"NO\";\n        }\n        for (long i = 2; i <= Math.Sqrt(intersectionLength);\
    \ i++) {\n            if (intersectionLength % i == 0) {\n                return\
    \ \"NO\";\n            }\n        }\n        return \"YES\";", "        long a1\
    \ = interval1.Item1;\n        long a2 = interval1.Item2;\n        long b1 = interval2.Item1;\n\
    \        long b2 = interval2.Item2;\n        long l = Intersect(a1, a2, b1, b2);\n\
    \        return IsPrime(l) ? \"YES\" : \"NO\";", "        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2) {\n            return\
    \ \"NO\";\n        }\n        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ Prime(end - start + 1) ? \"YES\" : \"NO\";", "        long s1 = interval1.Item1;\n\
    \        long e1 = interval1.Item2;\n        long s2 = interval2.Item1;\n    \
    \    long e2 = interval2.Item2;\n        long l = Math.Max(s1, s2);\n        long\
    \ r = Math.Min(e1, e2);\n        if (l > r) {\n            return \"NO\";\n  \
    \      }\n        return IsPrime(r - l + 1) ? \"YES\" : \"NO\";", "        long\
    \ start1 = interval1.Item1;\n        long end1 = interval1.Item2;\n        long\
    \ start2 = interval2.Item1;\n        long end2 = interval2.Item2;\n        long\
    \ start = Math.Max(start1, start2);\n        long end = Math.Min(end1, end2);\n\
    \        return start > end ? \"NO\" : IsPrime(end - start + 1) ? \"YES\" : \"\
    NO\";", "        bool isIntersect = interval1.Item1 <= interval2.Item2 && interval2.Item1\
    \ <= interval1.Item2;\n        if (isIntersect) {\n            var i1 = interval1.Item1\
    \ <= interval2.Item1 ? interval2.Item1 : interval1.Item1;\n            var i2\
    \ = interval1.Item2 <= interval2.Item2 ? interval1.Item2 : interval2.Item2;\n\
    \            var delta = i2 - i1 + 1;\n            return isPrime(delta) ? \"\
    YES\" : \"NO\";\n        }\n        return \"NO\";", "        long l1 = interval1.Item1;\n\
    \        long l2 = interval1.Item2;\n        long r1 = interval2.Item1;\n    \
    \    long r2 = interval2.Item2;\n        long l = Math.Max(l1, r1);\n        long\
    \ r = Math.Min(l2, r2);\n        if (l <= r) {\n            long d = r - l + 1;\n\
    \            if (IsPrime(d)) {\n                return \"YES\";\n            }\n\
    \        }\n        return \"NO\";", "        var max = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var min = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (max > min) return \"NO\";\n        var count = Math.Abs(min - max);\n\
    \        var a = 2;\n        while (a * a <= count) {\n            if (count %\
    \ a == 0) {\n                return \"NO\";\n            }\n            a++;\n\
    \        }\n        return \"YES\";", "        var start1 = interval1.Item1;\n\
    \        var end1 = interval1.Item2;\n        var start2 = interval2.Item1;\n\
    \        var end2 = interval2.Item2;\n        var intStart = Math.Max(start1,\
    \ start2);\n        var intEnd = Math.Min(end1, end2);\n        if (intStart <=\
    \ intEnd) {\n            var len = intEnd - intStart + 1;\n            var isPrime\
    \ = true;\n            for (var i = 2; i <= Math.Sqrt(len); i++) {\n         \
    \       if (len % i == 0) {\n                    isPrime = false;\n          \
    \          break;\n                }\n            }\n            return isPrime\
    \ ? \"YES\" : \"NO\";\n        }\n        return \"NO\";", "        // your code\
    \ here\n        // return \"YES\" if the intersection is a prime, \"NO\" otherwise.\n\
    \        long a = interval1.Item1;\n        long b = interval1.Item2;\n      \
    \  long c = interval2.Item1;\n        long d = interval2.Item2;\n        long\
    \ q = Math.Max(a, c);\n        long p = Math.Min(b, d);\n        if (p < q) {\n\
    \            return \"NO\";\n        }\n        var result = \"NO\";\n       \
    \ if (p - q + 1 == 2 || p - q + 1 == 3 || p - q + 1 == 5 || p - q + 1 == 7) {\n\
    \            result = \"YES\";\n        }\n        return result;", "        int\
    \ a = interval1.Item1 < interval2.Item1 ? interval2.Item1 : interval1.Item1;\n\
    \        int b = interval1.Item2 < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n\
    \        if (a > b) return \"NO\";\n        int c = b - a + 1;\n        return\
    \ isPrime(c) ? \"YES\" : \"NO\";", "        long x1 = interval1.Item1;\n     \
    \   long y1 = interval1.Item2;\n        long x2 = interval2.Item1;\n        long\
    \ y2 = interval2.Item2;\n        long diff = 0;\n        // check if the intervals\
    \ intersect\n        // if interval1 is left of interval2\n        if (x1 < x2)\
    \ {\n            // if interval1 is right of interval2\n            if (y1 < x2)\
    \ {\n                return \"NO\";\n            }\n            // otherwise find\
    \ the intersection length\n            diff = y1 - x2;\n        }\n        //\
    \ if interval2 is left of interval1\n        else if (x2 < x1) {\n           \
    \ // if interval2 is right of interval1\n            if (y2 < x1) {\n        \
    \        return \"NO\";\n            }\n            // otherwise find the intersection\
    \ length\n            diff = y2 - x1;\n        }\n        // if the intervals\
    \ are the same\n        else {\n            diff = y1 - x1;\n        }\n     \
    \   // return \"YES\" if the length is prime\n        return IsPrime(diff) ? \"\
    YES\" : \"NO\";", "        // n 1        2        3        4        5        6\
    \        7       8\n        //      |-------|       |-------|       |-------|\
    \       |-------|\n        //           |-------|       |-------|       |-------|\
    \       |-------|\n        //                   |-------|       |-------|    \
    \   |-------|       |-------|\n        //                               |-------|\
    \       |-------|       |-------|       |-------|\n        // intervals\n    \
    \    //      |-----------------|\n        //      |-------------|\n        //\
    \                   |-----------------|\n        //          |-----------------|\n\
    \        //                           |-----------------|\n        //        \
    \                           |-----------------|\n        // intersections\n  \
    \      //                                   |---|\n\n        long min1 = interval1.Item1;\n\
    \        long max1 = interval1.Item2;\n        long min2 = interval2.Item1;\n\
    \        long max2 = interval2.Item2;\n\n        // check if they overlap\n  \
    \      if (max1 < min2 || max2 < min1) {\n            return \"NO\";\n       \
    \ }\n\n        long start = Math.Max(min1, min2);\n        long end = Math.Min(max1,\
    \ max2);\n\n        var len = end - start + 1;\n        return IsPrime(len) ?\
    \ \"YES\" : \"NO\";", '        return IsPrime(intersection(interval1, interval2))
    ? "YES" : "NO";', "        // your code here...\n        long min = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long max = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long diff = max - min;\n        if (diff > 0)\n            return IsPrime(diff)\
    \ ? \"YES\" : \"NO\";\n        return \"NO\";", "        var a = interval1.Item1;\n\
    \        var b = interval1.Item2;\n        var c = interval2.Item1;\n        var\
    \ d = interval2.Item2;\n        var L = Math.Max(a, c);\n        var R = Math.Min(b,\
    \ d);\n        if (L > R) {\n            return \"NO\";\n        }\n        var\
    \ n = R - L + 1;\n        if (n < 2) {\n            return \"NO\";\n        }\n\
    \        if (n == 2) {\n            return \"YES\";\n        }\n        return\
    \ isPrime(n) ? \"YES\" : \"NO\";", "        var isec = Tuple.Create(Math.Max(interval1.Item1,\
    \ interval2.Item1), Math.Min(interval1.Item2, interval2.Item2));\n        var\
    \ len = isec.Item2 - isec.Item1 + 1;\n        if (len < 1) return \"NO\";\n  \
    \      return new[] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97}.Contains(len) ? \"YES\" : \"NO\";", "  \
    \      long start1 = interval1.Item1;\n        long end1 = interval1.Item2;\n\
    \        long start2 = interval2.Item1;\n        long end2 = interval2.Item2;\n\
    \        long newStart = Math.Max(start1, start2);\n        long newEnd = Math.Min(end1,\
    \ end2);\n        long diff = newEnd - newStart;\n        if (diff >= 0) {\n \
    \           bool isPrime = true;\n            for (long i = 2; i <= diff / 2;\
    \ i++) {\n                if (diff % i == 0) {\n                    isPrime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if (isPrime) {\n                return \"YES\";\n            }\n     \
    \   }\n        return \"NO\";", "        if (interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2) {\n            return \"NO\";\n      \
    \  }\n        var s = Math.Max(interval1.Item1, interval2.Item1);\n        var\
    \ e = Math.Min(interval1.Item2, interval2.Item2);\n        var len = e - s + 1;\n\
    \        return IsPrime(len) ? \"YES\" : \"NO\";", "        var lower = interval1.Item1\
    \ > interval2.Item1 ? interval1.Item1 : interval2.Item1;\n        var upper =\
    \ interval1.Item2 < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n   \
    \     if (lower > upper) {\n            return \"NO\";\n        }\n        var\
    \ dist = upper - lower;\n        if (dist == 0) {\n            return \"YES\"\
    ;\n        }\n        var sqrt = (long)Math.Sqrt(dist);\n        for (long i =\
    \ 2; i <= sqrt; i++) {\n            if (dist % i == 0) {\n                return\
    \ \"NO\";\n            }\n        }\n        return \"YES\";", "        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2) {\n            return\
    \ \"NO\";\n        }\n        var len = Math.Abs(Math.Min(interval1.Item2, interval2.Item2)\
    \ - Math.Max(interval1.Item1, interval2.Item1)) + 1;\n        return IsPrime(len)\
    \ ? \"YES\" : \"NO\";", "        if (interval1.Item1 > interval2.Item2 || interval2.Item1\
    \ > interval1.Item2) {\n            return \"NO\";\n        }\n        var start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        var end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start == end) {\n            return \"NO\";\n\
    \        }\n        return IntervalLengthIsPrime(start, end) ? \"YES\" : \"NO\"\
    ;", "        // check for intersection\n        if(!intersectionExists(interval1,\
    \ interval2)) {\n            return \"NO\";\n        }\n\n        var intersection\
    \ = calculateIntersection(interval1, interval2);\n        var length = intersection.Item2\
    \ - intersection.Item1 + 1;\n\n        return isPrime(length) ? \"YES\" : \"NO\"\
    ;", "        var a = interval1.Item1;\n        var b = interval1.Item2;\n    \
    \    var c = interval2.Item1;\n        var d = interval2.Item2;\n        // if\
    \ b < c or d < a, then these intervals dont intersect\n        if (b < c || d\
    \ < a) {\n            return \"NO\";\n        }\n        // else, find the max\
    \ and min of the start/end points of the interval\n        // to obtain the interval\
    \ of the intersection\n        var start = Math.Max(a, c);\n        var end =\
    \ Math.Min(b, d);\n        // determine if the length of this interval is prime\n\
    \        if (IsPrime(end - start + 1)) {\n            return \"YES\";\n      \
    \  }\n        return \"NO\";", "        long i1S = interval1.Item1;\n        long\
    \ i1E = interval1.Item2;\n        long i2S = interval2.Item1;\n        long i2E\
    \ = interval2.Item2;\n        long s = Math.Max(i1S, i2S);\n        long e = Math.Min(i1E,\
    \ i2E);\n        if (s > e) {\n            return \"NO\";\n        }\n       \
    \ BigInteger val = BigInteger.Parse(e.ToString()) - BigInteger.Parse(s.ToString())\
    \ + 1;\n        if (val == 1) {\n            return \"NO\";\n        }\n     \
    \   return IsPrime(val) ? \"YES\" : \"NO\";", "        if(interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2) {\n            return \"NO\";\n      \
    \  }\n        var intersectionStart = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var intersectionEnd = Math.Min(interval1.Item2, interval2.Item2);\n \
    \       var length = intersectionEnd - intersectionStart + 1;\n        return\
    \ length == 2 || length == 3 || length == 5 || length == 7 ? \"YES\" : \"NO\";",
  "        // find the intersection of the two intervals, if any.\n        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start > end) {\n            return \"NO\";\n\
    \        }\n        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "  \
    \      var lowestStart = Math.Max(interval1.Item1, interval2.Item1);\n       \
    \ var highestEnd = Math.Min(interval1.Item2, interval2.Item2);\n        var length\
    \ = Math.Max(highestEnd - lowestStart, 0);\n        var isPrime = !(length > 2)\
    \ && (length == 2 || IsPrime(length));\n        return isPrime ? \"YES\" : \"\
    NO\";", "        // A prime number (or a prime) is a natural number greater than\
    \ 1\n        // that has no positive divisors other than 1 and itself.\n     \
    \   // A natural number greater than 1 that is not a prime number is called a\
    \ composite number.\n        // - for any prime number, except 2, its last digit\
    \ is either 1, 3, 7 or 9.\n        // - for any prime number, except 2 and 5,\
    \ there is no even digit\n        // - for any prime number, except 2, 3 and 5,\
    \ there is no digit 3, 5 or 7.\n        // - for any prime number, except 2, 5,\
    \ 7 and 9, there is no digit 9.\n        // - for any prime number, except 2,\
    \ 5, 7 and 9, there is no digit 9.\n        // - the first few prime numbers are\
    \ 2, 3, 5, 7, 11, 13, 17, 19 and 23.\n        // - a prime number has no divisors\
    \ except 1 and itself\n        // - a prime number has exactly two positive divisors\n\
    \        // - a prime number is a number which is greater than 1 and cannot be\
    \ formed\n        // by multiplying two smaller natural numbers\n        // -\
    \ a prime number is a whole number greater than 1 that can only be divided\n \
    \       // by itself and 1.\n        // - a prime number is a whole number greater\
    \ than 1 whose only factors are 1 and itself\n        // - the first prime number\
    \ is 2\n        // - no even number, except 2, is prime\n        // - a prime\
    \ number must be greater than 1\n        // - 1 is not a prime number\n      \
    \  // - two is the only even prime number\n        // - prime numbers are divisible\
    \ only by 1 and by itself.\n        // - prime numbers are divisible only by 1,\
    \ itself and by 2\n        // - for any prime number, except 2, its last digit\
    \ is either 1, 3, 7 or 9.\n        // - for any prime number, except 2 and 5,\
    \ there is no even digit\n        // - for any prime number, except 2, 3 and 5,\
    \ there is no digit 3, 5 or 7.\n        // - for any prime number, except 2, 5,\
    \ 7 and 9, there is no digit 9.\n        // - for any prime number, except 2,\
    \ 5, 7 and 9, there is no digit", "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (start > end) return \"NO\";\n        long length = end - start +\
    \ 1;\n        return IsPrime(length) ? \"YES\" : \"NO\";", "        var min =\
    \ Math.Max(interval1.Item1, interval2.Item1);\n        var max = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (min > max) return \"NO\";\n        if (min ==\
    \ max) return \"YES\";\n        for (var i = min + 1; i < max; i++) {\n      \
    \      if (i.IsPrime()) return \"YES\";\n        }\n        return \"NO\";", " \
    \       // check if the two intervals have intersection\n        if (interval1.Item2\
    \ < interval2.Item1 || interval2.Item2 < interval1.Item1) {\n            return\
    \ \"NO\";\n        }\n\n        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        var len\
    \ = end - start + 1;\n        return IsPrime(len) ? \"YES\" : \"NO\";", "    \
    \    long start = Math.Max(interval1.Item1, interval2.Item1);\n        long end\
    \ = Math.Min(interval1.Item2, interval2.Item2);\n        long length = Math.Max(end\
    \ - start + 1, 0);\n        return IsPrime(length) ? \"YES\" : \"NO\";", "   \
    \     long[] l = new long[] { interval1.Item1, interval1.Item2, interval2.Item1,\
    \ interval2.Item2 };\n        if (l.All(x => x < 0) || l.All(x => x > 0)) {\n\
    \            return \"NO\";\n        }\n        long max = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long min = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long d = min - max;\n        if (d < 0) {\n            return \"NO\"\
    ;\n        }\n        return IsPrime(d) ? \"YES\" : \"NO\";", "        BigInteger\
    \ maxStart = BigInteger.Max(interval1.Item1, interval2.Item1);\n        BigInteger\
    \ minEnd = BigInteger.Min(interval1.Item2, interval2.Item2);\n        BigInteger\
    \ intersectionLen = minEnd - maxStart + 1;\n        return IsPrime(intersectionLen)\
    \ ? \"YES\" : \"NO\";", "        long low = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long high = Math.Min(interval1.Item2, interval2.Item2);\n        if (low\
    \ <= high) {\n            return IsPrime(high - low + 1) ? \"YES\" : \"NO\";\n\
    \        }\n        return \"NO\";", '        return isPrime(intersectionLength(interval1,
    interval2)) ? "YES" : "NO";', "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long length = end - start + 1;\n        return IsPrime(length) ? \"YES\"\
    \ : \"NO\";", "        if (interval1.Item1 > interval2.Item2 || interval2.Item1\
    \ > interval1.Item2) {\n            return \"NO\";\n        }\n\n        var start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        var end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        return Intersection(start, end) ? \"YES\" : \"NO\"\
    ;", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n      \
    \  long end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start >\
    \ end) {\n            return \"NO\";\n        }\n        long length = end - start\
    \ + 1;\n        return IsPrime(length) ? \"YES\" : \"NO\";", "        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start > end) {\n            return \"NO\";\n\
    \        }\n        return end - start > 1 ? \"NO\" : \"YES\";", "        string\
    \ ans = \"NO\";\n        long start = (interval1.Item1 > interval2.Item1) ? interval1.Item1\
    \ : interval2.Item1;\n        long end = (interval1.Item2 < interval2.Item2) ?\
    \ interval1.Item2 : interval2.Item2;\n        if (start <= end) {\n          \
    \  if (IsPrime(end - start + 1)) ans = \"YES\";\n        }\n        return ans;",
  "        // Your code goes here\n        bool is_intersect = false;\n        var\
    \ start1 = interval1.Item1;\n        var end1 = interval1.Item2;\n        var\
    \ start2 = interval2.Item1;\n        var end2 = interval2.Item2;\n        var\
    \ start_intersect = Math.Max(start1, start2);\n        var end_intersect = Math.Min(end1,\
    \ end2);\n        if (start_intersect <= end_intersect) {\n            is_intersect\
    \ = true;\n        }\n        if (is_intersect == false) {\n            return\
    \ \"NO\";\n        }\n        var length_intersect = end_intersect - start_intersect\
    \ + 1;\n        var is_prime = IsPrime(length_intersect);\n        if (is_prime)\
    \ {\n            return \"YES\";\n        } else {\n            return \"NO\"\
    ;\n        }", "        // Your code here!\n        var a = interval1.Item1;\n\
    \        var b = interval1.Item2;\n        var c = interval2.Item1;\n        var\
    \ d = interval2.Item2;\n        if (c > a) {\n            if (d < b) {\n     \
    \           if (d > c)\n                    return IsPrime(d - c) ? \"YES\" :\
    \ \"NO\";\n                else\n                    return \"NO\";\n        \
    \    } else {\n                if (b > c)\n                    return IsPrime(b\
    \ - c) ? \"YES\" : \"NO\";\n                else\n                    return \"\
    NO\";\n            }\n        } else {\n            if (d < b) {\n           \
    \     if (d > a)\n                    return IsPrime(d - a) ? \"YES\" : \"NO\"\
    ;\n                else\n                    return \"NO\";\n            } else\
    \ {\n                if (b > a)\n                    return IsPrime(b - a) ? \"\
    YES\" : \"NO\";\n                else\n                    return \"NO\";\n  \
    \          }\n        }", "        long maxStart = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long minEnd = Math.Min(interval1.Item2, interval2.Item2);\n        if\
    \ (maxStart > minEnd) {\n            return \"NO\";\n        }\n        long len\
    \ = minEnd - maxStart + 1;\n        if (len == 1) {\n            return \"NO\"\
    ;\n        }\n        var isPrime = new bool[len];\n        for (int i = 2; i\
    \ < len; i++) {\n            isPrime[i] = true;\n        }\n        for (int i\
    \ = 2; i < len; i++) {\n            if (isPrime[i]) {\n                for (int\
    \ j = i + i; j < len; j += i) {\n                    isPrime[j] = false;\n   \
    \             }\n            }\n        }\n        return isPrime[len - 1] ? \"\
    YES\" : \"NO\";", "        //TODO: determine if the length of the intersection\
    \ of two intervals is a prime number\n        if (interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2)\n            return \"NO\";\n        if\
    \ (interval1.Item1 > interval2.Item1)\n            return IsPrime(interval1.Item1\
    \ - interval2.Item2) ? \"YES\" : \"NO\";\n        return IsPrime(interval2.Item1\
    \ - interval1.Item2) ? \"YES\" : \"NO\";", "        long s1 = interval1.Item1;\n\
    \        long e1 = interval1.Item2;\n        long s2 = interval2.Item1;\n    \
    \    long e2 = interval2.Item2;\n        // if (s1 > e1 || s2 > e2) return \"\
    NO\";\n        long s = Math.Max(s1, s2);\n        long e = Math.Min(e1, e2);\n\
    \        if (s > e) return \"NO\";\n        return (IsPrime(e - s + 1)) ? \"YES\"\
    \ : \"NO\";", "        // TODO: Implement your solution here\n        long start1\
    \ = interval1.Item1;\n        long end1 = interval1.Item2;\n        long start2\
    \ = interval2.Item1;\n        long end2 = interval2.Item2;\n        long min1\
    \ = Math.Min(start1, end1);\n        long max1 = Math.Max(start1, end1);\n   \
    \     long min2 = Math.Min(start2, end2);\n        long max2 = Math.Max(start2,\
    \ end2);\n        long start = Math.Max(min1, min2);\n        long end = Math.Min(max1,\
    \ max2);\n        if (start > end) {\n            return \"NO\";\n        }\n\
    \        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        long A\
    \ = interval1.Item1;\n        long B = interval1.Item2;\n        long C = interval2.Item1;\n\
    \        long D = interval2.Item2;\n        if (D < A || B < C) {\n          \
    \  return \"NO\";\n        }\n        else {\n            return IsPrime(Math.Min(B,\
    \ D) - Math.Max(A, C) + 1) ? \"YES\" : \"NO\";\n        }", "        long[] left\
    \ = new long[] { interval1.Item1, interval2.Item1 };\n        long[] right = new\
    \ long[] { interval1.Item2, interval2.Item2 };\n        Array.Sort(left);\n  \
    \      Array.Sort(right);\n        long leftEnd = left[1];\n        long rightStart\
    \ = right[0];\n        if (leftEnd < rightStart) {\n            return \"NO\"\
    ;\n        }\n        long intersectionLength = rightStart - leftEnd;\n      \
    \  return IsPrime(intersectionLength) ? \"YES\" : \"NO\";", "        long a =\
    \ interval1.Item1;\n        long b = interval1.Item2;\n        long c = interval2.Item1;\n\
    \        long d = interval2.Item2;\n        long length = (Math.Min(b, d) - Math.Max(a,\
    \ c) + 1);\n        bool isPrime = IsPrime(length);\n        return (isPrime)\
    \ ? \"YES\" : \"NO\";", "        var a = interval1.Item1;\n        var b = interval1.Item2;\n\
    \        var c = interval2.Item1;\n        var d = interval2.Item2;\n        var\
    \ minStart = Math.Max(a, c);\n        var maxEnd = Math.Min(b, d);\n        if\
    \ (minStart > maxEnd) {\n            return \"NO\";\n        }\n        var length\
    \ = maxEnd - minStart + 1;\n        if (length < 2) {\n            return \"NO\"\
    ;\n        }\n        if (length == 2) {\n            return \"YES\";\n      \
    \  }\n        for (long i = 2; i <= length / 2; i++) {\n            if (length\
    \ % i == 0) {\n                return \"NO\";\n            }\n        }\n    \
    \    return \"YES\";", "        // find start, end of intersection\n        var\
    \ start = Math.Max(interval1.Item1, interval2.Item1);\n        var end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        // no intersection if start > end\n        if (start\
    \ > end) {\n            return \"NO\";\n        }\n        // compute length of\
    \ intersection\n        var length = end - start + 1;\n        // return YES if\
    \ length is prime, NO otherwise\n        return isPrime(length) ? \"YES\" : \"\
    NO\";", "        if(interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\n\
    \            return \"NO\";\n        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        var length\
    \ = end - start + 1;\n        var result = IsPrime(length);\n        return result\
    \ ? \"YES\" : \"NO\";", "        long start1 = interval1.Item1;\n        long\
    \ end1 = interval1.Item2;\n        long start2 = interval2.Item1;\n        long\
    \ end2 = interval2.Item2;\n        long start = Math.Max(start1, start2);\n  \
    \      long end = Math.Min(end1, end2);\n        if (start > end) {\n        \
    \    return \"NO\";\n        }\n        return (end - start + 1).IsPrime().ToString().ToUpper();",
  "        long start = Math.Max(interval1.Item1, interval2.Item1);\n        long\
    \ end = Math.Min(interval1.Item2, interval2.Item2);\n        long length = end\
    \ - start + 1;\n        if (length <= 0) return \"NO\";\n        return IsPrime(length)\
    \ ? \"YES\" : \"NO\";", "        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start\
    \ > end) return \"NO\";\n        for (long i = start; i <= end; i++) {\n     \
    \       if (IsPrime(i)) return \"YES\";\n        }\n        return \"NO\";", " \
    \       long start1 = interval1.Item1;\n        long end1 = interval1.Item2;\n\
    \        long start2 = interval2.Item1;\n        long end2 = interval2.Item2;\n\
    \        long start = Math.Max(start1, start2);\n        long end = Math.Min(end1,\
    \ end2);\n        if (start > end) {\n            return \"NO\";\n        }\n\
    \        long length = end - start + 1;\n        if (length < 2) {\n         \
    \   return \"NO\";\n        }\n        bool isPrime = true;\n        for (long\
    \ i = 2; i * i <= length; i++) {\n            if (length % i == 0) {\n       \
    \         isPrime = false;\n                break;\n            }\n        }\n\
    \        return isPrime ? \"YES\" : \"NO\";", "        if (interval1.Item1 > interval2.Item2\
    \ || interval2.Item1 > interval1.Item2)\n            return \"NO\";\n        long\
    \ start = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long len = end - start + 1;\n        return len ==\
    \ 1 ? \"NO\" : len == 2 ? \"YES\" : IsPrime(len) ? \"YES\" : \"NO\";", "     \
    \   BigInteger intersectionBegin = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        BigInteger intersectionEnd = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (intersectionBegin > intersectionEnd) {\n            return \"NO\"\
    ;\n        }\n        BigInteger intersectionLength = intersectionEnd - intersectionBegin\
    \ + 1;\n        return IsPrime(intersectionLength) ? \"YES\" : \"NO\";", "   \
    \     var int1 = (interval1.Item1 > interval2.Item1) ? interval1 : interval2;\n\
    \        var int2 = (interval1.Item1 > interval2.Item1) ? interval2 : interval1;\n\
    \        var int1end = int1.Item2;\n        var int2end = int2.Item2;\n      \
    \  var int1start = int1.Item1;\n        var int2start = int2.Item1;\n        if\
    \ (int1start > int2end || int2start > int1end) return \"NO\";\n        long result\
    \ = (int1start > int2start) ? (int1start - int2start) : (int2start - int1start);\n\
    \        return IsPrime(result) ? \"YES\" : \"NO\";", "        var i1 = interval1;\n\
    \        var i2 = interval2;\n        if (i1.Item1 > i2.Item1) {\n           \
    \ i1 = interval2;\n            i2 = interval1;\n        }\n        var isIntersect\
    \ = i1.Item2 >= i2.Item1;\n        if (!isIntersect) return \"NO\";\n        var\
    \ len = Math.Min(i1.Item2, i2.Item2) - i2.Item1 + 1;\n        return len.IsPrime()\
    \ ? \"YES\" : \"NO\";", "        var a = interval1.Item1;\n        var b = interval1.Item2;\n\
    \        var c = interval2.Item1;\n        var d = interval2.Item2;\n        if\
    \ (a > b) {\n            long t = a;\n            a = b;\n            b = t;\n\
    \        }\n        if (c > d) {\n            long t = c;\n            c = d;\n\
    \            d = t;\n        }\n        if (c > b || a > d) {\n            return\
    \ \"NO\";\n        }\n        if (c > a) {\n            a = c;\n        }\n  \
    \      if (b > d) {\n            b = d;\n        }\n        long n = b - a + 1;\n\
    \        return isPrime(n) ? \"YES\" : \"NO\";", "        // return \"YES\";\n\
    \        long start1 = interval1.Item1;\n        long end1 = interval1.Item2;\n\
    \        long start2 = interval2.Item1;\n        long end2 = interval2.Item2;\n\
    \        long l1 = end1 - start1 + 1;\n        long l2 = end2 - start2 + 1;\n\
    \        if (start1 <= start2 && start2 <= end1) {\n            // Intersects\n\
    \            long start = start2;\n            long end = Math.Min(end1, end2);\n\
    \            long length = end - start + 1;\n            return (IsPrime(length))\
    \ ? \"YES\" : \"NO\";\n        } else if (start2 <= start1 && start1 <= end2)\
    \ {\n            // Intersects\n            long start = start1;\n           \
    \ long end = Math.Min(end1, end2);\n            long length = end - start + 1;\n\
    \            return (IsPrime(length)) ? \"YES\" : \"NO\";\n        } else {\n\
    \            // Does not intersect\n            return \"NO\";\n        }", " \
    \       if (interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n\n        var start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        var end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        var diff = end - start + 1;\n        if (diff <= 1) {\n            return\
    \ \"NO\";\n        }\n        if (diff == 2) {\n            return \"YES\";\n\
    \        }\n        return IsPrime(diff) ? \"YES\" : \"NO\";", "        var (left,\
    \ right) = Intersection(interval1, interval2);\n        return (left == right)\
    \ ? \"NO\" : (IsPrime(right - left + 1) ? \"YES\" : \"NO\");", "        long Intersect(long\
    \ i1, long i2) {\n            if (i1 > i2) {\n                return 0;\n    \
    \        }\n            return i2 - i1 + 1;\n        }\n        long length =\
    \ Intersect(Math.Max(interval1.Item1, interval2.Item1), Math.Min(interval1.Item2,\
    \ interval2.Item2));\n        if (length <= 0) {\n            return \"NO\";\n\
    \        }\n        return IsPrime(length) ? \"YES\" : \"NO\";", "        long\
    \ start = interval1.Item1 > interval2.Item1 ? interval1.Item1 : interval2.Item1;\n\
    \        long end = interval1.Item2 < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n\
    \        if (start >= end) {\n            return \"NO\";\n        }\n        long\
    \ len = end - start;\n        return IsPrime(len) ? \"YES\" : \"NO\";", "    \
    \    long start = Math.Max(interval1.Item1, interval2.Item1);\n        long end\
    \ = Math.Min(interval1.Item2, interval2.Item2);\n        long len = Math.Max(end\
    \ - start + 1, 0);\n        return (len == 0 || IsPrime(len)) ? \"YES\" : \"NO\"\
    ;", "        bool DoesIntersect = (interval1.Item1 <= interval2.Item2 && interval2.Item1\
    \ <= interval1.Item2);\n        if (DoesIntersect) {\n            var a = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n            var b = Math.Min(interval1.Item2, interval2.Item2);\n\
    \            var len = b - a + 1;\n            return (len == 1 || len == 2 ||\
    \ IsPrime(len)) ? \"YES\" : \"NO\";\n        }\n        return \"NO\";", "   \
    \     if (interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n        if (interval1.Item1 < interval2.Item1)\
    \ {\n            var t = interval1;\n            interval1 = interval2;\n    \
    \        interval2 = t;\n        }\n        var low = interval1.Item1;\n     \
    \   var high = interval2.Item2;\n        if (high < low) {\n            var t\
    \ = low;\n            low = high;\n            high = t;\n        }\n        if\
    \ (high == low) {\n            return \"YES\";\n        }\n        var prime =\
    \ true;\n        for (var i = 2; i * i <= high; i++) {\n            if (high %\
    \ i == 0) {\n                prime = false;\n                break;\n        \
    \    }\n        }\n        return prime ? \"YES\" : \"NO\";", "        var result\
    \ = Intersect(interval1, interval2);\n        if (result == null) {\n        \
    \    return \"NO\";\n        }\n        var len = result.Item2 - result.Item1\
    \ + 1;\n        return IsPrime(len) ? \"YES\" : \"NO\";", "        if (interval1.Item1\
    \ > interval2.Item2 || interval2.Item1 > interval1.Item2) {\n            return\
    \ \"NO\";\n        }\n        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        long\
    \ length = end - start + 1;\n        return IsPrime(length) ? \"YES\" : \"NO\"\
    ;", "        if(interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n        long start = interval1.Item1\
    \ > interval2.Item1 ? interval1.Item1 : interval2.Item1;\n        long end = interval1.Item2\
    \ < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n        return IsPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";", "        // If intervals do not intersect,\
    \ return NO\n        if (interval1.Item2 < interval2.Item1 || interval2.Item2\
    \ < interval1.Item1)\n            return \"NO\";\n        // Find intersection\
    \ interval\n        var new_interval_left = interval1.Item1 > interval2.Item1\
    \ ? interval1.Item1 : interval2.Item1;\n        var new_interval_right = interval1.Item2\
    \ < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n        return IsPrime(new_interval_right\
    \ - new_interval_left + 1) ? \"YES\" : \"NO\";", "        // a1 <= b1 && a2 <=\
    \ b2\n        // intersection has to be positive, so we can\n        // take max\
    \ of each of the lower bounds, and\n        // then take min of each of the upper\
    \ bounds.\n        // if max1 < min2, then no intersection.\n        // if max2\
    \ < min1, then no intersection.\n        // else the intersection is from max1\
    \ to min2\n        var max1 = Math.Max(interval1.Item1, interval2.Item1);\n  \
    \      var max2 = Math.Max(interval1.Item2, interval2.Item2);\n        var min1\
    \ = Math.Min(interval1.Item1, interval2.Item1);\n        var min2 = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        // if they don't intersect, return no.\n        if\
    \ (max1 >= min2 || max2 <= min1) {\n            return \"NO\";\n        }\n  \
    \      var intersection = new Tuple<long, long>(max1, min2);\n        var intersectionLength\
    \ = intersection.Item2 - intersection.Item1 + 1;\n        // check if the length\
    \ of the intersection is prime.\n        if (intersectionLength < 2) {\n     \
    \       return \"NO\";\n        }\n        if (intersectionLength == 2) {\n  \
    \          return \"YES\";\n        }\n        if (intersectionLength % 2 == 0)\
    \ {\n            return \"NO\";\n        }\n        var sqrt = (long)Math.Floor(Math.Sqrt(intersectionLength));\n\
    \        for (var i = 3; i <= sqrt; i += 2) {\n            if (intersectionLength\
    \ % i == 0) {\n                return \"NO\";\n            }\n        }\n    \
    \    return \"YES\";", "        long min = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long max = Math.Min(interval1.Item2, interval2.Item2);\n        // debug\n\
    \        // Console.WriteLine(\"min: {0}, max: {1}\", min, max);\n        if (min\
    \ > max) return \"NO\";\n        return IsPrime(max - min + 1) ? \"YES\" : \"\
    NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n  \
    \      long end = Math.Min(interval1.Item2, interval2.Item2);\n        long len\
    \ = end - start + 1;\n        if (len < 0) {\n            return \"NO\";\n   \
    \     }\n        if (len < 2) {\n            return \"YES\";\n        }\n    \
    \    return len == 2 ? \"YES\" : len % 2 == 0 ? \"NO\" : IsPrime(len) ? \"YES\"\
    \ : \"NO\";", "        var x = Math.Max(interval1.Item1, interval2.Item1);\n \
    \       var y = Math.Min(interval1.Item2, interval2.Item2);\n        var len =\
    \ y - x + 1;\n        return Prime(len) ? \"YES\" : \"NO\";", "        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long length = end - start + 1;\n        if (length\
    \ < 1) {\n            return \"NO\";\n        }\n        if (length == 1) {\n\
    \            return \"YES\";\n        }\n        // length is at least 2.\n  \
    \      for (long i = 2; i * i <= length; i++) {\n            if (length % i ==\
    \ 0) {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        var l = interval1.Item1 < interval2.Item1 ? interval2.Item1\
    \ : interval1.Item1;\n        var r = interval1.Item2 < interval2.Item2 ? interval1.Item2\
    \ : interval2.Item2;\n        if (l > r) {\n            return \"NO\";\n     \
    \   }\n        return (r - l + 1).isPrime() ? \"YES\" : \"NO\";", "        //\
    \ Determine if the intersection of the two intervals is prime\n        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (start > end) return \"NO\";\n        long length\
    \ = end - start + 1;\n        if (length == 2) return \"YES\";\n        return\
    \ IsPrime(length) ? \"YES\" : \"NO\";", "        // Get the intersection point\
    \ of the intervals.\n        var intersectionPoint = getIntersectionPoint(interval1,\
    \ interval2);\n        // If the intersection is not a real interval, return no.\n\
    \        if (intersectionPoint.Item1 > intersectionPoint.Item2) {\n          \
    \  return \"NO\";\n        }\n        // Get the length of the intersection.\n\
    \        var length = intersectionPoint.Item2 - intersectionPoint.Item1 + 1;\n\
    \        // If the length is a prime, return yes, otherwise return no.\n     \
    \   return isPrime(length) ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long length = end - start + 1;\n        if (length < 0) {\n         \
    \   return \"NO\";\n        }\n        return IsPrime(length) ? \"YES\" : \"NO\"\
    ;", "        if (interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long length = end - start + 1;\n        if (isPrime(length)) {\n    \
    \        return \"YES\";\n        }\n        return \"NO\";", "        long int1Start\
    \ = interval1.Item1;\n        long int1End = interval1.Item2;\n        long int2Start\
    \ = interval2.Item1;\n        long int2End = interval2.Item2;\n        if (int1Start\
    \ > int1End) {\n            long tmp = int1Start;\n            int1Start = int1End;\n\
    \            int1End = tmp;\n        }\n        if (int2Start > int2End) {\n \
    \           long tmp = int2Start;\n            int2Start = int2End;\n        \
    \    int2End = tmp;\n        }\n        if (int1End < int2Start || int2End < int1Start)\
    \ {\n            return \"NO\";\n        }\n        long start = Math.Max(int1Start,\
    \ int2Start);\n        long end = Math.Min(int1End, int2End);\n        if (start\
    \ == end) {\n            return \"YES\";\n        }\n        return IsPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";", "        if (interval1.Item1 >= interval2.Item2\
    \ || interval2.Item1 >= interval1.Item2) {\n            return \"NO\";\n     \
    \   }\n        long start = Math.Max(interval1.Item1, interval2.Item1);\n    \
    \    long end = Math.Min(interval1.Item2, interval2.Item2);\n        var answer\
    \ = end - start + 1;\n        if (answer <= 1) {\n            return \"NO\";\n\
    \        }\n        if (IsPrime(answer)) {\n            return \"YES\";\n    \
    \    }\n        return \"NO\";", "        // The intersection length of two intervals\
    \ A and B can be expressed as:\n        // |A.x - B.x| + |A.y - B.y| - |A.x -\
    \ A.y| - |B.x - B.y|\n        // For example:\n        // |-1 - 2| + |-1 - 3|\
    \ - |-1 - (-1)| - |2 - 3| = 2 + 2 - 2 - 1 = 3\n        // This function is not\
    \ linear in either input.\n        // It includes one abs() call and two subtractions.\n\
    \        var aX = interval1.Item1;\n        var aY = interval1.Item2;\n      \
    \  var bX = interval2.Item1;\n        var bY = interval2.Item2;\n        var aLen\
    \ = aY - aX;\n        var bLen = bY - bX;\n        var lhs = Math.Abs(aX - bX)\
    \ + Math.Abs(aY - bY);\n        var rhs = aLen + bLen;\n        var intersectionLength\
    \ = lhs - rhs;\n        if (intersectionLength < 0) return \"NO\";\n        else\
    \ return IsPrime(intersectionLength) ? \"YES\" : \"NO\";", "        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long length = end - start + 1;\n        if (length\
    \ < 0) return \"NO\";\n        // 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97\n        // \"YES\" is supposed\
    \ to be returned for l in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n        // and \"NO\" otherwise.\n\
    \        return (length == 2 || length == 3 || length == 5 || length == 7 || length\
    \ == 11 || length == 13 || length == 17 || length == 19 || length == 23 || length\
    \ == 29 || length == 31 || length == 37 || length == 41 || length == 43 || length\
    \ == 47 || length == 53 || length == 59 || length == 61 || length == 67 || length\
    \ == 71 || length == 73 || length == 79 || length == 83 || length == 89 || length\
    \ == 97) ? \"YES\" : \"NO\";", "        // convert parameters to BigIntegers\n\
    \        // using Tuple.Item1 and Tuple.Item2\n        BigInteger b1 = interval1.Item1;\n\
    \        BigInteger b2 = interval1.Item2;\n        BigInteger b3 = interval2.Item1;\n\
    \        BigInteger b4 = interval2.Item2;\n        // find the intersection\n\
    \        var i1 = BigInteger.Max(b1, b3);\n        var i2 = BigInteger.Min(b2,\
    \ b4);\n        // find its length\n        var i3 = i2 - i1 + 1;\n        //\
    \ check if it is prime number\n        var prime = IsPrime(i3);\n        return\
    \ prime ? \"YES\" : \"NO\";", "        var intervals = new List<Tuple<long, long>>\
    \ { interval1, interval2 };\n        var sorted = intervals.OrderBy(a => a.Item1).ToList();\n\
    \        var result = new Tuple<long, long>(sorted[0].Item1, sorted[1].Item2);\n\
    \        if (result.Item1 > result.Item2) {\n            return \"NO\";\n    \
    \    }\n        return PrimeChecker.IsPrime(result.Item2 - result.Item1 + 1) ?\
    \ \"YES\" : \"NO\";", "        long start1 = interval1.Item1;\n        long end1\
    \ = interval1.Item2;\n        long start2 = interval2.Item1;\n        long end2\
    \ = interval2.Item2;\n        long start3 = Math.Max(start1, start2);\n      \
    \  long end3 = Math.Min(end1, end2);\n        long intersectionLength = end3 -\
    \ start3 + 1;\n        if (intersectionLength <= 0) {\n            return \"NO\"\
    ;\n        }\n        if (intersectionLength == 1) {\n            return \"YES\"\
    ;\n        }\n        if (intersectionLength == 2) {\n            return \"NO\"\
    ;\n        }\n        if (intersectionLength % 2 == 0) {\n            return \"\
    NO\";\n        }\n        long sqrt = (long)Math.Sqrt(intersectionLength);\n \
    \       for (long i = 3; i <= sqrt; i += 2) {\n            if (intersectionLength\
    \ % i == 0) {\n                return \"NO\";\n            }\n        }\n    \
    \    return \"YES\";", "        // check if the intervals intersect\n        if(interval1.Item2\
    \ < interval2.Item1 || interval2.Item2 < interval1.Item1) {\n            return\
    \ \"NO\";\n        }\n        // determine the intersection\n        long start\
    \ = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long len = end - start + 1;\n        // return result\n\
    \        if(len <= 1) {\n            return \"NO\";\n        }\n        // not\
    \ necessary, but it will speed up the execution\n        if(len < 2) {\n     \
    \       return \"YES\";\n        }\n        // check if the length is a prime\
    \ number\n        for(long i = 2; i * i <= len; i++) {\n            if(len % i\
    \ == 0) {\n                return \"NO\";\n            }\n        }\n        return\
    \ \"YES\";", "        var intersectionStart = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var intersectionEnd = Math.Min(interval1.Item2, interval2.Item2);\n \
    \       if (intersectionStart > intersectionEnd) return \"NO\";\n        long\
    \ len = intersectionEnd - intersectionStart + 1;\n        bool prime = true;\n\
    \        if (len < 2) prime = false;\n        else if (len == 2) prime = true;\n\
    \        else {\n            if (len % 2 == 0) prime = false;\n            else\
    \ {\n                int max = (int)Math.Ceiling(Math.Sqrt(len));\n          \
    \      for (int i = 3; i <= max; i += 2) {\n                    if (len % i ==\
    \ 0) {\n                        prime = false;\n                        break;\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ prime ? \"YES\" : \"NO\";", '        return IntersectionHelper(interval1, interval2)
    ? "YES" : "NO";', "        long start = interval1.Item1;\n        long end = interval1.Item2;\n\
    \        long lowerBound = interval2.Item1;\n        long upperBound = interval2.Item2;\n\
    \        if (lowerBound > upperBound) {\n            long tmp = lowerBound;\n\
    \            lowerBound = upperBound;\n            upperBound = tmp;\n       \
    \ }\n        if (start > end) {\n            long tmp = start;\n            start\
    \ = end;\n            end = tmp;\n        }\n        if (start > upperBound ||\
    \ end < lowerBound)\n            return \"NO\";\n        else {\n            if\
    \ (start > lowerBound)\n                lowerBound = start;\n            if (end\
    \ < upperBound)\n                upperBound = end;\n            return IsPrime(upperBound\
    \ - lowerBound + 1) ? \"YES\" : \"NO\";\n        }", "        long minEnd = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        long maxStart = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long length = minEnd - maxStart + 1;\n        if (length < 0) {\n   \
    \         return \"NO\";\n        }\n        for (long i = 2; i <= length / 2;\
    \ i++) {\n            if (length % i == 0) {\n                return \"NO\";\n\
    \            }\n        }\n        return \"YES\";", "        long min = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long max = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        if (min > max) return \"NO\";\n        long diff = max - min + 1;\n \
    \       return IsPrime(diff) ? \"YES\" : \"NO\";", "        // the smaller of\
    \ the two \"starts\"\n        var left = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        // the larger of the two \"ends\"\n        var right = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        var diff = right - left;\n        if (diff <= 0)\
    \ {\n            return \"NO\";\n        }\n        if (diff == 1) {\n       \
    \     return \"YES\";\n        }\n        return IsPrime(diff) ? \"YES\" : \"\
    NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n  \
    \      long end = Math.Min(interval1.Item2, interval2.Item2);\n        long length\
    \ = end - start + 1;\n        if (length < 1) return \"NO\";\n        else if\
    \ (length == 1) return \"YES\";\n        else if (length == 2) return \"NO\";\n\
    \        else if (length % 2 == 0) return \"NO\";\n        else {\n          \
    \  for (long i = 3; i <= Math.Ceiling(Math.Sqrt(length)); i += 2) {\n        \
    \        if (length % i == 0) return \"NO\";\n            }\n            return\
    \ \"YES\";\n        }", "        var min = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var max = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ min < max && isPrime(max - min) ? \"YES\" : \"NO\";", "        // Find the intersection\n\
    \        // of the two intervals\n        if(interval1.Item1 > interval2.Item2\
    \ ||\n           interval2.Item1 > interval1.Item2)\n            return \"NO\"\
    ;\n        var start = Math.Max(interval1.Item1, interval2.Item1);\n        var\
    \ end = Math.Min(interval1.Item2, interval2.Item2);\n        var interval = new\
    \ Tuple<long, long>(start, end);\n        // Compute the length of the intersection\n\
    \        var len = interval.Item2 - interval.Item1 + 1;\n        // Check if the\
    \ length is a prime number\n        if(len <= 1) return \"NO\";\n        // Compute\
    \ the square root of the number\n        var r = Math.Sqrt(len);\n        for(var\
    \ i = 2; i <= r; i++)\n            if(len % i == 0)\n                return \"\
    NO\";\n        return \"YES\";", '        return isPrime(intersectionLength(interval1,
    interval2)) ? "YES" : "NO";', "        if (interval1.Item1 > interval2.Item2 ||\
    \ interval2.Item1 > interval1.Item2) {\n            return \"NO\";\n        }\n\
    \        long min = Math.Max(interval1.Item1, interval2.Item1);\n        long\
    \ max = Math.Min(interval1.Item2, interval2.Item2);\n        return IsPrime(max\
    \ - min + 1) ? \"YES\" : \"NO\";", "        Tuple<long, long> inter = Intersect(interval1,\
    \ interval2);\n        if (inter == null) return \"NO\";\n        long diff =\
    \ inter.Item2 - inter.Item1 + 1;\n        return diff == 2 ? \"YES\" : \"NO\";",
  "        var start = Math.Max(interval1.Item1, interval2.Item1);\n        var end\
    \ = Math.Min(interval1.Item2, interval2.Item2);\n        if (start > end) {\n\
    \            return \"NO\";\n        }\n        var length = end - start + 1;\n\
    \        var prime = MathUtil.IsPrime(length);\n        return prime ? \"YES\"\
    \ : \"NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        if (start\
    \ > end) {\n            return \"NO\";\n        }\n        long length = end -\
    \ start + 1;\n        if (IsPrime(length)) {\n            return \"YES\";\n  \
    \      }\n        return \"NO\";", "        // interval1 <= interval2\n      \
    \  var start = interval1.Item1 > interval2.Item1 ? interval1.Item1 : interval2.Item1;\n\
    \        var end = interval1.Item2 < interval2.Item2 ? interval1.Item2 : interval2.Item2;\n\
    \        if (start > end) {\n            return \"NO\";\n        }\n        //\
    \ Prime: numbers that are only divisible by 1 and themselves\n        // Any number\
    \ that is divisible by 2 is not a prime number\n        // for any number <= 5,\
    \ use a simple rule to determine if it is a prime number\n        // for any number\
    \ > 5, use a simple rule to determine if it is a prime number\n        if (start\
    \ == 2) {\n            return \"YES\";\n        }\n        if (start == 3) {\n\
    \            return \"YES\";\n        }\n        if (start == 4) {\n         \
    \   return \"NO\";\n        }\n        if (start == 5) {\n            return \"\
    YES\";\n        }\n        if (start % 2 == 0) {\n            return \"NO\";\n\
    \        }\n        if (start % 3 == 0) {\n            return \"NO\";\n      \
    \  }\n        if (start % 5 == 0) {\n            return \"NO\";\n        }\n \
    \       // decide if a number is prime number based on the above rules\n     \
    \   // [6, n)\n        var isPrime = true;\n        var factor = 5;\n        for\
    \ (var i = 6; i < start; i++) {\n            if (i % 2 == 0) {\n             \
    \   continue;\n            }\n            if (i % 3 == 0) {\n                continue;\n\
    \            }\n            if (i % 5 == 0) {\n                continue;\n   \
    \         }\n            if (i % factor == 0) {\n                continue;\n \
    \           }\n            factor = i;\n            isPrime = true;\n        \
    \    for (var j = 5; j < i; j++) {\n                if (i % j == 0) {\n      \
    \              isPrime = false;\n                    break;\n                }\n\
    \            }\n            if (isPrime) {\n                continue;\n      \
    \      }\n            if (i == start - 1) {\n                return \"YES\";\n\
    \            }\n            return \"NO", "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long res = end - start + 1;\n        // if the intersection is empty\n\
    \        if (res <= 0) {\n            return \"NO\";\n        }\n        if (res\
    \ == 1) {\n            return \"NO\";\n        }\n        return \"YES\";", " \
    \       long istart = Math.Max(interval1.Item1, interval2.Item1);\n        long\
    \ iend = Math.Min(interval1.Item2, interval2.Item2);\n        if (istart > iend)\
    \ {\n            return \"NO\";\n        }\n        return isPrime(iend - istart\
    \ + 1) ? \"YES\" : \"NO\";", "        if (interval1.Item1 > interval2.Item2 ||\
    \ interval2.Item1 > interval1.Item2)\n            return \"NO\";\n        var\
    \ a = Math.Max(interval1.Item1, interval2.Item1);\n        var b = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        if (b - a == 0)\n            return \"NO\";\n   \
    \     if (b - a == 1)\n            return \"YES\";\n        return isPrime(b -\
    \ a) ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        long end = Math.Min(interval1.Item2, interval2.Item2);\n        long\
    \ len = end - start + 1;\n        if (len <= 0) return \"NO\";\n        return\
    \ (IsPrime(len)) ? \"YES\" : \"NO\";", "        var int1 = (new[] { interval1.Item1,\
    \ interval1.Item2 }).OrderBy(x => x).ToArray();\n        var int2 = (new[] { interval2.Item1,\
    \ interval2.Item2 }).OrderBy(x => x).ToArray();\n        if (int1[1] < int2[0]\
    \ || int2[1] < int1[0]) {\n            return \"NO\";\n        }\n        var\
    \ smallest = Math.Max(int1[0], int2[0]);\n        var largest = Math.Min(int1[1],\
    \ int2[1]);\n        if (largest - smallest <= 1) {\n            return \"NO\"\
    ;\n        }\n        return IsPrime(largest - smallest) ? \"YES\" : \"NO\";",
  "        if (interval1.Item1 > interval2.Item2 || interval2.Item1 > interval1.Item2)\
    \ {\n            return \"NO\";\n        }\n\n        // quick and dirty\n   \
    \     var a = new long[] { interval1.Item1, interval1.Item2, interval2.Item1,\
    \ interval2.Item2 };\n        Array.Sort(a);\n        return IsPrime(a[2] - a[1]\
    \ + 1) ? \"YES\" : \"NO\";", "        if(interval1.Item1 > interval2.Item2 ||\
    \ interval2.Item1 > interval1.Item2)\n            return \"NO\";\n        long\
    \ start = Math.Max(interval1.Item1, interval2.Item1);\n        long end = Math.Min(interval1.Item2,\
    \ interval2.Item2);\n        return isPrime(end - start + 1) ? \"YES\" : \"NO\"\
    ;", "        long start, end;\n        if (interval1.Item1 <= interval2.Item1)\
    \ {\n            start = interval2.Item1;\n        } else {\n            start\
    \ = interval1.Item1;\n        }\n        if (interval1.Item2 <= interval2.Item2)\
    \ {\n            end = interval1.Item2;\n        } else {\n            end = interval2.Item2;\n\
    \        }\n        if (start > end) {\n            return \"NO\";\n        }\n\
    \        return IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        var a\
    \ = interval1.Item1;\n        var b = interval1.Item2;\n        var c = interval2.Item1;\n\
    \        var d = interval2.Item2;\n        var x = Math.Max(a, c);\n        var\
    \ y = Math.Min(b, d);\n        if (x > y) {\n            return \"NO\";\n    \
    \    }\n        return IsPrime(y - x + 1) ? \"YES\" : \"NO\";", "        BigInteger\
    \ start = BigInteger.Max(interval1.Item1, interval2.Item1);\n        BigInteger\
    \ end = BigInteger.Min(interval1.Item2, interval2.Item2);\n        BigInteger\
    \ length = end - start + 1;\n        return length > 0 && IsPrime(length) ? \"\
    YES\" : \"NO\";", "        long a = interval1.Item1;\n        long b = interval1.Item2;\n\
    \        long c = interval2.Item1;\n        long d = interval2.Item2;\n      \
    \  long length = 0;\n        if (c > b || a > d) {\n            return \"NO\"\
    ;\n        }\n        if (a <= c && c <= b) {\n            length = b - c + 1;\n\
    \        } else if (c <= a && a <= d) {\n            length = d - a + 1;\n   \
    \     }\n        return IsPrime(length) ? \"YES\" : \"NO\";", "        long a\
    \ = interval1.Item1;\n        long b = interval1.Item2;\n        long c = interval2.Item1;\n\
    \        long d = interval2.Item2;\n        if (a > d || b < c) {\n          \
    \  return \"NO\";\n        }\n        long i = Math.Max(a, c);\n        long j\
    \ = Math.Min(b, d);\n        long n = j - i + 1;\n        if (n < 2) {\n     \
    \       return \"NO\";\n        }\n        for (long k = 2; k * k <= n; k++) {\n\
    \            if (n % k == 0) {\n                return \"NO\";\n            }\n\
    \        }\n        return \"YES\";", "        // The length of the intersection\
    \ of two intervals is the length of\n        // their intersection as integers.\n\
    \        // If the intersection doesn't exist, the length of the intersection\n\
    \        // is zero.\n        // The length of the intersection of (1, 2) and\
    \ (2, 3) is 1.\n        // The length of the intersection of (1, 2) and (3, 4)\
    \ is 0.\n        // If the length of the intersection is not greater than zero,\n\
    \        // return \"NO\".\n        // Otherwise, check if the length of the intersection\
    \ is a prime number.\n        if (interval1.Item1 > interval2.Item2 || interval2.Item1\
    \ > interval1.Item2) {\n            return \"NO\";\n        }\n        // Since\
    \ the intervals are not disjoint, the intersection is not empty.\n        var\
    \ maxStart = Math.Max(interval1.Item1, interval2.Item1);\n        var minEnd =\
    \ Math.Min(interval1.Item2, interval2.Item2);\n        var length = minEnd - maxStart\
    \ + 1;\n        return IsPrime(length) ? \"YES\" : \"NO\";", '        return IsPrime(Intersect(interval1,
    interval2)) ? "YES" : "NO";', "        var start = Math.Max(interval1.Item1, interval2.Item1);\n\
    \        var end = Math.Min(interval1.Item2, interval2.Item2);\n        return\
    \ IsPrime(end - start + 1) ? \"YES\" : \"NO\";", "        // Solution based on\
    \ Minsk, Belarus\n        var interval = interval1.Item1 <= interval2.Item1 ?\
    \ interval1 : interval2;\n        var otherInterval = interval1.Item1 <= interval2.Item1\
    \ ? interval2 : interval1;\n        var maxBegin = interval.Item1;\n        var\
    \ minEnd = Math.Min(interval.Item2, otherInterval.Item2);\n        if (maxBegin\
    \ > minEnd) return \"NO\";\n        var length = minEnd - maxBegin + 1;\n    \
    \    return IsPrime(length) ? \"YES\" : \"NO\";", "        long start = Math.Max(interval1.Item1,\
    \ interval2.Item1);\n        long end = Math.Min(interval1.Item2, interval2.Item2);\n\
    \        long len = end - start + 1;\n        if (len < 0) {\n            len\
    \ = 0;\n        }\n        if (len == 0) {\n            return \"NO\";\n     \
    \   }\n        if (IsPrime(len)) {\n            return \"YES\";\n        }\n \
    \       return \"NO\";", "        // problem as saying \"length of maximum interval\
    \ that is part of both intervals\"\n        long\n            start1 = interval1.Item1,\n\
    \            end1 = interval1.Item2,\n            start2 = interval2.Item1,\n\
    \            end2 = interval2.Item2;\n        if (start1 > end1 || start2 > end2)\
    \ {\n            throw new ArgumentException(\"input intervals must start before\
    \ they end\");\n        }\n        // order the input\n        if (start1 > start2)\
    \ {\n            (start1, end1, start2, end2) = (start2, end2, start1, end2);\n\
    \        }\n        // find intersection\n        long\n            length1 =\
    \ end1 - start1 + 1,\n            length2 = end2 - start2 + 1,\n            startIntersection\
    \ = Math.Max(start1, start2),\n            endIntersection = Math.Min(end1, end2),\n\
    \            lengthIntersection = endIntersection - startIntersection + 1;\n \
    \       // if there is no intersection, return \"NO\"\n        if (lengthIntersection\
    \ <= 0) {\n            return \"NO\";\n        }\n        // if there is an intersection\
    \ and the length is prime, return \"YES\"\n        if (isPrime(lengthIntersection))\
    \ {\n            return \"YES\";\n        }\n        // if there is an intersection\
    \ and the length is not prime, return \"NO\"\n        return \"NO\";"]
stop_tokens:
- "\n    }\n"
