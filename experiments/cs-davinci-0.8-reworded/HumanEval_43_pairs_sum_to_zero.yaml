name: HumanEval_43_pairs_sum_to_zero
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // pairs_sum_to_zero takes a list of integers as an input.\n  \
  \  // it returns true if there are two distinct elements in the list that\n    //\
  \ sum to zero, and false otherwise.\n    // >>> PairsSumToZero((new List<long>(new\
  \ long[]{(long)1L, (long)3L, (long)5L, (long)0L})))\n    // (false)\n    // >>>\
  \ PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L, (long)-2L, (long)1L})))\n\
  \    // (false)\n    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L,\
  \ (long)2L, (long)3L, (long)7L})))\n    // (false)\n    // >>> PairsSumToZero((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))\n\
  \    // (true)\n    // >>> PairsSumToZero((new List<long>(new long[]{(long)1L})))\n\
  \    // (false)\n    public static bool PairsSumToZero(List<long> l) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(PairsSumToZero((new\
  \ List<long>(new long[]{(long)1L, (long)3L, (long)5L, (long)0L}))) == (false));\n\
  \    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L, (long)3L,\
  \ (long)-2L, (long)1L}))) == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new\
  \ long[]{(long)1L, (long)2L, (long)3L, (long)7L}))) == (false));\n    Debug.Assert(PairsSumToZero((new\
  \ List<long>(new long[]{(long)2L, (long)4L, (long)-5L, (long)3L, (long)5L, (long)7L})))\
  \ == (true));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)1L})))\
  \ == (false));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L,\
  \ (long)9L, (long)-1L, (long)3L, (long)2L, (long)30L}))) == (true));\n    Debug.Assert(PairsSumToZero((new\
  \ List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)3L, (long)2L, (long)31L})))\
  \ == (true));\n    Debug.Assert(PairsSumToZero((new List<long>(new long[]{(long)-3L,\
  \ (long)9L, (long)-1L, (long)4L, (long)2L, (long)30L}))) == (false));\n    Debug.Assert(PairsSumToZero((new\
  \ List<long>(new long[]{(long)-3L, (long)9L, (long)-1L, (long)4L, (long)2L, (long)31L})))\
  \ == (false));\n    }\n\n}\n"
completions: ["        if (l.Count() <= 1) {\n            return false;\n        }\n\
    \        else {\n            var done = new Dictionary<long, bool>();\n      \
    \      foreach (var v in l) {\n                if (done.ContainsKey(-v)) {\n \
    \                   return true;\n                }\n                else {\n\
    \                    done[v] = true;\n                }\n            }\n     \
    \       return false;\n        }", "        Dictionary<long, long> d = new Dictionary<long,\
    \ long>();\n        foreach (long x in l) {\n            if (d.ContainsKey(-x))\
    \ {\n                return true;\n            }\n            if (!d.ContainsKey(x))\
    \ {\n                d[x] = 0L;\n            }\n            d[x]++;\n        }\n\
    \        return false;", "        bool res = false;\n        // check to see if\
    \ there are at least two distinct elements in the list\n        if (l.Count >=\
    \ 2) {\n            // sort the list\n            l.Sort();\n            // set\
    \ the first element\n            long last = l[0];\n            // check to see\
    \ if there are more than two elements in the list\n            if (l.Count > 2)\
    \ {\n                // iterate over every element except the first\n        \
    \        for (int i = 1; i < l.Count; i++) {\n                    // check to\
    \ see if the current element is distinct from the last\n                    if\
    \ (l[i] != last) {\n                        // check to see if the current and\
    \ last elements sum to zero\n                        if (l[i] + last == 0) {\n\
    \                            // there is a pair that sums to zero\n          \
    \                  res = true;\n                            break;\n         \
    \               }\n                        // set the last element to the current\
    \ element\n                        last = l[i];\n                    }\n     \
    \           }\n            }\n            // check to see if the last and first\
    \ elements sum to zero\n            else if (l[1] + l[0] == 0) {\n           \
    \     // there is a pair that sums to zero\n                res = true;\n    \
    \        }\n        }\n        return res;", "        foreach (var a in l) {\n\
    \            foreach (var b in l) {\n                if (a != b && a + b == 0)\
    \ {\n                    return true;\n                }\n            }\n    \
    \    }\n        return false;", "        bool q = default(bool);\n        foreach\
    \ (var i in Itertools.Range(0L, Itertools.Count(l))) {\n            foreach (var\
    \ j in Itertools.Range(0L, Itertools.Count(l))) {\n                if (i == j)\
    \ {\n                    continue;\n                }\n                q = (l[(int)i]\
    \ + l[(int)j]) == 0L;\n                if (q) {\n                    break;\n\
    \                }\n            }\n            if (q) {\n                break;\n\
    \            }\n        }\n        return q;", "        bool x = false;\n    \
    \    foreach (var i in l) {\n            foreach (var j in l) {\n            \
    \    if (i != j && i + j == 0) {\n                    x = true;\n            \
    \    }\n            }\n        }\n        return x;", "        Dictionary<long,\
    \ bool> d = new Dictionary<long, bool>();\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            d[l[i]] = true;\n        }\n        for (int i = 0; i <\
    \ l.Count; i++) {\n            if (d.ContainsKey(-l[i])) {\n                return\
    \ true;\n            }\n        }\n        return false;", "        Dictionary<long,\
    \ long> d = new Dictionary<long, long>();\n        foreach (long x in l) {\n \
    \           if (d.ContainsKey(x)) {\n                d[x] = d[x] + (long)1L;\n\
    \            }\n            else {\n                d[x] = (long)1L;\n       \
    \     }\n\n        }\n\n        foreach (long x in l) {\n            if (x ==\
    \ (long)0L) {\n                if (d[x] >= (long)2L) {\n                    return\
    \ true;\n                }\n\n            }\n            else {\n            \
    \    if (d.ContainsKey(-x)) {\n                    return true;\n            \
    \    }\n\n            }\n\n        }\n\n        return false;\n", '        throw
    new NotImplementedException();', "        var _tup4 = (l, (l.Count - (long)1L),\
    \ (long)0L, (long)0L);\n        long length = _tup4.Item2;\n        long i = _tup4.Item3;\n\
    \        long j = _tup4.Item4;\n        bool pairsSumToZero = default;\n     \
    \   while (i < length)\n        {\n            j = (long)0L;\n            while\
    \ (j < length)\n            {\n                if ((i != j) && ((l[(int)i] + l[(int)j])\
    \ == (long)0L))\n                {\n                    pairsSumToZero = true;\n\
    \                    goto matchFound;\n                }\n\n                j\
    \ = (j + (long)1L);\n\n            }\n\n            i = (i + (long)1L);\n\n  \
    \      }\n    matchFound:;\n        return pairsSumToZero;\n", "        for (long\
    \ i = 0L; i < l.Count; i++) {\n            for (long j = 0L; j < l.Count; j++)\
    \ {\n                if (i != j && l[(int)i] + l[(int)j] == 0L) {\n          \
    \          return true;\n                }\n            }\n        }\n       \
    \ return false;", '        throw new NotImplementedException();', "        //\
    \ Replace the line below with a single line that returns a\n        // boolean\
    \ value of the correct answer!\n        return false;", "        var length =\
    \ l.Count;\n        for (var i = 0; i < length; i++) {\n            for (var j\
    \ = i + 1; j < length; j++) {\n                if (l[i] + l[j] == 0L) {\n    \
    \                return true;\n                }\n            }\n        }\n \
    \       return false;", "        // Your code goes here.\n\n        return false;",
  '        return l.Count > 1 && l.GroupBy(x => Math.Abs(x)).Any(g => (g.Key == 0L
    && g.Count() > 1) || g.Count() > 1);', "        var set = new HashSet<long>();\n\
    \        foreach (var value in l) {\n            if (set.Contains(value)) {\n\
    \                return true;\n            }\n            set.Add(-value);\n \
    \       }\n        return false;", "        bool has_pair = false;\n        //\
    \ test whether the list has any pair that sums to zero\n        bool retval =\
    \ false;\n        return retval;", "        // Your code here\n        Dictionary<long,\
    \ int> d = new Dictionary<long, int>();\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            if (d.ContainsKey(l[i])) {\n                d[l[i]]++;\n\
    \            } else {\n                d[l[i]] = 1;\n            }\n        }\n\
    \        bool flag = false;\n        foreach (KeyValuePair<long, int> item in\
    \ d) {\n            if (item.Key != 0) {\n                if (d.ContainsKey(-item.Key))\
    \ {\n                    flag = true;\n                    break;\n          \
    \      }\n            } else {\n                if (item.Value > 1) {\n      \
    \              flag = true;\n                    break;\n                }\n \
    \           }\n        }\n        return flag;", "        var set = new HashSet<long>();\n\
    \        foreach (var item in l) {\n            if (set.Contains(-item)) {\n \
    \               return true;\n            }\n            set.Add(item);\n    \
    \    }\n        return false;", "      var s = new HashSet<long>();\n      foreach\
    \ (var i in l) {\n        if (s.Contains(i)) {\n          return true;\n     \
    \   }\n        s.Add(i);\n      }\n      foreach (var i in l) {\n        if (s.Contains(-i))\
    \ {\n          return true;\n        }\n      }\n      return false;", "     \
    \   long[] a = l.ToArray();\n        Array.Sort(a);\n        for (int i = 0; i\
    \ < a.Length; i++) {\n            for (int j = i + 1; j < a.Length; j++) {\n \
    \               if (a[i] + a[j] == 0) {\n                    return true;\n  \
    \              }\n            }\n        }\n        return false;", '        return
    false;', "        var lo = (long)0L;\n        var hi = (long)0L;\n        var\
    \ set = new HashSet<long>();\n        for (var i = (long)0L; i < (long)l.Count;\
    \ i++)\n        {\n            var v = l[(int)i];\n            var minusV = (-1L\
    \ * v);\n            if (set.Contains(minusV))\n            {\n              \
    \  lo = i;\n                hi = set[minusV];\n                return true;\n\
    \            }\n\n            set[v] = i;\n\n        }\n\n        return false;\n",
  "        Dictionary<long, bool> D = new Dictionary<long, bool>();\n        //long\
    \ x = 0L;\n        foreach (long x in l) {\n            if (D.ContainsKey(x))\
    \ {\n                return true;\n            }\n            D[-x] = true;\n\
    \        }\n        return false;", "        for (long i = 0L; i < (long)l.Count;\
    \ i++) {\n            for (long j = 0L; j < (long)l.Count; j++) {\n          \
    \      if (i != j && l[(int)i] + l[(int)j] == 0L) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  "        // We do this by constructing a set, which is a data structure\n      \
    \  // that allows you to check whether or not it contains a particular\n     \
    \   // value in O(1) time. We then iterate through the list, and check\n     \
    \   // whether -x is in the set, where x is the current element. If it\n     \
    \   // is, then we've found a pair that sums to zero.\n        HashSet<long> s\
    \ = new HashSet<long>();\n        foreach (long x in l) {\n            if (s.Contains((long)(-x)))\
    \ {\n                return true;\n            }\n            s.Add(x);\n    \
    \    }\n        return false;", '        throw new NotImplementedException();',
  "        var s = new HashSet<long>();\n        foreach (var v in l) {\n        \
    \    if (s.Contains(0L - v)) {\n                return true;\n            }\n\n\
    \            s.Add(v);\n        }\n\n        return false;\n", "        if (((long)l.Count)\
    \ == 0L) {\n            return false;\n        }\n        if (((long)l.Count)\
    \ == 1L) {\n            return false;\n        }\n        if (((long)l.Count)\
    \ == 2L) {\n            if ((l[0L] + l[1L]) == 0L) {\n                return true;\n\
    \            }\n            return false;\n        }\n        long last = l[((long)l.Count)\
    \ - 1L];\n        l.RemoveAt(((int)(((long)l.Count) - 1L)));\n        bool found\
    \ = PairsSumToZero(l);\n        l.Add(last);\n        if (found) {\n         \
    \   return true;\n        }\n        long last_last = l[((long)l.Count) - 2L];\n\
    \        l.RemoveAt(((int)(((long)l.Count) - 2L)));\n        found = PairsSumToZero(l);\n\
    \        l.Add(last_last);\n        if (found) {\n            return true;\n \
    \       }\n        if ((last + last_last) == 0L) {\n            return true;\n\
    \        }\n        return false;", "        int n = l.Count;\n        List<long>\
    \ a = new List<long>();\n        for (int i = 0; i < n; i++) {\n            a.Add(l[i]);\n\
    \        }\n        a.Sort();\n        int lx = a.Count;\n        int j = lx -\
    \ 1;\n        int i = 0;\n        while (i < j) {\n            if (a[i] + a[j]\
    \ == 0L) {\n                return true;\n            } else if (a[i] + a[j] <\
    \ 0L) {\n                i++;\n            } else {\n                j--;\n  \
    \          }\n        }\n        return false;", "        HashSet<long> lookup\
    \ = new HashSet<long>();\n        foreach (long x in l) {\n            long v\
    \ = x;\n            if (lookup.Contains(v)) {\n                return true;\n\
    \            }\n            lookup.Add(-v);\n        }\n        return false;",
  '        throw new NotImplementedException();', "        if (l.Count < 2) {\n  \
    \          return false;\n        }\n        HashSet<long> hs = new HashSet<long>();\n\
    \        foreach (long x in l) {\n            if (hs.Contains(0L - x)) {\n   \
    \             return true;\n            }\n            hs.Add(x);\n        }\n\
    \        return false;", "        var ht = new Dictionary<long, bool>();\n   \
    \     bool found = false;\n        foreach (var item in l) {\n            if (!ht.ContainsKey(item))\
    \ {\n                ht[item] = true;\n            }\n            else {\n   \
    \             found = true;\n            }\n        }\n        return found;",
  "        long n = (long)l.Count;\n        long i = (long)0L;\n        while (i <\
    \ n)\n        {\n            {\n                long j = (long)0L;\n         \
    \       while (j < n)\n                {\n                    {\n            \
    \            if (i != j && l[(int)i] + l[(int)j] == (long)0L)\n              \
    \          {\n                            return true;\n                     \
    \   }\n\n                    }\n\n                    j = j + (long)1L;\n    \
    \            }\n\n            }\n\n            i = i + (long)1L;\n        }\n\n\
    \        return false;\n", "        // declare a new dictionary of type Dictionary<string,long>\n\
    \        Dictionary<string, long> d = new Dictionary<string, long>();\n      \
    \  // for each value in the list\n        foreach (long x in l) {\n          \
    \  // if the dictionary contains the value -x\n            if (d.ContainsKey(__string.Concat(new\
    \ string[] { (x.ToString() + (long)(-x).ToString()) }))) {\n                //\
    \ return true\n                return true;\n            } else {\n          \
    \      // if the dictionary does not contain the value -x\n                //\
    \ add x to the dictionary\n                d.Add(x.ToString(), x);\n         \
    \   }\n        }\n        // otherwise return false\n        return false;", " \
    \       bool result = false;\n        long a;\n        long b;\n        foreach\
    \ (long k in l) {\n            if (k == 0L) {\n                if (l.Count > 1L)\
    \ {\n                    result = true;\n                }\n                else\
    \ {\n                    result = false;\n                }\n                break;\n\
    \            }\n            if (l.Contains(-k)) {\n                result = true;\n\
    \                break;\n            }\n        }\n        return result;", " \
    \       if (l.Count <= 1) {\n            return false;\n        }\n        long\
    \ last = l[0];\n        Dictionary<long, int> h = new Dictionary<long, int>();\n\
    \        h[last] = 1;\n        for (int i = 1; i < l.Count; i++) {\n         \
    \   if (l[i] == last) {\n                h[l[i]] = h[l[i]] + 1;\n            }\n\
    \            else {\n                h[l[i]] = 1;\n            }\n           \
    \ last = l[i];\n        }\n        for (int i = 0; i < l.Count; i++) {\n     \
    \       if (h.ContainsKey(-l[i])) {\n                if (l[i] == 0L) {\n     \
    \               if (h[l[i]] > 1) {\n                        return true;\n   \
    \                 }\n                }\n                else {\n             \
    \       return true;\n                }\n            }\n        }\n        return\
    \ false;", "        List<long> o = new List<long>();\n        foreach (long b\
    \ in l) {\n            if (!o.Contains(b)) {\n                o.Add(b);\n    \
    \        }\n        }\n        for (int i = 0; i < o.Count(); i++) {\n       \
    \     for (int j = i+1; j < o.Count(); j++) {\n                if (o[i] + o[j]\
    \ == 0) {\n                    return true;\n                }\n            }\n\
    \        }\n        return false;", "        for (int x_i = 0; x_i < (l.Count);\
    \ x_i++) {\n            for (int y_i = (x_i + 1); y_i < (l.Count); y_i++) {\n\
    \                bool x_y_sum_to_zero = ((l[x_i]) + (l[y_i])) == 0L;\n       \
    \         if (x_y_sum_to_zero) {\n                    return true;\n         \
    \       }\n\n            }\n\n        }\n        return false;\n", "        if\
    \ ((l.Count() < 2L)) {\n            return false;\n        }\n        var seen\
    \ = new Dictionary<long, bool>();\n        {\n            var i__prev1 = i;\n\n\
    \            foreach (var (__i, __x) in l)\n            {\n                i =\
    \ __i;\n                x = __x;\n                if (seen.ContainsKey(-x))\n\
    \                {\n                    return true;\n                }\n\n  \
    \              seen[x] = true;\n\n            }\n\n            i = i__prev1;\n\
    \        }\n\n        return false;\n", "        // foreach(var i in l)\n    \
    \    var i = (long)0L;\n        {\n            // foreach(var j in l)\n      \
    \      var j = (long)0L;\n            {\n                if ((i + j) == (long)0L)\n\
    \                {\n                    return true;\n                }\n\n  \
    \          }\n\n        }\n\n        return false;\n", '        return l.Contains(0L)
    && l.Count(x => x == 0L) > 1;', '        return false;', "        List<long> l2\
    \ = new List<long>();\n        foreach (long i in l) {\n            if (l2.Contains(i))\
    \ {\n                return true;\n            }\n            l2.Add((long)0L\
    \ - i);\n        }\n        return false;", '        throw new NotImplementedException();',
  "        bool result = false;\n        foreach (long value in l) {\n           \
    \ if (l.Contains(-value)) {\n                result = true;\n            }\n \
    \       }\n        return result;", "        int i = 0;\n        while (i < l.Count)\
    \ {\n            int j = i + 1;\n            while (j < l.Count) {\n         \
    \       if (l[i] + l[j] == 0L) {\n                    return true;\n         \
    \       }\n                j = j + 1;\n            }\n            i = i + 1;\n\
    \        }\n        return false;", "        // Fill in your answer here\n   \
    \     HashSet<long> hs = new HashSet<long>();\n        foreach (long i in l) {\n\
    \            if (hs.Contains(-i)) {\n                return true;\n          \
    \  }\n            hs.Add(i);\n        }\n        return false;", "        long\
    \ zero = (long)0L;\n        var hash = new HashSet<long>();\n        foreach (var\
    \ x in l)\n        {\n            if (hash.Contains(-x))\n            {\n    \
    \            return true;\n            }\n\n            hash.Add(x);\n\n     \
    \   }\n        return false;\n", "        bool flag = false;\n        foreach\
    \ (long i in l) {\n            foreach (long j in l) {\n                if (i\
    \ != j && i + j == 0) {\n                    flag = true;\n                }\n\
    \            }\n        }\n        return flag;", "        List<long> b = new\
    \ List<long>();\n        long i = 0L;\n        while (i < len(l))\n        {\n\
    \            long x = l[(int)i];\n            if (!(Contains(b, x)))\n       \
    \     {\n                b.Add(x);\n            }\n\n            i += 1L;\n\n\
    \        }\n\n        i = 0L;\n        while (i < len(b))\n        {\n       \
    \     long x = b[(int)i];\n            if (Contains(b, (x * -1L)))\n         \
    \   {\n                return true;\n            }\n\n            i += 1L;\n\n\
    \        }\n\n        return false;\n", "        HashSet<long> x = new HashSet<long>();\n\
    \        foreach (long e in l) {\n            if (x.Contains(-e)) {\n        \
    \        return true;\n            }\n\n            x.Add(e);\n        }\n\n \
    \       return false;\n", "        HashSet<long> s = new HashSet<long>();\n  \
    \      foreach (long n in l) {\n            if (s.Contains(n) || s.Contains(-n))\
    \ {\n                return true;\n            }\n            s.Add(n);\n    \
    \    }\n        return false;", "        l.Sort();\n        return (l.Count >\
    \ 1) && (l[0] == 0) && (l[1] == 0);", "        var _l = new HashSet<long>(l);\n\
    \        foreach (var item in _l) {\n            if (_l.Contains(-item)) {\n \
    \               return true;\n            }\n        }\n        return false;",
  "        bool pairsSumToZero = false;\n        if (l.Count > 0) {\n            //\
    \ Sorts a list of integers.\n            // >>> Sort((new List<long>(new long[]{(long)1L,\
    \ (long)3L, (long)5L, (long)2L})))\n            // (new List<long>(new long[]{(long)1L,\
    \ (long)2L, (long)3L, (long)5L}))\n            // >>> Sort((new List<long>(new\
    \ long[]{(long)1L, (long)2L, (long)2L, (long)1L})))\n            // (new List<long>(new\
    \ long[]{(long)1L, (long)1L, (long)2L, (long)2L}))\n            // >>> Sort((new\
    \ List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L})))\n         \
    \   // (new List<long>(new long[]{(long)1L, (long)1L, (long)1L, (long)1L}))\n\
    \            // >>> Sort((new List<long>(new long[]{(long)1L, (long)1L, (long)1L,\
    \ (long)2L})))\n            // (new List<long>(new long[]{(long)1L, (long)1L,\
    \ (long)1L, (long)2L}))\n            List<long> Sort(List<long> l1) {\n      \
    \          long key = 0L;\n                long j = 0L;\n                long\
    \ i = 0L;\n                long len_l1 = (long)l1.Count;\n                for\
    \ (i = (long)1L; i < len_l1; i++) {\n                    key = l1[(int)(i)];\n\
    \                    j = i - (long)1L;\n                    while (j >= (long)0L\
    \ && l1[(int)(j)] > key) {\n                        l1[(int)(j + (long)1L)] =\
    \ l1[(int)(j)];\n                        j = j - (long)1L;\n                 \
    \   }\n", "        var pairs = new Dictionary<long, bool>();\n        foreach\
    \ (var v in l) {\n            if (pairs.ContainsKey(-v)) {\n                return\
    \ true;\n            }\n            else {\n                pairs[v] = true;\n\
    \            }\n        }\n        return false;", "        // code here\n   \
    \     Dictionary<long, bool> hash = new Dictionary<long, bool>();\n        foreach\
    \ (long num in l) {\n            if (hash.ContainsKey(-num)) {\n             \
    \   return true;\n            }\n            hash[num] = true;\n        }\n  \
    \      return false;", "        HashSet<long> values = new HashSet<long>();\n\
    \        foreach (long x in l) {\n            if (values.Contains(0L - x)) {\n\
    \                return true;\n            }\n            values.Add(x);\n   \
    \     }\n        return false;", "        bool flag = false;\n        for (long\
    \ i = 0L; i < (long)l.Count; i++) {\n            for (long j = 0L; j < (long)l.Count;\
    \ j++) {\n                if (i != j && l[(int)i] + l[(int)j] == 0L) {\n     \
    \               flag = true;\n                }\n            }\n        }\n  \
    \      return flag;", "        foreach (var i in l) {\n            foreach (var\
    \ j in l) {\n                if (i == j) {\n                    continue;\n  \
    \              }\n\n                if (i + j == 0L) {\n                    return\
    \ true;\n                }\n\n            }\n\n        }\n        return false;\n",
  "        var data = new HashSet<long>();\n        foreach (var item in l) {\n  \
    \          data.Add(item);\n        }\n        foreach (var item in l) {\n   \
    \         if (data.Contains(-(item))) {\n                return true;\n      \
    \      }\n        }\n        return false;", "        List<long> taken_values\
    \ = new List<long>();\n        long i = 0L;\n        while (i < (long)l.Count)\
    \ {\n            if (taken_values.Contains(l[(int)i])) {\n                i =\
    \ i + (long)1L;\n                continue;\n            }\n            taken_values.Add(l[(int)i]);\n\
    \            long j = i + (long)1L;\n            while (j < (long)l.Count) {\n\
    \                if (l[(int)i] + l[(int)j] == (long)0L) {\n                  \
    \  return true;\n                }\n                j = j + (long)1L;\n      \
    \      }\n            i = i + (long)1L;\n        }\n        return false;", " \
    \       Dictionary<long, long> pairs = new Dictionary<long, long>();\n       \
    \ foreach (long num in l) {\n            if (pairs.ContainsKey(-num)) {\n    \
    \            return true;\n            }\n            if (!pairs.ContainsKey(num))\
    \ {\n                pairs[num] = 0L;\n            }\n            pairs[num]++;\n\
    \        }\n        return false;", '        return pairs_sum_to_zero(l);', " \
    \       var input_list = new HashSet<long>(l);\n        var visited = new HashSet<long>();\n\
    \        foreach (var item in input_list) {\n            if (visited.Contains(item))\
    \ {\n                continue;\n            }\n            if (input_list.Contains((long)((long)0L\
    \ - item))) {\n                return true;\n            }\n            visited.Add(item);\n\
    \        }\n        return false;", "        var count = new Dictionary<long,\
    \ long>();\n        foreach (var n in l) {\n            if (count.ContainsKey(n))\
    \ {\n                count[n]++;\n            } else {\n                count[n]\
    \ = 1L;\n            }\n        }\n        foreach (var n in l) {\n          \
    \  var complement = -n;\n            if (count.ContainsKey(complement)) {\n  \
    \              if (n == complement) {\n                    if (count[n] > 1L)\
    \ {\n                        return true;\n                    }\n           \
    \     } else {\n                    return true;\n                }\n        \
    \    }\n        }\n        return false;", "        // START SOLUTION\n      \
    \  long sum = 0L;\n        long product = 1L;\n        long count = 0L;\n    \
    \    var unique = new HashSet<long>();\n        foreach (var item in l) {\n  \
    \          sum += item;\n            product *= item;\n            if (unique.Contains(item))\
    \ {\n                count += 1L;\n            } else {\n                unique.Add(item);\n\
    \            }\n        }\n        if (count >= 2L && product == 0L) {\n     \
    \       return true;\n        }\n        if (unique.Contains(0L) && (unique.Count\
    \ - 1L) >= 2L) {\n            return true;\n        }\n        if (unique.Contains(0L)\
    \ && unique.Contains(-sum)) {\n            return true;\n        }\n        foreach\
    \ (var x in unique) {\n            if (unique.Contains(-x)) {\n              \
    \  return true;\n            }\n        }\n        return false;\n        // END\
    \ SOLUTION", "        // YOUR CODE HERE\n        return false;", '        throw
    new NotImplementedException();', "        var dict = new Dictionary<long, int>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            var v = l[i];\n    \
    \        if (dict.ContainsKey(-v)) {\n                return true;\n         \
    \   } else {\n                dict[v] = 1;\n            }\n        }\n       \
    \ return false;", "        // Replace the following line with your code\n    \
    \    long sum = 0;\n        bool result = false;\n        foreach (long i in l)\
    \ {\n            sum += i;\n        }\n        if (sum != 0) {\n            result\
    \ = false;\n        }\n        else {\n            result = true;\n        }\n\
    \        return result;", "        // define the set\n        var s = new HashSet<long>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            var n = l[i];\n    \
    \        if (s.Contains(-n)) {\n                return true;\n            }\n\
    \            s.Add(n);\n        }\n        return false;", "        // Extract\
    \ the list l, and initialize the hashtable \"h\" to be empty.\n        //\n  \
    \      // The hashtable h is a mapping from all integers to zero,\n        //\
    \ which will be used to keep track of all elements of the list.\n        var l\
    \ = l;\n        var h = (new Dictionary<long, long>());\n        {\n         \
    \   var i__prev1 = i;\n\n            foreach (var (__i) in Enumerable.Range(0,\
    \ l.Count))\n            {\n                i = __i;\n                h[l[i]]\
    \ = 0L;\n            }\n\n            i = i__prev1;\n        }\n\n        // For\
    \ each integer x in the list l, do the following:\n        //\n        // - If\
    \ the hashtable h contains the integer -x, then return true.\n        // - Otherwise,\
    \ update the hashtable h to map x to zero.\n        {\n            var i__prev1\
    \ = i;\n\n            foreach (var (__i) in Enumerable.Range(0, l.Count))\n  \
    \          {\n                i = __i;\n                var x = l[i];\n      \
    \          if (h.ContainsKey(-x))\n                {\n                    return\
    \ true;\n                }\n\n                h[x] = 0L;\n\n            }\n\n\
    \            i = i__prev1;\n        }\n\n        // If none of the above cases\
    \ match, return false.\n        return false;\n", "        // the total time for\
    \ this function is the time to execute the for-loop\n        // once for each\
    \ element in the list, plus the time to execute the inner\n        // if-statement\
    \ once for each element in the list.\n        // the list can contain up to 1,000,000\
    \ elements.\n        // each element can be as large as 1,000,000,000,000,000.\n\
    \        // the total time for this code is O(n^2).\n        // the space used\
    \ by this code is the space used by the list l.\n        // the list can contain\
    \ up to 1,000,000 elements.\n        // each element can be as large as 1,000,000,000,000,000.\n\
    \        // the total space used by this code is O(n).\n        // TODO: implement\
    \ this function.\n        // it should return true if there are two distinct elements\
    \ in the list\n        // that sum to zero, and false otherwise.\n        for\
    \ (long i = 0; i < l.Count; i++) {\n            for (long j = 0; j < l.Count;\
    \ j++) {\n                if (i != j && l[(int)i] + l[(int)j] == 0) {\n      \
    \              return true;\n                }\n            }\n        }\n   \
    \     return false;", "        var s = new HashSet<long>();\n        foreach (var\
    \ x in l) {\n            if (s.Contains(x)) {\n                return true;\n\
    \            }\n\n            s.Add(x);\n        }\n\n        return false;\n",
  "        // find the maximum and minimum element in the list\n        long minimum\
    \ = l[0];\n        long maximum = l[0];\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            if (l[i] < minimum) {\n                minimum = l[i];\n\
    \            }\n            if (l[i] > maximum) {\n                maximum = l[i];\n\
    \            }\n        }\n        long sum = 0L;\n        long left = 0L;\n \
    \       long right = 0L;\n        int j = 0;\n        int k = 0;\n        // Make\
    \ sure a[i] and a[j] are distinct\n        for (int i = 0; i < l.Count; i++) {\n\
    \            // find the sum of l[i] and l[j], where j>i\n            sum = 0L;\n\
    \            for (j = i + 1; j < l.Count; j++) {\n                sum = l[i] +\
    \ l[j];\n                if (sum == 0L) {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;", "      \
    \  bool sum;\n        long i;\n        i = (long)1L;\n        while (i < (long)l.Count())\n\
    \        {\n            sum = l.ElementAt((int)i) == (long)0L;\n            if\
    \ (sum)\n            {\n                return true;\n            }\n\n      \
    \      var tuples =\n                from index1 in Enumerable.Range(0, l.Count)\n\
    \                from index2 in Enumerable.Range(index1 + 1, l.Count - index1\
    \ - 1)\n                select new { Sum = l[index1] + l[index2], Index1 = index1,\
    \ Index2 = index2 };\n            foreach (var tuple in tuples)\n            {\n\
    \                sum = tuple.Sum == (long)0L;\n                if (sum)\n    \
    \            {\n                    return true;\n                }\n\n      \
    \      }\n\n            i = i + (long)1L;\n        }\n\n        return false;\n",
  "        var m = new HashSet<long>();\n        foreach (var x in l) {\n        \
    \    if (m.Contains(x)) {\n                return true;\n            }\n\n   \
    \         m.Add(-x);\n        }\n\n        return false;\n", "        for (long\
    \ _ = 0L; _ < 2L; _++) {\n            foreach (long __ in l) {\n             \
    \   long num = __;\n                if (l.Contains(-num)) {\n                \
    \    return true;\n                }\n            }\n        }\n        return\
    \ false;", "        HashSet<long> set = new HashSet<long>();\n        foreach\
    \ (long l1 in l) {\n            if (set.Contains(-l1)) {\n                return\
    \ true;\n            }\n            set.Add(l1);\n        }\n        return false;",
  "        List<long> newList = l.Distinct().ToList();\n        for (int i = 0; i\
    \ < newList.Count; i++) {\n            newList[i] = newList[i] * -1;\n       \
    \ }\n        return newList.Intersect(l).Count() > 0;", "        var sl = (new\
    \ HashSet<long>(l));\n        foreach (var _l in l) {\n            {\n       \
    \         var l__prev1 = l;\n\n                var l__prev2 = l;\n\n         \
    \       foreach (var l_ in sl)\n                {\n                    l = l_;\n\
    \                    if (_l + l == 0L)\n                    {\n              \
    \          return true;\n                    }\n\n                }\n\n      \
    \          l = l__prev2;\n            }\n\n            l = _l__prev1;\n      \
    \  }\n        return false;\n", "        int found_pos = 0;\n        int found_neg\
    \ = 0;\n        foreach (long v in l) {\n            if (v == 0L) {\n        \
    \        found_pos = 1;\n            }\n\n            if (v > 0L) {\n        \
    \        found_pos++;\n            }\n\n            if (v < 0L) {\n          \
    \      found_neg++;\n            }\n\n        }\n\n        if (found_pos > 1L\
    \ && found_neg > 1L) {\n            return true;\n        }\n\n        return\
    \ false;\n", "        bool found = false;\n        long i = 0L;\n        while\
    \ (i < (long)l.Count) {\n            if (l[(int)i] == 0L) {\n                i\
    \ = i + 1L;\n                continue;\n            }\n            long j = i\
    \ + 1L;\n            while (j < (long)l.Count) {\n                if (l[(int)i]\
    \ + l[(int)j] == 0L) {\n                    found = true;\n                  \
    \  break;\n                }\n                j = j + 1L;\n            }\n   \
    \         i = i + 1L;\n        }\n        return found;", "        if (l.Count()\
    \ <= 1) {\n            return false;\n        }\n        HashSet<long> s = new\
    \ HashSet<long>();\n        foreach (long v in l) {\n            if (s.Contains(-v))\
    \ {\n                return true;\n            }\n            s.Add(v);\n    \
    \    }\n        return false;", "        var done = new Dictionary<long, bool>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            var neg = -l[i];\n \
    \           if (done.ContainsKey(neg)) {\n                return true;\n     \
    \       }\n            else {\n                done[l[i]] = true;\n          \
    \  }\n        }\n        return false;", "        int n = l.Count;\n        long\
    \ min = long.MaxValue;\n        long max = long.MinValue;\n        long sum =\
    \ 0L;\n        foreach (long j in l) {\n            if (j < min) {\n         \
    \       min = j;\n            }\n\n            if (j > max) {\n              \
    \  max = j;\n            }\n\n            sum += j;\n\n        }\n\n        if\
    \ (max < 0L) {\n            return false;\n        }\n\n        if (min > 0L)\
    \ {\n            return false;\n        }\n\n        if (sum == 0L) {\n      \
    \      return true;\n        }\n\n        if (min < 0L && max >= 0L) {\n     \
    \       return true;\n        }\n\n        return false;\n", '        throw new
    NotImplementedException();', "        // your code here\n        return false;",
  '        return false;', "        int lo = 0;\n        int hi = l.Count - 1;\n \
    \       while (lo < hi) {\n            if (l[lo] + l[hi] == 0) {\n           \
    \     return true;\n            }\n            else if (l[lo] + l[hi] < 0) {\n\
    \                lo++;\n            }\n            else {\n                hi--;\n\
    \            }\n        }\n        return false;", "        foreach (var value\
    \ in l) {\n            if (l.Contains(-value)) {\n                return true;\n\
    \            }\n        }\n        return false;", '        throw new NotImplementedException();',
  "        // Fill in your answer here.\n        HashSet<long> set = new HashSet<long>();\n\
    \        foreach (long value in l) {\n            if (set.Contains(value)) {\n\
    \                return true;\n            }\n            set.Add(0 - value);\n\
    \        }\n        return false;", "        var ans = false;\n        for (var\
    \ i = 0L; i < (long)l.Count; i++) {\n            for (var j = 0L; j < (long)l.Count;\
    \ j++) {\n                if (((i != j) && ((l[(int)i] + l[(int)j]) == (long)0L)))\
    \ {\n                    ans = true;\n                }\n            }\n     \
    \   }\n        return ans;", "        Dictionary<long, long> d = new Dictionary<long,\
    \ long>();\n        foreach (long v in l) {\n            if (d.ContainsKey(v))\
    \ {\n                d[v] = d[v] + (long)1L;\n            }\n            else\
    \ {\n                d[v] = (long)1L;\n            }\n\n        }\n        foreach\
    \ (long k in d.Keys) {\n            if (d.ContainsKey(k * (long)-1L)) {\n    \
    \            if (k == (long)0L) {\n                    if (d[k] >= (long)2L) {\n\
    \                        return true;\n                    }\n\n             \
    \   }\n                else {\n                    return true;\n            \
    \    }\n\n            }\n\n        }\n        return false;\n", "        HashSet<long>\
    \ set = new HashSet<long>();\n        foreach (long x in l) {\n            if\
    \ (set.Contains(0L - x)) {\n                return true;\n            }\n\n  \
    \          set.Add(x);\n        }\n\n        return false;\n", "        var s\
    \ = new HashSet<long>();\n        foreach (var i in l) {\n            if (s.Contains(-i))\
    \ {\n                return true;\n            }\n\n            s.Add(i);\n  \
    \      }\n\n        return false;\n", "        var l2 = new List<long>();\n  \
    \      foreach (var item in l) {\n            if (item == 0L) {\n            \
    \    l2.Add(item);\n            }\n        }\n        if (l2.Count > 1L) {\n \
    \           return true;\n        }\n        var h = new HashSet<long>();\n  \
    \      foreach (var item in l) {\n            h.Add(item);\n        }\n      \
    \  foreach (var item in l) {\n            if (h.Contains(-(item))) {\n       \
    \         return true;\n            }\n        }\n        return false;", "  \
    \      bool flag = false;\n        for (int i = 0; i < l.Count; i++) {\n     \
    \       for (int j = i + 1; j < l.Count; j++) {\n                if (l[i] + l[j]\
    \ == 0) {\n                    flag = true;\n                }\n            }\n\
    \        }\n        return flag;", "        bool ret = false;\n        if(l.Count\
    \ >= 2) {\n            List<long> ls = new List<long>(l);\n            long a\
    \ = ls[0];\n            ls.RemoveAt(0);\n            foreach(long b in ls) {\n\
    \                if((a + b) == 0L) {\n                    ret = true;\n      \
    \              break;\n                }\n            }\n        }\n        return\
    \ ret;", "        var ns = new Dictionary<long, long>();\n        foreach (var\
    \ n in l) {\n            if (ns.ContainsKey(n)) {\n                ns[n] = ns[n]\
    \ + 1L;\n            }\n            else {\n                ns[n] = 1L;\n    \
    \        }\n        }\n        foreach (var n in l) {\n            var v = ns[n];\n\
    \            if (n == 0L && v >= 2L) {\n                return true;\n       \
    \     }\n            else if (n != 0L && ns.ContainsKey(-n)) {\n             \
    \   return true;\n            }\n        }\n        return false;", "        foreach\
    \ (long i in l) {\n            foreach (long j in l) {\n                if (i\
    \ != j && i + j == 0L) {\n                    return true;\n                }\n\
    \            }\n        }\n        return false;", "        HashSet<long> h =\
    \ new HashSet<long>();\n        for (int i = 0; i < l.Count; i++) {\n        \
    \    if (h.Contains(-l[i])) {\n                return true;\n            }\n \
    \           h.Add(l[i]);\n        }\n        return false;", "        // REPLACE\
    \ THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION\n        bool yes = false;\n\
    \        foreach (long element in l)\n        {\n            if (l.Contains(-element))\n\
    \            {\n                yes = true;\n            }\n        }\n      \
    \  return yes;", "        var m = new Dictionary<long, long>();\n        foreach\
    \ (var x in l) {\n            if (m.ContainsKey(-x)) {\n                return\
    \ true;\n            }\n\n            if (!m.ContainsKey(x)) {\n             \
    \   m[x] = 0L;\n            }\n\n            m[x]++;\n\n        }\n        return\
    \ false;\n", "        var l1 = l.AsEnumerable().ToList();\n        for (int i\
    \ = 0; i < l1.Count; i++) {\n            for (int j = i + 1; j < l1.Count; j++)\
    \ {\n                if (l1[i] + l1[j] == 0) {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;", "      \
    \  Dictionary<long, bool> seen = new Dictionary<long, bool>();\n        foreach\
    \ (long n in l) {\n            if (seen.ContainsKey(-n)) {\n                return\
    \ true;\n            }\n\n            seen[n] = true;\n        }\n\n        return\
    \ false;\n", "        Debug.Assert(l != null);\n        var length = l.Count;\n\
    \        Debug.Assert(length >= 0);\n        if (length < 2) {\n            return\
    \ false;\n        }\n        var copy = new List<long>(l);\n        copy.Sort();\n\
    \        var i = 0;\n        while (i < copy.Count - 1) {\n            var first\
    \ = copy[i];\n            var j = i + 1;\n            while (j < copy.Count) {\n\
    \                var second = copy[j];\n                if (first + second ==\
    \ 0L) {\n                    return true;\n                }\n               \
    \ if (first + second < 0L) {\n                    i++;\n                    break;\n\
    \                }\n                j++;\n            }\n            i++;\n  \
    \      }\n        return false;", "        List<long> list = new List<long>();\n\
    \        for (int i = 0; i < l.Count; i++) {\n            if (!list.Contains(l[i]))\
    \ {\n                list.Add(l[i]);\n            }\n        }\n        for (int\
    \ i = 0; i < list.Count; i++) {\n            if (list.Contains(-list[i])) {\n\
    \                return true;\n            }\n        }\n        return false;",
  "        bool hasZero = false;\n        bool[] seen = new bool[100000];\n      \
    \  for (int i = 0; i < l.Count; i++) {\n            int val = (int)l[i];\n   \
    \         if (val == 0) {\n                hasZero = true;\n            }\n  \
    \          else {\n                if (seen[-val]) {\n                    return\
    \ true;\n                }\n                seen[val] = true;\n            }\n\
    \        }\n        return hasZero;", "        // write your code here...\n  \
    \      return false;", "        HashSet<long> seen = new HashSet<long>();\n  \
    \      foreach (long n in l) {\n            if (seen.Contains(n)) {\n        \
    \        return true;\n            }\n            seen.Add(-n);\n        }\n \
    \       return false;", "        // REPLACE WITH SOLUTION\n        return false;",
  '        throw new NotImplementedException();', "        for (int i = 0; i < l.Count;\
    \ i++) {\n            for (int j = i + 1; j < l.Count; j++) {\n              \
    \  if (l[i] + l[j] == 0) {\n                    return true;\n               \
    \ }\n            }\n        }\n        return false;", "        bool tmp = false;\n\
    \        for (long i = 0L; i < (long)l.Count; i++) {\n            for (long j\
    \ = i + 1L; j < (long)l.Count; j++) {\n                if ((l[(int)i] + l[(int)j])\
    \ == 0L) {\n                    tmp = true;\n                }\n\n           \
    \ }\n\n        }\n        return tmp;\n", '        throw new NotImplementedException();',
  "        int len = l.Count;\n        if (len < 2) {\n            return false;\n\
    \        }\n        int i = 0;\n        while (i < len) {\n            int j =\
    \ i + 1;\n            while (j < len) {\n                if (l[i] + l[j] == 0L)\
    \ {\n                    return true;\n                }\n                j++;\n\
    \            }\n            i++;\n        }\n        return false;", '        return
    false;', "        int n = l.Count;\n        for (int i = 0; i < n; i++) {\n  \
    \          for (int j = i + 1; j < n; j++) {\n                if (l[i] + l[j]\
    \ == 0L) {\n                    return true;\n                }\n            }\n\
    \        }\n        return false;", "        int n = l.Count;\n        long s\
    \ = 0L;\n        long v = 0L;\n        long i = 0L;\n        long j = 0L;\n  \
    \      long k = 0L;\n        long m = 0L;\n        s = 0L;\n        for (i = 0L;\
    \ i < n; i++) {\n            v = l[(int)i];\n            s = s + v;\n        }\n\
    \        if (s == 0L) {\n            return true;\n        }\n        if (s %\
    \ 2L == 1L) {\n            return false;\n        }\n        s = s / 2L;\n   \
    \     m = Math.Min(s, n);\n        for (j = 0L; j < m; j++) {\n            v =\
    \ l[(int)j];\n            if (v == s) {\n                return true;\n      \
    \      }\n            if (v > s) {\n                return false;\n          \
    \  }\n            for (k = j + 1L; k < n; k++) {\n                if (v + l[(int)k]\
    \ == s) {\n                    return true;\n                }\n            }\n\
    \        }\n        return false;", "        HashSet<long> used_items = new HashSet<long>();\n\
    \        foreach (long i in l) {\n            if (used_items.Contains((long)0L\
    \ - i)) {\n                return true;\n            }\n            used_items.Add(i);\n\
    \        }\n        return false;", "        var s = new HashSet<long>();\n  \
    \      foreach (var x in l) {\n            if (s.Contains(x)) {\n            \
    \    return true;\n            }\n\n            if (s.Contains(-x)) {\n      \
    \          return true;\n            }\n\n            s.Add(x);\n\n        }\n\
    \n        return false;\n", "        foreach (long k in l) {\n            foreach\
    \ (long l0 in l) {\n                if (k != l0) {\n                    if (k\
    \ + l0 == 0L) {\n                        return true;\n                    }\n\
    \                }\n            }\n        }\n        return false;", "      \
    \  // We will assume that each entry of the list is distinct.\n        // We also\
    \ assume that l is sorted (in increasing order).\n        // We will assume that\
    \ all entries are integers.\n        // We assume that the list is not empty (i.e.\
    \ it contains at least one element).\n        if (l.Count == 1) {\n          \
    \  // We assume that there are at least two distinct entries.\n            return\
    \ false;\n        }\n        // We sort the input list in increasing order.\n\
    \        // We use a counting sort.\n        List<long> sorted_l = Sort(l);\n\
    \        // We search for an entry in the list that is 0.\n        // If such\
    \ an entry exists, we have found a solution.\n        long N = (long)sorted_l.Count;\n\
    \        long i = (long)0L;\n        while (i < N) {\n            if (sorted_l[(int)i]\
    \ == (long)0L) {\n                return true;\n            }\n            i =\
    \ i + (long)1L;\n        }\n        // We search for a solution of the form -a\
    \ + b = 0.\n        long j = (long)0L;\n        while (j < N) {\n            long\
    \ cur_value = sorted_l[(int)j];\n            long left = (long)0L;\n         \
    \   long right = N - (long)1L;\n            while (left <= right) {\n        \
    \        long mid = (left + right) / (long)2L;\n                if (sorted_l[(int)mid]\
    \ == -cur_value) {\n                    return true;\n                }\n    \
    \            if (sorted_l[(int)mid] < -cur_value) {\n                    left\
    \ = mid + (long)1L;\n                }\n                else {\n             \
    \       right = mid - (long)1L;\n                }\n            }\n          \
    \  j = j + (long)1L;\n        }\n        return false;", "        // {{{\n   \
    \     int n = l.Count;\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = i + 1; j < n; j++) {\n                if (l[i] + l[j] == 0L) {\n  \
    \                  return true;\n                }\n            }\n        }\n\
    \        return false;\n        // }}}", "        // input: List<long> l\n   \
    \     // output: bool\n        // hint: use a hash set to keep track of seen values.\n\
    \        throw new NotImplementedException();", "        // Your code here!\n\
    \        HashSet<long> store = new HashSet<long>();\n        foreach (long item\
    \ in l) {\n            if (store.Contains(item) || store.Contains(-item)) {\n\
    \                return true;\n            }\n            store.Add(item);\n \
    \       }\n        return false;", "        Dictionary<long, bool> mydict = new\
    \ Dictionary<long, bool>();\n        for (int i = 0; i < l.Count; i++) {\n   \
    \         long item = l[i];\n            bool v = mydict.ContainsKey(item);\n\
    \            if (v) {\n                return true;\n            }\n         \
    \   mydict[(-item)] = true;\n        }\n        return false;", "        foreach\
    \ (long x in l) {\n            foreach (long y in l) {\n                if (x\
    \ == y) {\n                    continue;\n                }\n                if\
    \ (x + y == 0L) {\n                    return true;\n                }\n     \
    \       }\n        }\n        return false;", "        if (l.Count <= 1) {\n \
    \           return false;\n        }\n        var sortedl = (l.OrderBy((long x)\
    \ => x).ToList());\n        long ai = (long)0L;\n        long bi = (long)0L;\n\
    \        while (true) {\n            while (ai < sortedl.Count - 1 && sortedl[(int)ai]\
    \ == sortedl[(int)(ai + 1L)]) {\n                ai++;\n            }\n      \
    \      while (bi < sortedl.Count - 1 && sortedl[(int)bi] == sortedl[(int)(bi +\
    \ 1L)]) {\n                bi++;\n            }\n            if (ai == bi) {\n\
    \                bi++;\n            }\n            if (bi >= sortedl.Count ||\
    \ sortedl[(int)bi] > (long)0L || sortedl[(int)ai] < (long)0L) {\n            \
    \    break;\n            }\n            if (sortedl[(int)ai] + sortedl[(int)bi]\
    \ == (long)0L) {\n                return true;\n            }\n            if\
    \ (sortedl[(int)ai] + sortedl[(int)bi] < (long)0L) {\n                ai++;\n\
    \            }\n            else {\n                bi++;\n            }\n   \
    \     }\n        return false;", "        // Your code here.\n        return false;",
  '        return false;', "        //if (l.Count <= 1L) {\n        //    return false;\n\
    \        //}\n        //long a = l[(int)0L];\n        //for (long i = 1L; i <\
    \ l.Count; i++) {\n        //    if (l.Contains(-a)) {\n        //        return\
    \ true;\n        //    }\n        //    a = l[(int)i];\n        //}\n        //return\
    \ false;\n        if (l.Count < 2)\n            return false;\n        else\n\
    \        {\n            foreach (var a in l)\n            {\n                if\
    \ (l.Contains(-a))\n                    return true;\n            }\n        \
    \    return false;\n        }", "        // // Implementation by Owen\n      \
    \  // List<long> newList = new List<long>();\n        // newList.AddRange(l);\n\
    \        // newList.Sort();\n        // bool flag = false;\n        // int low\
    \ = 0;\n        // int high = newList.Count - 1;\n        // while (low < high)\
    \ {\n        //     if (newList[low] == 0 || newList[high] == 0) {\n        //\
    \         flag = true;\n        //         break;\n        //     }\n        //\
    \     long sum = newList[low] + newList[high];\n        //     if (sum == 0) {\n\
    \        //         flag = true;\n        //         break;\n        //     }\
    \ else if (sum > 0) {\n        //         high--;\n        //     } else {\n \
    \       //         low++;\n        //     }\n        // }\n        // return flag;\n\
    \n        // Implementation by omerjerk\n        // if l is empty, then there\
    \ are no elements, so there are no pairs\n        if (l.Count == 0) {\n      \
    \      return false;\n        }\n        // if l has one element, there is no\
    \ pair\n        if (l.Count == 1) {\n            return false;\n        }\n  \
    \      // if the elements in l sum to zero, the pair is found\n        if (l.Sum()\
    \ == 0) {\n            return true;\n        }\n        // if the elements of\
    \ l are all the same, then there is no pair\n        if (l.All(x => x == l[0]))\
    \ {\n            return false;\n        }\n        // if the elements of l sum\
    \ to zero minus one, then we can subtract\n        // one from the first element,\
    \ which will make the pair appear\n        if (l.Sum() == -1) {\n            l[0]\
    \ = l[0] - 1;\n            return true;\n        }\n        // if the elements\
    \ of l sum to zero plus one, then we can add one to\n        // the first element,\
    \ which will make the pair appear\n        if (l.Sum() == 1) {\n            l[0]\
    \ = l[0] + 1;\n            return true;\n        }\n        // we", "        bool[]\
    \ p = new bool[2001];\n        long v = 0L;\n        foreach (var i in l)\n  \
    \      {\n            v = i + 1000L;\n            if (p[(int)v])\n           \
    \ {\n                return true;\n            }\n\n            p[(int)v] = true;\n\
    \n        }\n\n        return false;\n", "        // assumes l is sorted\n   \
    \     int low = 0;\n        int high = l.Count - 1;\n        while (low < high)\
    \ {\n            long sum = l[low] + l[high];\n            if (sum == 0) {\n \
    \               return true;\n            }\n            else if (sum < 0) {\n\
    \                low++;\n            }\n            else {\n                high--;\n\
    \            }\n        }\n        return false;", "        foreach (long i in\
    \ l) {\n            long j = i * -1L;\n            if (l.Contains(j)) {\n    \
    \            return true;\n            }\n        }\n        return false;", " \
    \       bool sumz = false;\n        bool sumzp = false;\n        for (int i =\
    \ 0; i < l.Count; i++) {\n            if (l[i] == 0L) {\n                sumz\
    \ = true;\n            }\n            else if (l[i] > 0L) {\n                sumzp\
    \ = true;\n            }\n        }\n        return (sumz && sumzp);", '        throw
    new NotImplementedException();', "        long sum = 0L;\n        foreach (long\
    \ elem in l) {\n            sum += elem;\n        }\n        return sum == 0L;",
  "        HashSet<long> hash_set = new HashSet<long>();\n        foreach (long x\
    \ in l) {\n            if (hash_set.Contains((long)0L - x)) {\n              \
    \  return true;\n            }\n            hash_set.Add(x);\n        }\n    \
    \    return false;", "        for (int i = 0; i < l.Count; i++) {\n          \
    \  long x = l[i];\n            for (int j = i + 1; j < l.Count; j++) {\n     \
    \           long y = l[j];\n                if (x + y == 0L) {\n             \
    \       return true;\n                }\n            }\n        }\n        return\
    \ false;", "        // TODO - you fill in here.\n        return false;", "   \
    \     List<long> list = new List<long>();\n        foreach (long i in l) {\n \
    \           list.Add(i);\n        }\n        List<long> list_1 = new List<long>();\n\
    \        foreach (long i_1 in l) {\n            list_1.Add(i_1);\n        }\n\
    \        foreach (long i_2 in list) {\n            foreach (long i_3 in list_1)\
    \ {\n                if ((i_2 + i_3) == (long)0L) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  "        long x;\n        Dictionary<long, long> hm = new Dictionary<long, long>();\n\
    \        foreach (long i in l) {\n            if (hm.ContainsKey(i)) {\n     \
    \           hm[i] = hm[i] + (long)1L;\n            }\n            else {\n   \
    \             hm[i] = (long)1L;\n            }\n        }\n        foreach (long\
    \ i in l) {\n            x = (long)0L - i;\n            if (hm.ContainsKey(x))\
    \ {\n                if (x == i) {\n                    if (hm[x] < (long)2L)\
    \ {\n                        continue;\n                    }\n              \
    \  }\n                return true;\n            }\n        }\n        return false;",
  "        HashSet<long> seen = new HashSet<long>();\n        foreach (long i in l)\
    \ {\n            if (seen.Contains((long)0L - i)) {\n                return true;\n\
    \            }\n            else {\n                seen.Add(i);\n           \
    \ }\n        }\n        return false;", "        if (l.Count < 2) {\n        \
    \    return false;\n        }\n        l.Sort();\n        int i = 0;\n       \
    \ int j = l.Count - 1;\n        while (i < j) {\n            var a = l[i];\n \
    \           var b = l[j];\n            if (a + b == 0) {\n                return\
    \ true;\n            }\n            if (a + b < 0) {\n                i++;\n \
    \           }\n            else {\n                j--;\n            }\n     \
    \   }\n        return false;", '        return false;', '        throw new NotImplementedException();',
  "        bool flag = false;\n        for (int i = 0; i < l.Count(); i++) {\n   \
    \         for (int j = i + 1; j < l.Count(); j++) {\n                if (l[i]\
    \ + l[j] == 0) {\n                    flag = true;\n                }\n      \
    \      }\n        }\n        return flag;", "        if (l.Count < 2) {\n    \
    \        return false;\n        }\n        HashSet<long> s = new HashSet<long>();\n\
    \        foreach (long x in l) {\n            if (s.Contains(x)) {\n         \
    \       return true;\n            }\n            s.Add(-x);\n        }\n     \
    \   return false;", '        throw new NotImplementedException();', "        for\
    \ (long i=0; i<l.Count; i++) {\n            for (long j=i+1; j<l.Count; j++) {\n\
    \                if (l[(int)i] + l[(int)j] == 0) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  "        bool _p0 = default(bool);\n        HashSet<long> _p0_s = new HashSet<long>();\n\
    \        foreach (var _p0_elem in l) {\n            _p0_s.Add(_p0_elem);\n   \
    \     }\n        HashSet<long> _p1 = default(HashSet<long>);\n        HashSet<long>\
    \ _input_set0 = new HashSet<long>();\n        _input_set0.Add((long)0L);\n   \
    \     _p1 = _p0_s;\n        bool _p2 = default(bool);\n        HashSet<long> _p2_set0\
    \ = new HashSet<long>();\n        foreach (var _p2_elem in _p1) {\n          \
    \  if (_input_set0.Contains(-_p2_elem)) {\n                _p2_set0.Add(_p2_elem);\n\
    \            }\n        }\n        _p2 = _p2_set0.Count > (long)0L;\n        _p0\
    \ = _p2;\n        return _p0;", "        // user code goes here\n        throw\
    \ new Exception(\"not implemented\");", "        // Implement this placeholder.\n\
    \        return false;", "        // This exercise is nearly identical to the\
    \ previous one, and you can\n        // solve it the same way.\n        // However,\
    \ you might find it instructive to try a different approach.\n        //\n   \
    \     // While the previous exercise was concerned with finding numbers that\n\
    \        // are equal to a target, this one is concerned with finding numbers\n\
    \        // that sum to a target. We can solve this problem more efficiently by\n\
    \        // sorting the list of numbers and then searching for a pair of numbers\n\
    \        // that sum to zero.\n        //\n        // Hint: Look at the Sort method,\
    \ and think about why it's faster than\n        // your solution to the previous\
    \ exercise.\n        // return false;\n        List<long> res = l.OrderBy(x =>\
    \ x).ToList();\n        int i = 0;\n        int j = res.Count() - 1;\n       \
    \ while (i <= j) {\n            long sum = res[i] + res[j];\n            if (sum\
    \ == 0) return true;\n            if (sum < 0) i++;\n            else j--;\n \
    \       }\n        return false;", "        if (l.Count() < 2) {\n           \
    \ return false;\n        }\n        else {\n            if (l.Contains((long)0L))\
    \ {\n                return true;\n            }\n            else {\n       \
    \         var hs = new HashSet<long>();\n                foreach (var elem in\
    \ l) {\n                    if (hs.Contains(-elem)) {\n                      \
    \  return true;\n                    }\n                    else {\n         \
    \               hs.Add(elem);\n                    }\n                }\n    \
    \            return false;\n            }\n        }", "        // Check if there\
    \ are any two elements in l that sum to zero\n        // l[0] can't be negative\
    \ because there are no positive numbers\n        // less than zero that add up\
    \ to l[0]\n        if (l[0] < 0) {\n            return false;\n        }\n   \
    \     // l[0] can't be positive because there are no negative numbers\n      \
    \  // greater than zero that add up to l[0]\n        if (l[0] > 0) {\n       \
    \     return false;\n        }\n        // a positive integer can't add up to\
    \ a negative integer\n        long last = l[0];\n        for (int i = 0; i < l.Count;\
    \ i++) {\n            if (last < 0 && l[i] > 0) {\n                return false;\n\
    \            }\n            if (last > 0 && l[i] < 0) {\n                return\
    \ false;\n            }\n            last = l[i];\n        }\n        return true;",
  "        //long A = 0L;\n        //long a = 0L;\n        //long varok = 0L;\n  \
    \      //long vp = 0L;\n        //long vc = 0L;\n        //long rr = 0L;\n   \
    \     //long ri = 0L;\n        //long P = 0L;\n        //long p = 0L;\n      \
    \  //long ok = 0L;\n        //long n = 0L;\n        //long c = 0L;\n        //long\
    \ b = 0L;\n        //long i = 0L;\n        //long j = 0L;\n        //long elem__prev1\
    \ = 0L;\n        //bool elem__last_bool = false;\n        //List<long> elem__prev2\
    \ = new List<long>();\n        var length = l.Count;\n        for (var i__1 =\
    \ 0L; i__1 < length; i__1++)\n        {\n            var elem = l[(int)i__1];\n\
    \            for (var j__1 = i__1 + 1L; j__1 < length; j__1++)\n            {\n\
    \                var elem__prev1 = l[(int)j__1];\n                if (elem + elem__prev1\
    \ == 0L)\n                {\n                    return true;\n              \
    \  }\n\n            }\n\n        }\n\n        return false;\n", '        return
    l.Distinct().Count() != l.Count();', '        throw new NotImplementedException();',
  "        Dictionary<long, long> d = new Dictionary<long, long>();\n        foreach\
    \ (long v in l) {\n            if (d.ContainsKey(v)) {\n                d[v] =\
    \ d[v] + (long)1L;\n            }\n            else {\n                d[v] =\
    \ (long)1L;\n            }\n\n        }\n        foreach (long v in l) {\n   \
    \         long v1 = v;\n            if (v1 == (long)0L) {\n                if\
    \ (d[v1] > (long)1L) {\n                    return true;\n                }\n\n\
    \            }\n            else {\n                long v2 = (long)0L - v1;\n\
    \                if (d.ContainsKey(v2)) {\n                    return true;\n\
    \                }\n\n            }\n\n        }\n        return false;\n", '        throw
    new NotImplementedException();', "        if (l.Count < 2) {\n            return\
    \ false;\n        }\n        var h = new Dictionary<long, bool>();\n        foreach\
    \ (var v in l) {\n            if (h.ContainsKey(-v)) {\n                return\
    \ true;\n            }\n            if (!h.ContainsKey(v)) {\n               \
    \ h[v] = true;\n            }\n        }\n        return false;", "        int\
    \ n = l.Count;\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = i + 1; j < n; j++) {\n                if (l[i] + l[j] == 0L) {\n         \
    \           return true;\n                }\n            }\n        }\n      \
    \  return false;", "        HashSet<long> set = new HashSet<long>();\n       \
    \ foreach (long l0 in l) {\n            if (set.Contains((-l0))) {\n         \
    \       return true;\n            }\n            set.Add(l0);\n        }\n   \
    \     return false;", "        if (l.Count() <= 1) {\n            return false;\n\
    \        }\n        HashSet<long> t = new HashSet<long>();\n        foreach (long\
    \ i in l) {\n            if (t.Contains(-i)) {\n                return true;\n\
    \            }\n            t.Add(i);\n        }\n        return false;", "  \
    \      var v = l.ToArray();\n        var n = (long)v.Length;\n        var new_l\
    \ = v.Distinct().ToArray();\n        var new_n = (long)new_l.Length;\n       \
    \ if (new_n <= 1L) {\n            return false;\n        }\n        if (v[0L]\
    \ == 0L && v[n - 1L] == 0L) {\n            return true;\n        }\n        var\
    \ hashed_values = new Dictionary<long, long>();\n        for (long i = 0L; i <\
    \ new_n; i++) {\n            {\n                var ____index = i;\n         \
    \       var ____value = new_l[____index];\n                hashed_values[____value]\
    \ = i;\n            }\n        }\n        for (long i = 0L; i < new_n; i++) {\n\
    \            {\n                var ____index = i;\n                var ____value\
    \ = new_l[____index];\n                var sum = (long)(0L - ____value);\n   \
    \             if (hashed_values.ContainsKey(sum)) {\n                    return\
    \ true;\n                }\n            }\n        }\n        return false;",
  "        bool r = false;\n        Dictionary<long, bool> sums = new Dictionary<long,\
    \ bool>();\n        for (int i = 0; ((i) < (l.Count)); i++) {\n            long\
    \ n = l[i];\n            if (sums.ContainsKey(n)) {\n                r = true;\n\
    \                break;\n            }\n            else {\n                sums[(0L\
    \ - n)] = true;\n            }\n        }\n        return r;", "        if (((l.Count\
    \ == 0L) || (l.Count == 1L))) {\n            return false;\n        }\n      \
    \  bool flag = false;\n        long zero = 0L;\n        List<long> list = l;\n\
    \        for (long j = 0L; j < list.Count; j++) {\n            long i = list[(int)j];\n\
    \            if (((i + zero) == 0L)) {\n                flag = true;\n       \
    \     }\n        }\n        return flag;", "        bool res = false;\n      \
    \  foreach (long el in l) {\n            if (l.IndexOf(el) != l.LastIndexOf(el))\
    \ {\n                res = true;\n                break;\n            }\n    \
    \    }\n        return res;", "        var s = new HashSet<long>();\n        foreach\
    \ (var i in l) {\n            if (s.Contains(i)) {\n                return true;\n\
    \            }\n            else {\n                s.Add(-i);\n            }\n\
    \        }\n        return false;", "        long i = (long)0L;\n        while\
    \ (i < (long)l.Count) {\n            long n = (long)l[(int)i];\n            long\
    \ j = (long)i + (long)1L;\n            while (j < (long)l.Count) {\n         \
    \       long m = (long)l[(int)j];\n                if (n + m == (long)0L) {\n\
    \                    return true;\n                }\n                j++;\n \
    \           }\n            i++;\n        }\n        return false;", '        throw
    new Exception("Not Implemented");', "        long zero = (long)0L;\n        bool\
    \ b = false;\n        for (long i = (long)0L; i < (long)l.Count; i++)\n      \
    \  {\n            for (long j = (long)0L; j < (long)l.Count; j++)\n          \
    \  {\n                if ((((long)i != (long)j) && ((l[(int)i] + l[(int)j]) ==\
    \ zero)))\n                {\n                    b = true;\n                }\n\
    \n            }\n\n        }\n\n        return b;", "        bool result = false;\n\
    \        if (l.Count < 2) {\n            return result;\n        }\n        Dictionary<long,\
    \ bool> d = new Dictionary<long, bool>();\n        long zero = (long)0L;\n   \
    \     foreach (long n in l) {\n            if (n == zero) {\n                continue;\n\
    \            }\n            long neg = zero - n;\n            if (d.ContainsKey(neg))\
    \ {\n                result = true;\n                break;\n            }\n \
    \           d[n] = true;\n        }\n        return result;", "        if ((l.Count()\
    \ == (long)1L)) {\n            return false;\n        }\n        if ((l.Count()\
    \ == (long)2L)) {\n            return ((l[(int)0L] + l[(int)1L]) == (long)0L);\n\
    \        }\n        long x = l[(int)0L];\n        l.RemoveAt((int)0L);\n     \
    \   return PairsSumToZero(l);", "        // Insert your code here\n        return\
    \ false;", "        var s = new SortedSet<long>();\n        foreach (var i in\
    \ l) {\n            s.Add(i);\n        }\n        foreach (var i in l) {\n   \
    \         if (s.Contains(-(i))) {\n                return true;\n            }\n\
    \        }\n        return false;", "        var memo = new HashSet<long>();\n\
    \        foreach (var elem in l) {\n            if (memo.Contains(elem)) {\n \
    \               return true;\n            }\n            memo.Add(0L - elem);\n\
    \        }\n        return false;", "        for (int i = 0; i < l.Count; i++)\
    \ {\n            for (int j = i + 1; j < l.Count; j++) {\n                if (l[i]\
    \ + l[j] == 0) {\n                    return true;\n                }\n      \
    \      }\n        }\n        return false;", '        return true;', "       \
    \ bool SumToZero = false;\n        foreach (var item in l) {\n            SumToZero\
    \ = SumToZero || l.Contains(-item);\n        }\n        return SumToZero;", " \
    \       HashSet<long> seen = new HashSet<long>();\n        foreach (long x in\
    \ l) {\n            if (seen.Contains((long)0L - x)) {\n                return\
    \ true;\n            }\n\n            seen.Add(x);\n        }\n\n        return\
    \ false;\n", "        HashSet<long> h = new HashSet<long>();\n        foreach\
    \ (long a in l) {\n            if (h.Contains(-a)) {\n                return true;\n\
    \            }\n\n            h.Add(a);\n        }\n\n        return false;\n",
  "        for (int i = 0; i < l.Count; i++) {\n            for (int j = i + 1; j\
    \ < l.Count; j++) {\n                if (l[i] + l[j] == 0) {\n               \
    \     return true;\n                }\n            }\n        }\n        return\
    \ false;", "        var h = new HashSet<long>();\n        foreach (var item in\
    \ l) {\n            if (h.Contains(0L - item)) {\n                return true;\n\
    \            }\n            h.Add(item);\n        }\n        return false;", " \
    \       for (int i = 0; i < l.Count; i++) {\n            for (int j = i + 1; j\
    \ < l.Count; j++) {\n                if (l[i] + l[j] == 0) {\n               \
    \     return true;\n                }\n            }\n        }\n        return\
    \ false;", '        return false;', "        bool found = false;\n        for\
    \ (long i = 0; i < l.Count; i++) {\n            for (long j = i + 1; j < l.Count;\
    \ j++) {\n                if (l[(int)i] + l[(int)j] == 0L) {\n               \
    \     found = true;\n                }\n            }\n        }\n        return\
    \ found;", '        return false;', "        HashSet<long> s = new HashSet<long>();\n\
    \        long minValue = long.MaxValue;\n        long maxValue = long.MinValue;\n\
    \        foreach (long i in l) {\n            s.Add(i);\n            if (i < minValue)\
    \ {\n                minValue = i;\n            }\n            if (i > maxValue)\
    \ {\n                maxValue = i;\n            }\n        }\n        return s.Contains(-(minValue\
    \ + maxValue));", "        for (long i = 0L; i < (long)l.Count; i++) {\n     \
    \       for (long j = 0L; j < (long)l.Count; j++) {\n                if (i !=\
    \ j && l[(int)i] + l[(int)j] == 0L) {\n                    return true;\n    \
    \            }\n            }\n        }\n        return false;", "        long[]\
    \ a = new long[3];\n        a[0] = 1;\n        a[1] = 2;\n        a[2] = 3;\n\
    \        a[0] = a[0] + a[1];\n        a[1] = a[1] - a[2];\n        if ((a[0] +\
    \ a[1]) == 4L) {\n            return true;\n        }\n        return false;"]
stop_tokens:
- "\n    }\n"
